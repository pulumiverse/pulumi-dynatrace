# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AlertingFilters',
    'AlertingFiltersFilter',
    'AlertingFiltersFilterCustom',
    'AlertingFiltersFilterCustomDescription',
    'AlertingFiltersFilterCustomMetadata',
    'AlertingFiltersFilterCustomMetadataItems',
    'AlertingFiltersFilterCustomMetadataItemsFilter',
    'AlertingFiltersFilterCustomTitle',
    'AlertingFiltersFilterPredefined',
    'AlertingProfileEventTypeFilter',
    'AlertingProfileEventTypeFilterCustomEventFilter',
    'AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter',
    'AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter',
    'AlertingProfileEventTypeFilterPredefinedEventFilter',
    'AlertingProfileMetadata',
    'AlertingProfileRule',
    'AlertingProfileRuleTagFilter',
    'AlertingProfileRuleTagFilterTagFilter',
    'AlertingRules',
    'AlertingRulesRule',
    'ApiDetectionConditions',
    'ApiDetectionConditionsCondition',
    'AppMonitoringAppMonitoring',
    'AppMonitoringAppMonitoringAppMonitoring',
    'ApplicationAnomaliesFailureRate',
    'ApplicationAnomaliesFailureRateAuto',
    'ApplicationAnomaliesFailureRateThresholds',
    'ApplicationAnomaliesResponseTime',
    'ApplicationAnomaliesResponseTimeAuto',
    'ApplicationAnomaliesResponseTimeThresholds',
    'ApplicationAnomaliesTraffic',
    'ApplicationAnomaliesTrafficDrops',
    'ApplicationAnomaliesTrafficSpikes',
    'ApplicationDataPrivacySessionReplayDataPrivacy',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettings',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlayback',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRules',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecording',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRules',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule',
    'ApplicationDetectionRuleFilterConfig',
    'ApplicationErrorRulesCustomErrors',
    'ApplicationErrorRulesCustomErrorsRule',
    'ApplicationErrorRulesHttpErrors',
    'ApplicationErrorRulesHttpErrorsRule',
    'AppsecNotificationAttackCandidateBasedEmailPayload',
    'AppsecNotificationAttackCandidateBasedJiraPayload',
    'AppsecNotificationAttackCandidateBasedWebhookPayload',
    'AppsecNotificationEmailConfiguration',
    'AppsecNotificationJiraConfiguration',
    'AppsecNotificationSecurityProblemBasedEmailPayload',
    'AppsecNotificationSecurityProblemBasedJiraPayload',
    'AppsecNotificationSecurityProblemBasedWebhookPayload',
    'AppsecNotificationWebhookConfiguration',
    'AppsecNotificationWebhookConfigurationHeaders',
    'AppsecNotificationWebhookConfigurationHeadersHeader',
    'AttackAllowlistAttackHandling',
    'AttackAllowlistCriteria',
    'AttackAllowlistMetadata',
    'AttackRulesAttackHandling',
    'AttackRulesCriteria',
    'AttackRulesMetadata',
    'AttackRulesResourceAttributeConditions',
    'AttackRulesResourceAttributeConditionsResourceAttributeCondition',
    'AttackSettingsDefaultAttackHandling',
    'AutomationBusinessCalendarHolidays',
    'AutomationBusinessCalendarHolidaysHoliday',
    'AutomationSchedulingRuleFixedOffset',
    'AutomationSchedulingRuleGrouping',
    'AutomationSchedulingRuleRecurrence',
    'AutomationSchedulingRuleRelativeOffset',
    'AutomationWorkflowAwsConnectionsWebIdentity',
    'AutomationWorkflowTasks',
    'AutomationWorkflowTasksTask',
    'AutomationWorkflowTasksTaskConditions',
    'AutomationWorkflowTasksTaskPosition',
    'AutomationWorkflowTasksTaskRetry',
    'AutomationWorkflowTrigger',
    'AutomationWorkflowTriggerEvent',
    'AutomationWorkflowTriggerEventConfig',
    'AutomationWorkflowTriggerEventConfigDavisEvent',
    'AutomationWorkflowTriggerEventConfigDavisProblem',
    'AutomationWorkflowTriggerEventConfigDavisProblemCategory',
    'AutomationWorkflowTriggerEventConfigEvent',
    'AutomationWorkflowTriggerSchedule',
    'AutomationWorkflowTriggerScheduleFilterParameters',
    'AutomationWorkflowTriggerScheduleTrigger',
    'AutotagEntitySelectorBasedRule',
    'AutotagRule',
    'AutotagRuleCondition',
    'AutotagRuleConditionApplicationType',
    'AutotagRuleConditionApplicationTypeComparison',
    'AutotagRuleConditionAzureComputeMode',
    'AutotagRuleConditionAzureComputeModeComparison',
    'AutotagRuleConditionAzureSkuComparision',
    'AutotagRuleConditionAzureSkus',
    'AutotagRuleConditionBaseComparisonBasic',
    'AutotagRuleConditionBaseConditionKey',
    'AutotagRuleConditionBitness',
    'AutotagRuleConditionBitnessComparision',
    'AutotagRuleConditionCloudType',
    'AutotagRuleConditionCloudTypeComparison',
    'AutotagRuleConditionComparison',
    'AutotagRuleConditionCustomApplicationType',
    'AutotagRuleConditionCustomApplicationTypeComparison',
    'AutotagRuleConditionCustomHostMetadata',
    'AutotagRuleConditionCustomHostMetadataConditionKey',
    'AutotagRuleConditionCustomHostMetadataConditionKeyDynamicKey',
    'AutotagRuleConditionCustomHostMetadataDynamicKey',
    'AutotagRuleConditionCustomProcessMetadata',
    'AutotagRuleConditionCustomProcessMetadataConditionKey',
    'AutotagRuleConditionCustomProcessMetadataConditionKeyDynamicKey',
    'AutotagRuleConditionCustomProcessMetadataDynamicKey',
    'AutotagRuleConditionDatabaseTopology',
    'AutotagRuleConditionDatabaseTopologyComparison',
    'AutotagRuleConditionDcrumDecoder',
    'AutotagRuleConditionDcrumDecoderComparison',
    'AutotagRuleConditionEntity',
    'AutotagRuleConditionEntityIdComparison',
    'AutotagRuleConditionHostTech',
    'AutotagRuleConditionHostTechValue',
    'AutotagRuleConditionHypervisor',
    'AutotagRuleConditionHypervisorTypeComparision',
    'AutotagRuleConditionIndexedName',
    'AutotagRuleConditionIndexedNameComparison',
    'AutotagRuleConditionIndexedString',
    'AutotagRuleConditionIndexedStringComparison',
    'AutotagRuleConditionIndexedTag',
    'AutotagRuleConditionIndexedTagComparison',
    'AutotagRuleConditionIndexedTagComparisonValue',
    'AutotagRuleConditionIndexedTagValue',
    'AutotagRuleConditionInteger',
    'AutotagRuleConditionIntegerComparison',
    'AutotagRuleConditionIpaddress',
    'AutotagRuleConditionIpaddressComparison',
    'AutotagRuleConditionKey',
    'AutotagRuleConditionMobilePlatform',
    'AutotagRuleConditionMobilePlatformComparison',
    'AutotagRuleConditionOsArch',
    'AutotagRuleConditionOsType',
    'AutotagRuleConditionOsarchitectureComparison',
    'AutotagRuleConditionOstypeComparison',
    'AutotagRuleConditionPaasType',
    'AutotagRuleConditionPaasTypeComparison',
    'AutotagRuleConditionProcessMetadata',
    'AutotagRuleConditionProcessMetadataConditionKey',
    'AutotagRuleConditionServiceTopology',
    'AutotagRuleConditionServiceTopologyComparison',
    'AutotagRuleConditionServiceType',
    'AutotagRuleConditionServiceTypeComparison',
    'AutotagRuleConditionSimpleHostTechComparison',
    'AutotagRuleConditionSimpleHostTechComparisonValue',
    'AutotagRuleConditionSimpleTechComparison',
    'AutotagRuleConditionSimpleTechComparisonValue',
    'AutotagRuleConditionString',
    'AutotagRuleConditionStringComparison',
    'AutotagRuleConditionStringConditionKey',
    'AutotagRuleConditionStringKey',
    'AutotagRuleConditionSyntheticEngine',
    'AutotagRuleConditionSyntheticEngineTypeComparison',
    'AutotagRuleConditionTag',
    'AutotagRuleConditionTagComparison',
    'AutotagRuleConditionTagComparisonValue',
    'AutotagRuleConditionTagValue',
    'AutotagRuleConditionTech',
    'AutotagRuleConditionTechValue',
    'AutotagRulesRules',
    'AutotagRulesRulesRule',
    'AutotagRulesRulesRuleAttributeRule',
    'AutotagRulesRulesRuleAttributeRuleConditions',
    'AutotagRulesRulesRuleAttributeRuleConditionsCondition',
    'AutotagV2Rules',
    'AutotagV2RulesRule',
    'AutotagV2RulesRuleAttributeRule',
    'AutotagV2RulesRuleAttributeRuleConditions',
    'AutotagV2RulesRuleAttributeRuleConditionsCondition',
    'AwsAnomaliesEc2CandidateHighCpuDetection',
    'AwsAnomaliesEc2CandidateHighCpuDetectionCustomThresholds',
    'AwsAnomaliesElbHighConnectionErrorsDetection',
    'AwsAnomaliesElbHighConnectionErrorsDetectionCustomThresholds',
    'AwsAnomaliesLambdaHighErrorRateDetection',
    'AwsAnomaliesLambdaHighErrorRateDetectionCustomThresholds',
    'AwsAnomaliesRdsHighCpuDetection',
    'AwsAnomaliesRdsHighCpuDetectionCustomThresholds',
    'AwsAnomaliesRdsHighMemoryDetection',
    'AwsAnomaliesRdsHighMemoryDetectionCustomThresholds',
    'AwsAnomaliesRdsHighWriteReadLatencyDetection',
    'AwsAnomaliesRdsHighWriteReadLatencyDetectionCustomThresholds',
    'AwsAnomaliesRdsLowStorageDetection',
    'AwsAnomaliesRdsLowStorageDetectionCustomThresholds',
    'AwsAnomaliesRdsRestartsSequenceDetection',
    'AwsAnomaliesRdsRestartsSequenceDetectionCustomThresholds',
    'AwsCredentialsAuthenticationData',
    'AwsCredentialsSupportingServicesToMonitor',
    'AwsCredentialsSupportingServicesToMonitorMonitoredMetric',
    'AwsCredentialsTagsToMonitor',
    'AwsServiceMetric',
    'AzureCredentialsMonitorOnlyExcludingTagPair',
    'AzureCredentialsMonitorOnlyTagPair',
    'AzureCredentialsSupportingService',
    'AzureCredentialsSupportingServiceMonitoredMetric',
    'AzureServiceMetric',
    'BrowserMonitorAnomalyDetection',
    'BrowserMonitorAnomalyDetectionLoadingTimeThreshold',
    'BrowserMonitorAnomalyDetectionLoadingTimeThresholdThreshold',
    'BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold',
    'BrowserMonitorAnomalyDetectionOutageHandling',
    'BrowserMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy',
    'BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy',
    'BrowserMonitorKeyPerformanceMetrics',
    'BrowserMonitorPerformanceThresholds',
    'BrowserMonitorPerformanceThresholdsThreshold',
    'BrowserMonitorScript',
    'BrowserMonitorScriptConfiguration',
    'BrowserMonitorScriptConfigurationBandwidth',
    'BrowserMonitorScriptConfigurationCookies',
    'BrowserMonitorScriptConfigurationCookiesCookie',
    'BrowserMonitorScriptConfigurationDevice',
    'BrowserMonitorScriptConfigurationHeaders',
    'BrowserMonitorScriptConfigurationHeadersHeader',
    'BrowserMonitorScriptConfigurationIgnoredErrorCodes',
    'BrowserMonitorScriptConfigurationJavascriptSetttings',
    'BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings',
    'BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions',
    'BrowserMonitorScriptEvents',
    'BrowserMonitorScriptEventsEvent',
    'BrowserMonitorScriptEventsEventClick',
    'BrowserMonitorScriptEventsEventClickTarget',
    'BrowserMonitorScriptEventsEventClickTargetLocator',
    'BrowserMonitorScriptEventsEventClickTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventClickValidate',
    'BrowserMonitorScriptEventsEventClickValidateValidation',
    'BrowserMonitorScriptEventsEventClickValidateValidationTarget',
    'BrowserMonitorScriptEventsEventClickValidateValidationTargetLocator',
    'BrowserMonitorScriptEventsEventClickValidateValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventClickWait',
    'BrowserMonitorScriptEventsEventClickWaitValidation',
    'BrowserMonitorScriptEventsEventClickWaitValidationTarget',
    'BrowserMonitorScriptEventsEventClickWaitValidationTargetLocator',
    'BrowserMonitorScriptEventsEventClickWaitValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventCookie',
    'BrowserMonitorScriptEventsEventCookieCookies',
    'BrowserMonitorScriptEventsEventCookieCookiesCookie',
    'BrowserMonitorScriptEventsEventJavascript',
    'BrowserMonitorScriptEventsEventJavascriptTarget',
    'BrowserMonitorScriptEventsEventJavascriptTargetLocator',
    'BrowserMonitorScriptEventsEventJavascriptTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventJavascriptWait',
    'BrowserMonitorScriptEventsEventJavascriptWaitValidation',
    'BrowserMonitorScriptEventsEventJavascriptWaitValidationTarget',
    'BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocator',
    'BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventKeystrokes',
    'BrowserMonitorScriptEventsEventKeystrokesCredential',
    'BrowserMonitorScriptEventsEventKeystrokesTarget',
    'BrowserMonitorScriptEventsEventKeystrokesTargetLocator',
    'BrowserMonitorScriptEventsEventKeystrokesTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventKeystrokesValidate',
    'BrowserMonitorScriptEventsEventKeystrokesValidateValidation',
    'BrowserMonitorScriptEventsEventKeystrokesValidateValidationTarget',
    'BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocator',
    'BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventKeystrokesWait',
    'BrowserMonitorScriptEventsEventKeystrokesWaitValidation',
    'BrowserMonitorScriptEventsEventKeystrokesWaitValidationTarget',
    'BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocator',
    'BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventNavigate',
    'BrowserMonitorScriptEventsEventNavigateAuthentication',
    'BrowserMonitorScriptEventsEventNavigateTarget',
    'BrowserMonitorScriptEventsEventNavigateTargetLocator',
    'BrowserMonitorScriptEventsEventNavigateTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventNavigateValidate',
    'BrowserMonitorScriptEventsEventNavigateValidateValidation',
    'BrowserMonitorScriptEventsEventNavigateValidateValidationTarget',
    'BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocator',
    'BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventNavigateWait',
    'BrowserMonitorScriptEventsEventNavigateWaitValidation',
    'BrowserMonitorScriptEventsEventNavigateWaitValidationTarget',
    'BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocator',
    'BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventSelect',
    'BrowserMonitorScriptEventsEventSelectSelections',
    'BrowserMonitorScriptEventsEventSelectSelectionsOption',
    'BrowserMonitorScriptEventsEventSelectTarget',
    'BrowserMonitorScriptEventsEventSelectTargetLocator',
    'BrowserMonitorScriptEventsEventSelectTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventSelectValidate',
    'BrowserMonitorScriptEventsEventSelectValidateValidation',
    'BrowserMonitorScriptEventsEventSelectValidateValidationTarget',
    'BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocator',
    'BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventSelectWait',
    'BrowserMonitorScriptEventsEventSelectWaitValidation',
    'BrowserMonitorScriptEventsEventSelectWaitValidationTarget',
    'BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocator',
    'BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventTap',
    'BrowserMonitorScriptEventsEventTapTarget',
    'BrowserMonitorScriptEventsEventTapTargetLocator',
    'BrowserMonitorScriptEventsEventTapTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventTapValidate',
    'BrowserMonitorScriptEventsEventTapValidateValidation',
    'BrowserMonitorScriptEventsEventTapValidateValidationTarget',
    'BrowserMonitorScriptEventsEventTapValidateValidationTargetLocator',
    'BrowserMonitorScriptEventsEventTapValidateValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventTapWait',
    'BrowserMonitorScriptEventsEventTapWaitValidation',
    'BrowserMonitorScriptEventsEventTapWaitValidationTarget',
    'BrowserMonitorScriptEventsEventTapWaitValidationTargetLocator',
    'BrowserMonitorScriptEventsEventTapWaitValidationTargetLocatorLocator',
    'BrowserMonitorTag',
    'BrowserMonitorTagTag',
    'BusinessEventsOneagentEvent',
    'BusinessEventsOneagentEventCategory',
    'BusinessEventsOneagentEventData',
    'BusinessEventsOneagentEventDataEventDataFieldComplex',
    'BusinessEventsOneagentEventDataEventDataFieldComplexSource',
    'BusinessEventsOneagentEventProvider',
    'BusinessEventsOneagentEventType',
    'BusinessEventsOneagentOutgoingEvent',
    'BusinessEventsOneagentOutgoingEventCategory',
    'BusinessEventsOneagentOutgoingEventData',
    'BusinessEventsOneagentOutgoingEventDataEventDataFieldComplex',
    'BusinessEventsOneagentOutgoingEventDataEventDataFieldComplexSource',
    'BusinessEventsOneagentOutgoingEventProvider',
    'BusinessEventsOneagentOutgoingEventType',
    'BusinessEventsOneagentOutgoingTriggers',
    'BusinessEventsOneagentOutgoingTriggersTrigger',
    'BusinessEventsOneagentOutgoingTriggersTriggerSource',
    'BusinessEventsOneagentTriggers',
    'BusinessEventsOneagentTriggersTrigger',
    'BusinessEventsOneagentTriggersTriggerSource',
    'BusinessEventsProcessingRuleTesting',
    'BusinessEventsProcessingTransformationFields',
    'BusinessEventsProcessingTransformationFieldsTransformationField',
    'BusinessEventsSecurityContextSecurityContextRule',
    'CalculatedMobileMetricDimension',
    'CalculatedMobileMetricDimensionDimension',
    'CalculatedMobileMetricUserActionFilter',
    'CalculatedServiceMetricCondition',
    'CalculatedServiceMetricConditionCondition',
    'CalculatedServiceMetricConditionConditionComparison',
    'CalculatedServiceMetricConditionConditionComparisonBoolean',
    'CalculatedServiceMetricConditionConditionComparisonEsbInputNodeType',
    'CalculatedServiceMetricConditionConditionComparisonFailedState',
    'CalculatedServiceMetricConditionConditionComparisonFailureReason',
    'CalculatedServiceMetricConditionConditionComparisonFastString',
    'CalculatedServiceMetricConditionConditionComparisonFlawState',
    'CalculatedServiceMetricConditionConditionComparisonGeneric',
    'CalculatedServiceMetricConditionConditionComparisonHttpMethod',
    'CalculatedServiceMetricConditionConditionComparisonHttpStatusClass',
    'CalculatedServiceMetricConditionConditionComparisonIibInputNodeType',
    'CalculatedServiceMetricConditionConditionComparisonNumber',
    'CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute',
    'CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource',
    'CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag',
    'CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTagTagKey',
    'CalculatedServiceMetricConditionConditionComparisonServiceType',
    'CalculatedServiceMetricConditionConditionComparisonString',
    'CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute',
    'CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource',
    'CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag',
    'CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTagTagKey',
    'CalculatedServiceMetricConditionConditionComparisonTag',
    'CalculatedServiceMetricConditionConditionComparisonTagValue',
    'CalculatedServiceMetricConditionConditionComparisonTagValues',
    'CalculatedServiceMetricConditionConditionComparisonTagValuesValue',
    'CalculatedServiceMetricConditionConditionComparisonZosCallType',
    'CalculatedServiceMetricDimensionDefinition',
    'CalculatedServiceMetricDimensionDefinitionPlaceholders',
    'CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder',
    'CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource',
    'CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag',
    'CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKey',
    'CalculatedServiceMetricMetricDefinition',
    'CalculatedSyntheticMetricDimension',
    'CalculatedSyntheticMetricDimensionDimension',
    'CalculatedSyntheticMetricFilter',
    'CalculatedWebMetricDimension',
    'CalculatedWebMetricDimensionDimension',
    'CalculatedWebMetricMetricDefinition',
    'CalculatedWebMetricUserActionFilter',
    'CalculatedWebMetricUserActionFilterUserActionProperty',
    'CalculatedWebMetricUserActionFilterUserActionPropertyProperty',
    'CloudappWorkloaddetectionCloudFoundry',
    'CloudappWorkloaddetectionDocker',
    'CloudappWorkloaddetectionKubernetes',
    'CloudappWorkloaddetectionKubernetesFilters',
    'CloudappWorkloaddetectionKubernetesFiltersFilter',
    'CloudappWorkloaddetectionKubernetesFiltersFilterInclusionToggles',
    'CloudappWorkloaddetectionKubernetesFiltersFilterMatchFilter',
    'CloudappWorkloaddetectionServerless',
    'CredentialsAllowedEntities',
    'CredentialsAllowedEntitiesEntity',
    'CredentialsCredentialUsageSummary',
    'CredentialsExternal',
    'CustomAnomaliesDimension',
    'CustomAnomaliesDimensionDimension',
    'CustomAnomaliesDimensionEntity',
    'CustomAnomaliesDimensionEntityFilter',
    'CustomAnomaliesDimensionString',
    'CustomAnomaliesDimensionStringFilter',
    'CustomAnomaliesScope',
    'CustomAnomaliesScopeCustomDeviceGroupName',
    'CustomAnomaliesScopeCustomDeviceGroupNameFilter',
    'CustomAnomaliesScopeEntity',
    'CustomAnomaliesScopeHostGroupName',
    'CustomAnomaliesScopeHostGroupNameFilter',
    'CustomAnomaliesScopeHostName',
    'CustomAnomaliesScopeHostNameFilter',
    'CustomAnomaliesScopeManagementZone',
    'CustomAnomaliesScopeName',
    'CustomAnomaliesScopeNameFilter',
    'CustomAnomaliesScopeProcessGroupId',
    'CustomAnomaliesScopeProcessGroupName',
    'CustomAnomaliesScopeProcessGroupNameFilter',
    'CustomAnomaliesScopeScope',
    'CustomAnomaliesScopeTag',
    'CustomAnomaliesScopeTagFilter',
    'CustomAnomaliesStrategy',
    'CustomAnomaliesStrategyAuto',
    'CustomAnomaliesStrategyGeneric',
    'CustomAnomaliesStrategyStatic',
    'CustomAppAnomaliesErrorRateIncrease',
    'CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto',
    'CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed',
    'CustomAppAnomaliesSlowUserActions',
    'CustomAppAnomaliesSlowUserActionsSlowUserActionsAuto',
    'CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting',
    'CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll',
    'CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest',
    'CustomAppAnomaliesSlowUserActionsSlowUserActionsFixed',
    'CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting',
    'CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed',
    'CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest',
    'CustomAppAnomaliesUnexpectedHighLoad',
    'CustomAppAnomaliesUnexpectedLowLoad',
    'CustomAppCrashRateCrashRateIncrease',
    'CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto',
    'CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed',
    'CustomAppEnablementRum',
    'CustomServiceRule',
    'CustomServiceRuleClass',
    'CustomServiceRuleFile',
    'CustomServiceRuleMethod',
    'CustomTagsTags',
    'CustomTagsTagsFilter',
    'DashboardDashboardMetadata',
    'DashboardDashboardMetadataDynamicFilters',
    'DashboardDashboardMetadataDynamicFiltersGenericTagFilters',
    'DashboardDashboardMetadataDynamicFiltersGenericTagFiltersFilter',
    'DashboardDashboardMetadataFilter',
    'DashboardDashboardMetadataFilterManagementZone',
    'DashboardDashboardMetadataSharingDetails',
    'DashboardMetadata',
    'DashboardSharingPermissions',
    'DashboardSharingPermissionsPermission',
    'DashboardSharingPublic',
    'DashboardTile',
    'DashboardTileBounds',
    'DashboardTileFilter',
    'DashboardTileFilterConfig',
    'DashboardTileFilterConfigChartConfig',
    'DashboardTileFilterConfigChartConfigResultMetadata',
    'DashboardTileFilterConfigChartConfigResultMetadataConfig',
    'DashboardTileFilterConfigChartConfigSeries',
    'DashboardTileFilterConfigChartConfigSeriesDimension',
    'DashboardTileFilterConfigFilters',
    'DashboardTileFilterConfigFiltersFilter',
    'DashboardTileFilterConfigFiltersFilterMatch',
    'DashboardTileFilterManagementZone',
    'DashboardTileVisualizationConfig',
    'DashboardsAllowlistAllowlist',
    'DashboardsAllowlistAllowlistUrlpattern',
    'DashboardsGeneralDefaultDashboardList',
    'DashboardsGeneralDefaultDashboardListDefaultDashboard',
    'DashboardsPresetsDashboardPresetsList',
    'DashboardsPresetsDashboardPresetsListDashboardPreset',
    'DataPrivacyDataCollection',
    'DataPrivacyDoNotTrack',
    'DataPrivacyMasking',
    'DataPrivacyUserTracking',
    'DatabaseAnomaliesDbConnectFailures',
    'DatabaseAnomaliesFailureRate',
    'DatabaseAnomaliesFailureRateAuto',
    'DatabaseAnomaliesFailureRateThresholds',
    'DatabaseAnomaliesLoad',
    'DatabaseAnomaliesLoadDrops',
    'DatabaseAnomaliesLoadSpikes',
    'DatabaseAnomaliesResponseTime',
    'DatabaseAnomaliesResponseTimeAuto',
    'DatabaseAnomaliesResponseTimeThresholds',
    'DatabaseAnomaliesV2DatabaseConnections',
    'DatabaseAnomaliesV2FailureRate',
    'DatabaseAnomaliesV2FailureRateAutoDetection',
    'DatabaseAnomaliesV2FailureRateAutoDetectionOverAlertingProtection',
    'DatabaseAnomaliesV2FailureRateFixedDetection',
    'DatabaseAnomaliesV2FailureRateFixedDetectionOverAlertingProtection',
    'DatabaseAnomaliesV2LoadDrops',
    'DatabaseAnomaliesV2LoadSpikes',
    'DatabaseAnomaliesV2ResponseTime',
    'DatabaseAnomaliesV2ResponseTimeAutoDetection',
    'DatabaseAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection',
    'DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll',
    'DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest',
    'DatabaseAnomaliesV2ResponseTimeFixedDetection',
    'DatabaseAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection',
    'DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll',
    'DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest',
    'DavisAnomalyDetectorsAnalyzer',
    'DavisAnomalyDetectorsAnalyzerInput',
    'DavisAnomalyDetectorsAnalyzerInputAnalyzerInputField',
    'DavisAnomalyDetectorsEventTemplate',
    'DavisAnomalyDetectorsEventTemplateProperties',
    'DavisAnomalyDetectorsEventTemplatePropertiesProperty',
    'DavisAnomalyDetectorsExecutionSettings',
    'DavisCopilotBlocklistEntries',
    'DavisCopilotBlocklistEntriesBlocklistEntry',
    'DduPoolEvents',
    'DduPoolLogMonitoring',
    'DduPoolMetrics',
    'DduPoolServerless',
    'DduPoolTraces',
    'DeclarativeGroupingDetection',
    'DeclarativeGroupingDetectionProcessDefinition',
    'DeclarativeGroupingDetectionProcessDefinitionRules',
    'DeclarativeGroupingDetectionProcessDefinitionRulesRule',
    'DirectSharesRecipients',
    'DirectSharesRecipientsRecipient',
    'DiscoveryDefaultRulesRule',
    'DiscoveryDefaultRulesRuleActions',
    'DiscoveryDefaultRulesRuleActionsAction',
    'DiscoveryDefaultRulesRuleActionsActionParameters',
    'DiscoveryDefaultRulesRuleActionsActionParametersParameter',
    'DiscoveryDefaultRulesSettings',
    'DiskAnomaliesDiskName',
    'DiskAnomaliesTags',
    'DiskAnomaliesTagsFilter',
    'DiskAnomaliesV2Disk',
    'DiskAnomaliesV2DiskDiskLowInodesDetection',
    'DiskAnomaliesV2DiskDiskLowInodesDetectionCustomThresholds',
    'DiskAnomaliesV2DiskDiskLowSpaceDetection',
    'DiskAnomaliesV2DiskDiskLowSpaceDetectionCustomThresholds',
    'DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetection',
    'DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionCustomThresholds',
    'DiskAnomalyRulesDiskNameFilter',
    'DiskAnomalyRulesSampleLimit',
    'DiskEdgeAnomalyDetectorsAlerts',
    'DiskEdgeAnomalyDetectorsAlertsAlert',
    'DiskEdgeAnomalyDetectorsAlertsAlertSampleCountThresholds',
    'DiskEdgeAnomalyDetectorsAlertsAlertSampleCountThresholdsImmediately',
    'DiskEdgeAnomalyDetectorsEventProperties',
    'DiskEdgeAnomalyDetectorsEventPropertiesEventProperty',
    'DiskEdgeAnomalyDetectorsHostMetadataConditions',
    'DiskEdgeAnomalyDetectorsHostMetadataConditionsHostMetadataCondition',
    'DiskEdgeAnomalyDetectorsHostMetadataConditionsHostMetadataConditionHostMetadataCondition',
    'DiskOptionsExclusions',
    'DiskOptionsExclusionsExclusion',
    'DiskSpecificAnomaliesV2DiskLowInodesDetection',
    'DiskSpecificAnomaliesV2DiskLowInodesDetectionCustomThresholds',
    'DiskSpecificAnomaliesV2DiskLowSpaceDetection',
    'DiskSpecificAnomaliesV2DiskLowSpaceDetectionCustomThresholds',
    'DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetection',
    'DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetectionCustomThresholds',
    'EnvironmentQuotas',
    'EnvironmentQuotasDdus',
    'EnvironmentQuotasDemUnits',
    'EnvironmentQuotasLogs',
    'EnvironmentQuotasSynthetic',
    'EnvironmentQuotasUserSessions',
    'EnvironmentStorage',
    'EnvironmentStorageLimits',
    'EnvironmentStorageRetention',
    'FailureDetectionParametersBrokenLinks',
    'FailureDetectionParametersExceptionRules',
    'FailureDetectionParametersExceptionRulesCustomErrorRules',
    'FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRule',
    'FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRuleCondition',
    'FailureDetectionParametersExceptionRulesCustomHandledExceptions',
    'FailureDetectionParametersExceptionRulesCustomHandledExceptionsCustomHandledException',
    'FailureDetectionParametersExceptionRulesIgnoredExceptions',
    'FailureDetectionParametersExceptionRulesIgnoredExceptionsCustomHandledException',
    'FailureDetectionParametersExceptionRulesSuccessForcingExceptions',
    'FailureDetectionParametersExceptionRulesSuccessForcingExceptionsCustomHandledException',
    'FailureDetectionParametersHttpResponseCodes',
    'FailureDetectionRulesConditions',
    'FailureDetectionRulesConditionsCondition',
    'FailureDetectionRulesConditionsConditionPredicate',
    'GenericRelationshipsSources',
    'GenericRelationshipsSourcesSource',
    'GenericRelationshipsSourcesSourceMappingRules',
    'GenericRelationshipsSourcesSourceMappingRulesMappingRule',
    'GenericTypesRules',
    'GenericTypesRulesRule',
    'GenericTypesRulesRuleAttributes',
    'GenericTypesRulesRuleAttributesAttribute',
    'GenericTypesRulesRuleRequiredDimensions',
    'GenericTypesRulesRuleRequiredDimensionsRequiredDimension',
    'GenericTypesRulesRuleSources',
    'GenericTypesRulesRuleSourcesSource',
    'GrailMetricsAllowlistAllowRules',
    'GrailMetricsAllowlistAllowRulesAllowRule',
    'HostAnomaliesConnections',
    'HostAnomaliesCpu',
    'HostAnomaliesCpuThresholds',
    'HostAnomaliesDisks',
    'HostAnomaliesDisksInodes',
    'HostAnomaliesDisksInodesThresholds',
    'HostAnomaliesDisksSpace',
    'HostAnomaliesDisksSpaceThresholds',
    'HostAnomaliesDisksSpeed',
    'HostAnomaliesDisksSpeedThresholds',
    'HostAnomaliesGc',
    'HostAnomaliesGcThresholds',
    'HostAnomaliesJava',
    'HostAnomaliesJavaOutOfMemory',
    'HostAnomaliesJavaOutOfMemoryThresholds',
    'HostAnomaliesJavaOutOfThreads',
    'HostAnomaliesJavaOutOfThreadsThresholds',
    'HostAnomaliesMemory',
    'HostAnomaliesMemoryThresholds',
    'HostAnomaliesMemoryThresholdsLinux',
    'HostAnomaliesMemoryThresholdsWindows',
    'HostAnomaliesNetwork',
    'HostAnomaliesNetworkConnectivity',
    'HostAnomaliesNetworkConnectivityThresholds',
    'HostAnomaliesNetworkDroppedPackets',
    'HostAnomaliesNetworkDroppedPacketsThresholds',
    'HostAnomaliesNetworkErrors',
    'HostAnomaliesNetworkErrorsThresholds',
    'HostAnomaliesNetworkRetransmission',
    'HostAnomaliesNetworkRetransmissionThresholds',
    'HostAnomaliesNetworkUtilization',
    'HostAnomaliesNetworkUtilizationThresholds',
    'HostAnomaliesV2Host',
    'HostAnomaliesV2HostConnectionLostDetection',
    'HostAnomaliesV2HostHighCpuSaturationDetection',
    'HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholds',
    'HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2HostHighGcActivityDetection',
    'HostAnomaliesV2HostHighGcActivityDetectionCustomThresholds',
    'HostAnomaliesV2HostHighGcActivityDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2HostHighMemoryDetection',
    'HostAnomaliesV2HostHighMemoryDetectionCustomThresholds',
    'HostAnomaliesV2HostHighMemoryDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2HostHighSystemLoadDetection',
    'HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholds',
    'HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2HostOutOfMemoryDetection',
    'HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholds',
    'HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2HostOutOfThreadsDetection',
    'HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholds',
    'HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2Network',
    'HostAnomaliesV2NetworkHighNetworkDetection',
    'HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholds',
    'HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2NetworkNetworkDroppedPacketsDetection',
    'HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholds',
    'HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2NetworkNetworkErrorsDetection',
    'HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholds',
    'HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2NetworkNetworkHighRetransmissionDetection',
    'HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholds',
    'HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2NetworkNetworkTcpProblemsDetection',
    'HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholds',
    'HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholdsEventThresholds',
    'HostNamingCondition',
    'HostNamingConditionCondition',
    'HostNamingConditionConditionApplicationType',
    'HostNamingConditionConditionApplicationTypeComparison',
    'HostNamingConditionConditionAzureComputeMode',
    'HostNamingConditionConditionAzureComputeModeComparison',
    'HostNamingConditionConditionAzureSkuComparision',
    'HostNamingConditionConditionAzureSkus',
    'HostNamingConditionConditionBaseComparisonBasic',
    'HostNamingConditionConditionBaseConditionKey',
    'HostNamingConditionConditionBitness',
    'HostNamingConditionConditionBitnessComparision',
    'HostNamingConditionConditionCloudType',
    'HostNamingConditionConditionCloudTypeComparison',
    'HostNamingConditionConditionComparison',
    'HostNamingConditionConditionCustomApplicationType',
    'HostNamingConditionConditionCustomApplicationTypeComparison',
    'HostNamingConditionConditionCustomHostMetadata',
    'HostNamingConditionConditionCustomHostMetadataConditionKey',
    'HostNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey',
    'HostNamingConditionConditionCustomHostMetadataDynamicKey',
    'HostNamingConditionConditionCustomProcessMetadata',
    'HostNamingConditionConditionCustomProcessMetadataConditionKey',
    'HostNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey',
    'HostNamingConditionConditionCustomProcessMetadataDynamicKey',
    'HostNamingConditionConditionDatabaseTopology',
    'HostNamingConditionConditionDatabaseTopologyComparison',
    'HostNamingConditionConditionDcrumDecoder',
    'HostNamingConditionConditionDcrumDecoderComparison',
    'HostNamingConditionConditionEntity',
    'HostNamingConditionConditionEntityIdComparison',
    'HostNamingConditionConditionHostTech',
    'HostNamingConditionConditionHostTechValue',
    'HostNamingConditionConditionHypervisor',
    'HostNamingConditionConditionHypervisorTypeComparision',
    'HostNamingConditionConditionIndexedName',
    'HostNamingConditionConditionIndexedNameComparison',
    'HostNamingConditionConditionIndexedString',
    'HostNamingConditionConditionIndexedStringComparison',
    'HostNamingConditionConditionIndexedTag',
    'HostNamingConditionConditionIndexedTagComparison',
    'HostNamingConditionConditionIndexedTagComparisonValue',
    'HostNamingConditionConditionIndexedTagValue',
    'HostNamingConditionConditionInteger',
    'HostNamingConditionConditionIntegerComparison',
    'HostNamingConditionConditionIpaddress',
    'HostNamingConditionConditionIpaddressComparison',
    'HostNamingConditionConditionKey',
    'HostNamingConditionConditionMobilePlatform',
    'HostNamingConditionConditionMobilePlatformComparison',
    'HostNamingConditionConditionOsArch',
    'HostNamingConditionConditionOsType',
    'HostNamingConditionConditionOsarchitectureComparison',
    'HostNamingConditionConditionOstypeComparison',
    'HostNamingConditionConditionPaasType',
    'HostNamingConditionConditionPaasTypeComparison',
    'HostNamingConditionConditionProcessMetadata',
    'HostNamingConditionConditionProcessMetadataConditionKey',
    'HostNamingConditionConditionServiceTopology',
    'HostNamingConditionConditionServiceTopologyComparison',
    'HostNamingConditionConditionServiceType',
    'HostNamingConditionConditionServiceTypeComparison',
    'HostNamingConditionConditionSimpleHostTechComparison',
    'HostNamingConditionConditionSimpleHostTechComparisonValue',
    'HostNamingConditionConditionSimpleTechComparison',
    'HostNamingConditionConditionSimpleTechComparisonValue',
    'HostNamingConditionConditionString',
    'HostNamingConditionConditionStringComparison',
    'HostNamingConditionConditionStringConditionKey',
    'HostNamingConditionConditionStringKey',
    'HostNamingConditionConditionSyntheticEngine',
    'HostNamingConditionConditionSyntheticEngineTypeComparison',
    'HostNamingConditionConditionTag',
    'HostNamingConditionConditionTagComparison',
    'HostNamingConditionConditionTagComparisonValue',
    'HostNamingConditionConditionTagValue',
    'HostNamingConditionConditionTech',
    'HostNamingConditionConditionTechValue',
    'HttpMonitorAnomalyDetection',
    'HttpMonitorAnomalyDetectionLoadingTimeThreshold',
    'HttpMonitorAnomalyDetectionLoadingTimeThresholdThreshold',
    'HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold',
    'HttpMonitorAnomalyDetectionOutageHandling',
    'HttpMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy',
    'HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy',
    'HttpMonitorCookiesCookies',
    'HttpMonitorCookiesCookiesCookie',
    'HttpMonitorPerformanceThresholds',
    'HttpMonitorPerformanceThresholdsThreshold',
    'HttpMonitorScript',
    'HttpMonitorScriptRequest',
    'HttpMonitorScriptRequestAuthentication',
    'HttpMonitorScriptRequestConfiguration',
    'HttpMonitorScriptRequestConfigurationHeaders',
    'HttpMonitorScriptRequestConfigurationHeadersHeader',
    'HttpMonitorScriptRequestValidation',
    'HttpMonitorScriptRequestValidationRule',
    'HttpMonitorScriptScript',
    'HttpMonitorScriptScriptRequest',
    'HttpMonitorScriptScriptRequestAuthentication',
    'HttpMonitorScriptScriptRequestConfiguration',
    'HttpMonitorScriptScriptRequestConfigurationHeaders',
    'HttpMonitorScriptScriptRequestConfigurationHeadersHeader',
    'HttpMonitorScriptScriptRequestValidation',
    'HttpMonitorScriptScriptRequestValidationRule',
    'HttpMonitorTag',
    'HttpMonitorTagTag',
    'HubSubscriptionsTokenSubscriptions',
    'HubSubscriptionsTokenSubscriptionsTokenSubscription',
    'IamGroupPermissions',
    'IamGroupPermissionsPermission',
    'IamPolicyBindingsV2Policy',
    'ImsBridgesQueueManager',
    'ImsBridgesQueueManagerQueueManager',
    'K8sClusterAnomaliesCpuRequestsSaturation',
    'K8sClusterAnomaliesCpuRequestsSaturationConfiguration',
    'K8sClusterAnomaliesMemoryRequestsSaturation',
    'K8sClusterAnomaliesMemoryRequestsSaturationConfiguration',
    'K8sClusterAnomaliesMonitoringIssues',
    'K8sClusterAnomaliesMonitoringIssuesConfiguration',
    'K8sClusterAnomaliesPodsSaturation',
    'K8sClusterAnomaliesPodsSaturationConfiguration',
    'K8sClusterAnomaliesReadinessIssues',
    'K8sClusterAnomaliesReadinessIssuesConfiguration',
    'K8sCredentialsEventsFieldSelector',
    'K8sMonitoringEventPatterns',
    'K8sMonitoringEventPatternsEventPattern',
    'K8sNamespaceAnomaliesCpuLimitsQuotaSaturation',
    'K8sNamespaceAnomaliesCpuLimitsQuotaSaturationConfiguration',
    'K8sNamespaceAnomaliesCpuRequestsQuotaSaturation',
    'K8sNamespaceAnomaliesCpuRequestsQuotaSaturationConfiguration',
    'K8sNamespaceAnomaliesMemoryLimitsQuotaSaturation',
    'K8sNamespaceAnomaliesMemoryLimitsQuotaSaturationConfiguration',
    'K8sNamespaceAnomaliesMemoryRequestsQuotaSaturation',
    'K8sNamespaceAnomaliesMemoryRequestsQuotaSaturationConfiguration',
    'K8sNamespaceAnomaliesPodsQuotaSaturation',
    'K8sNamespaceAnomaliesPodsQuotaSaturationConfiguration',
    'K8sNodeAnomaliesCpuRequestsSaturation',
    'K8sNodeAnomaliesCpuRequestsSaturationConfiguration',
    'K8sNodeAnomaliesMemoryRequestsSaturation',
    'K8sNodeAnomaliesMemoryRequestsSaturationConfiguration',
    'K8sNodeAnomaliesNodeProblematicCondition',
    'K8sNodeAnomaliesNodeProblematicConditionConfiguration',
    'K8sNodeAnomaliesPodsSaturation',
    'K8sNodeAnomaliesPodsSaturationConfiguration',
    'K8sNodeAnomaliesReadinessIssues',
    'K8sNodeAnomaliesReadinessIssuesConfiguration',
    'K8sPvcAnomaliesLowDiskSpaceCritical',
    'K8sPvcAnomaliesLowDiskSpaceCriticalConfiguration',
    'K8sPvcAnomaliesLowDiskSpaceCriticalPercentage',
    'K8sPvcAnomaliesLowDiskSpaceCriticalPercentageConfiguration',
    'K8sWorkloadAnomaliesContainerRestarts',
    'K8sWorkloadAnomaliesContainerRestartsConfiguration',
    'K8sWorkloadAnomaliesDeploymentStuck',
    'K8sWorkloadAnomaliesDeploymentStuckConfiguration',
    'K8sWorkloadAnomaliesHighCpuThrottling',
    'K8sWorkloadAnomaliesHighCpuThrottlingConfiguration',
    'K8sWorkloadAnomaliesHighCpuUsage',
    'K8sWorkloadAnomaliesHighCpuUsageConfiguration',
    'K8sWorkloadAnomaliesHighMemoryUsage',
    'K8sWorkloadAnomaliesHighMemoryUsageConfiguration',
    'K8sWorkloadAnomaliesJobFailureEvents',
    'K8sWorkloadAnomaliesNotAllPodsReady',
    'K8sWorkloadAnomaliesNotAllPodsReadyConfiguration',
    'K8sWorkloadAnomaliesOomKills',
    'K8sWorkloadAnomaliesPendingPods',
    'K8sWorkloadAnomaliesPendingPodsConfiguration',
    'K8sWorkloadAnomaliesPodBackoffEvents',
    'K8sWorkloadAnomaliesPodEvictionEvents',
    'K8sWorkloadAnomaliesPodPreemptionEvents',
    'K8sWorkloadAnomaliesPodStuckInTerminating',
    'K8sWorkloadAnomaliesPodStuckInTerminatingConfiguration',
    'K8sWorkloadAnomaliesWorkloadWithoutReadyPods',
    'K8sWorkloadAnomaliesWorkloadWithoutReadyPodsConfiguration',
    'KubernetesAppKubernetesAppOptions',
    'KubernetesEnrichmentRules',
    'KubernetesEnrichmentRulesRule',
    'KubernetesEventPatterns',
    'KubernetesEventPatternsEventPattern',
    'LimitOutboundConnectionsAllowedOutboundConnections',
    'LogCustomSourceContext',
    'LogCustomSourceContextContext',
    'LogCustomSourceCustomLogSource',
    'LogCustomSourceCustomLogSourceValuesAndEnrichment',
    'LogCustomSourceCustomLogSourceValuesAndEnrichmentCustomLogSourceWithEnrichment',
    'LogCustomSourceCustomLogSourceValuesAndEnrichmentCustomLogSourceWithEnrichmentEnrichment',
    'LogCustomSourceCustomLogSourceValuesAndEnrichmentCustomLogSourceWithEnrichmentEnrichmentEnrichment',
    'LogEventsEventTemplate',
    'LogEventsEventTemplateMetadata',
    'LogEventsEventTemplateMetadataItem',
    'LogProcessingProcessorDefinition',
    'LogProcessingRuleTesting',
    'LogSecurityContextSecurityContextRule',
    'LogSensitiveDataMaskingMasking',
    'LogSensitiveDataMaskingMatchers',
    'LogSensitiveDataMaskingMatchersMatcher',
    'LogStorageMatchers',
    'LogStorageMatchersMatcher',
    'LogTimestampEntryBoundary',
    'LogTimestampMatchers',
    'LogTimestampMatchersMatcher',
    'MaintenanceFilters',
    'MaintenanceFiltersFilter',
    'MaintenanceGeneralProperties',
    'MaintenanceSchedule',
    'MaintenanceScheduleDailyRecurrence',
    'MaintenanceScheduleDailyRecurrenceRecurrenceRange',
    'MaintenanceScheduleDailyRecurrenceTimeWindow',
    'MaintenanceScheduleMonthlyRecurrence',
    'MaintenanceScheduleMonthlyRecurrenceRecurrenceRange',
    'MaintenanceScheduleMonthlyRecurrenceTimeWindow',
    'MaintenanceScheduleOnceRecurrence',
    'MaintenanceScheduleWeeklyRecurrence',
    'MaintenanceScheduleWeeklyRecurrenceRecurrenceRange',
    'MaintenanceScheduleWeeklyRecurrenceTimeWindow',
    'MaintenanceWindowSchedule',
    'MaintenanceWindowScheduleRecurrence',
    'MaintenanceWindowScope',
    'MaintenanceWindowScopeMatch',
    'MaintenanceWindowScopeMatchTag',
    'ManagementZoneDimensionalRule',
    'ManagementZoneDimensionalRuleCondition',
    'ManagementZoneEntitySelectorBasedRule',
    'ManagementZoneRule',
    'ManagementZoneRuleCondition',
    'ManagementZoneRuleConditionApplicationType',
    'ManagementZoneRuleConditionApplicationTypeComparison',
    'ManagementZoneRuleConditionAzureComputeMode',
    'ManagementZoneRuleConditionAzureComputeModeComparison',
    'ManagementZoneRuleConditionAzureSkuComparision',
    'ManagementZoneRuleConditionAzureSkus',
    'ManagementZoneRuleConditionBaseComparisonBasic',
    'ManagementZoneRuleConditionBaseConditionKey',
    'ManagementZoneRuleConditionBitness',
    'ManagementZoneRuleConditionBitnessComparision',
    'ManagementZoneRuleConditionCloudType',
    'ManagementZoneRuleConditionCloudTypeComparison',
    'ManagementZoneRuleConditionComparison',
    'ManagementZoneRuleConditionCustomApplicationType',
    'ManagementZoneRuleConditionCustomApplicationTypeComparison',
    'ManagementZoneRuleConditionCustomHostMetadata',
    'ManagementZoneRuleConditionCustomHostMetadataConditionKey',
    'ManagementZoneRuleConditionCustomHostMetadataConditionKeyDynamicKey',
    'ManagementZoneRuleConditionCustomHostMetadataDynamicKey',
    'ManagementZoneRuleConditionCustomProcessMetadata',
    'ManagementZoneRuleConditionCustomProcessMetadataConditionKey',
    'ManagementZoneRuleConditionCustomProcessMetadataConditionKeyDynamicKey',
    'ManagementZoneRuleConditionCustomProcessMetadataDynamicKey',
    'ManagementZoneRuleConditionDatabaseTopology',
    'ManagementZoneRuleConditionDatabaseTopologyComparison',
    'ManagementZoneRuleConditionDcrumDecoder',
    'ManagementZoneRuleConditionDcrumDecoderComparison',
    'ManagementZoneRuleConditionEntity',
    'ManagementZoneRuleConditionEntityIdComparison',
    'ManagementZoneRuleConditionHostTech',
    'ManagementZoneRuleConditionHostTechValue',
    'ManagementZoneRuleConditionHypervisor',
    'ManagementZoneRuleConditionHypervisorTypeComparision',
    'ManagementZoneRuleConditionIndexedName',
    'ManagementZoneRuleConditionIndexedNameComparison',
    'ManagementZoneRuleConditionIndexedString',
    'ManagementZoneRuleConditionIndexedStringComparison',
    'ManagementZoneRuleConditionIndexedTag',
    'ManagementZoneRuleConditionIndexedTagComparison',
    'ManagementZoneRuleConditionIndexedTagComparisonValue',
    'ManagementZoneRuleConditionIndexedTagValue',
    'ManagementZoneRuleConditionInteger',
    'ManagementZoneRuleConditionIntegerComparison',
    'ManagementZoneRuleConditionIpaddress',
    'ManagementZoneRuleConditionIpaddressComparison',
    'ManagementZoneRuleConditionKey',
    'ManagementZoneRuleConditionMobilePlatform',
    'ManagementZoneRuleConditionMobilePlatformComparison',
    'ManagementZoneRuleConditionOsArch',
    'ManagementZoneRuleConditionOsType',
    'ManagementZoneRuleConditionOsarchitectureComparison',
    'ManagementZoneRuleConditionOstypeComparison',
    'ManagementZoneRuleConditionPaasType',
    'ManagementZoneRuleConditionPaasTypeComparison',
    'ManagementZoneRuleConditionProcessMetadata',
    'ManagementZoneRuleConditionProcessMetadataConditionKey',
    'ManagementZoneRuleConditionServiceTopology',
    'ManagementZoneRuleConditionServiceTopologyComparison',
    'ManagementZoneRuleConditionServiceType',
    'ManagementZoneRuleConditionServiceTypeComparison',
    'ManagementZoneRuleConditionSimpleHostTechComparison',
    'ManagementZoneRuleConditionSimpleHostTechComparisonValue',
    'ManagementZoneRuleConditionSimpleTechComparison',
    'ManagementZoneRuleConditionSimpleTechComparisonValue',
    'ManagementZoneRuleConditionString',
    'ManagementZoneRuleConditionStringComparison',
    'ManagementZoneRuleConditionStringConditionKey',
    'ManagementZoneRuleConditionStringKey',
    'ManagementZoneRuleConditionSyntheticEngine',
    'ManagementZoneRuleConditionSyntheticEngineTypeComparison',
    'ManagementZoneRuleConditionTag',
    'ManagementZoneRuleConditionTagComparison',
    'ManagementZoneRuleConditionTagComparisonValue',
    'ManagementZoneRuleConditionTagValue',
    'ManagementZoneRuleConditionTech',
    'ManagementZoneRuleConditionTechValue',
    'ManagementZoneV2Rules',
    'ManagementZoneV2RulesRule',
    'ManagementZoneV2RulesRuleAttributeRule',
    'ManagementZoneV2RulesRuleAttributeRuleAttributeConditions',
    'ManagementZoneV2RulesRuleAttributeRuleAttributeConditionsCondition',
    'ManagementZoneV2RulesRuleDimensionRule',
    'ManagementZoneV2RulesRuleDimensionRuleDimensionConditions',
    'ManagementZoneV2RulesRuleDimensionRuleDimensionConditionsCondition',
    'MetricEventsEventTemplate',
    'MetricEventsEventTemplateMetadata',
    'MetricEventsModelProperties',
    'MetricEventsQueryDefinition',
    'MetricEventsQueryDefinitionDimensionFilter',
    'MetricEventsQueryDefinitionDimensionFilterFilter',
    'MetricEventsQueryDefinitionEntityFilter',
    'MetricEventsQueryDefinitionEntityFilterConditions',
    'MetricEventsQueryDefinitionEntityFilterConditionsCondition',
    'MetricMetadataDimensions',
    'MetricMetadataDimensionsDimension',
    'MetricMetadataMetricProperties',
    'MobileAppAnomaliesErrorRateIncrease',
    'MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto',
    'MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed',
    'MobileAppAnomaliesSlowUserActions',
    'MobileAppAnomaliesSlowUserActionsSlowUserActionsAuto',
    'MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting',
    'MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll',
    'MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest',
    'MobileAppAnomaliesSlowUserActionsSlowUserActionsFixed',
    'MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting',
    'MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed',
    'MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest',
    'MobileAppAnomaliesUnexpectedHighLoad',
    'MobileAppAnomaliesUnexpectedLowLoad',
    'MobileAppCrashRateCrashRateIncrease',
    'MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto',
    'MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed',
    'MobileAppEnablementRum',
    'MobileAppEnablementSessionReplay',
    'MobileAppKeyPerformanceThresholds',
    'MobileAppRequestErrorsErrorRules',
    'MobileAppRequestErrorsErrorRulesErrorRule',
    'MobileApplicationApdex',
    'MobileApplicationProperties',
    'MobileApplicationPropertiesApiValue',
    'MobileApplicationPropertiesRequestAttribute',
    'NetworkMonitorOutageHandling',
    'NetworkMonitorPerformanceThresholds',
    'NetworkMonitorPerformanceThresholdsThresholds',
    'NetworkMonitorPerformanceThresholdsThresholdsThreshold',
    'NetworkMonitorStep',
    'NetworkMonitorStepStep',
    'NetworkMonitorStepStepConstraint',
    'NetworkMonitorStepStepConstraintConstraint',
    'NetworkMonitorStepStepRequestConfiguration',
    'NetworkMonitorStepStepRequestConfigurationRequestConfiguration',
    'NetworkMonitorStepStepRequestConfigurationRequestConfigurationConstraint',
    'NetworkMonitorStepStepRequestConfigurationRequestConfigurationConstraintConstraint',
    'NetworkMonitorTag',
    'NetworkMonitorTagTag',
    'NetworkTrafficExcludeIp',
    'NetworkTrafficExcludeIpIpAddressForm',
    'NetworkTrafficExcludeNic',
    'NetworkTrafficExcludeNicNicForm',
    'NotificationAnsibleTower',
    'NotificationConfig',
    'NotificationEmail',
    'NotificationJira',
    'NotificationOpsGenie',
    'NotificationPagerDuty',
    'NotificationServiceNow',
    'NotificationSlack',
    'NotificationTrello',
    'NotificationVictorOps',
    'NotificationWebHook',
    'NotificationWebHookHeader',
    'NotificationXmatters',
    'NotificationXmattersHeader',
    'OneagentUpdatesMaintenanceWindows',
    'OneagentUpdatesMaintenanceWindowsMaintenanceWindow',
    'OpentelemetryMetricsAdditionalAttributes',
    'OpentelemetryMetricsAdditionalAttributesAdditionalAttribute',
    'OpentelemetryMetricsToDropAttributes',
    'OpentelemetryMetricsToDropAttributesToDropAttribute',
    'OsServicesDetectionConditionsLinux',
    'OsServicesDetectionConditionsLinuxLinuxDetectionCondition',
    'OsServicesDetectionConditionsLinuxLinuxDetectionConditionHostMetadataCondition',
    'OsServicesDetectionConditionsWindows',
    'OsServicesDetectionConditionsWindowsDetectionConditionsWindow',
    'OsServicesDetectionConditionsWindowsDetectionConditionsWindowHostMetadataCondition',
    'OsServicesMetadata',
    'OsServicesMetadataItem',
    'OwnershipConfigOwnershipIdentifiers',
    'OwnershipConfigOwnershipIdentifiersOwnershipIdentifier',
    'OwnershipTeamsAdditionalInformation',
    'OwnershipTeamsAdditionalInformationAdditionalInformation',
    'OwnershipTeamsContactDetails',
    'OwnershipTeamsContactDetailsContactDetail',
    'OwnershipTeamsContactDetailsContactDetailJira',
    'OwnershipTeamsLinks',
    'OwnershipTeamsLinksLink',
    'OwnershipTeamsResponsibilities',
    'OwnershipTeamsSupplementaryIdentifiers',
    'OwnershipTeamsSupplementaryIdentifiersSupplementaryIdentifier',
    'PgAnomaliesAvailability',
    'ProcessAvailabilityMetadata',
    'ProcessAvailabilityMetadataItem',
    'ProcessAvailabilityRules',
    'ProcessAvailabilityRulesRule',
    'ProcessAvailabilityRulesRuleHostMetadataCondition',
    'ProcessGroupDetectionGroupExtraction',
    'ProcessGroupDetectionGroupExtractionDelimiter',
    'ProcessGroupDetectionInstanceExtraction',
    'ProcessGroupDetectionInstanceExtractionDelimiter',
    'ProcessGroupDetectionProcessDetection',
    'ProcessMonitoringRuleCondition',
    'ProcessgroupNamingCondition',
    'ProcessgroupNamingConditionCondition',
    'ProcessgroupNamingConditionConditionApplicationType',
    'ProcessgroupNamingConditionConditionApplicationTypeComparison',
    'ProcessgroupNamingConditionConditionAzureComputeMode',
    'ProcessgroupNamingConditionConditionAzureComputeModeComparison',
    'ProcessgroupNamingConditionConditionAzureSkuComparision',
    'ProcessgroupNamingConditionConditionAzureSkus',
    'ProcessgroupNamingConditionConditionBaseComparisonBasic',
    'ProcessgroupNamingConditionConditionBaseConditionKey',
    'ProcessgroupNamingConditionConditionBitness',
    'ProcessgroupNamingConditionConditionBitnessComparision',
    'ProcessgroupNamingConditionConditionCloudType',
    'ProcessgroupNamingConditionConditionCloudTypeComparison',
    'ProcessgroupNamingConditionConditionComparison',
    'ProcessgroupNamingConditionConditionCustomApplicationType',
    'ProcessgroupNamingConditionConditionCustomApplicationTypeComparison',
    'ProcessgroupNamingConditionConditionCustomHostMetadata',
    'ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey',
    'ProcessgroupNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey',
    'ProcessgroupNamingConditionConditionCustomHostMetadataDynamicKey',
    'ProcessgroupNamingConditionConditionCustomProcessMetadata',
    'ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey',
    'ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey',
    'ProcessgroupNamingConditionConditionCustomProcessMetadataDynamicKey',
    'ProcessgroupNamingConditionConditionDatabaseTopology',
    'ProcessgroupNamingConditionConditionDatabaseTopologyComparison',
    'ProcessgroupNamingConditionConditionDcrumDecoder',
    'ProcessgroupNamingConditionConditionDcrumDecoderComparison',
    'ProcessgroupNamingConditionConditionEntity',
    'ProcessgroupNamingConditionConditionEntityIdComparison',
    'ProcessgroupNamingConditionConditionHostTech',
    'ProcessgroupNamingConditionConditionHostTechValue',
    'ProcessgroupNamingConditionConditionHypervisor',
    'ProcessgroupNamingConditionConditionHypervisorTypeComparision',
    'ProcessgroupNamingConditionConditionIndexedName',
    'ProcessgroupNamingConditionConditionIndexedNameComparison',
    'ProcessgroupNamingConditionConditionIndexedString',
    'ProcessgroupNamingConditionConditionIndexedStringComparison',
    'ProcessgroupNamingConditionConditionIndexedTag',
    'ProcessgroupNamingConditionConditionIndexedTagComparison',
    'ProcessgroupNamingConditionConditionIndexedTagComparisonValue',
    'ProcessgroupNamingConditionConditionIndexedTagValue',
    'ProcessgroupNamingConditionConditionInteger',
    'ProcessgroupNamingConditionConditionIntegerComparison',
    'ProcessgroupNamingConditionConditionIpaddress',
    'ProcessgroupNamingConditionConditionIpaddressComparison',
    'ProcessgroupNamingConditionConditionKey',
    'ProcessgroupNamingConditionConditionMobilePlatform',
    'ProcessgroupNamingConditionConditionMobilePlatformComparison',
    'ProcessgroupNamingConditionConditionOsArch',
    'ProcessgroupNamingConditionConditionOsType',
    'ProcessgroupNamingConditionConditionOsarchitectureComparison',
    'ProcessgroupNamingConditionConditionOstypeComparison',
    'ProcessgroupNamingConditionConditionPaasType',
    'ProcessgroupNamingConditionConditionPaasTypeComparison',
    'ProcessgroupNamingConditionConditionProcessMetadata',
    'ProcessgroupNamingConditionConditionProcessMetadataConditionKey',
    'ProcessgroupNamingConditionConditionServiceTopology',
    'ProcessgroupNamingConditionConditionServiceTopologyComparison',
    'ProcessgroupNamingConditionConditionServiceType',
    'ProcessgroupNamingConditionConditionServiceTypeComparison',
    'ProcessgroupNamingConditionConditionSimpleHostTechComparison',
    'ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue',
    'ProcessgroupNamingConditionConditionSimpleTechComparison',
    'ProcessgroupNamingConditionConditionSimpleTechComparisonValue',
    'ProcessgroupNamingConditionConditionString',
    'ProcessgroupNamingConditionConditionStringComparison',
    'ProcessgroupNamingConditionConditionStringConditionKey',
    'ProcessgroupNamingConditionConditionStringKey',
    'ProcessgroupNamingConditionConditionSyntheticEngine',
    'ProcessgroupNamingConditionConditionSyntheticEngineTypeComparison',
    'ProcessgroupNamingConditionConditionTag',
    'ProcessgroupNamingConditionConditionTagComparison',
    'ProcessgroupNamingConditionConditionTagComparisonValue',
    'ProcessgroupNamingConditionConditionTagValue',
    'ProcessgroupNamingConditionConditionTech',
    'ProcessgroupNamingConditionConditionTechValue',
    'QueueManagerAliasQueue',
    'QueueManagerAliasQueueAliasQueue',
    'QueueManagerClusterQueue',
    'QueueManagerClusterQueueClusterQueue',
    'QueueManagerRemoteQueue',
    'QueueManagerRemoteQueueRemoteQueue',
    'ReportSubscriptions',
    'RequestAttributeDataSource',
    'RequestAttributeDataSourceCicsSdkMethodNodeCondition',
    'RequestAttributeDataSourceIibLabelMethodNodeCondition',
    'RequestAttributeDataSourceIibMethodNodeCondition',
    'RequestAttributeDataSourceMethod',
    'RequestAttributeDataSourceMethodMethod',
    'RequestAttributeDataSourceScope',
    'RequestAttributeDataSourceValueProcessing',
    'RequestAttributeDataSourceValueProcessingExtractSubstring',
    'RequestAttributeDataSourceValueProcessingValueCondition',
    'RequestNamingConditions',
    'RequestNamingConditionsCondition',
    'RequestNamingConditionsConditionComparison',
    'RequestNamingConditionsConditionComparisonBoolean',
    'RequestNamingConditionsConditionComparisonEsbInputNodeType',
    'RequestNamingConditionsConditionComparisonFailedState',
    'RequestNamingConditionsConditionComparisonFailureReason',
    'RequestNamingConditionsConditionComparisonFastString',
    'RequestNamingConditionsConditionComparisonFlawState',
    'RequestNamingConditionsConditionComparisonGeneric',
    'RequestNamingConditionsConditionComparisonHttpMethod',
    'RequestNamingConditionsConditionComparisonHttpStatusClass',
    'RequestNamingConditionsConditionComparisonIibInputNodeType',
    'RequestNamingConditionsConditionComparisonNumber',
    'RequestNamingConditionsConditionComparisonNumberRequestAttribute',
    'RequestNamingConditionsConditionComparisonNumberRequestAttributeSource',
    'RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag',
    'RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey',
    'RequestNamingConditionsConditionComparisonServiceType',
    'RequestNamingConditionsConditionComparisonString',
    'RequestNamingConditionsConditionComparisonStringRequestAttribute',
    'RequestNamingConditionsConditionComparisonStringRequestAttributeSource',
    'RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag',
    'RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey',
    'RequestNamingConditionsConditionComparisonTag',
    'RequestNamingConditionsConditionComparisonTagValue',
    'RequestNamingConditionsConditionComparisonTagValues',
    'RequestNamingConditionsConditionComparisonTagValuesValue',
    'RequestNamingConditionsConditionComparisonZosCallType',
    'RequestNamingPlaceholders',
    'RequestNamingPlaceholdersPlaceholder',
    'RequestNamingPlaceholdersPlaceholderSource',
    'RequestNamingPlaceholdersPlaceholderSourceServiceTag',
    'RequestNamingPlaceholdersPlaceholderSourceServiceTagTagKey',
    'ResourceAttributesKeys',
    'ResourceAttributesKeysRule',
    'RumProviderBreakdownDomainNamePatternList',
    'RumProviderBreakdownDomainNamePatternListDomainNamePattern',
    'ServiceAnomaliesFailureRates',
    'ServiceAnomaliesFailureRatesAuto',
    'ServiceAnomaliesFailureRatesThresholds',
    'ServiceAnomaliesLoad',
    'ServiceAnomaliesLoadDrops',
    'ServiceAnomaliesLoadSpikes',
    'ServiceAnomaliesResponseTimes',
    'ServiceAnomaliesResponseTimesAuto',
    'ServiceAnomaliesResponseTimesThresholds',
    'ServiceAnomaliesV2FailureRate',
    'ServiceAnomaliesV2FailureRateAutoDetection',
    'ServiceAnomaliesV2FailureRateAutoDetectionOverAlertingProtection',
    'ServiceAnomaliesV2FailureRateFixedDetection',
    'ServiceAnomaliesV2FailureRateFixedDetectionOverAlertingProtection',
    'ServiceAnomaliesV2LoadDrops',
    'ServiceAnomaliesV2LoadSpikes',
    'ServiceAnomaliesV2ResponseTime',
    'ServiceAnomaliesV2ResponseTimeAutoDetection',
    'ServiceAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection',
    'ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll',
    'ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest',
    'ServiceAnomaliesV2ResponseTimeFixedDetection',
    'ServiceAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection',
    'ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll',
    'ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest',
    'ServiceExternalWebRequestConditions',
    'ServiceExternalWebRequestConditionsCondition',
    'ServiceExternalWebRequestIdContributors',
    'ServiceExternalWebRequestIdContributorsApplicationId',
    'ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributor',
    'ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformations',
    'ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation',
    'ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride',
    'ServiceExternalWebRequestIdContributorsContextRoot',
    'ServiceExternalWebRequestIdContributorsContextRootServiceIdContributor',
    'ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformations',
    'ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation',
    'ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorValueOverride',
    'ServiceExternalWebRequestIdContributorsPublicDomainName',
    'ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributor',
    'ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformations',
    'ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformationsTransformation',
    'ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorValueOverride',
    'ServiceExternalWebServiceConditions',
    'ServiceExternalWebServiceConditionsCondition',
    'ServiceExternalWebServiceIdContributors',
    'ServiceExternalWebServiceIdContributorsUrlPath',
    'ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributor',
    'ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformations',
    'ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformationsTransformation',
    'ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorValueOverride',
    'ServiceFailureExceptionRules',
    'ServiceFailureExceptionRulesCustomErrorRules',
    'ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRule',
    'ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRuleCondition',
    'ServiceFailureExceptionRulesCustomHandledExceptions',
    'ServiceFailureExceptionRulesCustomHandledExceptionsCustomHandledException',
    'ServiceFailureExceptionRulesIgnoredExceptions',
    'ServiceFailureExceptionRulesIgnoredExceptionsCustomHandledException',
    'ServiceFailureExceptionRulesSuccessForcingExceptions',
    'ServiceFailureExceptionRulesSuccessForcingExceptionsCustomHandledException',
    'ServiceFullWebRequestConditions',
    'ServiceFullWebRequestConditionsCondition',
    'ServiceFullWebRequestIdContributors',
    'ServiceFullWebRequestIdContributorsApplicationId',
    'ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributor',
    'ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformations',
    'ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation',
    'ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride',
    'ServiceFullWebRequestIdContributorsContextRoot',
    'ServiceFullWebRequestIdContributorsContextRootServiceIdContributor',
    'ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformations',
    'ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation',
    'ServiceFullWebRequestIdContributorsContextRootServiceIdContributorValueOverride',
    'ServiceFullWebRequestIdContributorsServerName',
    'ServiceFullWebRequestIdContributorsServerNameServiceIdContributor',
    'ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformations',
    'ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformationsTransformation',
    'ServiceFullWebRequestIdContributorsServerNameServiceIdContributorValueOverride',
    'ServiceFullWebServiceConditions',
    'ServiceFullWebServiceConditionsCondition',
    'ServiceFullWebServiceIdContributors',
    'ServiceFullWebServiceIdContributorsApplicationId',
    'ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributor',
    'ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformations',
    'ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformationsTransformation',
    'ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorValueOverride',
    'ServiceFullWebServiceIdContributorsContextRoot',
    'ServiceFullWebServiceIdContributorsContextRootServiceIdContributor',
    'ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformations',
    'ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformationsTransformation',
    'ServiceFullWebServiceIdContributorsContextRootServiceIdContributorValueOverride',
    'ServiceFullWebServiceIdContributorsServerName',
    'ServiceFullWebServiceIdContributorsServerNameServiceIdContributor',
    'ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformations',
    'ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformationsTransformation',
    'ServiceFullWebServiceIdContributorsServerNameServiceIdContributorValueOverride',
    'ServiceFullWebServiceIdContributorsWebServiceName',
    'ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributor',
    'ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformations',
    'ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformationsTransformation',
    'ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorValueOverride',
    'ServiceFullWebServiceIdContributorsWebServiceNamespace',
    'ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributor',
    'ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformations',
    'ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformationsTransformation',
    'ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorValueOverride',
    'ServiceHttpFailureBrokenLinks',
    'ServiceHttpFailureHttpResponseCodes',
    'ServiceNamingCondition',
    'ServiceNamingConditionCondition',
    'ServiceNamingConditionConditionApplicationType',
    'ServiceNamingConditionConditionApplicationTypeComparison',
    'ServiceNamingConditionConditionAzureComputeMode',
    'ServiceNamingConditionConditionAzureComputeModeComparison',
    'ServiceNamingConditionConditionAzureSkuComparision',
    'ServiceNamingConditionConditionAzureSkus',
    'ServiceNamingConditionConditionBaseComparisonBasic',
    'ServiceNamingConditionConditionBaseConditionKey',
    'ServiceNamingConditionConditionBitness',
    'ServiceNamingConditionConditionBitnessComparision',
    'ServiceNamingConditionConditionCloudType',
    'ServiceNamingConditionConditionCloudTypeComparison',
    'ServiceNamingConditionConditionComparison',
    'ServiceNamingConditionConditionCustomApplicationType',
    'ServiceNamingConditionConditionCustomApplicationTypeComparison',
    'ServiceNamingConditionConditionCustomHostMetadata',
    'ServiceNamingConditionConditionCustomHostMetadataConditionKey',
    'ServiceNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey',
    'ServiceNamingConditionConditionCustomHostMetadataDynamicKey',
    'ServiceNamingConditionConditionCustomProcessMetadata',
    'ServiceNamingConditionConditionCustomProcessMetadataConditionKey',
    'ServiceNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey',
    'ServiceNamingConditionConditionCustomProcessMetadataDynamicKey',
    'ServiceNamingConditionConditionDatabaseTopology',
    'ServiceNamingConditionConditionDatabaseTopologyComparison',
    'ServiceNamingConditionConditionDcrumDecoder',
    'ServiceNamingConditionConditionDcrumDecoderComparison',
    'ServiceNamingConditionConditionEntity',
    'ServiceNamingConditionConditionEntityIdComparison',
    'ServiceNamingConditionConditionHostTech',
    'ServiceNamingConditionConditionHostTechValue',
    'ServiceNamingConditionConditionHypervisor',
    'ServiceNamingConditionConditionHypervisorTypeComparision',
    'ServiceNamingConditionConditionIndexedName',
    'ServiceNamingConditionConditionIndexedNameComparison',
    'ServiceNamingConditionConditionIndexedString',
    'ServiceNamingConditionConditionIndexedStringComparison',
    'ServiceNamingConditionConditionIndexedTag',
    'ServiceNamingConditionConditionIndexedTagComparison',
    'ServiceNamingConditionConditionIndexedTagComparisonValue',
    'ServiceNamingConditionConditionIndexedTagValue',
    'ServiceNamingConditionConditionInteger',
    'ServiceNamingConditionConditionIntegerComparison',
    'ServiceNamingConditionConditionIpaddress',
    'ServiceNamingConditionConditionIpaddressComparison',
    'ServiceNamingConditionConditionKey',
    'ServiceNamingConditionConditionMobilePlatform',
    'ServiceNamingConditionConditionMobilePlatformComparison',
    'ServiceNamingConditionConditionOsArch',
    'ServiceNamingConditionConditionOsType',
    'ServiceNamingConditionConditionOsarchitectureComparison',
    'ServiceNamingConditionConditionOstypeComparison',
    'ServiceNamingConditionConditionPaasType',
    'ServiceNamingConditionConditionPaasTypeComparison',
    'ServiceNamingConditionConditionProcessMetadata',
    'ServiceNamingConditionConditionProcessMetadataConditionKey',
    'ServiceNamingConditionConditionServiceTopology',
    'ServiceNamingConditionConditionServiceTopologyComparison',
    'ServiceNamingConditionConditionServiceType',
    'ServiceNamingConditionConditionServiceTypeComparison',
    'ServiceNamingConditionConditionSimpleHostTechComparison',
    'ServiceNamingConditionConditionSimpleHostTechComparisonValue',
    'ServiceNamingConditionConditionSimpleTechComparison',
    'ServiceNamingConditionConditionSimpleTechComparisonValue',
    'ServiceNamingConditionConditionString',
    'ServiceNamingConditionConditionStringComparison',
    'ServiceNamingConditionConditionStringConditionKey',
    'ServiceNamingConditionConditionStringKey',
    'ServiceNamingConditionConditionSyntheticEngine',
    'ServiceNamingConditionConditionSyntheticEngineTypeComparison',
    'ServiceNamingConditionConditionTag',
    'ServiceNamingConditionConditionTagComparison',
    'ServiceNamingConditionConditionTagComparisonValue',
    'ServiceNamingConditionConditionTagValue',
    'ServiceNamingConditionConditionTech',
    'ServiceNamingConditionConditionTechValue',
    'SessionReplayWebPrivacyMaskingPresets',
    'SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRules',
    'SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRulesAllowListRule',
    'SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRules',
    'SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRulesBlockListRule',
    'SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRules',
    'SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRulesAllowListRule',
    'SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRules',
    'SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRulesBlockListRule',
    'SiteReliabilityGuardianObjectives',
    'SiteReliabilityGuardianObjectivesObjective',
    'SiteReliabilityGuardianVariables',
    'SiteReliabilityGuardianVariablesVariable',
    'SloErrorBudgetBurnRate',
    'SloV2ErrorBudgetBurnRate',
    'SpanCaptureRuleMatches',
    'SpanCaptureRuleMatchesMatch',
    'SpanContextPropagationMatches',
    'SpanContextPropagationMatchesMatch',
    'SpanEntryPointMatches',
    'SpanEntryPointMatchesMatch',
    'UpdateWindowsDailyRecurrence',
    'UpdateWindowsDailyRecurrenceRecurrenceRange',
    'UpdateWindowsDailyRecurrenceUpdateTime',
    'UpdateWindowsMonthlyRecurrence',
    'UpdateWindowsMonthlyRecurrenceRecurrenceRange',
    'UpdateWindowsMonthlyRecurrenceUpdateTime',
    'UpdateWindowsOnceRecurrence',
    'UpdateWindowsOnceRecurrenceRecurrenceRange',
    'UpdateWindowsWeeklyRecurrence',
    'UpdateWindowsWeeklyRecurrenceRecurrenceRange',
    'UpdateWindowsWeeklyRecurrenceSelectedWeekDays',
    'UpdateWindowsWeeklyRecurrenceUpdateTime',
    'UrlBasedSamplingQueryParameters',
    'UrlBasedSamplingQueryParametersParameter',
    'UserActionMetricsFilters',
    'UserActionMetricsFiltersFilter',
    'UserActionMetricsValue',
    'UserGroupPermissions',
    'UserGroupPermissionsGrant',
    'UserSessionMetricsFilters',
    'UserSessionMetricsFiltersFilter',
    'UserSessionMetricsValue',
    'VmwareAnomaliesDroppedPacketsDetection',
    'VmwareAnomaliesDroppedPacketsDetectionCustomThresholds',
    'VmwareAnomaliesEsxiHighCpuDetection',
    'VmwareAnomaliesEsxiHighCpuDetectionCustomThresholds',
    'VmwareAnomaliesEsxiHighMemoryDetection',
    'VmwareAnomaliesEsxiHighMemoryDetectionCustomThresholds',
    'VmwareAnomaliesGuestCpuLimitDetection',
    'VmwareAnomaliesGuestCpuLimitDetectionCustomThresholds',
    'VmwareAnomaliesLowDatastoreSpaceDetection',
    'VmwareAnomaliesLowDatastoreSpaceDetectionCustomThresholds',
    'VmwareAnomaliesOverloadedStorageDetection',
    'VmwareAnomaliesOverloadedStorageDetectionCustomThresholds',
    'VmwareAnomaliesSlowPhysicalStorageDetection',
    'VmwareAnomaliesSlowPhysicalStorageDetectionCustomThresholds',
    'VmwareAnomaliesUndersizedStorageDetection',
    'VmwareAnomaliesUndersizedStorageDetectionCustomThresholds',
    'VulnerabilityCodeCriteria',
    'VulnerabilityCodeMetadata',
    'VulnerabilityCodeResourceAttributeConditions',
    'VulnerabilityCodeResourceAttributeConditionsResourceAttributeCondition',
    'VulnerabilityCodeVulnerabilityDetectionControl',
    'VulnerabilitySettingsTechnologies',
    'WebAppAnomaliesErrorRate',
    'WebAppAnomaliesErrorRateErrorRateAuto',
    'WebAppAnomaliesErrorRateErrorRateAutoOverAlertingProtection',
    'WebAppAnomaliesErrorRateErrorRateFixed',
    'WebAppAnomaliesResponseTime',
    'WebAppAnomaliesResponseTimeResponseTimeAuto',
    'WebAppAnomaliesResponseTimeResponseTimeAutoOverAlertingProtection',
    'WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeAll',
    'WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeSlowest',
    'WebAppAnomaliesResponseTimeResponseTimeFixed',
    'WebAppAnomaliesResponseTimeResponseTimeFixedOverAlertingProtection',
    'WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeAll',
    'WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeSlowest',
    'WebAppAnomaliesTrafficDrops',
    'WebAppAnomaliesTrafficDropsTrafficDrops',
    'WebAppAnomaliesTrafficSpikes',
    'WebAppAnomaliesTrafficSpikesTrafficSpikes',
    'WebAppCustomErrorsErrorRules',
    'WebAppCustomErrorsErrorRulesErrorRule',
    'WebAppCustomErrorsErrorRulesErrorRuleCaptureSettings',
    'WebAppEnablementRum',
    'WebAppEnablementSessionReplay',
    'WebAppKeyPerformanceCustomThresholds',
    'WebAppKeyPerformanceLoadFallbackThresholds',
    'WebAppKeyPerformanceLoadThresholds',
    'WebAppKeyPerformanceXhrFallbackThresholds',
    'WebAppKeyPerformanceXhrThresholds',
    'WebAppRequestErrorsErrorRules',
    'WebAppRequestErrorsErrorRulesErrorRule',
    'WebAppRequestErrorsErrorRulesErrorRuleCaptureSettings',
    'WebAppRequestErrorsErrorRulesErrorRuleFilterSettings',
    'WebApplicationConversionGoals',
    'WebApplicationConversionGoalsGoal',
    'WebApplicationConversionGoalsGoalDestination',
    'WebApplicationConversionGoalsGoalUserAction',
    'WebApplicationConversionGoalsGoalVisitDuration',
    'WebApplicationConversionGoalsGoalVisitNumAction',
    'WebApplicationCustomActionApdexSettings',
    'WebApplicationKeyUserAction',
    'WebApplicationKeyUserActionAction',
    'WebApplicationLoadActionApdexSettings',
    'WebApplicationMetaDataCaptureSettings',
    'WebApplicationMetaDataCaptureSettingsCapture',
    'WebApplicationMonitoringSettings',
    'WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings',
    'WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers',
    'WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings',
    'WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings',
    'WebApplicationMonitoringSettingsBrowserRestrictionSettings',
    'WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictions',
    'WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction',
    'WebApplicationMonitoringSettingsContentCapture',
    'WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings',
    'WebApplicationMonitoringSettingsContentCaptureTimeoutSettings',
    'WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings',
    'WebApplicationMonitoringSettingsIpAddressRestrictionSettings',
    'WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictions',
    'WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange',
    'WebApplicationMonitoringSettingsJavascriptFrameworkSupport',
    'WebApplicationMonitoringSettingsJavascriptInjectionRules',
    'WebApplicationMonitoringSettingsJavascriptInjectionRulesRule',
    'WebApplicationSessionReplayConfig',
    'WebApplicationUserActionAndSessionProperties',
    'WebApplicationUserActionAndSessionPropertiesProperty',
    'WebApplicationUserActionNamingSettings',
    'WebApplicationUserActionNamingSettingsCustomActionNamingRules',
    'WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule',
    'WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditions',
    'WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCondition',
    'WebApplicationUserActionNamingSettingsLoadActionNamingRules',
    'WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule',
    'WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditions',
    'WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCondition',
    'WebApplicationUserActionNamingSettingsPlaceholders',
    'WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder',
    'WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps',
    'WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep',
    'WebApplicationUserActionNamingSettingsXhrActionNamingRules',
    'WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule',
    'WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditions',
    'WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCondition',
    'WebApplicationUserTags',
    'WebApplicationUserTagsTag',
    'WebApplicationWaterfallSettings',
    'WebApplicationXhrActionApdexSettings',
    'WebhookNotificationHeaders',
    'WebhookNotificationHeadersHeader',
    'WebhookNotificationOauth2Credentials',
    'XmattersNotificationHeaders',
    'XmattersNotificationHeadersHeader',
    'GetAlertingProfilesValueResult',
    'GetApiTokensApiTokenResult',
    'GetDocumentsValueResult',
    'GetEntitiesEntityResult',
    'GetEntitiesEntityTagResult',
    'GetEntitiesEntityTagTagResult',
    'GetGenericSettingsValueResult',
    'GetHubItemsItemResult',
    'GetIamPoliciesPolicyResult',
    'GetManagementZonesValueResult',
    'GetRemoteEnvironmentsRemoteEnvironmentResult',
    'GetSyntheticLocationsLocationsResult',
    'GetSyntheticNodesNodeResult',
]

@pulumi.output_type
class AlertingFilters(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.AlertingFiltersFilter']] = None):
        """
        :param Sequence['AlertingFiltersFilterArgs'] filters: A conditions for the metric usage
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.AlertingFiltersFilter']]:
        """
        A conditions for the metric usage
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class AlertingFiltersFilter(dict):
    def __init__(__self__, *,
                 custom: Optional['outputs.AlertingFiltersFilterCustom'] = None,
                 predefined: Optional['outputs.AlertingFiltersFilterPredefined'] = None):
        """
        :param 'AlertingFiltersFilterCustomArgs' custom: Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
        :param 'AlertingFiltersFilterPredefinedArgs' predefined: Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
        """
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if predefined is not None:
            pulumi.set(__self__, "predefined", predefined)

    @property
    @pulumi.getter
    def custom(self) -> Optional['outputs.AlertingFiltersFilterCustom']:
        """
        Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
        """
        return pulumi.get(self, "custom")

    @property
    @pulumi.getter
    def predefined(self) -> Optional['outputs.AlertingFiltersFilterPredefined']:
        """
        Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
        """
        return pulumi.get(self, "predefined")


@pulumi.output_type
class AlertingFiltersFilterCustom(dict):
    def __init__(__self__, *,
                 description: Optional['outputs.AlertingFiltersFilterCustomDescription'] = None,
                 metadata: Optional['outputs.AlertingFiltersFilterCustomMetadata'] = None,
                 title: Optional['outputs.AlertingFiltersFilterCustomTitle'] = None):
        """
        :param 'AlertingFiltersFilterCustomDescriptionArgs' description: Configuration of a matching filter
        :param 'AlertingFiltersFilterCustomMetadataArgs' metadata: Configuration of a matching filter
        :param 'AlertingFiltersFilterCustomTitleArgs' title: Configuration of a matching filter
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> Optional['outputs.AlertingFiltersFilterCustomDescription']:
        """
        Configuration of a matching filter
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.AlertingFiltersFilterCustomMetadata']:
        """
        Configuration of a matching filter
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AlertingFiltersFilterCustomTitle']:
        """
        Configuration of a matching filter
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class AlertingFiltersFilterCustomDescription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingFiltersFilterCustomDescription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingFiltersFilterCustomDescription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingFiltersFilterCustomDescription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 case_sensitive: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 negate: Optional[bool] = None):
        """
        :param str operator: Operator of the comparison.   You can reverse it by setting **negate** to `true`. Possible values are `BEGINS_WITH`, `CONTAINS`, `REGEX_MATCHES`, `ENDS_WITH` and `STRING_EQUALS`
        :param str value: The value to compare to
        :param bool case_sensitive: The condition is case sensitive (`false`) or case insensitive (`true`).   If not set, then `false` is used, making the condition case sensitive
        :param bool enabled: The filter is enabled (`true`) or disabled (`false`)
        :param bool negate: Reverses the comparison **operator**. For example it turns the **begins with** into **does not begin with**
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison.   You can reverse it by setting **negate** to `true`. Possible values are `BEGINS_WITH`, `CONTAINS`, `REGEX_MATCHES`, `ENDS_WITH` and `STRING_EQUALS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The condition is case sensitive (`false`) or case insensitive (`true`).   If not set, then `false` is used, making the condition case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        The filter is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the comparison **operator**. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")


@pulumi.output_type
class AlertingFiltersFilterCustomMetadata(dict):
    def __init__(__self__, *,
                 items: 'outputs.AlertingFiltersFilterCustomMetadataItems'):
        """
        :param 'AlertingFiltersFilterCustomMetadataItemsArgs' items: Define filters for event properties. A maximum of 20 properties is allowed.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> 'outputs.AlertingFiltersFilterCustomMetadataItems':
        """
        Define filters for event properties. A maximum of 20 properties is allowed.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class AlertingFiltersFilterCustomMetadataItems(dict):
    def __init__(__self__, *,
                 filters: Sequence['outputs.AlertingFiltersFilterCustomMetadataItemsFilter']):
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.AlertingFiltersFilterCustomMetadataItemsFilter']:
        return pulumi.get(self, "filters")


@pulumi.output_type
class AlertingFiltersFilterCustomMetadataItemsFilter(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 negate: Optional[bool] = None):
        """
        :param str key: GET /api/v2/eventProperties for list of available keys
        :param str value: Value
        :param bool negate: no documentation available
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        GET /api/v2/eventProperties for list of available keys
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        no documentation available
        """
        return pulumi.get(self, "negate")


@pulumi.output_type
class AlertingFiltersFilterCustomTitle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingFiltersFilterCustomTitle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingFiltersFilterCustomTitle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingFiltersFilterCustomTitle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 case_sensitive: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 negate: Optional[bool] = None):
        """
        :param str operator: Operator of the comparison.   You can reverse it by setting **negate** to `true`. Possible values are `BEGINS_WITH`, `CONTAINS`, `REGEX_MATCHES`, `ENDS_WITH` and `STRING_EQUALS`
        :param str value: The value to compare to
        :param bool case_sensitive: The condition is case sensitive (`false`) or case insensitive (`true`).   If not set, then `false` is used, making the condition case sensitive
        :param bool enabled: The filter is enabled (`true`) or disabled (`false`)
        :param bool negate: Reverses the comparison **operator**. For example it turns the **begins with** into **does not begin with**
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison.   You can reverse it by setting **negate** to `true`. Possible values are `BEGINS_WITH`, `CONTAINS`, `REGEX_MATCHES`, `ENDS_WITH` and `STRING_EQUALS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The condition is case sensitive (`false`) or case insensitive (`true`).   If not set, then `false` is used, making the condition case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        The filter is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the comparison **operator**. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")


@pulumi.output_type
class AlertingFiltersFilterPredefined(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None):
        """
        :param str type: The type of the predefined event. Possible values are `APPLICATION_ERROR_RATE_INCREASED`, `APPLICATION_SLOWDOWN`, `APPLICATION_UNEXPECTED_HIGH_LOAD`, `APPLICATION_UNEXPECTED_LOW_LOAD`, `AWS_LAMBDA_HIGH_ERROR_RATE`, `CUSTOM_APPLICATION_ERROR_RATE_INCREASED`, `CUSTOM_APPLICATION_SLOWDOWN`, `CUSTOM_APPLICATION_UNEXPECTED_HIGH_LOAD`, `CUSTOM_APPLICATION_UNEXPECTED_LOW_LOAD`, `CUSTOM_APP_CRASH_RATE_INCREASED`, `DATABASE_CONNECTION_FAILURE`, `DATA_CENTER_SERVICE_PERFORMANCE_DEGRADATION`, `DATA_CENTER_SERVICE_UNAVAILABLE`, `EBS_VOLUME_HIGH_LATENCY`, `EC2_HIGH_CPU`, `ELB_HIGH_BACKEND_ERROR_RATE`, `ENTERPRICE_APPLICATION_PERFORMANCE_DEGRADATION`, `ENTERPRISE_APPLICATION_UNAVAILABLE`, `ESXI_GUEST_ACTIVE_SWAP_WAIT`, `ESXI_GUEST_CPU_LIMIT_REACHED`, `ESXI_HOST_CPU_SATURATION`, `ESXI_HOST_DATASTORE_LOW_DISK_SPACE`, `ESXI_HOST_DISK_QUEUE_SLOW`, `ESXI_HOST_DISK_SLOW`, `ESXI_HOST_MEMORY_SATURATION`, `ESXI_HOST_NETWORK_PROBLEMS`, `ESXI_HOST_OVERLOADED_STORAGE`, `ESXI_VM_IMPACT_HOST_CPU_SATURATION`, `ESXI_VM_IMPACT_HOST_MEMORY_SATURATION`, `EXTERNAL_SYNTHETIC_TEST_OUTAGE`, `EXTERNAL_SYNTHETIC_TEST_SLOWDOWN`, `HOST_OF_SERVICE_UNAVAILABLE`, `HTTP_CHECK_GLOBAL_OUTAGE`, `HTTP_CHECK_LOCAL_OUTAGE`, `HTTP_CHECK_TEST_LOCATION_SLOWDOWN`, `MOBILE_APPLICATION_ERROR_RATE_INCREASED`, `MOBILE_APPLICATION_SLOWDOWN`, `MOBILE_APPLICATION_UNEXPECTED_HIGH_LOAD`, `MOBILE_APPLICATION_UNEXPECTED_LOW_LOAD`, `MOBILE_APP_CRASH_RATE_INCREASED`, `MONITORING_UNAVAILABLE`, `OSI_DISK_LOW_INODES`, `OSI_GRACEFULLY_SHUTDOWN`, `OSI_HIGH_CPU`, `OSI_HIGH_MEMORY`, `OSI_LOW_DISK_SPACE`, `OSI_NIC_DROPPED_PACKETS_HIGH`, `OSI_NIC_ERRORS_HIGH`, `OSI_NIC_UTILIZATION_HIGH`, `OSI_SLOW_DISK`, `OSI_UNEXPECTEDLY_UNAVAILABLE`, `PGI_OF_SERVICE_UNAVAILABLE`, `PGI_UNAVAILABLE`, `PG_LOW_INSTANCE_COUNT`, `PROCESS_CRASHED`, `PROCESS_HIGH_GC_ACTIVITY`, `PROCESS_MEMORY_RESOURCE_EXHAUSTED`, `PROCESS_NA_HIGH_CONN_FAIL_RATE`, `PROCESS_NA_HIGH_LOSS_RATE`, `PROCESS_THREADS_RESOURCE_EXHAUSTED`, `RDS_HIGH_CPU`, `RDS_HIGH_LATENCY`, `RDS_LOW_MEMORY`, `RDS_LOW_STORAGE_SPACE`, `RDS_OF_SERVICE_UNAVAILABLE`, `RDS_RESTART_SEQUENCE`, `SERVICE_ERROR_RATE_INCREASED`, `SERVICE_SLOWDOWN`, `SERVICE_UNEXPECTED_HIGH_LOAD`, `SERVICE_UNEXPECTED_LOW_LOAD`, `SYNTHETIC_GLOBAL_OUTAGE`, `SYNTHETIC_LOCAL_OUTAGE`, `SYNTHETIC_NODE_OUTAGE`, `SYNTHETIC_PRIVATE_LOCATION_OUTAGE` and `SYNTHETIC_TEST_LOCATION_SLOWDOWN`
        :param bool negate: The alert triggers when the problem of specified severity arises while the specified event **is** happening (`false`) or while the specified event is **not** happening (`true`).   For example, if you chose the Slowdown (`PERFORMANCE`) severity and Unexpected high traffic (`APPLICATION_UNEXPECTED_HIGH_LOAD`) event with **negate** set to `true`, the alerting profile will trigger only when the slowdown problem is raised while there is no unexpected high traffic event.  Consider the following use case as an example. The Slowdown (`PERFORMANCE`) severity rule is set. Depending on the configuration of the event filter (Unexpected high traffic (`APPLICATION_UNEXPECTED_HIGH_LOAD`) event is used as an example), the options of the alerting profile is one of the following:* **negate** is set to `false`: The alert triggers when the slowdown problem is raised while unexpected high traffic event is happening.  * **negate** is set to `true`: The alert triggers when the slowdown problem is raised while there is no unexpected high traffic event.  * no event rule is set: The alert triggers when the slowdown problem is raised, regardless of any events
        """
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the predefined event. Possible values are `APPLICATION_ERROR_RATE_INCREASED`, `APPLICATION_SLOWDOWN`, `APPLICATION_UNEXPECTED_HIGH_LOAD`, `APPLICATION_UNEXPECTED_LOW_LOAD`, `AWS_LAMBDA_HIGH_ERROR_RATE`, `CUSTOM_APPLICATION_ERROR_RATE_INCREASED`, `CUSTOM_APPLICATION_SLOWDOWN`, `CUSTOM_APPLICATION_UNEXPECTED_HIGH_LOAD`, `CUSTOM_APPLICATION_UNEXPECTED_LOW_LOAD`, `CUSTOM_APP_CRASH_RATE_INCREASED`, `DATABASE_CONNECTION_FAILURE`, `DATA_CENTER_SERVICE_PERFORMANCE_DEGRADATION`, `DATA_CENTER_SERVICE_UNAVAILABLE`, `EBS_VOLUME_HIGH_LATENCY`, `EC2_HIGH_CPU`, `ELB_HIGH_BACKEND_ERROR_RATE`, `ENTERPRICE_APPLICATION_PERFORMANCE_DEGRADATION`, `ENTERPRISE_APPLICATION_UNAVAILABLE`, `ESXI_GUEST_ACTIVE_SWAP_WAIT`, `ESXI_GUEST_CPU_LIMIT_REACHED`, `ESXI_HOST_CPU_SATURATION`, `ESXI_HOST_DATASTORE_LOW_DISK_SPACE`, `ESXI_HOST_DISK_QUEUE_SLOW`, `ESXI_HOST_DISK_SLOW`, `ESXI_HOST_MEMORY_SATURATION`, `ESXI_HOST_NETWORK_PROBLEMS`, `ESXI_HOST_OVERLOADED_STORAGE`, `ESXI_VM_IMPACT_HOST_CPU_SATURATION`, `ESXI_VM_IMPACT_HOST_MEMORY_SATURATION`, `EXTERNAL_SYNTHETIC_TEST_OUTAGE`, `EXTERNAL_SYNTHETIC_TEST_SLOWDOWN`, `HOST_OF_SERVICE_UNAVAILABLE`, `HTTP_CHECK_GLOBAL_OUTAGE`, `HTTP_CHECK_LOCAL_OUTAGE`, `HTTP_CHECK_TEST_LOCATION_SLOWDOWN`, `MOBILE_APPLICATION_ERROR_RATE_INCREASED`, `MOBILE_APPLICATION_SLOWDOWN`, `MOBILE_APPLICATION_UNEXPECTED_HIGH_LOAD`, `MOBILE_APPLICATION_UNEXPECTED_LOW_LOAD`, `MOBILE_APP_CRASH_RATE_INCREASED`, `MONITORING_UNAVAILABLE`, `OSI_DISK_LOW_INODES`, `OSI_GRACEFULLY_SHUTDOWN`, `OSI_HIGH_CPU`, `OSI_HIGH_MEMORY`, `OSI_LOW_DISK_SPACE`, `OSI_NIC_DROPPED_PACKETS_HIGH`, `OSI_NIC_ERRORS_HIGH`, `OSI_NIC_UTILIZATION_HIGH`, `OSI_SLOW_DISK`, `OSI_UNEXPECTEDLY_UNAVAILABLE`, `PGI_OF_SERVICE_UNAVAILABLE`, `PGI_UNAVAILABLE`, `PG_LOW_INSTANCE_COUNT`, `PROCESS_CRASHED`, `PROCESS_HIGH_GC_ACTIVITY`, `PROCESS_MEMORY_RESOURCE_EXHAUSTED`, `PROCESS_NA_HIGH_CONN_FAIL_RATE`, `PROCESS_NA_HIGH_LOSS_RATE`, `PROCESS_THREADS_RESOURCE_EXHAUSTED`, `RDS_HIGH_CPU`, `RDS_HIGH_LATENCY`, `RDS_LOW_MEMORY`, `RDS_LOW_STORAGE_SPACE`, `RDS_OF_SERVICE_UNAVAILABLE`, `RDS_RESTART_SEQUENCE`, `SERVICE_ERROR_RATE_INCREASED`, `SERVICE_SLOWDOWN`, `SERVICE_UNEXPECTED_HIGH_LOAD`, `SERVICE_UNEXPECTED_LOW_LOAD`, `SYNTHETIC_GLOBAL_OUTAGE`, `SYNTHETIC_LOCAL_OUTAGE`, `SYNTHETIC_NODE_OUTAGE`, `SYNTHETIC_PRIVATE_LOCATION_OUTAGE` and `SYNTHETIC_TEST_LOCATION_SLOWDOWN`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        The alert triggers when the problem of specified severity arises while the specified event **is** happening (`false`) or while the specified event is **not** happening (`true`).   For example, if you chose the Slowdown (`PERFORMANCE`) severity and Unexpected high traffic (`APPLICATION_UNEXPECTED_HIGH_LOAD`) event with **negate** set to `true`, the alerting profile will trigger only when the slowdown problem is raised while there is no unexpected high traffic event.  Consider the following use case as an example. The Slowdown (`PERFORMANCE`) severity rule is set. Depending on the configuration of the event filter (Unexpected high traffic (`APPLICATION_UNEXPECTED_HIGH_LOAD`) event is used as an example), the options of the alerting profile is one of the following:* **negate** is set to `false`: The alert triggers when the slowdown problem is raised while unexpected high traffic event is happening.  * **negate** is set to `true`: The alert triggers when the slowdown problem is raised while there is no unexpected high traffic event.  * no event rule is set: The alert triggers when the slowdown problem is raised, regardless of any events
        """
        return pulumi.get(self, "negate")


@pulumi.output_type
class AlertingProfileEventTypeFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customEventFilters":
            suggest = "custom_event_filters"
        elif key == "predefinedEventFilters":
            suggest = "predefined_event_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileEventTypeFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileEventTypeFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileEventTypeFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_event_filters: Optional[Sequence['outputs.AlertingProfileEventTypeFilterCustomEventFilter']] = None,
                 predefined_event_filters: Optional[Sequence['outputs.AlertingProfileEventTypeFilterPredefinedEventFilter']] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence['AlertingProfileEventTypeFilterCustomEventFilterArgs'] custom_event_filters: Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
        :param Sequence['AlertingProfileEventTypeFilterPredefinedEventFilterArgs'] predefined_event_filters: Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if custom_event_filters is not None:
            pulumi.set(__self__, "custom_event_filters", custom_event_filters)
        if predefined_event_filters is not None:
            pulumi.set(__self__, "predefined_event_filters", predefined_event_filters)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="customEventFilters")
    def custom_event_filters(self) -> Optional[Sequence['outputs.AlertingProfileEventTypeFilterCustomEventFilter']]:
        """
        Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
        """
        return pulumi.get(self, "custom_event_filters")

    @property
    @pulumi.getter(name="predefinedEventFilters")
    def predefined_event_filters(self) -> Optional[Sequence['outputs.AlertingProfileEventTypeFilterPredefinedEventFilter']]:
        """
        Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
        """
        return pulumi.get(self, "predefined_event_filters")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileEventTypeFilterCustomEventFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDescriptionFilters":
            suggest = "custom_description_filters"
        elif key == "customTitleFilters":
            suggest = "custom_title_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileEventTypeFilterCustomEventFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileEventTypeFilterCustomEventFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileEventTypeFilterCustomEventFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_description_filters: Optional[Sequence['outputs.AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter']] = None,
                 custom_title_filters: Optional[Sequence['outputs.AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter']] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence['AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilterArgs'] custom_description_filters: Configuration of a matching filter
        :param Sequence['AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilterArgs'] custom_title_filters: Configuration of a matching filter
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if custom_description_filters is not None:
            pulumi.set(__self__, "custom_description_filters", custom_description_filters)
        if custom_title_filters is not None:
            pulumi.set(__self__, "custom_title_filters", custom_title_filters)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="customDescriptionFilters")
    def custom_description_filters(self) -> Optional[Sequence['outputs.AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter']]:
        """
        Configuration of a matching filter
        """
        return pulumi.get(self, "custom_description_filters")

    @property
    @pulumi.getter(name="customTitleFilters")
    def custom_title_filters(self) -> Optional[Sequence['outputs.AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter']]:
        """
        Configuration of a matching filter
        """
        return pulumi.get(self, "custom_title_filters")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseInsensitive":
            suggest = "case_insensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 case_insensitive: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str operator: Operator of the comparison.   You can reverse it by setting **negate** to `true`. Possible values are `BEGINS_WITH`, `CONTAINS`, `CONTAINS_REGEX`, `ENDS_WITH` and `EQUALS`
        :param str value: The value to compare to
        :param bool case_insensitive: The condition is case sensitive (`false`) or case insensitive (`true`).   If not set, then `false` is used, making the condition case sensitive
        :param bool enabled: The filter is enabled (`true`) or disabled (`false`)
        :param bool negate: Reverses the comparison **operator**. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if case_insensitive is not None:
            pulumi.set(__self__, "case_insensitive", case_insensitive)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison.   You can reverse it by setting **negate** to `true`. Possible values are `BEGINS_WITH`, `CONTAINS`, `CONTAINS_REGEX`, `ENDS_WITH` and `EQUALS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseInsensitive")
    def case_insensitive(self) -> Optional[bool]:
        """
        The condition is case sensitive (`false`) or case insensitive (`true`).   If not set, then `false` is used, making the condition case sensitive
        """
        return pulumi.get(self, "case_insensitive")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        The filter is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the comparison **operator**. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseInsensitive":
            suggest = "case_insensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 case_insensitive: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str operator: Operator of the comparison.   You can reverse it by setting **negate** to `true`. Possible values are `BEGINS_WITH`, `CONTAINS`, `CONTAINS_REGEX`, `ENDS_WITH` and `EQUALS`
        :param str value: The value to compare to
        :param bool case_insensitive: The condition is case sensitive (`false`) or case insensitive (`true`).   If not set, then `false` is used, making the condition case sensitive
        :param bool enabled: The filter is enabled (`true`) or disabled (`false`)
        :param bool negate: Reverses the comparison **operator**. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if case_insensitive is not None:
            pulumi.set(__self__, "case_insensitive", case_insensitive)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison.   You can reverse it by setting **negate** to `true`. Possible values are `BEGINS_WITH`, `CONTAINS`, `CONTAINS_REGEX`, `ENDS_WITH` and `EQUALS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseInsensitive")
    def case_insensitive(self) -> Optional[bool]:
        """
        The condition is case sensitive (`false`) or case insensitive (`true`).   If not set, then `false` is used, making the condition case sensitive
        """
        return pulumi.get(self, "case_insensitive")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        The filter is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the comparison **operator**. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileEventTypeFilterPredefinedEventFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileEventTypeFilterPredefinedEventFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileEventTypeFilterPredefinedEventFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileEventTypeFilterPredefinedEventFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str event_type: The type of the predefined event. Possible values are `APPLICATION_ERROR_RATE_INCREASED`, `APPLICATION_SLOWDOWN`, `APPLICATION_UNEXPECTED_HIGH_LOAD`, `APPLICATION_UNEXPECTED_LOW_LOAD`, `AWS_LAMBDA_HIGH_ERROR_RATE`, `CUSTOM_APPLICATION_ERROR_RATE_INCREASED`, `CUSTOM_APPLICATION_SLOWDOWN`, `CUSTOM_APPLICATION_UNEXPECTED_HIGH_LOAD`, `CUSTOM_APPLICATION_UNEXPECTED_LOW_LOAD`, `CUSTOM_APP_CRASH_RATE_INCREASED`, `DATABASE_CONNECTION_FAILURE`, `DATA_CENTER_SERVICE_PERFORMANCE_DEGRADATION`, `DATA_CENTER_SERVICE_UNAVAILABLE`, `EBS_VOLUME_HIGH_LATENCY`, `EC2_HIGH_CPU`, `ELB_HIGH_BACKEND_ERROR_RATE`, `ENTERPRICE_APPLICATION_PERFORMANCE_DEGRADATION`, `ENTERPRISE_APPLICATION_UNAVAILABLE`, `ESXI_GUEST_ACTIVE_SWAP_WAIT`, `ESXI_GUEST_CPU_LIMIT_REACHED`, `ESXI_HOST_CPU_SATURATION`, `ESXI_HOST_DATASTORE_LOW_DISK_SPACE`, `ESXI_HOST_DISK_QUEUE_SLOW`, `ESXI_HOST_DISK_SLOW`, `ESXI_HOST_MEMORY_SATURATION`, `ESXI_HOST_NETWORK_PROBLEMS`, `ESXI_HOST_OVERLOADED_STORAGE`, `ESXI_VM_IMPACT_HOST_CPU_SATURATION`, `ESXI_VM_IMPACT_HOST_MEMORY_SATURATION`, `EXTERNAL_SYNTHETIC_TEST_OUTAGE`, `EXTERNAL_SYNTHETIC_TEST_SLOWDOWN`, `HOST_OF_SERVICE_UNAVAILABLE`, `HTTP_CHECK_GLOBAL_OUTAGE`, `HTTP_CHECK_LOCAL_OUTAGE`, `HTTP_CHECK_TEST_LOCATION_SLOWDOWN`, `MOBILE_APPLICATION_ERROR_RATE_INCREASED`, `MOBILE_APPLICATION_SLOWDOWN`, `MOBILE_APPLICATION_UNEXPECTED_HIGH_LOAD`, `MOBILE_APPLICATION_UNEXPECTED_LOW_LOAD`, `MOBILE_APP_CRASH_RATE_INCREASED`, `MONITORING_UNAVAILABLE`, `OSI_DISK_LOW_INODES`, `OSI_GRACEFULLY_SHUTDOWN`, `OSI_HIGH_CPU`, `OSI_HIGH_MEMORY`, `OSI_LOW_DISK_SPACE`, `OSI_NIC_DROPPED_PACKETS_HIGH`, `OSI_NIC_ERRORS_HIGH`, `OSI_NIC_UTILIZATION_HIGH`, `OSI_SLOW_DISK`, `OSI_UNEXPECTEDLY_UNAVAILABLE`, `PGI_OF_SERVICE_UNAVAILABLE`, `PGI_UNAVAILABLE`, `PG_LOW_INSTANCE_COUNT`, `PROCESS_CRASHED`, `PROCESS_HIGH_GC_ACTIVITY`, `PROCESS_MEMORY_RESOURCE_EXHAUSTED`, `PROCESS_NA_HIGH_CONN_FAIL_RATE`, `PROCESS_NA_HIGH_LOSS_RATE`, `PROCESS_THREADS_RESOURCE_EXHAUSTED`, `RDS_HIGH_CPU`, `RDS_HIGH_LATENCY`, `RDS_LOW_MEMORY`, `RDS_LOW_STORAGE_SPACE`, `RDS_OF_SERVICE_UNAVAILABLE`, `RDS_RESTART_SEQUENCE`, `SERVICE_ERROR_RATE_INCREASED`, `SERVICE_SLOWDOWN`, `SERVICE_UNEXPECTED_HIGH_LOAD`, `SERVICE_UNEXPECTED_LOW_LOAD`, `SYNTHETIC_GLOBAL_OUTAGE`, `SYNTHETIC_LOCAL_OUTAGE`, `SYNTHETIC_NODE_OUTAGE`, `SYNTHETIC_PRIVATE_LOCATION_OUTAGE` and `SYNTHETIC_TEST_LOCATION_SLOWDOWN`
        :param bool negate: The alert triggers when the problem of specified severity arises while the specified event **is** happening (`false`) or while the specified event is **not** happening (`true`).   For example, if you chose the Slowdown (`PERFORMANCE`) severity and Unexpected high traffic (`APPLICATION_UNEXPECTED_HIGH_LOAD`) event with **negate** set to `true`, the alerting profile will trigger only when the slowdown problem is raised while there is no unexpected high traffic event.  Consider the following use case as an example. The Slowdown (`PERFORMANCE`) severity rule is set. Depending on the configuration of the event filter (Unexpected high traffic (`APPLICATION_UNEXPECTED_HIGH_LOAD`) event is used as an example), the behavior of the alerting profile is one of the following:* **negate** is set to `false`: The alert triggers when the slowdown problem is raised while unexpected high traffic event is happening.  * **negate** is set to `true`: The alert triggers when the slowdown problem is raised while there is no unexpected high traffic event.  * no event rule is set: The alert triggers when the slowdown problem is raised, regardless of any events
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "event_type", event_type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> str:
        """
        The type of the predefined event. Possible values are `APPLICATION_ERROR_RATE_INCREASED`, `APPLICATION_SLOWDOWN`, `APPLICATION_UNEXPECTED_HIGH_LOAD`, `APPLICATION_UNEXPECTED_LOW_LOAD`, `AWS_LAMBDA_HIGH_ERROR_RATE`, `CUSTOM_APPLICATION_ERROR_RATE_INCREASED`, `CUSTOM_APPLICATION_SLOWDOWN`, `CUSTOM_APPLICATION_UNEXPECTED_HIGH_LOAD`, `CUSTOM_APPLICATION_UNEXPECTED_LOW_LOAD`, `CUSTOM_APP_CRASH_RATE_INCREASED`, `DATABASE_CONNECTION_FAILURE`, `DATA_CENTER_SERVICE_PERFORMANCE_DEGRADATION`, `DATA_CENTER_SERVICE_UNAVAILABLE`, `EBS_VOLUME_HIGH_LATENCY`, `EC2_HIGH_CPU`, `ELB_HIGH_BACKEND_ERROR_RATE`, `ENTERPRICE_APPLICATION_PERFORMANCE_DEGRADATION`, `ENTERPRISE_APPLICATION_UNAVAILABLE`, `ESXI_GUEST_ACTIVE_SWAP_WAIT`, `ESXI_GUEST_CPU_LIMIT_REACHED`, `ESXI_HOST_CPU_SATURATION`, `ESXI_HOST_DATASTORE_LOW_DISK_SPACE`, `ESXI_HOST_DISK_QUEUE_SLOW`, `ESXI_HOST_DISK_SLOW`, `ESXI_HOST_MEMORY_SATURATION`, `ESXI_HOST_NETWORK_PROBLEMS`, `ESXI_HOST_OVERLOADED_STORAGE`, `ESXI_VM_IMPACT_HOST_CPU_SATURATION`, `ESXI_VM_IMPACT_HOST_MEMORY_SATURATION`, `EXTERNAL_SYNTHETIC_TEST_OUTAGE`, `EXTERNAL_SYNTHETIC_TEST_SLOWDOWN`, `HOST_OF_SERVICE_UNAVAILABLE`, `HTTP_CHECK_GLOBAL_OUTAGE`, `HTTP_CHECK_LOCAL_OUTAGE`, `HTTP_CHECK_TEST_LOCATION_SLOWDOWN`, `MOBILE_APPLICATION_ERROR_RATE_INCREASED`, `MOBILE_APPLICATION_SLOWDOWN`, `MOBILE_APPLICATION_UNEXPECTED_HIGH_LOAD`, `MOBILE_APPLICATION_UNEXPECTED_LOW_LOAD`, `MOBILE_APP_CRASH_RATE_INCREASED`, `MONITORING_UNAVAILABLE`, `OSI_DISK_LOW_INODES`, `OSI_GRACEFULLY_SHUTDOWN`, `OSI_HIGH_CPU`, `OSI_HIGH_MEMORY`, `OSI_LOW_DISK_SPACE`, `OSI_NIC_DROPPED_PACKETS_HIGH`, `OSI_NIC_ERRORS_HIGH`, `OSI_NIC_UTILIZATION_HIGH`, `OSI_SLOW_DISK`, `OSI_UNEXPECTEDLY_UNAVAILABLE`, `PGI_OF_SERVICE_UNAVAILABLE`, `PGI_UNAVAILABLE`, `PG_LOW_INSTANCE_COUNT`, `PROCESS_CRASHED`, `PROCESS_HIGH_GC_ACTIVITY`, `PROCESS_MEMORY_RESOURCE_EXHAUSTED`, `PROCESS_NA_HIGH_CONN_FAIL_RATE`, `PROCESS_NA_HIGH_LOSS_RATE`, `PROCESS_THREADS_RESOURCE_EXHAUSTED`, `RDS_HIGH_CPU`, `RDS_HIGH_LATENCY`, `RDS_LOW_MEMORY`, `RDS_LOW_STORAGE_SPACE`, `RDS_OF_SERVICE_UNAVAILABLE`, `RDS_RESTART_SEQUENCE`, `SERVICE_ERROR_RATE_INCREASED`, `SERVICE_SLOWDOWN`, `SERVICE_UNEXPECTED_HIGH_LOAD`, `SERVICE_UNEXPECTED_LOW_LOAD`, `SYNTHETIC_GLOBAL_OUTAGE`, `SYNTHETIC_LOCAL_OUTAGE`, `SYNTHETIC_NODE_OUTAGE`, `SYNTHETIC_PRIVATE_LOCATION_OUTAGE` and `SYNTHETIC_TEST_LOCATION_SLOWDOWN`
        """
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        The alert triggers when the problem of specified severity arises while the specified event **is** happening (`false`) or while the specified event is **not** happening (`true`).   For example, if you chose the Slowdown (`PERFORMANCE`) severity and Unexpected high traffic (`APPLICATION_UNEXPECTED_HIGH_LOAD`) event with **negate** set to `true`, the alerting profile will trigger only when the slowdown problem is raised while there is no unexpected high traffic event.  Consider the following use case as an example. The Slowdown (`PERFORMANCE`) severity rule is set. Depending on the configuration of the event filter (Unexpected high traffic (`APPLICATION_UNEXPECTED_HIGH_LOAD`) event is used as an example), the behavior of the alerting profile is one of the following:* **negate** is set to `false`: The alert triggers when the slowdown problem is raised while unexpected high traffic event is happening.  * **negate** is set to `true`: The alert triggers when the slowdown problem is raised while there is no unexpected high traffic event.  * no event rule is set: The alert triggers when the slowdown problem is raised, regardless of any events
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "configurationVersions":
            suggest = "configuration_versions"
        elif key == "currentConfigurationVersions":
            suggest = "current_configuration_versions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_version: Optional[str] = None,
                 configuration_versions: Optional[Sequence[int]] = None,
                 current_configuration_versions: Optional[Sequence[str]] = None):
        """
        :param str cluster_version: Dynatrace server version
        :param Sequence[int] configuration_versions: A Sorted list of the version numbers of the configuration
        :param Sequence[str] current_configuration_versions: A Sorted list of the version numbers of the configuration
        """
        if cluster_version is not None:
            pulumi.set(__self__, "cluster_version", cluster_version)
        if configuration_versions is not None:
            pulumi.set(__self__, "configuration_versions", configuration_versions)
        if current_configuration_versions is not None:
            pulumi.set(__self__, "current_configuration_versions", current_configuration_versions)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> Optional[str]:
        """
        Dynatrace server version
        """
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter(name="configurationVersions")
    def configuration_versions(self) -> Optional[Sequence[int]]:
        """
        A Sorted list of the version numbers of the configuration
        """
        return pulumi.get(self, "configuration_versions")

    @property
    @pulumi.getter(name="currentConfigurationVersions")
    def current_configuration_versions(self) -> Optional[Sequence[str]]:
        """
        A Sorted list of the version numbers of the configuration
        """
        return pulumi.get(self, "current_configuration_versions")


@pulumi.output_type
class AlertingProfileRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayInMinutes":
            suggest = "delay_in_minutes"
        elif key == "severityLevel":
            suggest = "severity_level"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_in_minutes: int,
                 severity_level: str,
                 tag_filters: Sequence['outputs.AlertingProfileRuleTagFilter'],
                 unknowns: Optional[str] = None):
        """
        :param int delay_in_minutes: Send a notification if a problem remains open longer than *X* minutes
        :param str severity_level: The severity level to trigger the alert. Possible values are `AVAILABILITY`,	`CUSTOM_ALERT`,	`ERROR`,`MONITORING_UNAVAILABLE`,`PERFORMANCE` and `RESOURCE_CONTENTION`.
        :param Sequence['AlertingProfileRuleTagFilterArgs'] tag_filters: Configuration of the tag filtering of the alerting profile
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "delay_in_minutes", delay_in_minutes)
        pulumi.set(__self__, "severity_level", severity_level)
        pulumi.set(__self__, "tag_filters", tag_filters)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="delayInMinutes")
    def delay_in_minutes(self) -> int:
        """
        Send a notification if a problem remains open longer than *X* minutes
        """
        return pulumi.get(self, "delay_in_minutes")

    @property
    @pulumi.getter(name="severityLevel")
    def severity_level(self) -> str:
        """
        The severity level to trigger the alert. Possible values are `AVAILABILITY`,	`CUSTOM_ALERT`,	`ERROR`,`MONITORING_UNAVAILABLE`,`PERFORMANCE` and `RESOURCE_CONTENTION`.
        """
        return pulumi.get(self, "severity_level")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Sequence['outputs.AlertingProfileRuleTagFilter']:
        """
        Configuration of the tag filtering of the alerting profile
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileRuleTagFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeMode":
            suggest = "include_mode"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileRuleTagFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileRuleTagFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileRuleTagFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_mode: str,
                 tag_filters: Optional[Sequence['outputs.AlertingProfileRuleTagFilterTagFilter']] = None,
                 unknowns: Optional[str] = None):
        """
        :param str include_mode: The filtering mode:  * `INCLUDE_ANY`: The rule applies to monitored entities that have at least one of the specified tags. You can specify up to 100 tags.  * `INCLUDE_ALL`: The rule applies to monitored entities that have **all** of the specified tags. You can specify up to 10 tags.  * `NONE`: The rule applies to all monitored entities
        :param Sequence['AlertingProfileRuleTagFilterTagFilterArgs'] tag_filters: A list of required tags
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "include_mode", include_mode)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="includeMode")
    def include_mode(self) -> str:
        """
        The filtering mode:  * `INCLUDE_ANY`: The rule applies to monitored entities that have at least one of the specified tags. You can specify up to 100 tags.  * `INCLUDE_ALL`: The rule applies to monitored entities that have **all** of the specified tags. You can specify up to 10 tags.  * `NONE`: The rule applies to all monitored entities
        """
        return pulumi.get(self, "include_mode")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.AlertingProfileRuleTagFilterTagFilter']]:
        """
        A list of required tags
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileRuleTagFilterTagFilter(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AlertingRules(dict):
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.AlertingRulesRule']] = None):
        """
        :param Sequence['AlertingRulesRuleArgs'] rules: A conditions for the metric usage
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.AlertingRulesRule']]:
        """
        A conditions for the metric usage
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class AlertingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayInMinutes":
            suggest = "delay_in_minutes"
        elif key == "includeMode":
            suggest = "include_mode"
        elif key == "severityLevel":
            suggest = "severity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_in_minutes: int,
                 include_mode: str,
                 severity_level: str,
                 tags: Optional[Sequence[str]] = None):
        """
        :param int delay_in_minutes: Send a notification if a problem remains open longer than *X* minutes
        :param str include_mode: The filtering mode:  * `INCLUDE_ANY`: The rule applies to monitored entities that have at least one of the specified tags. You can specify up to 100 tags.  * `INCLUDE_ALL`: The rule applies to monitored entities that have **all** of the specified tags. You can specify up to 10 tags.  * `NONE`: The rule applies to all monitored entities
        :param str severity_level: The severity level to trigger the alert. Possible values are `AVAILABILITY`,	`CUSTOM_ALERT`,	`ERRORS`,`MONITORING_UNAVAILABLE`,`PERFORMANCE` and `RESOURCE_CONTENTION`.
        :param Sequence[str] tags: Entities which contain any/all of the configured tags will match this alerting profile. It is recommended to use manual tags.
        """
        pulumi.set(__self__, "delay_in_minutes", delay_in_minutes)
        pulumi.set(__self__, "include_mode", include_mode)
        pulumi.set(__self__, "severity_level", severity_level)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="delayInMinutes")
    def delay_in_minutes(self) -> int:
        """
        Send a notification if a problem remains open longer than *X* minutes
        """
        return pulumi.get(self, "delay_in_minutes")

    @property
    @pulumi.getter(name="includeMode")
    def include_mode(self) -> str:
        """
        The filtering mode:  * `INCLUDE_ANY`: The rule applies to monitored entities that have at least one of the specified tags. You can specify up to 100 tags.  * `INCLUDE_ALL`: The rule applies to monitored entities that have **all** of the specified tags. You can specify up to 10 tags.  * `NONE`: The rule applies to all monitored entities
        """
        return pulumi.get(self, "include_mode")

    @property
    @pulumi.getter(name="severityLevel")
    def severity_level(self) -> str:
        """
        The severity level to trigger the alert. Possible values are `AVAILABILITY`,	`CUSTOM_ALERT`,	`ERRORS`,`MONITORING_UNAVAILABLE`,`PERFORMANCE` and `RESOURCE_CONTENTION`.
        """
        return pulumi.get(self, "severity_level")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        Entities which contain any/all of the configured tags will match this alerting profile. It is recommended to use manual tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ApiDetectionConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.ApiDetectionConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.ApiDetectionConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ApiDetectionConditionsCondition(dict):
    def __init__(__self__, *,
                 base: str,
                 matcher: str,
                 pattern: str):
        """
        :param str base: Possible Values: `FILE_NAME`, `FQCN`, `PACKAGE`
        :param str matcher: Possible Values: `BEGINS_WITH`, `CONTAINS`
        :param str pattern: no documentation available
        """
        pulumi.set(__self__, "base", base)
        pulumi.set(__self__, "matcher", matcher)
        pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def base(self) -> str:
        """
        Possible Values: `FILE_NAME`, `FQCN`, `PACKAGE`
        """
        return pulumi.get(self, "base")

    @property
    @pulumi.getter
    def matcher(self) -> str:
        """
        Possible Values: `BEGINS_WITH`, `CONTAINS`
        """
        return pulumi.get(self, "matcher")

    @property
    @pulumi.getter
    def pattern(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "pattern")


@pulumi.output_type
class AppMonitoringAppMonitoring(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appMonitorings":
            suggest = "app_monitorings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppMonitoringAppMonitoring. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppMonitoringAppMonitoring.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppMonitoringAppMonitoring.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_monitorings: Sequence['outputs.AppMonitoringAppMonitoringAppMonitoring']):
        pulumi.set(__self__, "app_monitorings", app_monitorings)

    @property
    @pulumi.getter(name="appMonitorings")
    def app_monitorings(self) -> Sequence['outputs.AppMonitoringAppMonitoringAppMonitoring']:
        return pulumi.get(self, "app_monitorings")


@pulumi.output_type
class AppMonitoringAppMonitoringAppMonitoring(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "customLogLevel":
            suggest = "custom_log_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppMonitoringAppMonitoringAppMonitoring. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppMonitoringAppMonitoringAppMonitoring.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppMonitoringAppMonitoringAppMonitoring.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: str,
                 custom_log_level: str):
        """
        :param str app_id: App ID
        :param str custom_log_level: Possible Values: `Debug`, `Error`, `Info`, `Off`, `UseDefault`, `Warn`
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "custom_log_level", custom_log_level)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        App ID
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="customLogLevel")
    def custom_log_level(self) -> str:
        """
        Possible Values: `Debug`, `Error`, `Info`, `Off`, `UseDefault`, `Warn`
        """
        return pulumi.get(self, "custom_log_level")


@pulumi.output_type
class ApplicationAnomaliesFailureRate(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.ApplicationAnomaliesFailureRateAuto'] = None,
                 thresholds: Optional['outputs.ApplicationAnomaliesFailureRateThresholds'] = None):
        """
        :param 'ApplicationAnomaliesFailureRateAutoArgs' auto: Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
        :param 'ApplicationAnomaliesFailureRateThresholdsArgs' thresholds: Fixed thresholds for failure rate increase detection
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.ApplicationAnomaliesFailureRateAuto']:
        """
        Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.ApplicationAnomaliesFailureRateThresholds']:
        """
        Fixed thresholds for failure rate increase detection
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class ApplicationAnomaliesFailureRateAuto(dict):
    def __init__(__self__, *,
                 absolute: int,
                 relative: int,
                 unknowns: Optional[str] = None):
        """
        :param int absolute: Absolute increase of failing service calls to trigger an alert, %
        :param int relative: Relative increase of failing service calls to trigger an alert, %
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "absolute", absolute)
        pulumi.set(__self__, "relative", relative)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def absolute(self) -> int:
        """
        Absolute increase of failing service calls to trigger an alert, %
        """
        return pulumi.get(self, "absolute")

    @property
    @pulumi.getter
    def relative(self) -> int:
        """
        Relative increase of failing service calls to trigger an alert, %
        """
        return pulumi.get(self, "relative")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ApplicationAnomaliesFailureRateThresholds(dict):
    def __init__(__self__, *,
                 sensitivity: str,
                 threshold: int,
                 unknowns: Optional[str] = None):
        """
        :param str sensitivity: Sensitivity of the threshold.  With `low` sensitivity, high statistical confidence is used. Brief violations (for example, due to a surge in load) won't trigger alerts.  With `high` sensitivity, no statistical confidence is used. Each violation triggers alert
        :param int threshold: Failure rate during any 5-minute period to trigger an alert, %
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold", threshold)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        """
        Sensitivity of the threshold.  With `low` sensitivity, high statistical confidence is used. Brief violations (for example, due to a surge in load) won't trigger alerts.  With `high` sensitivity, no statistical confidence is used. Each violation triggers alert
        """
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        Failure rate during any 5-minute period to trigger an alert, %
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ApplicationAnomaliesResponseTime(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.ApplicationAnomaliesResponseTimeAuto'] = None,
                 thresholds: Optional['outputs.ApplicationAnomaliesResponseTimeThresholds'] = None):
        """
        :param 'ApplicationAnomaliesResponseTimeAutoArgs' auto: Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
        :param 'ApplicationAnomaliesResponseTimeThresholdsArgs' thresholds: Fixed thresholds for response time degradation detection
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.ApplicationAnomaliesResponseTimeAuto']:
        """
        Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.ApplicationAnomaliesResponseTimeThresholds']:
        """
        Fixed thresholds for response time degradation detection
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class ApplicationAnomaliesResponseTimeAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestMilliseconds":
            suggest = "slowest_milliseconds"
        elif key == "slowestPercent":
            suggest = "slowest_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAnomaliesResponseTimeAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAnomaliesResponseTimeAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAnomaliesResponseTimeAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load: str,
                 milliseconds: int,
                 percent: int,
                 slowest_milliseconds: int,
                 slowest_percent: int,
                 unknowns: Optional[str] = None):
        """
        :param str load: Minimal service load to detect response time degradation. Response time degradation of services with smaller load won't trigger alerts. Possible values are `FIFTEEN_REQUESTS_PER_MINUTE`, `FIVE_REQUESTS_PER_MINUTE`, `ONE_REQUEST_PER_MINUTE` and `TEN_REQUESTS_PER_MINUTE`
        :param int milliseconds: Alert if the response time degrades by more than *X* milliseconds
        :param int percent: Alert if the response time degrades by more than *X* %
        :param int slowest_milliseconds: Alert if the response time of the slowest 10% degrades by more than *X* milliseconds
        :param int slowest_percent: Alert if the response time of the slowest 10% degrades by more than *X* milliseconds
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "load", load)
        pulumi.set(__self__, "milliseconds", milliseconds)
        pulumi.set(__self__, "percent", percent)
        pulumi.set(__self__, "slowest_milliseconds", slowest_milliseconds)
        pulumi.set(__self__, "slowest_percent", slowest_percent)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def load(self) -> str:
        """
        Minimal service load to detect response time degradation. Response time degradation of services with smaller load won't trigger alerts. Possible values are `FIFTEEN_REQUESTS_PER_MINUTE`, `FIVE_REQUESTS_PER_MINUTE`, `ONE_REQUEST_PER_MINUTE` and `TEN_REQUESTS_PER_MINUTE`
        """
        return pulumi.get(self, "load")

    @property
    @pulumi.getter
    def milliseconds(self) -> int:
        """
        Alert if the response time degrades by more than *X* milliseconds
        """
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def percent(self) -> int:
        """
        Alert if the response time degrades by more than *X* %
        """
        return pulumi.get(self, "percent")

    @property
    @pulumi.getter(name="slowestMilliseconds")
    def slowest_milliseconds(self) -> int:
        """
        Alert if the response time of the slowest 10% degrades by more than *X* milliseconds
        """
        return pulumi.get(self, "slowest_milliseconds")

    @property
    @pulumi.getter(name="slowestPercent")
    def slowest_percent(self) -> int:
        """
        Alert if the response time of the slowest 10% degrades by more than *X* milliseconds
        """
        return pulumi.get(self, "slowest_percent")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ApplicationAnomaliesResponseTimeThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestMilliseconds":
            suggest = "slowest_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAnomaliesResponseTimeThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAnomaliesResponseTimeThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAnomaliesResponseTimeThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load: str,
                 milliseconds: int,
                 sensitivity: str,
                 slowest_milliseconds: int,
                 unknowns: Optional[str] = None):
        """
        :param str load: Minimal service load to detect response time degradation. Response time degradation of services with smaller load won't trigger alerts. Possible values are `FIFTEEN_REQUESTS_PER_MINUTE`, `FIVE_REQUESTS_PER_MINUTE`, `ONE_REQUEST_PER_MINUTE` and `TEN_REQUESTS_PER_MINUTE`
        :param int milliseconds: Response time during any 5-minute period to trigger an alert, in milliseconds
        :param str sensitivity: Sensitivity of the threshold.  With `low` sensitivity, high statistical confidence is used. Brief violations (for example, due to a surge in load) won't trigger alerts.  With `high` sensitivity, no statistical confidence is used. Each violation triggers an alert
        :param int slowest_milliseconds: Response time of the 10% slowest during any 5-minute period to trigger an alert, in milliseconds
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "load", load)
        pulumi.set(__self__, "milliseconds", milliseconds)
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "slowest_milliseconds", slowest_milliseconds)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def load(self) -> str:
        """
        Minimal service load to detect response time degradation. Response time degradation of services with smaller load won't trigger alerts. Possible values are `FIFTEEN_REQUESTS_PER_MINUTE`, `FIVE_REQUESTS_PER_MINUTE`, `ONE_REQUEST_PER_MINUTE` and `TEN_REQUESTS_PER_MINUTE`
        """
        return pulumi.get(self, "load")

    @property
    @pulumi.getter
    def milliseconds(self) -> int:
        """
        Response time during any 5-minute period to trigger an alert, in milliseconds
        """
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        """
        Sensitivity of the threshold.  With `low` sensitivity, high statistical confidence is used. Brief violations (for example, due to a surge in load) won't trigger alerts.  With `high` sensitivity, no statistical confidence is used. Each violation triggers an alert
        """
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter(name="slowestMilliseconds")
    def slowest_milliseconds(self) -> int:
        """
        Response time of the 10% slowest during any 5-minute period to trigger an alert, in milliseconds
        """
        return pulumi.get(self, "slowest_milliseconds")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ApplicationAnomaliesTraffic(dict):
    def __init__(__self__, *,
                 drops: Optional['outputs.ApplicationAnomaliesTrafficDrops'] = None,
                 spikes: Optional['outputs.ApplicationAnomaliesTrafficSpikes'] = None):
        """
        :param 'ApplicationAnomaliesTrafficDropsArgs' drops: The configuration of traffic drops detection
        :param 'ApplicationAnomaliesTrafficSpikesArgs' spikes: The configuration of traffic spikes detection
        """
        if drops is not None:
            pulumi.set(__self__, "drops", drops)
        if spikes is not None:
            pulumi.set(__self__, "spikes", spikes)

    @property
    @pulumi.getter
    def drops(self) -> Optional['outputs.ApplicationAnomaliesTrafficDrops']:
        """
        The configuration of traffic drops detection
        """
        return pulumi.get(self, "drops")

    @property
    @pulumi.getter
    def spikes(self) -> Optional['outputs.ApplicationAnomaliesTrafficSpikes']:
        """
        The configuration of traffic spikes detection
        """
        return pulumi.get(self, "spikes")


@pulumi.output_type
class ApplicationAnomaliesTrafficDrops(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 percent: Optional[int] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param int percent: Alert if the observed traffic is less than *X* % of the expected value
        """
        pulumi.set(__self__, "enabled", enabled)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        """
        Alert if the observed traffic is less than *X* % of the expected value
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class ApplicationAnomaliesTrafficSpikes(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 percent: Optional[int] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param int percent: Alert if the observed traffic is less than *X* % of the expected value
        """
        pulumi.set(__self__, "enabled", enabled)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        """
        Alert if the observed traffic is less than *X* % of the expected value
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentMaskingSettings":
            suggest = "content_masking_settings"
        elif key == "optIn":
            suggest = "opt_in"
        elif key == "urlExclusionRules":
            suggest = "url_exclusion_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationDataPrivacySessionReplayDataPrivacy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationDataPrivacySessionReplayDataPrivacy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationDataPrivacySessionReplayDataPrivacy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_masking_settings: 'outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettings',
                 opt_in: Optional[bool] = None,
                 url_exclusion_rules: Optional[Sequence[str]] = None):
        """
        :param 'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsArgs' content_masking_settings: (Field has overlap with `SessionReplayWebPrivacy`) Content masking settings for Session Replay.
        :param bool opt_in: (Field has overlap with `SessionReplayWebPrivacy`) If `true`, session recording is disabled until JavaScriptAPI `dtrum.enableSessionReplay()` is called
        :param Sequence[str] url_exclusion_rules: (Field has overlap with `SessionReplayWebPrivacy`) A list of URLs to be excluded from recording
        """
        pulumi.set(__self__, "content_masking_settings", content_masking_settings)
        if opt_in is not None:
            pulumi.set(__self__, "opt_in", opt_in)
        if url_exclusion_rules is not None:
            pulumi.set(__self__, "url_exclusion_rules", url_exclusion_rules)

    @property
    @pulumi.getter(name="contentMaskingSettings")
    def content_masking_settings(self) -> 'outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettings':
        """
        (Field has overlap with `SessionReplayWebPrivacy`) Content masking settings for Session Replay.
        """
        return pulumi.get(self, "content_masking_settings")

    @property
    @pulumi.getter(name="optIn")
    def opt_in(self) -> Optional[bool]:
        """
        (Field has overlap with `SessionReplayWebPrivacy`) If `true`, session recording is disabled until JavaScriptAPI `dtrum.enableSessionReplay()` is called
        """
        return pulumi.get(self, "opt_in")

    @property
    @pulumi.getter(name="urlExclusionRules")
    def url_exclusion_rules(self) -> Optional[Sequence[str]]:
        """
        (Field has overlap with `SessionReplayWebPrivacy`) A list of URLs to be excluded from recording
        """
        return pulumi.get(self, "url_exclusion_rules")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettings(dict):
    def __init__(__self__, *,
                 playback: 'outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlayback',
                 recording: 'outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecording'):
        """
        :param 'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackArgs' playback: (Field has overlap with `SessionReplayWebPrivacy`) Configuration of the Session Replay masking during Playback
        :param 'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingArgs' recording: (Field has overlap with `SessionReplayWebPrivacy`) Configuration of the Session Replay masking during Recording
        """
        pulumi.set(__self__, "playback", playback)
        pulumi.set(__self__, "recording", recording)

    @property
    @pulumi.getter
    def playback(self) -> 'outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlayback':
        """
        (Field has overlap with `SessionReplayWebPrivacy`) Configuration of the Session Replay masking during Playback
        """
        return pulumi.get(self, "playback")

    @property
    @pulumi.getter
    def recording(self) -> 'outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecording':
        """
        (Field has overlap with `SessionReplayWebPrivacy`) Configuration of the Session Replay masking during Recording
        """
        return pulumi.get(self, "recording")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlayback(dict):
    def __init__(__self__, *,
                 preset: str,
                 rules: Optional['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRules'] = None):
        """
        :param str preset: The type of the masking:
        :param 'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesArgs' rules: A list of masking rules
        """
        pulumi.set(__self__, "preset", preset)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def preset(self) -> str:
        """
        The type of the masking:
        """
        return pulumi.get(self, "preset")

    @property
    @pulumi.getter
    def rules(self) -> Optional['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRules']:
        """
        A list of masking rules
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule']):
        """
        :param Sequence['ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRuleArgs'] rules: The masking rule defining how data is hidden
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule']:
        """
        The masking rule defining how data is hidden
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userInteractionHidden":
            suggest = "user_interaction_hidden"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selector: str,
                 type: str,
                 user_interaction_hidden: Optional[bool] = None):
        """
        :param str selector: The selector for the element or the attribute to be masked.
        :param str type: The type of the masking rule
        :param bool user_interaction_hidden: Interactions with the element are (`true`) or are not (`false) masked
        """
        pulumi.set(__self__, "selector", selector)
        pulumi.set(__self__, "type", type)
        if user_interaction_hidden is not None:
            pulumi.set(__self__, "user_interaction_hidden", user_interaction_hidden)

    @property
    @pulumi.getter
    def selector(self) -> str:
        """
        The selector for the element or the attribute to be masked.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the masking rule
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userInteractionHidden")
    def user_interaction_hidden(self) -> Optional[bool]:
        """
        Interactions with the element are (`true`) or are not (`false) masked
        """
        return pulumi.get(self, "user_interaction_hidden")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecording(dict):
    def __init__(__self__, *,
                 preset: str,
                 rules: Optional['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRules'] = None):
        """
        :param str preset: The type of the masking:
        :param 'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesArgs' rules: A list of masking rules
        """
        pulumi.set(__self__, "preset", preset)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def preset(self) -> str:
        """
        The type of the masking:
        """
        return pulumi.get(self, "preset")

    @property
    @pulumi.getter
    def rules(self) -> Optional['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRules']:
        """
        A list of masking rules
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule']):
        """
        :param Sequence['ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRuleArgs'] rules: The masking rule defining how data is hidden
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule']:
        """
        The masking rule defining how data is hidden
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userInteractionHidden":
            suggest = "user_interaction_hidden"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selector: str,
                 type: str,
                 user_interaction_hidden: Optional[bool] = None):
        """
        :param str selector: The selector for the element or the attribute to be masked.
        :param str type: The type of the masking rule
        :param bool user_interaction_hidden: Interactions with the element are (`true`) or are not (`false) masked
        """
        pulumi.set(__self__, "selector", selector)
        pulumi.set(__self__, "type", type)
        if user_interaction_hidden is not None:
            pulumi.set(__self__, "user_interaction_hidden", user_interaction_hidden)

    @property
    @pulumi.getter
    def selector(self) -> str:
        """
        The selector for the element or the attribute to be masked.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the masking rule
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userInteractionHidden")
    def user_interaction_hidden(self) -> Optional[bool]:
        """
        Interactions with the element are (`true`) or are not (`false) masked
        """
        return pulumi.get(self, "user_interaction_hidden")


@pulumi.output_type
class ApplicationDetectionRuleFilterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationMatchTarget":
            suggest = "application_match_target"
        elif key == "applicationMatchType":
            suggest = "application_match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationDetectionRuleFilterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationDetectionRuleFilterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationDetectionRuleFilterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_match_target: str,
                 application_match_type: str,
                 pattern: str):
        """
        :param str application_match_target: Where to look for the pattern value, possible values are `DOMAIN` or `URL`
        :param str application_match_type: The operator used for matching the application detection rule, possible values are `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`, `MATCHES`
        :param str pattern: The value to look for with the application detection rule
        """
        pulumi.set(__self__, "application_match_target", application_match_target)
        pulumi.set(__self__, "application_match_type", application_match_type)
        pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter(name="applicationMatchTarget")
    def application_match_target(self) -> str:
        """
        Where to look for the pattern value, possible values are `DOMAIN` or `URL`
        """
        return pulumi.get(self, "application_match_target")

    @property
    @pulumi.getter(name="applicationMatchType")
    def application_match_type(self) -> str:
        """
        The operator used for matching the application detection rule, possible values are `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`, `MATCHES`
        """
        return pulumi.get(self, "application_match_type")

    @property
    @pulumi.getter
    def pattern(self) -> str:
        """
        The value to look for with the application detection rule
        """
        return pulumi.get(self, "pattern")


@pulumi.output_type
class ApplicationErrorRulesCustomErrors(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.ApplicationErrorRulesCustomErrorsRule']):
        """
        :param Sequence['ApplicationErrorRulesCustomErrorsRuleArgs'] rules: Configuration of the custom error in the web application
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.ApplicationErrorRulesCustomErrorsRule']:
        """
        Configuration of the custom error in the web application
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationErrorRulesCustomErrorsRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customAlerting":
            suggest = "custom_alerting"
        elif key == "impactApdex":
            suggest = "impact_apdex"
        elif key == "keyMatcher":
            suggest = "key_matcher"
        elif key == "keyPattern":
            suggest = "key_pattern"
        elif key == "valueMatcher":
            suggest = "value_matcher"
        elif key == "valuePattern":
            suggest = "value_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationErrorRulesCustomErrorsRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationErrorRulesCustomErrorsRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationErrorRulesCustomErrorsRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture: Optional[bool] = None,
                 custom_alerting: Optional[bool] = None,
                 impact_apdex: Optional[bool] = None,
                 key_matcher: Optional[str] = None,
                 key_pattern: Optional[str] = None,
                 value_matcher: Optional[str] = None,
                 value_pattern: Optional[str] = None):
        """
        :param bool capture: Capture (`true`) or ignore (`false`) the error
        :param bool custom_alerting: Include (`true`) or exclude (`false`) the error in Davis AI [problem detection and analysis](https://dt-url.net/a963kd2)
        :param bool impact_apdex: Include (`true`) or exclude (`false`) the error in Apdex calculation
        :param str key_matcher: The matching operation for the **keyPattern**. Possible values are `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH` and `EQUALS`
        :param str key_pattern: The key of the error to look for
        :param str value_matcher: The matching operation for the **valuePattern**. Possible values are `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH` and `EQUALS`.
        :param str value_pattern: The value of the error to look for
        """
        if capture is not None:
            pulumi.set(__self__, "capture", capture)
        if custom_alerting is not None:
            pulumi.set(__self__, "custom_alerting", custom_alerting)
        if impact_apdex is not None:
            pulumi.set(__self__, "impact_apdex", impact_apdex)
        if key_matcher is not None:
            pulumi.set(__self__, "key_matcher", key_matcher)
        if key_pattern is not None:
            pulumi.set(__self__, "key_pattern", key_pattern)
        if value_matcher is not None:
            pulumi.set(__self__, "value_matcher", value_matcher)
        if value_pattern is not None:
            pulumi.set(__self__, "value_pattern", value_pattern)

    @property
    @pulumi.getter
    def capture(self) -> Optional[bool]:
        """
        Capture (`true`) or ignore (`false`) the error
        """
        return pulumi.get(self, "capture")

    @property
    @pulumi.getter(name="customAlerting")
    def custom_alerting(self) -> Optional[bool]:
        """
        Include (`true`) or exclude (`false`) the error in Davis AI [problem detection and analysis](https://dt-url.net/a963kd2)
        """
        return pulumi.get(self, "custom_alerting")

    @property
    @pulumi.getter(name="impactApdex")
    def impact_apdex(self) -> Optional[bool]:
        """
        Include (`true`) or exclude (`false`) the error in Apdex calculation
        """
        return pulumi.get(self, "impact_apdex")

    @property
    @pulumi.getter(name="keyMatcher")
    def key_matcher(self) -> Optional[str]:
        """
        The matching operation for the **keyPattern**. Possible values are `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH` and `EQUALS`
        """
        return pulumi.get(self, "key_matcher")

    @property
    @pulumi.getter(name="keyPattern")
    def key_pattern(self) -> Optional[str]:
        """
        The key of the error to look for
        """
        return pulumi.get(self, "key_pattern")

    @property
    @pulumi.getter(name="valueMatcher")
    def value_matcher(self) -> Optional[str]:
        """
        The matching operation for the **valuePattern**. Possible values are `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH` and `EQUALS`.
        """
        return pulumi.get(self, "value_matcher")

    @property
    @pulumi.getter(name="valuePattern")
    def value_pattern(self) -> Optional[str]:
        """
        The value of the error to look for
        """
        return pulumi.get(self, "value_pattern")


@pulumi.output_type
class ApplicationErrorRulesHttpErrors(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.ApplicationErrorRulesHttpErrorsRule']):
        """
        :param Sequence['ApplicationErrorRulesHttpErrorsRuleArgs'] rules: Configuration of the HTTP error in the web application
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.ApplicationErrorRulesHttpErrorsRule']:
        """
        Configuration of the HTTP error in the web application
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationErrorRulesHttpErrorsRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "considerBlockedRequests":
            suggest = "consider_blocked_requests"
        elif key == "considerForAi":
            suggest = "consider_for_ai"
        elif key == "considerUnknownErrorCode":
            suggest = "consider_unknown_error_code"
        elif key == "errorCodes":
            suggest = "error_codes"
        elif key == "filterByUrl":
            suggest = "filter_by_url"
        elif key == "impactApdex":
            suggest = "impact_apdex"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationErrorRulesHttpErrorsRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationErrorRulesHttpErrorsRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationErrorRulesHttpErrorsRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture: Optional[bool] = None,
                 consider_blocked_requests: Optional[bool] = None,
                 consider_for_ai: Optional[bool] = None,
                 consider_unknown_error_code: Optional[bool] = None,
                 error_codes: Optional[str] = None,
                 filter: Optional[str] = None,
                 filter_by_url: Optional[bool] = None,
                 impact_apdex: Optional[bool] = None,
                 url: Optional[str] = None):
        """
        :param bool capture: Capture (`true`) or ignore (`false`) the error
        :param bool consider_blocked_requests: If `true`, match by errors that have CSP Rule violations
        :param bool consider_for_ai: Include (`true`) or exclude (`false`) the error in Davis AI [problem detection and analysis](https://dt-url.net/a963kd2)
        :param bool consider_unknown_error_code: If `true`, match by errors that have unknown HTTP status code
        :param str error_codes: The HTTP status code or status code range to match by.
        :param str filter: The matching rule for the URL. Popssible values are `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH` and `EQUALS`.
        :param bool filter_by_url: If `true`, filter errors by URL
        :param bool impact_apdex: Include (`true`) or exclude (`false`) the error in Apdex calculation
        :param str url: The URL to look for
        """
        if capture is not None:
            pulumi.set(__self__, "capture", capture)
        if consider_blocked_requests is not None:
            pulumi.set(__self__, "consider_blocked_requests", consider_blocked_requests)
        if consider_for_ai is not None:
            pulumi.set(__self__, "consider_for_ai", consider_for_ai)
        if consider_unknown_error_code is not None:
            pulumi.set(__self__, "consider_unknown_error_code", consider_unknown_error_code)
        if error_codes is not None:
            pulumi.set(__self__, "error_codes", error_codes)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if filter_by_url is not None:
            pulumi.set(__self__, "filter_by_url", filter_by_url)
        if impact_apdex is not None:
            pulumi.set(__self__, "impact_apdex", impact_apdex)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def capture(self) -> Optional[bool]:
        """
        Capture (`true`) or ignore (`false`) the error
        """
        return pulumi.get(self, "capture")

    @property
    @pulumi.getter(name="considerBlockedRequests")
    def consider_blocked_requests(self) -> Optional[bool]:
        """
        If `true`, match by errors that have CSP Rule violations
        """
        return pulumi.get(self, "consider_blocked_requests")

    @property
    @pulumi.getter(name="considerForAi")
    def consider_for_ai(self) -> Optional[bool]:
        """
        Include (`true`) or exclude (`false`) the error in Davis AI [problem detection and analysis](https://dt-url.net/a963kd2)
        """
        return pulumi.get(self, "consider_for_ai")

    @property
    @pulumi.getter(name="considerUnknownErrorCode")
    def consider_unknown_error_code(self) -> Optional[bool]:
        """
        If `true`, match by errors that have unknown HTTP status code
        """
        return pulumi.get(self, "consider_unknown_error_code")

    @property
    @pulumi.getter(name="errorCodes")
    def error_codes(self) -> Optional[str]:
        """
        The HTTP status code or status code range to match by.
        """
        return pulumi.get(self, "error_codes")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        The matching rule for the URL. Popssible values are `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH` and `EQUALS`.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="filterByUrl")
    def filter_by_url(self) -> Optional[bool]:
        """
        If `true`, filter errors by URL
        """
        return pulumi.get(self, "filter_by_url")

    @property
    @pulumi.getter(name="impactApdex")
    def impact_apdex(self) -> Optional[bool]:
        """
        Include (`true`) or exclude (`false`) the error in Apdex calculation
        """
        return pulumi.get(self, "impact_apdex")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL to look for
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AppsecNotificationAttackCandidateBasedEmailPayload(dict):
    def __init__(__self__, *,
                 body: str,
                 subject: str):
        """
        :param str body: The template of the email notifications.  
               In case a value of a security problem is not set, the placeholder will be replaced by an empty string.. **Note:** Security notifications contain sensitive information. Excessive usage of placeholders in the body might leak information to untrusted parties.  
                 
               Available placeholders:  
               **{AttackDisplayId}**: The unique identifier assigned by Dynatrace, for example: "A-1234".  
               **{Title}**: Location of the attack, for example: "com.dynatrace.Class.method():120"  
               **{Type}**: The type of attack, for example: "SQL Injection".  
               **{AttackUrl}**: URL of the attack in Dynatrace.  
               **{ProcessGroupId}**: Details about the process group attacked.  
               **{EntryPoint}**: The entry point of the attack into the process, for example: "/login". Can be empty.  
               **{Status}**: The status of the attack, for example: "Exploited"  
               **{Timestamp}**: When the attack happened.  
               **{VulnerabilityName}**: Name of the associated code-level vulnerability, for example: "InMemoryDatabaseCaller.getAccountInfo():51". Can be empty.
        :param str subject: The subject of the email notifications.. Available placeholders:  
               **{AttackDisplayId}**: The unique identifier assigned by Dynatrace, for example, "A-1234".  
               **{Title}**: Location of the attack, for example: "com.dynatrace.Class.method():120"  
               **{Type}**: The type of attack, for example: "SQL Injection".  
               **{AttackUrl}**: URL of the attack in Dynatrace.  
               **{ProcessGroupId}**: Details about the process group attacked.  
               **{EntryPoint}**: The entry point of the attack into the process, for example: "/login". Can be empty.  
               **{Status}**: The status of the attack, for example: "Exploited"  
               **{Timestamp}**: When the attack happened.  
               **{VulnerabilityName}**: Name of the associated code-level vulnerability, for example: "InMemoryDatabaseCaller.getAccountInfo():51". Can be empty.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter
    def body(self) -> str:
        """
        The template of the email notifications.  
        In case a value of a security problem is not set, the placeholder will be replaced by an empty string.. **Note:** Security notifications contain sensitive information. Excessive usage of placeholders in the body might leak information to untrusted parties.  
          
        Available placeholders:  
        **{AttackDisplayId}**: The unique identifier assigned by Dynatrace, for example: "A-1234".  
        **{Title}**: Location of the attack, for example: "com.dynatrace.Class.method():120"  
        **{Type}**: The type of attack, for example: "SQL Injection".  
        **{AttackUrl}**: URL of the attack in Dynatrace.  
        **{ProcessGroupId}**: Details about the process group attacked.  
        **{EntryPoint}**: The entry point of the attack into the process, for example: "/login". Can be empty.  
        **{Status}**: The status of the attack, for example: "Exploited"  
        **{Timestamp}**: When the attack happened.  
        **{VulnerabilityName}**: Name of the associated code-level vulnerability, for example: "InMemoryDatabaseCaller.getAccountInfo():51". Can be empty.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        The subject of the email notifications.. Available placeholders:  
        **{AttackDisplayId}**: The unique identifier assigned by Dynatrace, for example, "A-1234".  
        **{Title}**: Location of the attack, for example: "com.dynatrace.Class.method():120"  
        **{Type}**: The type of attack, for example: "SQL Injection".  
        **{AttackUrl}**: URL of the attack in Dynatrace.  
        **{ProcessGroupId}**: Details about the process group attacked.  
        **{EntryPoint}**: The entry point of the attack into the process, for example: "/login". Can be empty.  
        **{Status}**: The status of the attack, for example: "Exploited"  
        **{Timestamp}**: When the attack happened.  
        **{VulnerabilityName}**: Name of the associated code-level vulnerability, for example: "InMemoryDatabaseCaller.getAccountInfo():51". Can be empty.
        """
        return pulumi.get(self, "subject")


@pulumi.output_type
class AppsecNotificationAttackCandidateBasedJiraPayload(dict):
    def __init__(__self__, *,
                 description: str,
                 summary: str):
        """
        :param str description: The description of the Jira issue to be created by this notification.  
               In case a value of an attack is not set, the placeholder will be replaced by an empty string.. **Note:** Security notifications contain sensitive information. Excessive usage of placeholders in the description might leak information to untrusted parties.  
                 
               Available placeholders:  
               **{AttackDisplayId}**: The unique identifier assigned by Dynatrace, for example: "A-1234".  
               **{Title}**: Location of the attack, for example: "com.dynatrace.Class.method():120"  
               **{Type}**: The type of attack, for example: "SQL Injection".  
               **{AttackUrl}**: URL of the attack in Dynatrace.  
               **{ProcessGroupId}**: Details about the process group attacked.  
               **{EntryPoint}**: The entry point of the attack into the process, for example: "/login". Can be empty.  
               **{Status}**: The status of the attack, for example: "Exploited"  
               **{Timestamp}**: When the attack happened.  
               **{VulnerabilityName}**: Name of the associated code-level vulnerability, for example: "InMemoryDatabaseCaller.getAccountInfo():51". Can be empty.
        :param str summary: The summary of the Jira issue to be created by this notification.. **Note:** The Jira summary field must contain less than 255 characters. Any content exceeding this limit after evaluating the placeholders will be discarded.  
                 
               Available placeholders:  
               **{AttackDisplayId}**: The unique identifier assigned by Dynatrace, for example, "A-1234".  
               **{Title}**: Location of the attack, for example: "com.dynatrace.Class.method():120"  
               **{Type}**: The type of attack, for example: "SQL Injection".  
               **{AttackUrl}**: URL of the attack in Dynatrace.  
               **{ProcessGroupId}**: Details about the process group attacked.  
               **{EntryPoint}**: The entry point of the attack into the process, for example: "/login". Can be empty.  
               **{Status}**: The status of the attack, for example: "Exploited"  
               **{Timestamp}**: When the attack happened.  
               **{VulnerabilityName}**: Name of the associated code-level vulnerability, for example: "InMemoryDatabaseCaller.getAccountInfo():51". Can be empty.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "summary", summary)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the Jira issue to be created by this notification.  
        In case a value of an attack is not set, the placeholder will be replaced by an empty string.. **Note:** Security notifications contain sensitive information. Excessive usage of placeholders in the description might leak information to untrusted parties.  
          
        Available placeholders:  
        **{AttackDisplayId}**: The unique identifier assigned by Dynatrace, for example: "A-1234".  
        **{Title}**: Location of the attack, for example: "com.dynatrace.Class.method():120"  
        **{Type}**: The type of attack, for example: "SQL Injection".  
        **{AttackUrl}**: URL of the attack in Dynatrace.  
        **{ProcessGroupId}**: Details about the process group attacked.  
        **{EntryPoint}**: The entry point of the attack into the process, for example: "/login". Can be empty.  
        **{Status}**: The status of the attack, for example: "Exploited"  
        **{Timestamp}**: When the attack happened.  
        **{VulnerabilityName}**: Name of the associated code-level vulnerability, for example: "InMemoryDatabaseCaller.getAccountInfo():51". Can be empty.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The summary of the Jira issue to be created by this notification.. **Note:** The Jira summary field must contain less than 255 characters. Any content exceeding this limit after evaluating the placeholders will be discarded.  
          
        Available placeholders:  
        **{AttackDisplayId}**: The unique identifier assigned by Dynatrace, for example, "A-1234".  
        **{Title}**: Location of the attack, for example: "com.dynatrace.Class.method():120"  
        **{Type}**: The type of attack, for example: "SQL Injection".  
        **{AttackUrl}**: URL of the attack in Dynatrace.  
        **{ProcessGroupId}**: Details about the process group attacked.  
        **{EntryPoint}**: The entry point of the attack into the process, for example: "/login". Can be empty.  
        **{Status}**: The status of the attack, for example: "Exploited"  
        **{Timestamp}**: When the attack happened.  
        **{VulnerabilityName}**: Name of the associated code-level vulnerability, for example: "InMemoryDatabaseCaller.getAccountInfo():51". Can be empty.
        """
        return pulumi.get(self, "summary")


@pulumi.output_type
class AppsecNotificationAttackCandidateBasedWebhookPayload(dict):
    def __init__(__self__, *,
                 payload: str):
        """
        :param str payload: This is the content your notification message will include when users view it.  
               In case a value of an attack is not set, the placeholder will be replaced by an empty string.. **Note:** Security notifications contain sensitive information. Excessive usage of placeholders in the custom payload might leak information to untrusted parties.  
                 
               Available placeholders:  
               **{AttackDisplayId}**: The unique identifier assigned by Dynatrace, for example: "A-1234".  
               **{Title}**: Location of the attack, for example: "com.dynatrace.Class.method():120"  
               **{Type}**: The type of attack, for example: "SQL Injection".  
               **{AttackUrl}**: URL of the attack in Dynatrace.  
               **{ProcessGroupId}**: Details about the process group attacked.  
               **{EntryPoint}**: The entry point of the attack into the process, for example: "/login". Can be empty.  
               **{Status}**: The status of the attack, for example: "Exploited"  
               **{Timestamp}**: When the attack happened.  
               **{VulnerabilityName}**: Name of the associated code-level vulnerability, for example: "InMemoryDatabaseCaller.getAccountInfo():51". Can be empty.
        """
        pulumi.set(__self__, "payload", payload)

    @property
    @pulumi.getter
    def payload(self) -> str:
        """
        This is the content your notification message will include when users view it.  
        In case a value of an attack is not set, the placeholder will be replaced by an empty string.. **Note:** Security notifications contain sensitive information. Excessive usage of placeholders in the custom payload might leak information to untrusted parties.  
          
        Available placeholders:  
        **{AttackDisplayId}**: The unique identifier assigned by Dynatrace, for example: "A-1234".  
        **{Title}**: Location of the attack, for example: "com.dynatrace.Class.method():120"  
        **{Type}**: The type of attack, for example: "SQL Injection".  
        **{AttackUrl}**: URL of the attack in Dynatrace.  
        **{ProcessGroupId}**: Details about the process group attacked.  
        **{EntryPoint}**: The entry point of the attack into the process, for example: "/login". Can be empty.  
        **{Status}**: The status of the attack, for example: "Exploited"  
        **{Timestamp}**: When the attack happened.  
        **{VulnerabilityName}**: Name of the associated code-level vulnerability, for example: "InMemoryDatabaseCaller.getAccountInfo():51". Can be empty.
        """
        return pulumi.get(self, "payload")


@pulumi.output_type
class AppsecNotificationEmailConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bccRecipients":
            suggest = "bcc_recipients"
        elif key == "ccRecipients":
            suggest = "cc_recipients"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsecNotificationEmailConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsecNotificationEmailConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsecNotificationEmailConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recipients: Sequence[str],
                 bcc_recipients: Optional[Sequence[str]] = None,
                 cc_recipients: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] recipients: To
        :param Sequence[str] bcc_recipients: BCC
        :param Sequence[str] cc_recipients: CC
        """
        pulumi.set(__self__, "recipients", recipients)
        if bcc_recipients is not None:
            pulumi.set(__self__, "bcc_recipients", bcc_recipients)
        if cc_recipients is not None:
            pulumi.set(__self__, "cc_recipients", cc_recipients)

    @property
    @pulumi.getter
    def recipients(self) -> Sequence[str]:
        """
        To
        """
        return pulumi.get(self, "recipients")

    @property
    @pulumi.getter(name="bccRecipients")
    def bcc_recipients(self) -> Optional[Sequence[str]]:
        """
        BCC
        """
        return pulumi.get(self, "bcc_recipients")

    @property
    @pulumi.getter(name="ccRecipients")
    def cc_recipients(self) -> Optional[Sequence[str]]:
        """
        CC
        """
        return pulumi.get(self, "cc_recipients")


@pulumi.output_type
class AppsecNotificationJiraConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "issueType":
            suggest = "issue_type"
        elif key == "projectKey":
            suggest = "project_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsecNotificationJiraConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsecNotificationJiraConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsecNotificationJiraConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str,
                 issue_type: str,
                 project_key: str,
                 url: str,
                 username: str):
        """
        :param str api_token: The API token for the Jira profile. Using password authentication [was deprecated by Jira](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-basic-auth-and-cookie-based-auth/)
        :param str issue_type: The type of the Jira issue to be created by this notification.
               
               To find all available issue types or create your own, in Jira, go to Project settings > Issue types.
        :param str project_key: The project key of the Jira issue to be created by this notification.
        :param str url: The URL of the Jira API endpoint.
        :param str username: The username of the Jira profile.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "issue_type", issue_type)
        pulumi.set(__self__, "project_key", project_key)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        The API token for the Jira profile. Using password authentication [was deprecated by Jira](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-basic-auth-and-cookie-based-auth/)
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="issueType")
    def issue_type(self) -> str:
        """
        The type of the Jira issue to be created by this notification.

        To find all available issue types or create your own, in Jira, go to Project settings > Issue types.
        """
        return pulumi.get(self, "issue_type")

    @property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> str:
        """
        The project key of the Jira issue to be created by this notification.
        """
        return pulumi.get(self, "project_key")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the Jira API endpoint.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username of the Jira profile.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class AppsecNotificationSecurityProblemBasedEmailPayload(dict):
    def __init__(__self__, *,
                 body: str,
                 subject: str):
        """
        :param str body: The template of the email notifications.  
               In case a value of a security problem is not set, the placeholder will be replaced by an empty string.. **Note:** Security notifications contain sensitive information. Excessive usage of placeholders in the description might leak information to untrusted parties.  
                 
               Available placeholders:  
               **{SecurityProblemId}**: The unique identifier assigned by Dynatrace, for example, "S-1234".  
               **{Title}**: A short summary of the type of vulnerability that was found, for example, "Remote Code Execution".  
               **{Description}**: A more detailed description of the vulnerability.  
               **{CvssScore}**: CVSS score of the identified vulnerability, for example, "10.0". Can be empty. 
               **{DavisSecurityScore}**: [Davis Security Score](https://www.dynatrace.com/support/help/how-to-use-dynatrace/application-security/davis-security-score/) is an enhanced risk-calculation score based on the CVSS, for example, "10.0".  
               **{Severity}**: The security problem severity, for example, "Critical" or "Medium".  
               **{SecurityProblemUrl}**: URL of the security problem in Dynatrace.  
               **{AffectedEntities}**: Details about the entities affected by the security problem in a json array.  
               **{ManagementZones}**: Comma-separated list of all management zones affected by the vulnerability at the time of detection.  
               **{Tags}**: Comma-separated list of tags that are defined for a vulnerability's affected entities. For example: "PROD, owner:John". Assign the tag's key in square brackets: **{Tags[key]}** to get all associated values. For example: "{Tags[owner]}" will be resolved as "John". Tags without an assigned value will be resolved as empty string.  
               **{Exposed}**: Describes whether one or more affected process is exposed to the public Internet. Can be "true" or "false".  
               **{DataAssetsReachable}**: Describes whether one or more affected process can reach data assets. Can be "true" or "false".  
               **{ExploitAvailable}**: Describes whether there's an exploit available for the vulnerability. Can be "true" or "false".
        :param str subject: The subject of the email notifications.. Available placeholders:  
               **{SecurityProblemId}**: The unique identifier assigned by Dynatrace, for example, "S-1234".  
               **{Title}**: A short summary of the type of vulnerability that was found, for example, "Remote Code Execution".  
               **{CvssScore}**: CVSS score of the identified vulnerability, for example, "10.0". Can be empty. 
               **{DavisSecurityScore}**: [Davis Security Score](https://www.dynatrace.com/support/help/how-to-use-dynatrace/application-security/davis-security-score/) is an enhanced risk-calculation score based on the CVSS, for example, "10.0".  
               **{Severity}**: The security problem severity, for example, "Critical" or "Medium".  
               **{SecurityProblemUrl}**: URL of the security problem in Dynatrace.  
               **{Exposed}**: Describes whether one or more affected process is exposed to the public Internet. Can be "true" or "false".  
               **{DataAssetsReachable}**: Describes whether one or more affected process can reach data assets. Can be "true" or "false".  
               **{ExploitAvailable}**: Describes whether there's an exploit available for the vulnerability. Can be "true" or "false".
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter
    def body(self) -> str:
        """
        The template of the email notifications.  
        In case a value of a security problem is not set, the placeholder will be replaced by an empty string.. **Note:** Security notifications contain sensitive information. Excessive usage of placeholders in the description might leak information to untrusted parties.  
          
        Available placeholders:  
        **{SecurityProblemId}**: The unique identifier assigned by Dynatrace, for example, "S-1234".  
        **{Title}**: A short summary of the type of vulnerability that was found, for example, "Remote Code Execution".  
        **{Description}**: A more detailed description of the vulnerability.  
        **{CvssScore}**: CVSS score of the identified vulnerability, for example, "10.0". Can be empty. 
        **{DavisSecurityScore}**: [Davis Security Score](https://www.dynatrace.com/support/help/how-to-use-dynatrace/application-security/davis-security-score/) is an enhanced risk-calculation score based on the CVSS, for example, "10.0".  
        **{Severity}**: The security problem severity, for example, "Critical" or "Medium".  
        **{SecurityProblemUrl}**: URL of the security problem in Dynatrace.  
        **{AffectedEntities}**: Details about the entities affected by the security problem in a json array.  
        **{ManagementZones}**: Comma-separated list of all management zones affected by the vulnerability at the time of detection.  
        **{Tags}**: Comma-separated list of tags that are defined for a vulnerability's affected entities. For example: "PROD, owner:John". Assign the tag's key in square brackets: **{Tags[key]}** to get all associated values. For example: "{Tags[owner]}" will be resolved as "John". Tags without an assigned value will be resolved as empty string.  
        **{Exposed}**: Describes whether one or more affected process is exposed to the public Internet. Can be "true" or "false".  
        **{DataAssetsReachable}**: Describes whether one or more affected process can reach data assets. Can be "true" or "false".  
        **{ExploitAvailable}**: Describes whether there's an exploit available for the vulnerability. Can be "true" or "false".
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        The subject of the email notifications.. Available placeholders:  
        **{SecurityProblemId}**: The unique identifier assigned by Dynatrace, for example, "S-1234".  
        **{Title}**: A short summary of the type of vulnerability that was found, for example, "Remote Code Execution".  
        **{CvssScore}**: CVSS score of the identified vulnerability, for example, "10.0". Can be empty. 
        **{DavisSecurityScore}**: [Davis Security Score](https://www.dynatrace.com/support/help/how-to-use-dynatrace/application-security/davis-security-score/) is an enhanced risk-calculation score based on the CVSS, for example, "10.0".  
        **{Severity}**: The security problem severity, for example, "Critical" or "Medium".  
        **{SecurityProblemUrl}**: URL of the security problem in Dynatrace.  
        **{Exposed}**: Describes whether one or more affected process is exposed to the public Internet. Can be "true" or "false".  
        **{DataAssetsReachable}**: Describes whether one or more affected process can reach data assets. Can be "true" or "false".  
        **{ExploitAvailable}**: Describes whether there's an exploit available for the vulnerability. Can be "true" or "false".
        """
        return pulumi.get(self, "subject")


@pulumi.output_type
class AppsecNotificationSecurityProblemBasedJiraPayload(dict):
    def __init__(__self__, *,
                 description: str,
                 summary: str):
        """
        :param str description: The description of the Jira issue to be created by this notification.  
               In case a value of a security problem is not set, the placeholder will be replaced by an empty string.. **Note:** Security notifications contain sensitive information. Excessive usage of placeholders in the description might leak information to untrusted parties.  
                 
               Available placeholders:  
               **{SecurityProblemId}**: The unique identifier assigned by Dynatrace, for example, "S-1234".  
               **{Title}**: A short summary of the type of vulnerability that was found, for example, "Remote Code Execution".  
               **{Description}**: A more detailed description of the vulnerability.  
               **{CvssScore}**: CVSS score of the identified vulnerability, for example, "10.0". Can be empty. 
               **{DavisSecurityScore}**: [Davis Security Score](https://www.dynatrace.com/support/help/how-to-use-dynatrace/application-security/davis-security-score/) is an enhanced risk-calculation score based on the CVSS, for example, "10.0".  
               **{Severity}**: The security problem severity, for example, "Critical" or "Medium".  
               **{SecurityProblemUrl}**: URL of the security problem in Dynatrace.  
               **{AffectedEntities}**: Details about the entities affected by the security problem in a json array.  
               **{ManagementZones}**: Comma-separated list of all management zones affected by the vulnerability at the time of detection.  
               **{Tags}**: Comma-separated list of tags that are defined for a vulnerability's affected entities. For example: "PROD, owner:John". Assign the tag's key in square brackets: **{Tags[key]}** to get all associated values. For example: "{Tags[owner]}" will be resolved as "John". Tags without an assigned value will be resolved as empty string.  
               **{Exposed}**: Describes whether one or more affected process is exposed to the public Internet. Can be "true" or "false".  
               **{DataAssetsReachable}**: Describes whether one or more affected process can reach data assets. Can be "true" or "false".  
               **{ExploitAvailable}**: Describes whether there's an exploit available for the vulnerability. Can be "true" or "false".
        :param str summary: The summary of the Jira issue to be created by this notification.. **Note:** The Jira summary field must contain less than 255 characters. Any content exceeding this limit after evaluating the placeholders will be discarded.  
                 
               Available placeholders:  
               **{SecurityProblemId}**: The unique identifier assigned by Dynatrace, for example, "S-1234".  
               **{Title}**: A short summary of the type of vulnerability that was found, for example, "Remote Code Execution".  
               **{CvssScore}**: CVSS score of the identified vulnerability, for example, "10.0". Can be empty. 
               **{DavisSecurityScore}**: [Davis Security Score](https://www.dynatrace.com/support/help/how-to-use-dynatrace/application-security/davis-security-score/) is an enhanced risk-calculation score based on the CVSS, for example, "10.0".  
               **{Severity}**: The security problem severity, for example, "Critical" or "Medium".  
               **{SecurityProblemUrl}**: URL of the security problem in Dynatrace.  
               **{Exposed}**: Describes whether one or more affected process is exposed to the public Internet. Can be "true" or "false".  
               **{DataAssetsReachable}**: Describes whether one or more affected process can reach data assets. Can be "true" or "false".  
               **{ExploitAvailable}**: Describes whether there's an exploit available for the vulnerability. Can be "true" or "false".
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "summary", summary)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the Jira issue to be created by this notification.  
        In case a value of a security problem is not set, the placeholder will be replaced by an empty string.. **Note:** Security notifications contain sensitive information. Excessive usage of placeholders in the description might leak information to untrusted parties.  
          
        Available placeholders:  
        **{SecurityProblemId}**: The unique identifier assigned by Dynatrace, for example, "S-1234".  
        **{Title}**: A short summary of the type of vulnerability that was found, for example, "Remote Code Execution".  
        **{Description}**: A more detailed description of the vulnerability.  
        **{CvssScore}**: CVSS score of the identified vulnerability, for example, "10.0". Can be empty. 
        **{DavisSecurityScore}**: [Davis Security Score](https://www.dynatrace.com/support/help/how-to-use-dynatrace/application-security/davis-security-score/) is an enhanced risk-calculation score based on the CVSS, for example, "10.0".  
        **{Severity}**: The security problem severity, for example, "Critical" or "Medium".  
        **{SecurityProblemUrl}**: URL of the security problem in Dynatrace.  
        **{AffectedEntities}**: Details about the entities affected by the security problem in a json array.  
        **{ManagementZones}**: Comma-separated list of all management zones affected by the vulnerability at the time of detection.  
        **{Tags}**: Comma-separated list of tags that are defined for a vulnerability's affected entities. For example: "PROD, owner:John". Assign the tag's key in square brackets: **{Tags[key]}** to get all associated values. For example: "{Tags[owner]}" will be resolved as "John". Tags without an assigned value will be resolved as empty string.  
        **{Exposed}**: Describes whether one or more affected process is exposed to the public Internet. Can be "true" or "false".  
        **{DataAssetsReachable}**: Describes whether one or more affected process can reach data assets. Can be "true" or "false".  
        **{ExploitAvailable}**: Describes whether there's an exploit available for the vulnerability. Can be "true" or "false".
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The summary of the Jira issue to be created by this notification.. **Note:** The Jira summary field must contain less than 255 characters. Any content exceeding this limit after evaluating the placeholders will be discarded.  
          
        Available placeholders:  
        **{SecurityProblemId}**: The unique identifier assigned by Dynatrace, for example, "S-1234".  
        **{Title}**: A short summary of the type of vulnerability that was found, for example, "Remote Code Execution".  
        **{CvssScore}**: CVSS score of the identified vulnerability, for example, "10.0". Can be empty. 
        **{DavisSecurityScore}**: [Davis Security Score](https://www.dynatrace.com/support/help/how-to-use-dynatrace/application-security/davis-security-score/) is an enhanced risk-calculation score based on the CVSS, for example, "10.0".  
        **{Severity}**: The security problem severity, for example, "Critical" or "Medium".  
        **{SecurityProblemUrl}**: URL of the security problem in Dynatrace.  
        **{Exposed}**: Describes whether one or more affected process is exposed to the public Internet. Can be "true" or "false".  
        **{DataAssetsReachable}**: Describes whether one or more affected process can reach data assets. Can be "true" or "false".  
        **{ExploitAvailable}**: Describes whether there's an exploit available for the vulnerability. Can be "true" or "false".
        """
        return pulumi.get(self, "summary")


@pulumi.output_type
class AppsecNotificationSecurityProblemBasedWebhookPayload(dict):
    def __init__(__self__, *,
                 payload: str):
        """
        :param str payload: This is the content your notification message will include when users view it.  
               In case a value of a security problem is not set, the placeholder will be replaced by an empty string.. **Note:** Security notifications contain sensitive information. Excessive usage of placeholders in the custom payload might leak information to untrusted parties.  
                 
               Available placeholders:  
               **{SecurityProblemId}**: The unique identifier assigned by Dynatrace, for example, "S-1234".  
               **{Title}**: A short summary of the type of vulnerability that was found, for example, "Remote Code Execution".  
               **{Description}**: A more detailed description of the vulnerability.  
               **{CvssScore}**: CVSS score of the identified vulnerability, for example, "10.0". Can be empty. 
               **{DavisSecurityScore}**: [Davis Security Score](https://www.dynatrace.com/support/help/how-to-use-dynatrace/application-security/davis-security-score/) is an enhanced risk-calculation score based on the CVSS, for example, "10.0".  
               **{Severity}**: The security problem severity, for example, "Critical" or "Medium".  
               **{SecurityProblemUrl}**: URL of the security problem in Dynatrace.  
               **{AffectedEntities}**: Details about the entities affected by the security problem in a json array.  
               **{ManagementZones}**: Comma-separated list of all management zones affected by the vulnerability at the time of detection.  
               **{Tags}**: Comma-separated list of tags that are defined for a vulnerability's affected entities. For example: "PROD, owner:John". Assign the tag's key in square brackets: **{Tags[key]}** to get all associated values. For example: "{Tags[owner]}" will be resolved as "John". Tags without an assigned value will be resolved as empty string.  
               **{Exposed}**: Describes whether one or more affected process is exposed to the public Internet. Can be "true" or "false".  
               **{DataAssetsReachable}**: Describes whether one or more affected process can reach data assets. Can be "true" or "false".  
               **{ExploitAvailable}**: Describes whether there's an exploit available for the vulnerability. Can be "true" or "false".
        """
        pulumi.set(__self__, "payload", payload)

    @property
    @pulumi.getter
    def payload(self) -> str:
        """
        This is the content your notification message will include when users view it.  
        In case a value of a security problem is not set, the placeholder will be replaced by an empty string.. **Note:** Security notifications contain sensitive information. Excessive usage of placeholders in the custom payload might leak information to untrusted parties.  
          
        Available placeholders:  
        **{SecurityProblemId}**: The unique identifier assigned by Dynatrace, for example, "S-1234".  
        **{Title}**: A short summary of the type of vulnerability that was found, for example, "Remote Code Execution".  
        **{Description}**: A more detailed description of the vulnerability.  
        **{CvssScore}**: CVSS score of the identified vulnerability, for example, "10.0". Can be empty. 
        **{DavisSecurityScore}**: [Davis Security Score](https://www.dynatrace.com/support/help/how-to-use-dynatrace/application-security/davis-security-score/) is an enhanced risk-calculation score based on the CVSS, for example, "10.0".  
        **{Severity}**: The security problem severity, for example, "Critical" or "Medium".  
        **{SecurityProblemUrl}**: URL of the security problem in Dynatrace.  
        **{AffectedEntities}**: Details about the entities affected by the security problem in a json array.  
        **{ManagementZones}**: Comma-separated list of all management zones affected by the vulnerability at the time of detection.  
        **{Tags}**: Comma-separated list of tags that are defined for a vulnerability's affected entities. For example: "PROD, owner:John". Assign the tag's key in square brackets: **{Tags[key]}** to get all associated values. For example: "{Tags[owner]}" will be resolved as "John". Tags without an assigned value will be resolved as empty string.  
        **{Exposed}**: Describes whether one or more affected process is exposed to the public Internet. Can be "true" or "false".  
        **{DataAssetsReachable}**: Describes whether one or more affected process can reach data assets. Can be "true" or "false".  
        **{ExploitAvailable}**: Describes whether there's an exploit available for the vulnerability. Can be "true" or "false".
        """
        return pulumi.get(self, "payload")


@pulumi.output_type
class AppsecNotificationWebhookConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptAnyCertificate":
            suggest = "accept_any_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsecNotificationWebhookConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsecNotificationWebhookConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsecNotificationWebhookConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept_any_certificate: bool,
                 url: str,
                 headers: Optional['outputs.AppsecNotificationWebhookConfigurationHeaders'] = None):
        """
        :param bool accept_any_certificate: Accept any SSL certificate (including self-signed and invalid certificates)
        :param str url: Webhook endpoint URL
        :param 'AppsecNotificationWebhookConfigurationHeadersArgs' headers: Use additional HTTP headers to attach any additional information, for example, configuration, authorization, or metadata.  
                 
               Note that JSON-based webhook endpoints require the addition of the **Content-Type: application/json** header to enable escaping of special characters and to avoid malformed JSON content.
        """
        pulumi.set(__self__, "accept_any_certificate", accept_any_certificate)
        pulumi.set(__self__, "url", url)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter(name="acceptAnyCertificate")
    def accept_any_certificate(self) -> bool:
        """
        Accept any SSL certificate (including self-signed and invalid certificates)
        """
        return pulumi.get(self, "accept_any_certificate")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Webhook endpoint URL
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.AppsecNotificationWebhookConfigurationHeaders']:
        """
        Use additional HTTP headers to attach any additional information, for example, configuration, authorization, or metadata.  
          
        Note that JSON-based webhook endpoints require the addition of the **Content-Type: application/json** header to enable escaping of special characters and to avoid malformed JSON content.
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class AppsecNotificationWebhookConfigurationHeaders(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.AppsecNotificationWebhookConfigurationHeadersHeader']):
        pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.AppsecNotificationWebhookConfigurationHeadersHeader']:
        return pulumi.get(self, "headers")


@pulumi.output_type
class AppsecNotificationWebhookConfigurationHeadersHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretValue":
            suggest = "secret_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsecNotificationWebhookConfigurationHeadersHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsecNotificationWebhookConfigurationHeadersHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsecNotificationWebhookConfigurationHeadersHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 secret: bool,
                 secret_value: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: no documentation available
        :param bool secret: Secret HTTP header value
        :param str secret_value: The secret value of the HTTP header. May contain an empty value.
        :param str value: The value of the HTTP header. May contain an empty value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret", secret)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def secret(self) -> bool:
        """
        Secret HTTP header value
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[str]:
        """
        The secret value of the HTTP header. May contain an empty value.
        """
        return pulumi.get(self, "secret_value")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the HTTP header. May contain an empty value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AttackAllowlistAttackHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockingStrategy":
            suggest = "blocking_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttackAllowlistAttackHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttackAllowlistAttackHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttackAllowlistAttackHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blocking_strategy: str):
        """
        :param str blocking_strategy: Possible Values: `MONITOR`, `OFF`
        """
        pulumi.set(__self__, "blocking_strategy", blocking_strategy)

    @property
    @pulumi.getter(name="blockingStrategy")
    def blocking_strategy(self) -> str:
        """
        Possible Values: `MONITOR`, `OFF`
        """
        return pulumi.get(self, "blocking_strategy")


@pulumi.output_type
class AttackAllowlistCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attackPattern":
            suggest = "attack_pattern"
        elif key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttackAllowlistCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttackAllowlistCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttackAllowlistCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attack_pattern: Optional[str] = None,
                 source_ip: Optional[str] = None):
        """
        :param str attack_pattern: Only consider attacks matching the specified pattern.
        :param str source_ip: Source IP
        """
        if attack_pattern is not None:
            pulumi.set(__self__, "attack_pattern", attack_pattern)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @property
    @pulumi.getter(name="attackPattern")
    def attack_pattern(self) -> Optional[str]:
        """
        Only consider attacks matching the specified pattern.
        """
        return pulumi.get(self, "attack_pattern")

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[str]:
        """
        Source IP
        """
        return pulumi.get(self, "source_ip")


@pulumi.output_type
class AttackAllowlistMetadata(dict):
    def __init__(__self__, *,
                 comment: str):
        """
        :param str comment: no documentation available
        """
        pulumi.set(__self__, "comment", comment)

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "comment")


@pulumi.output_type
class AttackRulesAttackHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockingStrategy":
            suggest = "blocking_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttackRulesAttackHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttackRulesAttackHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttackRulesAttackHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blocking_strategy: str):
        """
        :param str blocking_strategy: Possible Values: `BLOCK`, `MONITOR`, `OFF`
        """
        pulumi.set(__self__, "blocking_strategy", blocking_strategy)

    @property
    @pulumi.getter(name="blockingStrategy")
    def blocking_strategy(self) -> str:
        """
        Possible Values: `BLOCK`, `MONITOR`, `OFF`
        """
        return pulumi.get(self, "blocking_strategy")


@pulumi.output_type
class AttackRulesCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attackType":
            suggest = "attack_type"
        elif key == "processGroup":
            suggest = "process_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttackRulesCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttackRulesCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttackRulesCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attack_type: str,
                 process_group: Optional[str] = None):
        """
        :param str attack_type: Possible Values: `ANY`, `CMD_INJECTION`, `JNDI_INJECTION`, `SQL_INJECTION`, `SSRF`
        :param str process_group: Process group
        """
        pulumi.set(__self__, "attack_type", attack_type)
        if process_group is not None:
            pulumi.set(__self__, "process_group", process_group)

    @property
    @pulumi.getter(name="attackType")
    def attack_type(self) -> str:
        """
        Possible Values: `ANY`, `CMD_INJECTION`, `JNDI_INJECTION`, `SQL_INJECTION`, `SSRF`
        """
        return pulumi.get(self, "attack_type")

    @property
    @pulumi.getter(name="processGroup")
    @_utilities.deprecated("""This field has been deprecated""")
    def process_group(self) -> Optional[str]:
        """
        Process group
        """
        return pulumi.get(self, "process_group")


@pulumi.output_type
class AttackRulesMetadata(dict):
    def __init__(__self__, *,
                 comment: str):
        """
        :param str comment: no documentation available
        """
        pulumi.set(__self__, "comment", comment)

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "comment")


@pulumi.output_type
class AttackRulesResourceAttributeConditions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceAttributeConditions":
            suggest = "resource_attribute_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttackRulesResourceAttributeConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttackRulesResourceAttributeConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttackRulesResourceAttributeConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_attribute_conditions: Sequence['outputs.AttackRulesResourceAttributeConditionsResourceAttributeCondition']):
        pulumi.set(__self__, "resource_attribute_conditions", resource_attribute_conditions)

    @property
    @pulumi.getter(name="resourceAttributeConditions")
    def resource_attribute_conditions(self) -> Sequence['outputs.AttackRulesResourceAttributeConditionsResourceAttributeCondition']:
        return pulumi.get(self, "resource_attribute_conditions")


@pulumi.output_type
class AttackRulesResourceAttributeConditionsResourceAttributeCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceAttributeKey":
            suggest = "resource_attribute_key"
        elif key == "resourceAttributeValue":
            suggest = "resource_attribute_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttackRulesResourceAttributeConditionsResourceAttributeCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttackRulesResourceAttributeConditionsResourceAttributeCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttackRulesResourceAttributeConditionsResourceAttributeCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 matcher: str,
                 resource_attribute_key: str,
                 resource_attribute_value: Optional[str] = None):
        """
        :param str matcher: Possible Values: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_END_WITH`, `DOES_NOT_EXIST`, `DOES_NOT_START_WITH`, `ENDS_WITH`, `EQUALS`, `EXISTS`, `NOT_EQUALS`, `STARTS_WITH`
        :param str resource_attribute_key: Resource attribute key
        :param str resource_attribute_value: Resource attribute value
        """
        pulumi.set(__self__, "matcher", matcher)
        pulumi.set(__self__, "resource_attribute_key", resource_attribute_key)
        if resource_attribute_value is not None:
            pulumi.set(__self__, "resource_attribute_value", resource_attribute_value)

    @property
    @pulumi.getter
    def matcher(self) -> str:
        """
        Possible Values: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_END_WITH`, `DOES_NOT_EXIST`, `DOES_NOT_START_WITH`, `ENDS_WITH`, `EQUALS`, `EXISTS`, `NOT_EQUALS`, `STARTS_WITH`
        """
        return pulumi.get(self, "matcher")

    @property
    @pulumi.getter(name="resourceAttributeKey")
    def resource_attribute_key(self) -> str:
        """
        Resource attribute key
        """
        return pulumi.get(self, "resource_attribute_key")

    @property
    @pulumi.getter(name="resourceAttributeValue")
    def resource_attribute_value(self) -> Optional[str]:
        """
        Resource attribute value
        """
        return pulumi.get(self, "resource_attribute_value")


@pulumi.output_type
class AttackSettingsDefaultAttackHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockingStrategyJava":
            suggest = "blocking_strategy_java"
        elif key == "blockingStrategyDotNet":
            suggest = "blocking_strategy_dot_net"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttackSettingsDefaultAttackHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttackSettingsDefaultAttackHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttackSettingsDefaultAttackHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blocking_strategy_java: str,
                 blocking_strategy_dot_net: Optional[str] = None):
        """
        :param str blocking_strategy_java: Possible Values: `BLOCK`, `MONITOR`, `OFF`
        :param str blocking_strategy_dot_net: (v1.290) Possible Values: `BLOCK`, `MONITOR`, `OFF`
        """
        pulumi.set(__self__, "blocking_strategy_java", blocking_strategy_java)
        if blocking_strategy_dot_net is not None:
            pulumi.set(__self__, "blocking_strategy_dot_net", blocking_strategy_dot_net)

    @property
    @pulumi.getter(name="blockingStrategyJava")
    def blocking_strategy_java(self) -> str:
        """
        Possible Values: `BLOCK`, `MONITOR`, `OFF`
        """
        return pulumi.get(self, "blocking_strategy_java")

    @property
    @pulumi.getter(name="blockingStrategyDotNet")
    def blocking_strategy_dot_net(self) -> Optional[str]:
        """
        (v1.290) Possible Values: `BLOCK`, `MONITOR`, `OFF`
        """
        return pulumi.get(self, "blocking_strategy_dot_net")


@pulumi.output_type
class AutomationBusinessCalendarHolidays(dict):
    def __init__(__self__, *,
                 holidays: Sequence['outputs.AutomationBusinessCalendarHolidaysHoliday']):
        """
        :param Sequence['AutomationBusinessCalendarHolidaysHolidayArgs'] holidays: A (unordered) list of holidays valid in this calendar
        """
        pulumi.set(__self__, "holidays", holidays)

    @property
    @pulumi.getter
    def holidays(self) -> Sequence['outputs.AutomationBusinessCalendarHolidaysHoliday']:
        """
        A (unordered) list of holidays valid in this calendar
        """
        return pulumi.get(self, "holidays")


@pulumi.output_type
class AutomationBusinessCalendarHolidaysHoliday(dict):
    def __init__(__self__, *,
                 date: str,
                 title: str):
        """
        :param str date: The date of this holiday: Example `2017-07-04` for July 4th 2017
        :param str title: An official name for this holiday
        """
        pulumi.set(__self__, "date", date)
        pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def date(self) -> str:
        """
        The date of this holiday: Example `2017-07-04` for July 4th 2017
        """
        return pulumi.get(self, "date")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        An official name for this holiday
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class AutomationSchedulingRuleFixedOffset(dict):
    def __init__(__self__, *,
                 offset: int,
                 rule: str):
        """
        :param int offset: Every day of the scheduling rule referred to with `rule` will be offset by this amount of days
        :param str rule: Refers to a scheduling rule for which to produce valid days with an offset
        """
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "rule", rule)

    @property
    @pulumi.getter
    def offset(self) -> int:
        """
        Every day of the scheduling rule referred to with `rule` will be offset by this amount of days
        """
        return pulumi.get(self, "offset")

    @property
    @pulumi.getter
    def rule(self) -> str:
        """
        Refers to a scheduling rule for which to produce valid days with an offset
        """
        return pulumi.get(self, "rule")


@pulumi.output_type
class AutomationSchedulingRuleGrouping(dict):
    def __init__(__self__, *,
                 combines: Sequence[str],
                 intersects: Optional[Sequence[str]] = None,
                 subtracts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] combines: The IDs of scheduling rules determining the days the schedule should apply to
        :param Sequence[str] intersects: The IDs of scheduling rules determining the days the schedule is allowed apply to. If specified, only days that are covered by `combine` and `intersect` are valid days for the schedule
        :param Sequence[str] subtracts: The IDs of scheduling rules determing the days the schedule must not apply. If specified it reduces down the set of days covered by `combine` and `intersect`
        """
        pulumi.set(__self__, "combines", combines)
        if intersects is not None:
            pulumi.set(__self__, "intersects", intersects)
        if subtracts is not None:
            pulumi.set(__self__, "subtracts", subtracts)

    @property
    @pulumi.getter
    def combines(self) -> Sequence[str]:
        """
        The IDs of scheduling rules determining the days the schedule should apply to
        """
        return pulumi.get(self, "combines")

    @property
    @pulumi.getter
    def intersects(self) -> Optional[Sequence[str]]:
        """
        The IDs of scheduling rules determining the days the schedule is allowed apply to. If specified, only days that are covered by `combine` and `intersect` are valid days for the schedule
        """
        return pulumi.get(self, "intersects")

    @property
    @pulumi.getter
    def subtracts(self) -> Optional[Sequence[str]]:
        """
        The IDs of scheduling rules determing the days the schedule must not apply. If specified it reduces down the set of days covered by `combine` and `intersect`
        """
        return pulumi.get(self, "subtracts")


@pulumi.output_type
class AutomationSchedulingRuleRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysInMonths":
            suggest = "days_in_months"
        elif key == "daysInYears":
            suggest = "days_in_years"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationSchedulingRuleRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationSchedulingRuleRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationSchedulingRuleRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datestart: str,
                 frequency: str,
                 workdays: str,
                 days_in_months: Optional[Sequence[int]] = None,
                 days_in_years: Optional[Sequence[int]] = None,
                 easters: Optional[Sequence[int]] = None,
                 interval: Optional[int] = None,
                 months: Optional[Sequence[int]] = None,
                 weekdays: Optional[Sequence[str]] = None,
                 weeks: Optional[Sequence[int]] = None):
        """
        :param str datestart: The recurrence start. Example: `2017-07-04` represents July 4th 2017
        :param str frequency: Possible values are `YEARLY`, `MONTHLY`, `WEEKLY`, `DAILY`, `HOURLY`, `MINUTELY` and `SECONDLY`. Example: `frequency` = `DAILY` and `interval` = `2` schedules for every other day
        :param str workdays: Possible values are `WORKING` (Work days), `HOLIDAYS` (Holidays) and `OFF` (Weekends + Holidays)
        :param Sequence[int] days_in_months: Restricts the recurrence to specific days within a month. `1`, `2`, `3`, ... refers to the first, second, third day in the month. You can also specify negative values to refer to values relative to the last day. `-1` refers to the last day, `-2` refers to the second to the last day, ...
        :param Sequence[int] days_in_years: Restricts the recurrence to specific days within a year. `1`, `2`, `3`, ... refers to the first, second, third day of the year. You can also specify negative values to refer to values relative to the last day. `-1` refers to the last day, `-2` refers to the second to the last day, ...
        :param Sequence[int] easters: Restricts the recurrence to specific days relative to Easter Sunday. `0` will yield the Easter Sunday itself
        :param int interval: The interval between each iteration. Default: 1. Example: `frequency` = `DAILY` and `interval` = `2` schedules for every other day
        :param Sequence[int] months: Restricts the recurrence to specific months. `1` for `January`, `2` for `February`, ..., `12` for `December`
        :param Sequence[str] weekdays: Restricts the recurrence to specific week days. Possible values are `MO`, `TU`, `WE`, `TH`, `FR`, `SA` and `SU`
        :param Sequence[int] weeks: Restricts the recurrence to specific weeks within a year. `1`, `2`, `3`, ... refers to the first, second, third week of the year. You can also specify negative values to refer to values relative to the last week. `-1` refers to the last week, `-2` refers to the second to the last week, ...
        """
        pulumi.set(__self__, "datestart", datestart)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "workdays", workdays)
        if days_in_months is not None:
            pulumi.set(__self__, "days_in_months", days_in_months)
        if days_in_years is not None:
            pulumi.set(__self__, "days_in_years", days_in_years)
        if easters is not None:
            pulumi.set(__self__, "easters", easters)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)
        if weeks is not None:
            pulumi.set(__self__, "weeks", weeks)

    @property
    @pulumi.getter
    def datestart(self) -> str:
        """
        The recurrence start. Example: `2017-07-04` represents July 4th 2017
        """
        return pulumi.get(self, "datestart")

    @property
    @pulumi.getter
    def frequency(self) -> str:
        """
        Possible values are `YEARLY`, `MONTHLY`, `WEEKLY`, `DAILY`, `HOURLY`, `MINUTELY` and `SECONDLY`. Example: `frequency` = `DAILY` and `interval` = `2` schedules for every other day
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter
    def workdays(self) -> str:
        """
        Possible values are `WORKING` (Work days), `HOLIDAYS` (Holidays) and `OFF` (Weekends + Holidays)
        """
        return pulumi.get(self, "workdays")

    @property
    @pulumi.getter(name="daysInMonths")
    def days_in_months(self) -> Optional[Sequence[int]]:
        """
        Restricts the recurrence to specific days within a month. `1`, `2`, `3`, ... refers to the first, second, third day in the month. You can also specify negative values to refer to values relative to the last day. `-1` refers to the last day, `-2` refers to the second to the last day, ...
        """
        return pulumi.get(self, "days_in_months")

    @property
    @pulumi.getter(name="daysInYears")
    def days_in_years(self) -> Optional[Sequence[int]]:
        """
        Restricts the recurrence to specific days within a year. `1`, `2`, `3`, ... refers to the first, second, third day of the year. You can also specify negative values to refer to values relative to the last day. `-1` refers to the last day, `-2` refers to the second to the last day, ...
        """
        return pulumi.get(self, "days_in_years")

    @property
    @pulumi.getter
    def easters(self) -> Optional[Sequence[int]]:
        """
        Restricts the recurrence to specific days relative to Easter Sunday. `0` will yield the Easter Sunday itself
        """
        return pulumi.get(self, "easters")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        The interval between each iteration. Default: 1. Example: `frequency` = `DAILY` and `interval` = `2` schedules for every other day
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence[int]]:
        """
        Restricts the recurrence to specific months. `1` for `January`, `2` for `February`, ..., `12` for `December`
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[Sequence[str]]:
        """
        Restricts the recurrence to specific week days. Possible values are `MO`, `TU`, `WE`, `TH`, `FR`, `SA` and `SU`
        """
        return pulumi.get(self, "weekdays")

    @property
    @pulumi.getter
    def weeks(self) -> Optional[Sequence[int]]:
        """
        Restricts the recurrence to specific weeks within a year. `1`, `2`, `3`, ... refers to the first, second, third week of the year. You can also specify negative values to refer to values relative to the last week. `-1` refers to the last week, `-2` refers to the second to the last week, ...
        """
        return pulumi.get(self, "weeks")


@pulumi.output_type
class AutomationSchedulingRuleRelativeOffset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceRule":
            suggest = "source_rule"
        elif key == "targetRule":
            suggest = "target_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationSchedulingRuleRelativeOffset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationSchedulingRuleRelativeOffset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationSchedulingRuleRelativeOffset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direction: str,
                 source_rule: str,
                 target_rule: str):
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "source_rule", source_rule)
        pulumi.set(__self__, "target_rule", target_rule)

    @property
    @pulumi.getter
    def direction(self) -> str:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="sourceRule")
    def source_rule(self) -> str:
        return pulumi.get(self, "source_rule")

    @property
    @pulumi.getter(name="targetRule")
    def target_rule(self) -> str:
        return pulumi.get(self, "target_rule")


@pulumi.output_type
class AutomationWorkflowAwsConnectionsWebIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "policyArns":
            suggest = "policy_arns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationWorkflowAwsConnectionsWebIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationWorkflowAwsConnectionsWebIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationWorkflowAwsConnectionsWebIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str,
                 policy_arns: Optional[Sequence[str]] = None):
        """
        :param str role_arn: The ARN of the AWS role that should be assumed
        :param Sequence[str] policy_arns: An optional list of policies that can be used to restrict the AWS role
        """
        pulumi.set(__self__, "role_arn", role_arn)
        if policy_arns is not None:
            pulumi.set(__self__, "policy_arns", policy_arns)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the AWS role that should be assumed
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="policyArns")
    def policy_arns(self) -> Optional[Sequence[str]]:
        """
        An optional list of policies that can be used to restrict the AWS role
        """
        return pulumi.get(self, "policy_arns")


@pulumi.output_type
class AutomationWorkflowTasks(dict):
    def __init__(__self__, *,
                 tasks: Optional[Sequence['outputs.AutomationWorkflowTasksTask']] = None):
        """
        :param Sequence['AutomationWorkflowTasksTaskArgs'] tasks: TODO: No documentation available
        """
        if tasks is not None:
            pulumi.set(__self__, "tasks", tasks)

    @property
    @pulumi.getter
    def tasks(self) -> Optional[Sequence['outputs.AutomationWorkflowTasksTask']]:
        """
        TODO: No documentation available
        """
        return pulumi.get(self, "tasks")


@pulumi.output_type
class AutomationWorkflowTasksTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "withItems":
            suggest = "with_items"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationWorkflowTasksTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationWorkflowTasksTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationWorkflowTasksTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 name: str,
                 active: Optional[bool] = None,
                 concurrency: Optional[str] = None,
                 conditions: Optional['outputs.AutomationWorkflowTasksTaskConditions'] = None,
                 description: Optional[str] = None,
                 input: Optional[str] = None,
                 position: Optional['outputs.AutomationWorkflowTasksTaskPosition'] = None,
                 retry: Optional['outputs.AutomationWorkflowTasksTaskRetry'] = None,
                 timeout: Optional[str] = None,
                 with_items: Optional[str] = None):
        """
        :param str action: Currently known and supported values are `dynatrace.automations:http-function`, `dynatrace.automations:run-javascript` and `dynatrace.automations:execute-dql-query`
        :param str name: The name of the task
        :param bool active: Specifies whether a task should be skipped as a no operation or not
        :param str concurrency: Required if `with_items` is specified. By default loops execute sequentially with concurrency set to 1. You can increase how often it runs in parallel
        :param 'AutomationWorkflowTasksTaskConditionsArgs' conditions: Conditions that have to be met in order to execute that task
        :param str description: A description for this task
        :param str input: Parameters and values for this task as JSON code. Contents depend on the kind of task - determined by the attribute `action`
        :param 'AutomationWorkflowTasksTaskPositionArgs' position: Layouting information about the task tile when visualized. If not specified Dynatrace will position the task tiles automatically
        :param 'AutomationWorkflowTasksTaskRetryArgs' retry: Configure whether to automatically rerun the task on failure. If not specified no retries will be attempted
        :param str timeout: Specifies a default task timeout in seconds. 15 * 60 (15min) is used when not set. Minimum 1. Maximum 604800
        :param str with_items: Iterates over items in a list, allowing actions to be executed repeatedly. Example: Specifying `item in [1, 2, 3]` here will execute the task three times for the numbers 1, 2 and 3 - with the current number available for scripting using the expression `{{ _.item }}`
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if concurrency is not None:
            pulumi.set(__self__, "concurrency", concurrency)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if input is not None:
            pulumi.set(__self__, "input", input)
        if position is not None:
            pulumi.set(__self__, "position", position)
        if retry is not None:
            pulumi.set(__self__, "retry", retry)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if with_items is not None:
            pulumi.set(__self__, "with_items", with_items)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Currently known and supported values are `dynatrace.automations:http-function`, `dynatrace.automations:run-javascript` and `dynatrace.automations:execute-dql-query`
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the task
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def active(self) -> Optional[bool]:
        """
        Specifies whether a task should be skipped as a no operation or not
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def concurrency(self) -> Optional[str]:
        """
        Required if `with_items` is specified. By default loops execute sequentially with concurrency set to 1. You can increase how often it runs in parallel
        """
        return pulumi.get(self, "concurrency")

    @property
    @pulumi.getter
    def conditions(self) -> Optional['outputs.AutomationWorkflowTasksTaskConditions']:
        """
        Conditions that have to be met in order to execute that task
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description for this task
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def input(self) -> Optional[str]:
        """
        Parameters and values for this task as JSON code. Contents depend on the kind of task - determined by the attribute `action`
        """
        return pulumi.get(self, "input")

    @property
    @pulumi.getter
    def position(self) -> Optional['outputs.AutomationWorkflowTasksTaskPosition']:
        """
        Layouting information about the task tile when visualized. If not specified Dynatrace will position the task tiles automatically
        """
        return pulumi.get(self, "position")

    @property
    @pulumi.getter
    def retry(self) -> Optional['outputs.AutomationWorkflowTasksTaskRetry']:
        """
        Configure whether to automatically rerun the task on failure. If not specified no retries will be attempted
        """
        return pulumi.get(self, "retry")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        Specifies a default task timeout in seconds. 15 * 60 (15min) is used when not set. Minimum 1. Maximum 604800
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="withItems")
    def with_items(self) -> Optional[str]:
        """
        Iterates over items in a list, allowing actions to be executed repeatedly. Example: Specifying `item in [1, 2, 3]` here will execute the task three times for the numbers 1, 2 and 3 - with the current number available for scripting using the expression `{{ _.item }}`
        """
        return pulumi.get(self, "with_items")


@pulumi.output_type
class AutomationWorkflowTasksTaskConditions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "else":
            suggest = "else_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationWorkflowTasksTaskConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationWorkflowTasksTaskConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationWorkflowTasksTaskConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 states: Mapping[str, str],
                 custom: Optional[str] = None,
                 else_: Optional[str] = None):
        """
        :param Mapping[str, str] states: key/value pairs where the `key` is the name of another task and the value the status it needs to be for the current task to get executed. Possible values are `SUCCESS`, `ERROR`, `ANY`, `OK` (Success or Skipped) and `NOK` (Error or Cancelled)
        :param str custom: A custom condition that needs to be met for the current task to get executed
        :param str else_: Possible values are `SKIP` and `STOP`
        """
        pulumi.set(__self__, "states", states)
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if else_ is not None:
            pulumi.set(__self__, "else_", else_)

    @property
    @pulumi.getter
    def states(self) -> Mapping[str, str]:
        """
        key/value pairs where the `key` is the name of another task and the value the status it needs to be for the current task to get executed. Possible values are `SUCCESS`, `ERROR`, `ANY`, `OK` (Success or Skipped) and `NOK` (Error or Cancelled)
        """
        return pulumi.get(self, "states")

    @property
    @pulumi.getter
    def custom(self) -> Optional[str]:
        """
        A custom condition that needs to be met for the current task to get executed
        """
        return pulumi.get(self, "custom")

    @property
    @pulumi.getter(name="else")
    def else_(self) -> Optional[str]:
        """
        Possible values are `SKIP` and `STOP`
        """
        return pulumi.get(self, "else_")


@pulumi.output_type
class AutomationWorkflowTasksTaskPosition(dict):
    def __init__(__self__, *,
                 x: int,
                 y: int):
        """
        :param int x: x-coordinate for layouting
        :param int y: y-coordinate for layouting
        """
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def x(self) -> int:
        """
        x-coordinate for layouting
        """
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> int:
        """
        y-coordinate for layouting
        """
        return pulumi.get(self, "y")


@pulumi.output_type
class AutomationWorkflowTasksTaskRetry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failedLoopIterationsOnly":
            suggest = "failed_loop_iterations_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationWorkflowTasksTaskRetry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationWorkflowTasksTaskRetry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationWorkflowTasksTaskRetry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[str] = None,
                 delay: Optional[str] = None,
                 failed_loop_iterations_only: Optional[bool] = None):
        """
        :param str count: Specifies a maximum number of times that a task can be repeated in case it fails on execution. You can specify either a number between 1 and 99 here or use an expression (`{{}}`). Default: 1
        :param str delay: Specifies a delay in seconds between subsequent task retries. You can specify either a number between 1 and 3600 here or an expression (`{{...}}`). Default: 1
        :param bool failed_loop_iterations_only: Specifies whether retrying the failed iterations or the whole loop. Default: true
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if failed_loop_iterations_only is not None:
            pulumi.set(__self__, "failed_loop_iterations_only", failed_loop_iterations_only)

    @property
    @pulumi.getter
    def count(self) -> Optional[str]:
        """
        Specifies a maximum number of times that a task can be repeated in case it fails on execution. You can specify either a number between 1 and 99 here or use an expression (`{{}}`). Default: 1
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def delay(self) -> Optional[str]:
        """
        Specifies a delay in seconds between subsequent task retries. You can specify either a number between 1 and 3600 here or an expression (`{{...}}`). Default: 1
        """
        return pulumi.get(self, "delay")

    @property
    @pulumi.getter(name="failedLoopIterationsOnly")
    def failed_loop_iterations_only(self) -> Optional[bool]:
        """
        Specifies whether retrying the failed iterations or the whole loop. Default: true
        """
        return pulumi.get(self, "failed_loop_iterations_only")


@pulumi.output_type
class AutomationWorkflowTrigger(dict):
    def __init__(__self__, *,
                 event: Optional['outputs.AutomationWorkflowTriggerEvent'] = None,
                 schedule: Optional['outputs.AutomationWorkflowTriggerSchedule'] = None):
        """
        :param 'AutomationWorkflowTriggerEventArgs' event: If specified the workflow is getting triggered based on events
        :param 'AutomationWorkflowTriggerScheduleArgs' schedule: If specified the workflow is getting triggered based on a schedule
        """
        if event is not None:
            pulumi.set(__self__, "event", event)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter
    def event(self) -> Optional['outputs.AutomationWorkflowTriggerEvent']:
        """
        If specified the workflow is getting triggered based on events
        """
        return pulumi.get(self, "event")

    @property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.AutomationWorkflowTriggerSchedule']:
        """
        If specified the workflow is getting triggered based on a schedule
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class AutomationWorkflowTriggerEvent(dict):
    def __init__(__self__, *,
                 active: Optional[bool] = None,
                 config: Optional['outputs.AutomationWorkflowTriggerEventConfig'] = None):
        """
        :param bool active: If specified the workflow is getting triggered based on a schedule
        :param 'AutomationWorkflowTriggerEventConfigArgs' config: If specified the workflow is getting triggered based on events
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if config is not None:
            pulumi.set(__self__, "config", config)

    @property
    @pulumi.getter
    def active(self) -> Optional[bool]:
        """
        If specified the workflow is getting triggered based on a schedule
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.AutomationWorkflowTriggerEventConfig']:
        """
        If specified the workflow is getting triggered based on events
        """
        return pulumi.get(self, "config")


@pulumi.output_type
class AutomationWorkflowTriggerEventConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "davisEvent":
            suggest = "davis_event"
        elif key == "davisProblem":
            suggest = "davis_problem"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationWorkflowTriggerEventConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationWorkflowTriggerEventConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationWorkflowTriggerEventConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 davis_event: Optional['outputs.AutomationWorkflowTriggerEventConfigDavisEvent'] = None,
                 davis_problem: Optional['outputs.AutomationWorkflowTriggerEventConfigDavisProblem'] = None,
                 event: Optional['outputs.AutomationWorkflowTriggerEventConfigEvent'] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param 'AutomationWorkflowTriggerEventConfigDavisEventArgs' davis_event: Contains trigger configuration based on Davis Events. Either `davis_event`, `davis_problem`, `davis_event` or `config` need to set
        :param 'AutomationWorkflowTriggerEventConfigDavisProblemArgs' davis_problem: Contains trigger configuration based on Davis Problems. Either `davis_event`, `davis_problem`, `davis_event` or `config` need to set
        :param 'AutomationWorkflowTriggerEventConfigEventArgs' event: Contains trigger configuration based on Davis Problems. Either `davis_event`, `davis_problem`, `davis_event` or `config` need to set
        :param str type: The type of the trigger configuration to expect within attribute `value`. Only required if `config` is set. Must not be set if `davis_event`, `davis_problem` or `event` are present
        :param str value: Contains JSON encoded trigger configuration if the trigger type is neither `davis_event`, `davis_problem` or `event`. It requires the attribute `type` to be set in combination
        """
        if davis_event is not None:
            pulumi.set(__self__, "davis_event", davis_event)
        if davis_problem is not None:
            pulumi.set(__self__, "davis_problem", davis_problem)
        if event is not None:
            pulumi.set(__self__, "event", event)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="davisEvent")
    def davis_event(self) -> Optional['outputs.AutomationWorkflowTriggerEventConfigDavisEvent']:
        """
        Contains trigger configuration based on Davis Events. Either `davis_event`, `davis_problem`, `davis_event` or `config` need to set
        """
        return pulumi.get(self, "davis_event")

    @property
    @pulumi.getter(name="davisProblem")
    def davis_problem(self) -> Optional['outputs.AutomationWorkflowTriggerEventConfigDavisProblem']:
        """
        Contains trigger configuration based on Davis Problems. Either `davis_event`, `davis_problem`, `davis_event` or `config` need to set
        """
        return pulumi.get(self, "davis_problem")

    @property
    @pulumi.getter
    def event(self) -> Optional['outputs.AutomationWorkflowTriggerEventConfigEvent']:
        """
        Contains trigger configuration based on Davis Problems. Either `davis_event`, `davis_problem`, `davis_event` or `config` need to set
        """
        return pulumi.get(self, "event")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the trigger configuration to expect within attribute `value`. Only required if `config` is set. Must not be set if `davis_event`, `davis_problem` or `event` are present
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Contains JSON encoded trigger configuration if the trigger type is neither `davis_event`, `davis_problem` or `event`. It requires the attribute `type` to be set in combination
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutomationWorkflowTriggerEventConfigDavisEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityTags":
            suggest = "entity_tags"
        elif key == "entityTagsMatch":
            suggest = "entity_tags_match"
        elif key == "onProblemClose":
            suggest = "on_problem_close"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationWorkflowTriggerEventConfigDavisEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationWorkflowTriggerEventConfigDavisEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationWorkflowTriggerEventConfigDavisEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 types: Sequence[str],
                 entity_tags: Optional[Mapping[str, str]] = None,
                 entity_tags_match: Optional[str] = None,
                 on_problem_close: Optional[bool] = None):
        """
        :param Sequence[str] types: The types of davis events to trigger an execution. Possible values are `CUSTOM_ANNOTATION`, `APPLICATION_UNEXPECTED_HIGH_LOAD`, `APPLICATION_UNEXPECTED_LOW_LOAD`, `APPLICATION_OVERLOAD_PREVENTION`, `APPLICATION_SLOWDOWN`, `AVAILABILITY_EVENT`, `LOG_AVAILABILITY`, `EC2_HIGH_CPU`, `RDS_BACKUP_COMPLETED`, `RDS_BACKUP_STARTED`, `SYNTHETIC_GLOBAL_OUTAGE`, `SYNTHETIC_LOCAL_OUTAGE`, `SYNTHETIC_TEST_LOCATION_SLOWDOWN`, `CUSTOM_CONFIGURATION`, `PROCESS_NA_HIGH_CONN_FAIL_RATE`, `OSI_HIGH_CPU`, `CUSTOM_ALERT`, `CUSTOM_APP_CRASH_RATE_INCREASED`, `CUSTOM_APPLICATION_ERROR_RATE_INCREASED`, `CUSTOM_APPLICATION_UNEXPECTED_HIGH_LOAD`, `CUSTOM_APPLICATION_UNEXPECTED_LOW_LOAD`, `CUSTOM_APPLICATION_OVERLOAD_PREVENTION`, `CUSTOM_APPLICATION_SLOWDOWN`, `PGI_CUSTOM_AVAILABILITY`, `PGI_CUSTOM_ERROR`, `CUSTOM_INFO`, `PGI_CUSTOM_PERFORMANCE`, `CUSTOM_DEPLOYMENT`, `DEPLOYMENT_CHANGED_CHANGE`, `DEPLOYMENT_CHANGED_NEW`, `DEPLOYMENT_CHANGED_REMOVED`, `EBS_VOLUME_HIGH_LATENCY`, `ERROR_EVENT`, `LOG_ERROR`, `ESXI_HOST_CONNECTION_FAILED`, `ESXI_HOST_CONNECTION_LOST`, `ESXI_GUEST_CPU_LIMIT_REACHED`, `ESXI_GUEST_ACTIVE_SWAP_WAIT`, `ESXI_HOST_CPU_SATURATION`, `ESXI_HOST_MEMORY_SATURATION`, `ESXI_HOST_MAINTENANCE`, `ESXI_HOST_NETWORK_PROBLEMS`, `ESXI_HOST_NO_CONNECTION`, `ESXI_HOST_SHUTDOWN`, `ESXI_HOST_DISK_SLOW`, `ESXI_HOST_UP`, `ESXI_HOST_TIMEOUT`, `ESXI_VM_IMPACT_HOST_CPU_SATURATION`, `ESXI_VM_IMPACT_HOST_MEMORY_SATURATION`, `DATABASE_CONNECTION_FAILURE`, `RDS_AZ_FAILOVER_COMPLETED`, `RDS_AZ_FAILOVER_STARTED`, `SERVICE_ERROR_RATE_INCREASED`, `RDS_HIGH_LATENCY`, `OSI_NIC_UTILIZATION_HIGH`, `OSI_NIC_ERRORS_HIGH`, `PGI_HAPROXY_QUEUED_REQUESTS_HIGH`, `PGI_RMQ_HIGH_FILE_DESC_USAGE`, `PGI_RMQ_HIGH_MEM_USAGE`, `PGI_RMQ_HIGH_PROCESS_USAGE`, `PGI_RMQ_HIGH_SOCKETS_USAGE`, `OSI_NIC_DROPPED_PACKETS_HIGH`, `PGI_MYSQL_SLOW_QUERIES_RATE_HIGH`, `PGI_KEYSTONE_SLOW`, `PGI_HAPROXY_SESSION_USAGE_HIGH`, `HOST_LOG_AVAILABILITY`, `HOST_LOG_ERROR`, `OSI_GRACEFULLY_SHUTDOWN`, `HOST_LOG_MATCHED`, `OSI_UNEXPECTEDLY_UNAVAILABLE`, `HOST_LOG_PERFORMANCE`, `HOST_OF_SERVICE_UNAVAILABLE`, `HTTP_CHECK_GLOBAL_OUTAGE`, `HTTP_CHECK_LOCAL_OUTAGE`, `HTTP_CHECK_TEST_LOCATION_SLOWDOWN`, `ESXI_HOST_DISK_QUEUE_SLOW`, `LOG_MATCHED`, `APPLICATION_ERROR_RATE_INCREASED`, `APPLICATION_JS_FRAMEWORK_DETECTED`, `AWS_LAMBDA_HIGH_ERROR_RATE`, `ELB_HIGH_BACKEND_ERROR_RATE`, `ELB_HIGH_FRONTEND_ERROR_RATE`, `ELB_HIGH_UNHEALTHY_HOST_RATE`, `PROCESS_HIGH_GC_ACTIVITY`, `ESXI_HOST_DATASTORE_LOW_DISK_SPACE`, `OSI_DOCKER_DEVICEMAPPER_LOW_DATA_SPACE`, `OSI_LOW_DISK_SPACE`, `OSI_DOCKER_DEVICEMAPPER_LOW_METADATA_SPACE`, `OSI_DISK_LOW_INODES`, `PGI_RMQ_LOW_DISK_SPACE`, `RDS_LOW_STORAGE_SPACE`, `MARKED_FOR_TERMINATION`, `PROCESS_MEMORY_RESOURCE_EXHAUSTED`, `OSI_HIGH_MEMORY`, `MOBILE_APP_CRASH_RATE_INCREASED`, `MOBILE_APPLICATION_ERROR_RATE_INCREASED`, `MOBILE_APPLICATION_OVERLOAD_PREVENTION`, `MOBILE_APPLICATION_SLOWDOWN`, `MOBILE_APPLICATION_UNEXPECTED_HIGH_LOAD`, `MOBILE_APPLICATION_UNEXPECTED_LOW_LOAD`, `MONITORING_UNAVAILABLE`, `PROCESS_NA_HIGH_LOSS_RATE`, `PGI_KEYSTONE_UNHEALTHY`, `ESXI_HOST_OVERLOADED_STORAGE`, `PERFORMANCE_EVENT`, `LOG_PERFORMANCE`, `PGI_LOG_AVAILABILITY`, `PGI_CRASHED_INFO`, `PROCESS_CRASHED`, `PGI_LOG_ERROR`, `PG_LOW_INSTANCE_COUNT`, `PGI_LOG_MATCHED`, `PGI_MEMDUMP`, `PGI_LOG_PERFORMANCE`, `PROCESS_RESTART`, `PGI_UNAVAILABLE`, `RDS_HIGH_CPU`, `RDS_LOW_MEMORY`, `RDS_OF_SERVICE_UNAVAILABLE`, `RESOURCE_CONTENTION_EVENT`, `SERVICE_SLOWDOWN`, `RDS_RESTART`, `RDS_RESTART_SEQUENCE`, `PGI_OF_SERVICE_UNAVAILABLE`, `OSI_SLOW_DISK`, `SYNTHETIC_NODE_OUTAGE`, `SYNTHETIC_PRIVATE_LOCATION_OUTAGE`, `EXTERNAL_SYNTHETIC_TEST_OUTAGE`, `EXTERNAL_SYNTHETIC_TEST_SLOWDOWN`, `PROCESS_THREADS_RESOURCE_EXHAUSTED`, `SERVICE_UNEXPECTED_HIGH_LOAD`, `SERVICE_UNEXPECTED_LOW_LOAD`, `ESXI_VM_DISCONNECTED`, `OPENSTACK_VM_LAUNCH_FAILED`, `ESXI_HOST_VM_MOTION_LEFT`, `ESXI_HOST_VM_MOTION_ARRIVED`, `ESXI_VM_MOTION`, `OPENSTACK_VM_MOTION`, `ESXI_VM_POWER_OFF`, `ESXI_VM_SHUTDOWN`, `OPENSTACK_HOST_VM_SHUTDOWN`, `ESXI_VM_START`, `ESXI_HOST_VM_STARTED`, `OPENSTACK_HOST_VM_STARTED`
        :param Mapping[str, str] entity_tags: key/value pairs for entity tags to match for. For tags that don't require a value, just specify an empty string as value. Omit this attribute if all entities should match
        :param str entity_tags_match: Specifies whether all or just any of the configured entity tags need to match. Possible values: `all` and `any`. Omit this attribute if all entities should match
        :param bool on_problem_close: If set to `true` closing a problem also is considered an event that triggers the execution
        """
        pulumi.set(__self__, "types", types)
        if entity_tags is not None:
            pulumi.set(__self__, "entity_tags", entity_tags)
        if entity_tags_match is not None:
            pulumi.set(__self__, "entity_tags_match", entity_tags_match)
        if on_problem_close is not None:
            pulumi.set(__self__, "on_problem_close", on_problem_close)

    @property
    @pulumi.getter
    def types(self) -> Sequence[str]:
        """
        The types of davis events to trigger an execution. Possible values are `CUSTOM_ANNOTATION`, `APPLICATION_UNEXPECTED_HIGH_LOAD`, `APPLICATION_UNEXPECTED_LOW_LOAD`, `APPLICATION_OVERLOAD_PREVENTION`, `APPLICATION_SLOWDOWN`, `AVAILABILITY_EVENT`, `LOG_AVAILABILITY`, `EC2_HIGH_CPU`, `RDS_BACKUP_COMPLETED`, `RDS_BACKUP_STARTED`, `SYNTHETIC_GLOBAL_OUTAGE`, `SYNTHETIC_LOCAL_OUTAGE`, `SYNTHETIC_TEST_LOCATION_SLOWDOWN`, `CUSTOM_CONFIGURATION`, `PROCESS_NA_HIGH_CONN_FAIL_RATE`, `OSI_HIGH_CPU`, `CUSTOM_ALERT`, `CUSTOM_APP_CRASH_RATE_INCREASED`, `CUSTOM_APPLICATION_ERROR_RATE_INCREASED`, `CUSTOM_APPLICATION_UNEXPECTED_HIGH_LOAD`, `CUSTOM_APPLICATION_UNEXPECTED_LOW_LOAD`, `CUSTOM_APPLICATION_OVERLOAD_PREVENTION`, `CUSTOM_APPLICATION_SLOWDOWN`, `PGI_CUSTOM_AVAILABILITY`, `PGI_CUSTOM_ERROR`, `CUSTOM_INFO`, `PGI_CUSTOM_PERFORMANCE`, `CUSTOM_DEPLOYMENT`, `DEPLOYMENT_CHANGED_CHANGE`, `DEPLOYMENT_CHANGED_NEW`, `DEPLOYMENT_CHANGED_REMOVED`, `EBS_VOLUME_HIGH_LATENCY`, `ERROR_EVENT`, `LOG_ERROR`, `ESXI_HOST_CONNECTION_FAILED`, `ESXI_HOST_CONNECTION_LOST`, `ESXI_GUEST_CPU_LIMIT_REACHED`, `ESXI_GUEST_ACTIVE_SWAP_WAIT`, `ESXI_HOST_CPU_SATURATION`, `ESXI_HOST_MEMORY_SATURATION`, `ESXI_HOST_MAINTENANCE`, `ESXI_HOST_NETWORK_PROBLEMS`, `ESXI_HOST_NO_CONNECTION`, `ESXI_HOST_SHUTDOWN`, `ESXI_HOST_DISK_SLOW`, `ESXI_HOST_UP`, `ESXI_HOST_TIMEOUT`, `ESXI_VM_IMPACT_HOST_CPU_SATURATION`, `ESXI_VM_IMPACT_HOST_MEMORY_SATURATION`, `DATABASE_CONNECTION_FAILURE`, `RDS_AZ_FAILOVER_COMPLETED`, `RDS_AZ_FAILOVER_STARTED`, `SERVICE_ERROR_RATE_INCREASED`, `RDS_HIGH_LATENCY`, `OSI_NIC_UTILIZATION_HIGH`, `OSI_NIC_ERRORS_HIGH`, `PGI_HAPROXY_QUEUED_REQUESTS_HIGH`, `PGI_RMQ_HIGH_FILE_DESC_USAGE`, `PGI_RMQ_HIGH_MEM_USAGE`, `PGI_RMQ_HIGH_PROCESS_USAGE`, `PGI_RMQ_HIGH_SOCKETS_USAGE`, `OSI_NIC_DROPPED_PACKETS_HIGH`, `PGI_MYSQL_SLOW_QUERIES_RATE_HIGH`, `PGI_KEYSTONE_SLOW`, `PGI_HAPROXY_SESSION_USAGE_HIGH`, `HOST_LOG_AVAILABILITY`, `HOST_LOG_ERROR`, `OSI_GRACEFULLY_SHUTDOWN`, `HOST_LOG_MATCHED`, `OSI_UNEXPECTEDLY_UNAVAILABLE`, `HOST_LOG_PERFORMANCE`, `HOST_OF_SERVICE_UNAVAILABLE`, `HTTP_CHECK_GLOBAL_OUTAGE`, `HTTP_CHECK_LOCAL_OUTAGE`, `HTTP_CHECK_TEST_LOCATION_SLOWDOWN`, `ESXI_HOST_DISK_QUEUE_SLOW`, `LOG_MATCHED`, `APPLICATION_ERROR_RATE_INCREASED`, `APPLICATION_JS_FRAMEWORK_DETECTED`, `AWS_LAMBDA_HIGH_ERROR_RATE`, `ELB_HIGH_BACKEND_ERROR_RATE`, `ELB_HIGH_FRONTEND_ERROR_RATE`, `ELB_HIGH_UNHEALTHY_HOST_RATE`, `PROCESS_HIGH_GC_ACTIVITY`, `ESXI_HOST_DATASTORE_LOW_DISK_SPACE`, `OSI_DOCKER_DEVICEMAPPER_LOW_DATA_SPACE`, `OSI_LOW_DISK_SPACE`, `OSI_DOCKER_DEVICEMAPPER_LOW_METADATA_SPACE`, `OSI_DISK_LOW_INODES`, `PGI_RMQ_LOW_DISK_SPACE`, `RDS_LOW_STORAGE_SPACE`, `MARKED_FOR_TERMINATION`, `PROCESS_MEMORY_RESOURCE_EXHAUSTED`, `OSI_HIGH_MEMORY`, `MOBILE_APP_CRASH_RATE_INCREASED`, `MOBILE_APPLICATION_ERROR_RATE_INCREASED`, `MOBILE_APPLICATION_OVERLOAD_PREVENTION`, `MOBILE_APPLICATION_SLOWDOWN`, `MOBILE_APPLICATION_UNEXPECTED_HIGH_LOAD`, `MOBILE_APPLICATION_UNEXPECTED_LOW_LOAD`, `MONITORING_UNAVAILABLE`, `PROCESS_NA_HIGH_LOSS_RATE`, `PGI_KEYSTONE_UNHEALTHY`, `ESXI_HOST_OVERLOADED_STORAGE`, `PERFORMANCE_EVENT`, `LOG_PERFORMANCE`, `PGI_LOG_AVAILABILITY`, `PGI_CRASHED_INFO`, `PROCESS_CRASHED`, `PGI_LOG_ERROR`, `PG_LOW_INSTANCE_COUNT`, `PGI_LOG_MATCHED`, `PGI_MEMDUMP`, `PGI_LOG_PERFORMANCE`, `PROCESS_RESTART`, `PGI_UNAVAILABLE`, `RDS_HIGH_CPU`, `RDS_LOW_MEMORY`, `RDS_OF_SERVICE_UNAVAILABLE`, `RESOURCE_CONTENTION_EVENT`, `SERVICE_SLOWDOWN`, `RDS_RESTART`, `RDS_RESTART_SEQUENCE`, `PGI_OF_SERVICE_UNAVAILABLE`, `OSI_SLOW_DISK`, `SYNTHETIC_NODE_OUTAGE`, `SYNTHETIC_PRIVATE_LOCATION_OUTAGE`, `EXTERNAL_SYNTHETIC_TEST_OUTAGE`, `EXTERNAL_SYNTHETIC_TEST_SLOWDOWN`, `PROCESS_THREADS_RESOURCE_EXHAUSTED`, `SERVICE_UNEXPECTED_HIGH_LOAD`, `SERVICE_UNEXPECTED_LOW_LOAD`, `ESXI_VM_DISCONNECTED`, `OPENSTACK_VM_LAUNCH_FAILED`, `ESXI_HOST_VM_MOTION_LEFT`, `ESXI_HOST_VM_MOTION_ARRIVED`, `ESXI_VM_MOTION`, `OPENSTACK_VM_MOTION`, `ESXI_VM_POWER_OFF`, `ESXI_VM_SHUTDOWN`, `OPENSTACK_HOST_VM_SHUTDOWN`, `ESXI_VM_START`, `ESXI_HOST_VM_STARTED`, `OPENSTACK_HOST_VM_STARTED`
        """
        return pulumi.get(self, "types")

    @property
    @pulumi.getter(name="entityTags")
    def entity_tags(self) -> Optional[Mapping[str, str]]:
        """
        key/value pairs for entity tags to match for. For tags that don't require a value, just specify an empty string as value. Omit this attribute if all entities should match
        """
        return pulumi.get(self, "entity_tags")

    @property
    @pulumi.getter(name="entityTagsMatch")
    def entity_tags_match(self) -> Optional[str]:
        """
        Specifies whether all or just any of the configured entity tags need to match. Possible values: `all` and `any`. Omit this attribute if all entities should match
        """
        return pulumi.get(self, "entity_tags_match")

    @property
    @pulumi.getter(name="onProblemClose")
    def on_problem_close(self) -> Optional[bool]:
        """
        If set to `true` closing a problem also is considered an event that triggers the execution
        """
        return pulumi.get(self, "on_problem_close")


@pulumi.output_type
class AutomationWorkflowTriggerEventConfigDavisProblem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customFilter":
            suggest = "custom_filter"
        elif key == "entityTags":
            suggest = "entity_tags"
        elif key == "entityTagsMatch":
            suggest = "entity_tags_match"
        elif key == "onProblemClose":
            suggest = "on_problem_close"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationWorkflowTriggerEventConfigDavisProblem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationWorkflowTriggerEventConfigDavisProblem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationWorkflowTriggerEventConfigDavisProblem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 categories: Sequence['outputs.AutomationWorkflowTriggerEventConfigDavisProblemCategory'],
                 custom_filter: Optional[str] = None,
                 entity_tags: Optional[Mapping[str, str]] = None,
                 entity_tags_match: Optional[str] = None,
                 on_problem_close: Optional[bool] = None):
        """
        :param Mapping[str, str] entity_tags: key/value pairs for entity tags to match for. For tags that don't require a value, just specify an empty string as value. Omit this attribute if all entities should match
        :param str entity_tags_match: Specifies whether all or just any of the configured entity tags need to match. Possible values: `all` and `any`. Omit this attribute if all entities should match
        :param bool on_problem_close: If set to `true` closing a problem also is considered an event that triggers the execution
        """
        pulumi.set(__self__, "categories", categories)
        if custom_filter is not None:
            pulumi.set(__self__, "custom_filter", custom_filter)
        if entity_tags is not None:
            pulumi.set(__self__, "entity_tags", entity_tags)
        if entity_tags_match is not None:
            pulumi.set(__self__, "entity_tags_match", entity_tags_match)
        if on_problem_close is not None:
            pulumi.set(__self__, "on_problem_close", on_problem_close)

    @property
    @pulumi.getter
    def categories(self) -> Sequence['outputs.AutomationWorkflowTriggerEventConfigDavisProblemCategory']:
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter(name="customFilter")
    def custom_filter(self) -> Optional[str]:
        return pulumi.get(self, "custom_filter")

    @property
    @pulumi.getter(name="entityTags")
    def entity_tags(self) -> Optional[Mapping[str, str]]:
        """
        key/value pairs for entity tags to match for. For tags that don't require a value, just specify an empty string as value. Omit this attribute if all entities should match
        """
        return pulumi.get(self, "entity_tags")

    @property
    @pulumi.getter(name="entityTagsMatch")
    def entity_tags_match(self) -> Optional[str]:
        """
        Specifies whether all or just any of the configured entity tags need to match. Possible values: `all` and `any`. Omit this attribute if all entities should match
        """
        return pulumi.get(self, "entity_tags_match")

    @property
    @pulumi.getter(name="onProblemClose")
    def on_problem_close(self) -> Optional[bool]:
        """
        If set to `true` closing a problem also is considered an event that triggers the execution
        """
        return pulumi.get(self, "on_problem_close")


@pulumi.output_type
class AutomationWorkflowTriggerEventConfigDavisProblemCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitoringUnavailable":
            suggest = "monitoring_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationWorkflowTriggerEventConfigDavisProblemCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationWorkflowTriggerEventConfigDavisProblemCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationWorkflowTriggerEventConfigDavisProblemCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[bool] = None,
                 custom: Optional[bool] = None,
                 error: Optional[bool] = None,
                 info: Optional[bool] = None,
                 monitoring_unavailable: Optional[bool] = None,
                 resource: Optional[bool] = None,
                 slowdown: Optional[bool] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if info is not None:
            pulumi.set(__self__, "info", info)
        if monitoring_unavailable is not None:
            pulumi.set(__self__, "monitoring_unavailable", monitoring_unavailable)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if slowdown is not None:
            pulumi.set(__self__, "slowdown", slowdown)

    @property
    @pulumi.getter
    def availability(self) -> Optional[bool]:
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter
    def custom(self) -> Optional[bool]:
        return pulumi.get(self, "custom")

    @property
    @pulumi.getter
    def error(self) -> Optional[bool]:
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def info(self) -> Optional[bool]:
        return pulumi.get(self, "info")

    @property
    @pulumi.getter(name="monitoringUnavailable")
    def monitoring_unavailable(self) -> Optional[bool]:
        return pulumi.get(self, "monitoring_unavailable")

    @property
    @pulumi.getter
    def resource(self) -> Optional[bool]:
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def slowdown(self) -> Optional[bool]:
        return pulumi.get(self, "slowdown")


@pulumi.output_type
class AutomationWorkflowTriggerEventConfigEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationWorkflowTriggerEventConfigEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationWorkflowTriggerEventConfigEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationWorkflowTriggerEventConfigEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 event_type: Optional[str] = None):
        """
        :param str query: A query based on DQL for events that trigger executions
        :param str event_type: Possible values: `events` or `bizevents`. Default: `events`
        """
        pulumi.set(__self__, "query", query)
        if event_type is not None:
            pulumi.set(__self__, "event_type", event_type)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        A query based on DQL for events that trigger executions
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional[str]:
        """
        Possible values: `events` or `bizevents`. Default: `events`
        """
        return pulumi.get(self, "event_type")


@pulumi.output_type
class AutomationWorkflowTriggerSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterParameters":
            suggest = "filter_parameters"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationWorkflowTriggerSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationWorkflowTriggerSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationWorkflowTriggerSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trigger: 'outputs.AutomationWorkflowTriggerScheduleTrigger',
                 active: Optional[bool] = None,
                 filter_parameters: Optional['outputs.AutomationWorkflowTriggerScheduleFilterParameters'] = None,
                 rule: Optional[str] = None,
                 time_zone: Optional[str] = None):
        """
        :param 'AutomationWorkflowTriggerScheduleTriggerArgs' trigger: Detailed configuration about the timing constraints that trigger the execution
        :param bool active: The trigger is enabled (`true`) or not (`false`). Default is `false`
        :param 'AutomationWorkflowTriggerScheduleFilterParametersArgs' filter_parameters: Advanced restrictions for the schedule to trigger executions
        :param str rule: Refers to a configured rule that determines at which days the schedule should be active. If not specified it implies that the schedule is valid every day
        :param str time_zone: A time zone the scheduled times to align with. If not specified it will be chosen automatically based on the location of the Dynatrace Server
        """
        pulumi.set(__self__, "trigger", trigger)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if filter_parameters is not None:
            pulumi.set(__self__, "filter_parameters", filter_parameters)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def trigger(self) -> 'outputs.AutomationWorkflowTriggerScheduleTrigger':
        """
        Detailed configuration about the timing constraints that trigger the execution
        """
        return pulumi.get(self, "trigger")

    @property
    @pulumi.getter
    def active(self) -> Optional[bool]:
        """
        The trigger is enabled (`true`) or not (`false`). Default is `false`
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="filterParameters")
    def filter_parameters(self) -> Optional['outputs.AutomationWorkflowTriggerScheduleFilterParameters']:
        """
        Advanced restrictions for the schedule to trigger executions
        """
        return pulumi.get(self, "filter_parameters")

    @property
    @pulumi.getter
    def rule(self) -> Optional[str]:
        """
        Refers to a configured rule that determines at which days the schedule should be active. If not specified it implies that the schedule is valid every day
        """
        return pulumi.get(self, "rule")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        A time zone the scheduled times to align with. If not specified it will be chosen automatically based on the location of the Dynatrace Server
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class AutomationWorkflowTriggerScheduleFilterParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "earliestStart":
            suggest = "earliest_start"
        elif key == "earliestStartTime":
            suggest = "earliest_start_time"
        elif key == "excludeDates":
            suggest = "exclude_dates"
        elif key == "includeDates":
            suggest = "include_dates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationWorkflowTriggerScheduleFilterParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationWorkflowTriggerScheduleFilterParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationWorkflowTriggerScheduleFilterParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[int] = None,
                 earliest_start: Optional[str] = None,
                 earliest_start_time: Optional[str] = None,
                 exclude_dates: Optional[Sequence[str]] = None,
                 include_dates: Optional[Sequence[str]] = None,
                 until: Optional[str] = None):
        """
        :param int count: If specified, the schedule will end triggering executions af the given amount of executions. Minimum: 1, Maximum: 10
        :param str earliest_start: If specified, the schedule won't trigger executions before the given date
        :param str earliest_start_time: If specified, the schedule won't trigger executions before the given time
        :param Sequence[str] exclude_dates: If specified, the schedule won't trigger exeuctions on the given dates
        :param Sequence[str] include_dates: If specified, the schedule will trigger executions on the given dates, even if the main configuration prohibits it
        :param str until: If specified, the schedule won't trigger executions after the given date
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if earliest_start is not None:
            pulumi.set(__self__, "earliest_start", earliest_start)
        if earliest_start_time is not None:
            pulumi.set(__self__, "earliest_start_time", earliest_start_time)
        if exclude_dates is not None:
            pulumi.set(__self__, "exclude_dates", exclude_dates)
        if include_dates is not None:
            pulumi.set(__self__, "include_dates", include_dates)
        if until is not None:
            pulumi.set(__self__, "until", until)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        If specified, the schedule will end triggering executions af the given amount of executions. Minimum: 1, Maximum: 10
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="earliestStart")
    def earliest_start(self) -> Optional[str]:
        """
        If specified, the schedule won't trigger executions before the given date
        """
        return pulumi.get(self, "earliest_start")

    @property
    @pulumi.getter(name="earliestStartTime")
    def earliest_start_time(self) -> Optional[str]:
        """
        If specified, the schedule won't trigger executions before the given time
        """
        return pulumi.get(self, "earliest_start_time")

    @property
    @pulumi.getter(name="excludeDates")
    def exclude_dates(self) -> Optional[Sequence[str]]:
        """
        If specified, the schedule won't trigger exeuctions on the given dates
        """
        return pulumi.get(self, "exclude_dates")

    @property
    @pulumi.getter(name="includeDates")
    def include_dates(self) -> Optional[Sequence[str]]:
        """
        If specified, the schedule will trigger executions on the given dates, even if the main configuration prohibits it
        """
        return pulumi.get(self, "include_dates")

    @property
    @pulumi.getter
    def until(self) -> Optional[str]:
        """
        If specified, the schedule won't trigger executions after the given date
        """
        return pulumi.get(self, "until")


@pulumi.output_type
class AutomationWorkflowTriggerScheduleTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "betweenEnd":
            suggest = "between_end"
        elif key == "betweenStart":
            suggest = "between_start"
        elif key == "intervalMinutes":
            suggest = "interval_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationWorkflowTriggerScheduleTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationWorkflowTriggerScheduleTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationWorkflowTriggerScheduleTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 between_end: Optional[str] = None,
                 between_start: Optional[str] = None,
                 cron: Optional[str] = None,
                 interval_minutes: Optional[int] = None,
                 time: Optional[str] = None):
        """
        :param str between_end: Triggers the schedule every n minutes within a given time frame - specifying the end time on any valid day in 24h format (e.g. 14:22:44). Conflicts with `cron` and `time`. Required with `interval_minutes` and `between_start`
        :param str between_start: Triggers the schedule every n minutes within a given time frame - specifying the start time on any valid day in 24h format (e.g. 13:22:44). Conflicts with `cron` and `time`. Required with `interval_minutes` and `between_end`
        :param str cron: Configures using cron syntax. Conflicts with `time`, `interval_minutes`, `between_start` and `between_end`
        :param int interval_minutes: Triggers the schedule every n minutes within a given time frame. Minimum: 1, Maximum: 720. Required with `between_start` and `between_end`. Conflicts with `cron` and `time`
        :param str time: Specifies a fixed time the schedule will trigger at in 24h format (e.g. `14:23:59`). Conflicts with `cron`, `interval_minutes`, `between_start` and `between_end`
        """
        if between_end is not None:
            pulumi.set(__self__, "between_end", between_end)
        if between_start is not None:
            pulumi.set(__self__, "between_start", between_start)
        if cron is not None:
            pulumi.set(__self__, "cron", cron)
        if interval_minutes is not None:
            pulumi.set(__self__, "interval_minutes", interval_minutes)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="betweenEnd")
    def between_end(self) -> Optional[str]:
        """
        Triggers the schedule every n minutes within a given time frame - specifying the end time on any valid day in 24h format (e.g. 14:22:44). Conflicts with `cron` and `time`. Required with `interval_minutes` and `between_start`
        """
        return pulumi.get(self, "between_end")

    @property
    @pulumi.getter(name="betweenStart")
    def between_start(self) -> Optional[str]:
        """
        Triggers the schedule every n minutes within a given time frame - specifying the start time on any valid day in 24h format (e.g. 13:22:44). Conflicts with `cron` and `time`. Required with `interval_minutes` and `between_end`
        """
        return pulumi.get(self, "between_start")

    @property
    @pulumi.getter
    def cron(self) -> Optional[str]:
        """
        Configures using cron syntax. Conflicts with `time`, `interval_minutes`, `between_start` and `between_end`
        """
        return pulumi.get(self, "cron")

    @property
    @pulumi.getter(name="intervalMinutes")
    def interval_minutes(self) -> Optional[int]:
        """
        Triggers the schedule every n minutes within a given time frame. Minimum: 1, Maximum: 720. Required with `between_start` and `between_end`. Conflicts with `cron` and `time`
        """
        return pulumi.get(self, "interval_minutes")

    @property
    @pulumi.getter
    def time(self) -> Optional[str]:
        """
        Specifies a fixed time the schedule will trigger at in 24h format (e.g. `14:23:59`). Conflicts with `cron`, `interval_minutes`, `between_start` and `between_end`
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class AutotagEntitySelectorBasedRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagEntitySelectorBasedRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagEntitySelectorBasedRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagEntitySelectorBasedRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 normalization: Optional[str] = None,
                 selector: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value_format: Optional[str] = None):
        """
        :param bool enabled: The rule is enabled (`true`) or disabled (`false`)
        :param str normalization: Changes applied to the value after applying the value format. Possible values are `LEAVE_TEXT_AS_IS`, `TO_LOWER_CASE` and `TO_UPPER_CASE`. Default is `LEAVE_TEXT_AS_IS`
        :param str selector: The entity selector string, by which the entities are selected
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value_format: The value of the entity-selector-based auto-tag. If specified, the tag is used in the `name:valueFormat` format. 
               
               For example, you can extend the `Infrastructure` tag to `Infrastructure:Windows` and `Infrastructure:Linux`
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if normalization is not None:
            pulumi.set(__self__, "normalization", normalization)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        The rule is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def normalization(self) -> Optional[str]:
        """
        Changes applied to the value after applying the value format. Possible values are `LEAVE_TEXT_AS_IS`, `TO_LOWER_CASE` and `TO_UPPER_CASE`. Default is `LEAVE_TEXT_AS_IS`
        """
        return pulumi.get(self, "normalization")

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        """
        The entity selector string, by which the entities are selected
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[str]:
        """
        The value of the entity-selector-based auto-tag. If specified, the tag is used in the `name:valueFormat` format. 

        For example, you can extend the `Infrastructure` tag to `Infrastructure:Windows` and `Infrastructure:Linux`
        """
        return pulumi.get(self, "value_format")


@pulumi.output_type
class AutotagRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propagationTypes":
            suggest = "propagation_types"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.AutotagRuleCondition']] = None,
                 enabled: Optional[bool] = None,
                 normalization: Optional[str] = None,
                 propagation_types: Optional[Sequence[str]] = None,
                 unknowns: Optional[str] = None,
                 value_format: Optional[str] = None):
        """
        :param str type: The type of Dynatrace entities the management zone can be applied to
        :param Sequence['AutotagRuleConditionArgs'] conditions: A list of matching rules for the management zone. The management zone applies only if **all** conditions are fulfilled
        :param bool enabled: The rule is enabled (`true`) or disabled (`false`)
        :param str normalization: Changes applied to the value after applying the value format. Possible values are `LEAVE_TEXT_AS_IS`, `TO_LOWER_CASE` and `TO_UPPER_CASE`. Default is `LEAVE_TEXT_AS_IS`
        :param Sequence[str] propagation_types: How to apply the management zone to underlying entities:
                  - `SERVICE_TO_HOST_LIKE`: Apply to underlying hosts of matching services
                  - `SERVICE_TO_PROCESS_GROUP_LIKE`: Apply to underlying process groups of matching services
                  - `PROCESS_GROUP_TO_HOST`: Apply to underlying hosts of matching process groups
                  - `PROCESS_GROUP_TO_SERVICE`: Apply to all services provided by matching process groups
                  - `HOST_TO_PROCESS_GROUP_INSTANCE`: Apply to processes running on matching hosts
                  - `CUSTOM_DEVICE_GROUP_TO_CUSTOM_DEVICE`: Apply to custom devices in matching custom device groups
                  - `AZURE_TO_PG`: Apply to process groups connected to matching Azure entities
                  - `AZURE_TO_SERVICE`: Apply to services provided by matching Azure entities
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value_format: The value of the auto-tag. If specified, the tag is used in the `name:valueFormat` format.  For example, you can extend the `Infrastructure` tag to `Infrastructure:Windows` and `Infrastructure:Linux`.  You can use the following placeholders here:  * `{AwsAutoScalingGroup:Name}`  * `{AwsAvailabilityZone:Name}`  * `{AwsElasticLoadBalancer:Name}`  * `{AwsRelationalDatabaseService:DBName}`  * `{AwsRelationalDatabaseService:Endpoint}`  * `{AwsRelationalDatabaseService:Engine}`  * `{AwsRelationalDatabaseService:InstanceClass}`  * `{AwsRelationalDatabaseService:Name}`  * `{AwsRelationalDatabaseService:Port}`  * `{AzureRegion:Name}`  * `{AzureScaleSet:Name}`  * `{AzureVm:Name}`  * `{CloudFoundryOrganization:Name}`  * `{CustomDevice:DetectedName}`  * `{CustomDevice:DnsName}`  * `{CustomDevice:IpAddress}`  * `{CustomDevice:Port}`  * `{DockerContainerGroupInstance:ContainerName}`  * `{DockerContainerGroupInstance:FullImageName}`  * `{DockerContainerGroupInstance:ImageVersion}`  * `{DockerContainerGroupInstance:StrippedImageName}`  * `{ESXIHost:HardwareModel}`  * `{ESXIHost:HardwareVendor}`  * `{ESXIHost:Name}`  * `{ESXIHost:ProductName}`  * `{ESXIHost:ProductVersion}`  * `{Ec2Instance:AmiId}`  * `{Ec2Instance:BeanstalkEnvironmentName}`  * `{Ec2Instance:InstanceId}`  * `{Ec2Instance:InstanceType}`  * `{Ec2Instance:LocalHostName}`  * `{Ec2Instance:Name}`  * `{Ec2Instance:PublicHostName}`  * `{Ec2Instance:SecurityGroup}`  * `{GoogleComputeInstance:Id}`  * `{GoogleComputeInstance:IpAddresses}`  * `{GoogleComputeInstance:MachineType}`  * `{GoogleComputeInstance:Name}`  * `{GoogleComputeInstance:ProjectId}`  * `{GoogleComputeInstance:Project}`  * `{Host:AWSNameTag}`  * `{Host:AixLogicalCpuCount}`  * `{Host:AzureHostName}`  * `{Host:AzureSiteName}`  * `{Host:BoshDeploymentId}`  * `{Host:BoshInstanceId}`  * `{Host:BoshInstanceName}`  * `{Host:BoshName}`  * `{Host:BoshStemcellVersion}`  * `{Host:CpuCores}`  * `{Host:DetectedName}`  * `{Host:Environment:AppName}`  * `{Host:Environment:BoshReleaseVersion}`  * `{Host:Environment:Environment}`  * `{Host:Environment:Link}`  * `{Host:Environment:Organization}`  * `{Host:Environment:Owner}`  * `{Host:Environment:Support}`  * `{Host:IpAddress}`  * `{Host:LogicalCpuCores}`  * `{Host:OneAgentCustomHostName}`  * `{Host:OperatingSystemVersion}`  * `{Host:PaasMemoryLimit}`  * `{HostGroup:Name}`  * `{KubernetesCluster:Name}`  * `{KubernetesNode:DetectedName}`  * `{OpenstackAvailabilityZone:Name}`  * `{OpenstackZone:Name}`  * `{OpenstackComputeNode:Name}`  * `{OpenstackProject:Name}`  * `{OpenstackVm:UnstanceType}`  * `{OpenstackVm:Name}`  * `{OpenstackVm:SecurityGroup}`  * `{ProcessGroup:AmazonECRImageAccountId}`  * `{ProcessGroup:AmazonECRImageRegion}`  * `{ProcessGroup:AmazonECSCluster}`  * `{ProcessGroup:AmazonECSContainerName}`  * `{ProcessGroup:AmazonECSFamily}`  * `{ProcessGroup:AmazonECSRevision}`  * `{ProcessGroup:AmazonLambdaFunctionName}`  * `{ProcessGroup:AmazonRegion}`  * `{ProcessGroup:ApacheConfigPath}`  * `{ProcessGroup:ApacheSparkMasterIpAddress}`  * `{ProcessGroup:AspDotNetCoreApplicationPath}`  * `{ProcessGroup:AspDotNetCoreApplicationPath}`  * `{ProcessGroup:AzureHostName}`  * `{ProcessGroup:AzureSiteName}`  * `{ProcessGroup:CassandraClusterName}`  * `{ProcessGroup:CatalinaBase}`  * `{ProcessGroup:CatalinaHome}`  * `{ProcessGroup:CloudFoundryAppId}`  * `{ProcessGroup:CloudFoundryAppName}`  * `{ProcessGroup:CloudFoundryInstanceIndex}`  * `{ProcessGroup:CloudFoundrySpaceId}`  * `{ProcessGroup:CloudFoundrySpaceName}`  * `{ProcessGroup:ColdFusionJvmConfigFile}`  * `{ProcessGroup:ColdFusionServiceName}`  * `{ProcessGroup:CommandLineArgs}`  * `{ProcessGroup:DetectedName}`  * `{ProcessGroup:DotNetCommandPath}`  * `{ProcessGroup:DotNetCommand}`  * `{ProcessGroup:DotNetClusterId}`  * `{ProcessGroup:DotNetNodeId}`  * `{ProcessGroup:ElasticsearchClusterName}`  * `{ProcessGroup:ElasticsearchNodeName}`  * `{ProcessGroup:EquinoxConfigPath}`  * `{ProcessGroup:ExeName}`  * `{ProcessGroup:ExePath}`  * `{ProcessGroup:GlassFishDomainName}`  * `{ProcessGroup:GlassFishInstanceName}`  * `{ProcessGroup:GoogleAppEngineInstance}`  * `{ProcessGroup:GoogleAppEngineService}`  * `{ProcessGroup:GoogleCloudProject}`  * `{ProcessGroup:HybrisBinDirectory}`  * `{ProcessGroup:HybrisConfigDirectory}`  * `{ProcessGroup:HybrisConfigDirectory}`  * `{ProcessGroup:HybrisDataDirectory}`  * `{ProcessGroup:IBMCicsRegion}`  * `{ProcessGroup:IBMCtgName}`  * `{ProcessGroup:IBMImsConnectRegion}`  * `{ProcessGroup:IBMImsControlRegion}`  * `{ProcessGroup:IBMImsMessageProcessingRegion}`  * `{ProcessGroup:IBMImsSoapGwName}`  * `{ProcessGroup:IBMIntegrationNodeName}`  * `{ProcessGroup:IBMIntegrationServerName}`  * `{ProcessGroup:IISAppPool}`  * `{ProcessGroup:IISRoleName}`  * `{ProcessGroup:JbossHome}`  * `{ProcessGroup:JbossMode}`  * `{ProcessGroup:JbossServerName}`  * `{ProcessGroup:JavaJarFile}`  * `{ProcessGroup:JavaJarPath}`  * `{ProcessGroup:JavaMainCLass}`  * `{ProcessGroup:KubernetesBasePodName}`  * `{ProcessGroup:KubernetesContainerName}`  * `{ProcessGroup:KubernetesFullPodName}`  * `{ProcessGroup:KubernetesNamespace}`  * `{ProcessGroup:KubernetesPodUid}`  * `{ProcessGroup:MssqlInstanceName}`  * `{ProcessGroup:NodeJsAppBaseDirectory}`  * `{ProcessGroup:NodeJsAppName}`  * `{ProcessGroup:NodeJsScriptName}`  * `{ProcessGroup:OracleSid}`  * `{ProcessGroup:PHPScriptPath}`  * `{ProcessGroup:PHPWorkingDirectory}`  * `{ProcessGroup:Ports}`  * `{ProcessGroup:RubyAppRootPath}`  * `{ProcessGroup:RubyScriptPath}`  * `{ProcessGroup:SoftwareAGInstallRoot}`  * `{ProcessGroup:SoftwareAGProductPropertyName}`  * `{ProcessGroup:SpringBootAppName}`  * `{ProcessGroup:SpringBootProfileName}`  * `{ProcessGroup:SpringBootStartupClass}`  * `{ProcessGroup:TIBCOBusinessWorksAppNodeName}`  * `{ProcessGroup:TIBCOBusinessWorksAppSpaceName}`  * `{ProcessGroup:TIBCOBusinessWorksCeAppName}`  * `{ProcessGroup:TIBCOBusinessWorksCeVersion}`  * `{ProcessGroup:TIBCOBusinessWorksDomainName}`  * `{ProcessGroup:TIBCOBusinessWorksEnginePropertyFilePath}`  * `{ProcessGroup:TIBCOBusinessWorksEnginePropertyFile}`  * `{ProcessGroup:TIBCOBusinessWorksHome}`  * `{ProcessGroup:VarnishInstanceName}`  * `{ProcessGroup:WebLogicClusterName}`  * `{ProcessGroup:WebLogicDomainName}`  * `{ProcessGroup:WebLogicHome}`  * `{ProcessGroup:WebLogicName}`  * `{ProcessGroup:WebSphereCellName}`  * `{ProcessGroup:WebSphereClusterName}`  * `{ProcessGroup:WebSphereNodeName}`  * `{ProcessGroup:WebSphereServerName}`  * `{ProcessGroup:ActorSystem}`  * `{Service:STGServerName}`  * `{Service:DatabaseHostName}`  * `{Service:DatabaseName}`  * `{Service:DatabaseVendor}`  * `{Service:DetectedName}`  * `{Service:EndpointPath}`  * `{Service:EndpointPathGatewayUrl}`  * `{Service:IIBApplicationName}`  * `{Service:MessageListenerClassName}`  * `{Service:Port}`  * `{Service:PublicDomainName}`  * `{Service:RemoteEndpoint}`  * `{Service:RemoteName}`  * `{Service:WebApplicationId}`  * `{Service:WebContextRoot}`  * `{Service:WebServerName}`  * `{Service:WebServiceNamespace}`  * `{Service:WebServiceName}`  * `{VmwareDatacenter:Name}`  * `{VmwareVm:Name}`
        """
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if normalization is not None:
            pulumi.set(__self__, "normalization", normalization)
        if propagation_types is not None:
            pulumi.set(__self__, "propagation_types", propagation_types)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of Dynatrace entities the management zone can be applied to
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.AutotagRuleCondition']]:
        """
        A list of matching rules for the management zone. The management zone applies only if **all** conditions are fulfilled
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        The rule is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def normalization(self) -> Optional[str]:
        """
        Changes applied to the value after applying the value format. Possible values are `LEAVE_TEXT_AS_IS`, `TO_LOWER_CASE` and `TO_UPPER_CASE`. Default is `LEAVE_TEXT_AS_IS`
        """
        return pulumi.get(self, "normalization")

    @property
    @pulumi.getter(name="propagationTypes")
    def propagation_types(self) -> Optional[Sequence[str]]:
        """
        How to apply the management zone to underlying entities:
           - `SERVICE_TO_HOST_LIKE`: Apply to underlying hosts of matching services
           - `SERVICE_TO_PROCESS_GROUP_LIKE`: Apply to underlying process groups of matching services
           - `PROCESS_GROUP_TO_HOST`: Apply to underlying hosts of matching process groups
           - `PROCESS_GROUP_TO_SERVICE`: Apply to all services provided by matching process groups
           - `HOST_TO_PROCESS_GROUP_INSTANCE`: Apply to processes running on matching hosts
           - `CUSTOM_DEVICE_GROUP_TO_CUSTOM_DEVICE`: Apply to custom devices in matching custom device groups
           - `AZURE_TO_PG`: Apply to process groups connected to matching Azure entities
           - `AZURE_TO_SERVICE`: Apply to services provided by matching Azure entities
        """
        return pulumi.get(self, "propagation_types")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[str]:
        """
        The value of the auto-tag. If specified, the tag is used in the `name:valueFormat` format.  For example, you can extend the `Infrastructure` tag to `Infrastructure:Windows` and `Infrastructure:Linux`.  You can use the following placeholders here:  * `{AwsAutoScalingGroup:Name}`  * `{AwsAvailabilityZone:Name}`  * `{AwsElasticLoadBalancer:Name}`  * `{AwsRelationalDatabaseService:DBName}`  * `{AwsRelationalDatabaseService:Endpoint}`  * `{AwsRelationalDatabaseService:Engine}`  * `{AwsRelationalDatabaseService:InstanceClass}`  * `{AwsRelationalDatabaseService:Name}`  * `{AwsRelationalDatabaseService:Port}`  * `{AzureRegion:Name}`  * `{AzureScaleSet:Name}`  * `{AzureVm:Name}`  * `{CloudFoundryOrganization:Name}`  * `{CustomDevice:DetectedName}`  * `{CustomDevice:DnsName}`  * `{CustomDevice:IpAddress}`  * `{CustomDevice:Port}`  * `{DockerContainerGroupInstance:ContainerName}`  * `{DockerContainerGroupInstance:FullImageName}`  * `{DockerContainerGroupInstance:ImageVersion}`  * `{DockerContainerGroupInstance:StrippedImageName}`  * `{ESXIHost:HardwareModel}`  * `{ESXIHost:HardwareVendor}`  * `{ESXIHost:Name}`  * `{ESXIHost:ProductName}`  * `{ESXIHost:ProductVersion}`  * `{Ec2Instance:AmiId}`  * `{Ec2Instance:BeanstalkEnvironmentName}`  * `{Ec2Instance:InstanceId}`  * `{Ec2Instance:InstanceType}`  * `{Ec2Instance:LocalHostName}`  * `{Ec2Instance:Name}`  * `{Ec2Instance:PublicHostName}`  * `{Ec2Instance:SecurityGroup}`  * `{GoogleComputeInstance:Id}`  * `{GoogleComputeInstance:IpAddresses}`  * `{GoogleComputeInstance:MachineType}`  * `{GoogleComputeInstance:Name}`  * `{GoogleComputeInstance:ProjectId}`  * `{GoogleComputeInstance:Project}`  * `{Host:AWSNameTag}`  * `{Host:AixLogicalCpuCount}`  * `{Host:AzureHostName}`  * `{Host:AzureSiteName}`  * `{Host:BoshDeploymentId}`  * `{Host:BoshInstanceId}`  * `{Host:BoshInstanceName}`  * `{Host:BoshName}`  * `{Host:BoshStemcellVersion}`  * `{Host:CpuCores}`  * `{Host:DetectedName}`  * `{Host:Environment:AppName}`  * `{Host:Environment:BoshReleaseVersion}`  * `{Host:Environment:Environment}`  * `{Host:Environment:Link}`  * `{Host:Environment:Organization}`  * `{Host:Environment:Owner}`  * `{Host:Environment:Support}`  * `{Host:IpAddress}`  * `{Host:LogicalCpuCores}`  * `{Host:OneAgentCustomHostName}`  * `{Host:OperatingSystemVersion}`  * `{Host:PaasMemoryLimit}`  * `{HostGroup:Name}`  * `{KubernetesCluster:Name}`  * `{KubernetesNode:DetectedName}`  * `{OpenstackAvailabilityZone:Name}`  * `{OpenstackZone:Name}`  * `{OpenstackComputeNode:Name}`  * `{OpenstackProject:Name}`  * `{OpenstackVm:UnstanceType}`  * `{OpenstackVm:Name}`  * `{OpenstackVm:SecurityGroup}`  * `{ProcessGroup:AmazonECRImageAccountId}`  * `{ProcessGroup:AmazonECRImageRegion}`  * `{ProcessGroup:AmazonECSCluster}`  * `{ProcessGroup:AmazonECSContainerName}`  * `{ProcessGroup:AmazonECSFamily}`  * `{ProcessGroup:AmazonECSRevision}`  * `{ProcessGroup:AmazonLambdaFunctionName}`  * `{ProcessGroup:AmazonRegion}`  * `{ProcessGroup:ApacheConfigPath}`  * `{ProcessGroup:ApacheSparkMasterIpAddress}`  * `{ProcessGroup:AspDotNetCoreApplicationPath}`  * `{ProcessGroup:AspDotNetCoreApplicationPath}`  * `{ProcessGroup:AzureHostName}`  * `{ProcessGroup:AzureSiteName}`  * `{ProcessGroup:CassandraClusterName}`  * `{ProcessGroup:CatalinaBase}`  * `{ProcessGroup:CatalinaHome}`  * `{ProcessGroup:CloudFoundryAppId}`  * `{ProcessGroup:CloudFoundryAppName}`  * `{ProcessGroup:CloudFoundryInstanceIndex}`  * `{ProcessGroup:CloudFoundrySpaceId}`  * `{ProcessGroup:CloudFoundrySpaceName}`  * `{ProcessGroup:ColdFusionJvmConfigFile}`  * `{ProcessGroup:ColdFusionServiceName}`  * `{ProcessGroup:CommandLineArgs}`  * `{ProcessGroup:DetectedName}`  * `{ProcessGroup:DotNetCommandPath}`  * `{ProcessGroup:DotNetCommand}`  * `{ProcessGroup:DotNetClusterId}`  * `{ProcessGroup:DotNetNodeId}`  * `{ProcessGroup:ElasticsearchClusterName}`  * `{ProcessGroup:ElasticsearchNodeName}`  * `{ProcessGroup:EquinoxConfigPath}`  * `{ProcessGroup:ExeName}`  * `{ProcessGroup:ExePath}`  * `{ProcessGroup:GlassFishDomainName}`  * `{ProcessGroup:GlassFishInstanceName}`  * `{ProcessGroup:GoogleAppEngineInstance}`  * `{ProcessGroup:GoogleAppEngineService}`  * `{ProcessGroup:GoogleCloudProject}`  * `{ProcessGroup:HybrisBinDirectory}`  * `{ProcessGroup:HybrisConfigDirectory}`  * `{ProcessGroup:HybrisConfigDirectory}`  * `{ProcessGroup:HybrisDataDirectory}`  * `{ProcessGroup:IBMCicsRegion}`  * `{ProcessGroup:IBMCtgName}`  * `{ProcessGroup:IBMImsConnectRegion}`  * `{ProcessGroup:IBMImsControlRegion}`  * `{ProcessGroup:IBMImsMessageProcessingRegion}`  * `{ProcessGroup:IBMImsSoapGwName}`  * `{ProcessGroup:IBMIntegrationNodeName}`  * `{ProcessGroup:IBMIntegrationServerName}`  * `{ProcessGroup:IISAppPool}`  * `{ProcessGroup:IISRoleName}`  * `{ProcessGroup:JbossHome}`  * `{ProcessGroup:JbossMode}`  * `{ProcessGroup:JbossServerName}`  * `{ProcessGroup:JavaJarFile}`  * `{ProcessGroup:JavaJarPath}`  * `{ProcessGroup:JavaMainCLass}`  * `{ProcessGroup:KubernetesBasePodName}`  * `{ProcessGroup:KubernetesContainerName}`  * `{ProcessGroup:KubernetesFullPodName}`  * `{ProcessGroup:KubernetesNamespace}`  * `{ProcessGroup:KubernetesPodUid}`  * `{ProcessGroup:MssqlInstanceName}`  * `{ProcessGroup:NodeJsAppBaseDirectory}`  * `{ProcessGroup:NodeJsAppName}`  * `{ProcessGroup:NodeJsScriptName}`  * `{ProcessGroup:OracleSid}`  * `{ProcessGroup:PHPScriptPath}`  * `{ProcessGroup:PHPWorkingDirectory}`  * `{ProcessGroup:Ports}`  * `{ProcessGroup:RubyAppRootPath}`  * `{ProcessGroup:RubyScriptPath}`  * `{ProcessGroup:SoftwareAGInstallRoot}`  * `{ProcessGroup:SoftwareAGProductPropertyName}`  * `{ProcessGroup:SpringBootAppName}`  * `{ProcessGroup:SpringBootProfileName}`  * `{ProcessGroup:SpringBootStartupClass}`  * `{ProcessGroup:TIBCOBusinessWorksAppNodeName}`  * `{ProcessGroup:TIBCOBusinessWorksAppSpaceName}`  * `{ProcessGroup:TIBCOBusinessWorksCeAppName}`  * `{ProcessGroup:TIBCOBusinessWorksCeVersion}`  * `{ProcessGroup:TIBCOBusinessWorksDomainName}`  * `{ProcessGroup:TIBCOBusinessWorksEnginePropertyFilePath}`  * `{ProcessGroup:TIBCOBusinessWorksEnginePropertyFile}`  * `{ProcessGroup:TIBCOBusinessWorksHome}`  * `{ProcessGroup:VarnishInstanceName}`  * `{ProcessGroup:WebLogicClusterName}`  * `{ProcessGroup:WebLogicDomainName}`  * `{ProcessGroup:WebLogicHome}`  * `{ProcessGroup:WebLogicName}`  * `{ProcessGroup:WebSphereCellName}`  * `{ProcessGroup:WebSphereClusterName}`  * `{ProcessGroup:WebSphereNodeName}`  * `{ProcessGroup:WebSphereServerName}`  * `{ProcessGroup:ActorSystem}`  * `{Service:STGServerName}`  * `{Service:DatabaseHostName}`  * `{Service:DatabaseName}`  * `{Service:DatabaseVendor}`  * `{Service:DetectedName}`  * `{Service:EndpointPath}`  * `{Service:EndpointPathGatewayUrl}`  * `{Service:IIBApplicationName}`  * `{Service:MessageListenerClassName}`  * `{Service:Port}`  * `{Service:PublicDomainName}`  * `{Service:RemoteEndpoint}`  * `{Service:RemoteName}`  * `{Service:WebApplicationId}`  * `{Service:WebContextRoot}`  * `{Service:WebServerName}`  * `{Service:WebServiceNamespace}`  * `{Service:WebServiceName}`  * `{VmwareDatacenter:Name}`  * `{VmwareVm:Name}`
        """
        return pulumi.get(self, "value_format")


@pulumi.output_type
class AutotagRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationTypeComparisons":
            suggest = "application_type_comparisons"
        elif key == "applicationTypes":
            suggest = "application_types"
        elif key == "azureComputeModeComparisons":
            suggest = "azure_compute_mode_comparisons"
        elif key == "azureComputeModes":
            suggest = "azure_compute_modes"
        elif key == "azureSkuComparisions":
            suggest = "azure_sku_comparisions"
        elif key == "azureSkus":
            suggest = "azure_skus"
        elif key == "baseComparisonBasics":
            suggest = "base_comparison_basics"
        elif key == "baseConditionKeys":
            suggest = "base_condition_keys"
        elif key == "bitnessComparisions":
            suggest = "bitness_comparisions"
        elif key == "cloudTypeComparisons":
            suggest = "cloud_type_comparisons"
        elif key == "cloudTypes":
            suggest = "cloud_types"
        elif key == "customApplicationTypeComparisons":
            suggest = "custom_application_type_comparisons"
        elif key == "customApplicationTypes":
            suggest = "custom_application_types"
        elif key == "customHostMetadataConditionKeys":
            suggest = "custom_host_metadata_condition_keys"
        elif key == "customHostMetadatas":
            suggest = "custom_host_metadatas"
        elif key == "customProcessMetadataConditionKeys":
            suggest = "custom_process_metadata_condition_keys"
        elif key == "customProcessMetadatas":
            suggest = "custom_process_metadatas"
        elif key == "databaseTopologies":
            suggest = "database_topologies"
        elif key == "databaseTopologyComparisons":
            suggest = "database_topology_comparisons"
        elif key == "dcrumDecoderComparisons":
            suggest = "dcrum_decoder_comparisons"
        elif key == "dcrumDecoders":
            suggest = "dcrum_decoders"
        elif key == "entityIdComparisons":
            suggest = "entity_id_comparisons"
        elif key == "hostTeches":
            suggest = "host_teches"
        elif key == "hypervisorTypeComparisions":
            suggest = "hypervisor_type_comparisions"
        elif key == "indexedNameComparisons":
            suggest = "indexed_name_comparisons"
        elif key == "indexedNames":
            suggest = "indexed_names"
        elif key == "indexedStringComparisons":
            suggest = "indexed_string_comparisons"
        elif key == "indexedStrings":
            suggest = "indexed_strings"
        elif key == "indexedTagComparisons":
            suggest = "indexed_tag_comparisons"
        elif key == "indexedTags":
            suggest = "indexed_tags"
        elif key == "integerComparisons":
            suggest = "integer_comparisons"
        elif key == "ipaddressComparisons":
            suggest = "ipaddress_comparisons"
        elif key == "mobilePlatformComparisons":
            suggest = "mobile_platform_comparisons"
        elif key == "mobilePlatforms":
            suggest = "mobile_platforms"
        elif key == "osArches":
            suggest = "os_arches"
        elif key == "osTypes":
            suggest = "os_types"
        elif key == "osarchitectureComparisons":
            suggest = "osarchitecture_comparisons"
        elif key == "ostypeComparisons":
            suggest = "ostype_comparisons"
        elif key == "paasTypeComparisons":
            suggest = "paas_type_comparisons"
        elif key == "paasTypes":
            suggest = "paas_types"
        elif key == "processMetadataConditionKeys":
            suggest = "process_metadata_condition_keys"
        elif key == "processMetadatas":
            suggest = "process_metadatas"
        elif key == "serviceTopologies":
            suggest = "service_topologies"
        elif key == "serviceTopologyComparisons":
            suggest = "service_topology_comparisons"
        elif key == "serviceTypeComparisons":
            suggest = "service_type_comparisons"
        elif key == "serviceTypes":
            suggest = "service_types"
        elif key == "simpleHostTechComparisons":
            suggest = "simple_host_tech_comparisons"
        elif key == "simpleTechComparisons":
            suggest = "simple_tech_comparisons"
        elif key == "stringComparisons":
            suggest = "string_comparisons"
        elif key == "stringConditionKeys":
            suggest = "string_condition_keys"
        elif key == "stringKeys":
            suggest = "string_keys"
        elif key == "syntheticEngineTypeComparisons":
            suggest = "synthetic_engine_type_comparisons"
        elif key == "syntheticEngines":
            suggest = "synthetic_engines"
        elif key == "tagComparisons":
            suggest = "tag_comparisons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_type_comparisons: Optional[Sequence['outputs.AutotagRuleConditionApplicationTypeComparison']] = None,
                 application_types: Optional[Sequence['outputs.AutotagRuleConditionApplicationType']] = None,
                 azure_compute_mode_comparisons: Optional[Sequence['outputs.AutotagRuleConditionAzureComputeModeComparison']] = None,
                 azure_compute_modes: Optional[Sequence['outputs.AutotagRuleConditionAzureComputeMode']] = None,
                 azure_sku_comparisions: Optional[Sequence['outputs.AutotagRuleConditionAzureSkuComparision']] = None,
                 azure_skus: Optional[Sequence['outputs.AutotagRuleConditionAzureSkus']] = None,
                 base_comparison_basics: Optional[Sequence['outputs.AutotagRuleConditionBaseComparisonBasic']] = None,
                 base_condition_keys: Optional[Sequence['outputs.AutotagRuleConditionBaseConditionKey']] = None,
                 bitness_comparisions: Optional[Sequence['outputs.AutotagRuleConditionBitnessComparision']] = None,
                 bitnesses: Optional[Sequence['outputs.AutotagRuleConditionBitness']] = None,
                 cloud_type_comparisons: Optional[Sequence['outputs.AutotagRuleConditionCloudTypeComparison']] = None,
                 cloud_types: Optional[Sequence['outputs.AutotagRuleConditionCloudType']] = None,
                 comparisons: Optional[Sequence['outputs.AutotagRuleConditionComparison']] = None,
                 custom_application_type_comparisons: Optional[Sequence['outputs.AutotagRuleConditionCustomApplicationTypeComparison']] = None,
                 custom_application_types: Optional[Sequence['outputs.AutotagRuleConditionCustomApplicationType']] = None,
                 custom_host_metadata_condition_keys: Optional[Sequence['outputs.AutotagRuleConditionCustomHostMetadataConditionKey']] = None,
                 custom_host_metadatas: Optional[Sequence['outputs.AutotagRuleConditionCustomHostMetadata']] = None,
                 custom_process_metadata_condition_keys: Optional[Sequence['outputs.AutotagRuleConditionCustomProcessMetadataConditionKey']] = None,
                 custom_process_metadatas: Optional[Sequence['outputs.AutotagRuleConditionCustomProcessMetadata']] = None,
                 database_topologies: Optional[Sequence['outputs.AutotagRuleConditionDatabaseTopology']] = None,
                 database_topology_comparisons: Optional[Sequence['outputs.AutotagRuleConditionDatabaseTopologyComparison']] = None,
                 dcrum_decoder_comparisons: Optional[Sequence['outputs.AutotagRuleConditionDcrumDecoderComparison']] = None,
                 dcrum_decoders: Optional[Sequence['outputs.AutotagRuleConditionDcrumDecoder']] = None,
                 entities: Optional[Sequence['outputs.AutotagRuleConditionEntity']] = None,
                 entity_id_comparisons: Optional[Sequence['outputs.AutotagRuleConditionEntityIdComparison']] = None,
                 host_teches: Optional[Sequence['outputs.AutotagRuleConditionHostTech']] = None,
                 hypervisor_type_comparisions: Optional[Sequence['outputs.AutotagRuleConditionHypervisorTypeComparision']] = None,
                 hypervisors: Optional[Sequence['outputs.AutotagRuleConditionHypervisor']] = None,
                 indexed_name_comparisons: Optional[Sequence['outputs.AutotagRuleConditionIndexedNameComparison']] = None,
                 indexed_names: Optional[Sequence['outputs.AutotagRuleConditionIndexedName']] = None,
                 indexed_string_comparisons: Optional[Sequence['outputs.AutotagRuleConditionIndexedStringComparison']] = None,
                 indexed_strings: Optional[Sequence['outputs.AutotagRuleConditionIndexedString']] = None,
                 indexed_tag_comparisons: Optional[Sequence['outputs.AutotagRuleConditionIndexedTagComparison']] = None,
                 indexed_tags: Optional[Sequence['outputs.AutotagRuleConditionIndexedTag']] = None,
                 integer_comparisons: Optional[Sequence['outputs.AutotagRuleConditionIntegerComparison']] = None,
                 integers: Optional[Sequence['outputs.AutotagRuleConditionInteger']] = None,
                 ipaddress_comparisons: Optional[Sequence['outputs.AutotagRuleConditionIpaddressComparison']] = None,
                 ipaddresses: Optional[Sequence['outputs.AutotagRuleConditionIpaddress']] = None,
                 keys: Optional[Sequence['outputs.AutotagRuleConditionKey']] = None,
                 mobile_platform_comparisons: Optional[Sequence['outputs.AutotagRuleConditionMobilePlatformComparison']] = None,
                 mobile_platforms: Optional[Sequence['outputs.AutotagRuleConditionMobilePlatform']] = None,
                 os_arches: Optional[Sequence['outputs.AutotagRuleConditionOsArch']] = None,
                 os_types: Optional[Sequence['outputs.AutotagRuleConditionOsType']] = None,
                 osarchitecture_comparisons: Optional[Sequence['outputs.AutotagRuleConditionOsarchitectureComparison']] = None,
                 ostype_comparisons: Optional[Sequence['outputs.AutotagRuleConditionOstypeComparison']] = None,
                 paas_type_comparisons: Optional[Sequence['outputs.AutotagRuleConditionPaasTypeComparison']] = None,
                 paas_types: Optional[Sequence['outputs.AutotagRuleConditionPaasType']] = None,
                 process_metadata_condition_keys: Optional[Sequence['outputs.AutotagRuleConditionProcessMetadataConditionKey']] = None,
                 process_metadatas: Optional[Sequence['outputs.AutotagRuleConditionProcessMetadata']] = None,
                 service_topologies: Optional[Sequence['outputs.AutotagRuleConditionServiceTopology']] = None,
                 service_topology_comparisons: Optional[Sequence['outputs.AutotagRuleConditionServiceTopologyComparison']] = None,
                 service_type_comparisons: Optional[Sequence['outputs.AutotagRuleConditionServiceTypeComparison']] = None,
                 service_types: Optional[Sequence['outputs.AutotagRuleConditionServiceType']] = None,
                 simple_host_tech_comparisons: Optional[Sequence['outputs.AutotagRuleConditionSimpleHostTechComparison']] = None,
                 simple_tech_comparisons: Optional[Sequence['outputs.AutotagRuleConditionSimpleTechComparison']] = None,
                 string_comparisons: Optional[Sequence['outputs.AutotagRuleConditionStringComparison']] = None,
                 string_condition_keys: Optional[Sequence['outputs.AutotagRuleConditionStringConditionKey']] = None,
                 string_keys: Optional[Sequence['outputs.AutotagRuleConditionStringKey']] = None,
                 strings: Optional[Sequence['outputs.AutotagRuleConditionString']] = None,
                 synthetic_engine_type_comparisons: Optional[Sequence['outputs.AutotagRuleConditionSyntheticEngineTypeComparison']] = None,
                 synthetic_engines: Optional[Sequence['outputs.AutotagRuleConditionSyntheticEngine']] = None,
                 tag_comparisons: Optional[Sequence['outputs.AutotagRuleConditionTagComparison']] = None,
                 tags: Optional[Sequence['outputs.AutotagRuleConditionTag']] = None,
                 teches: Optional[Sequence['outputs.AutotagRuleConditionTech']] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence['AutotagRuleConditionApplicationTypeComparisonArgs'] application_type_comparisons: Comparison for `APPLICATION_TYPE` attributes
        :param Sequence['AutotagRuleConditionApplicationTypeArgs'] application_types: Comparison for `APPLICATION_TYPE` attributes
        :param Sequence['AutotagRuleConditionAzureComputeModeComparisonArgs'] azure_compute_mode_comparisons: Comparison for `AZURE_COMPUTE_MODE` attributes
        :param Sequence['AutotagRuleConditionAzureComputeModeArgs'] azure_compute_modes: Comparison for `AZURE_COMPUTE_MODE` attributes
        :param Sequence['AutotagRuleConditionAzureSkuComparisionArgs'] azure_sku_comparisions: Comparison for `AZURE_SKU` attributes
        :param Sequence['AutotagRuleConditionAzureSkusArgs'] azure_skus: Comparison for `AZURE_SKU` attributes
        :param Sequence['AutotagRuleConditionBaseComparisonBasicArgs'] base_comparison_basics: A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        :param Sequence['AutotagRuleConditionBaseConditionKeyArgs'] base_condition_keys: Fallback for not yet known type
        :param Sequence['AutotagRuleConditionBitnessComparisionArgs'] bitness_comparisions: Comparison for `BITNESS` attributes
        :param Sequence['AutotagRuleConditionBitnessArgs'] bitnesses: Comparison for `BITNESS` attributes
        :param Sequence['AutotagRuleConditionCloudTypeComparisonArgs'] cloud_type_comparisons: Comparison for `CLOUD_TYPE` attributes
        :param Sequence['AutotagRuleConditionCloudTypeArgs'] cloud_types: Comparison for `CLOUD_TYPE` attributes
        :param Sequence['AutotagRuleConditionComparisonArgs'] comparisons: A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        :param Sequence['AutotagRuleConditionCustomApplicationTypeComparisonArgs'] custom_application_type_comparisons: Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        :param Sequence['AutotagRuleConditionCustomApplicationTypeArgs'] custom_application_types: Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        :param Sequence['AutotagRuleConditionCustomHostMetadataConditionKeyArgs'] custom_host_metadata_condition_keys: Key for Custom Host Metadata
        :param Sequence['AutotagRuleConditionCustomHostMetadataArgs'] custom_host_metadatas: Key for Custom Host Metadata
        :param Sequence['AutotagRuleConditionCustomProcessMetadataConditionKeyArgs'] custom_process_metadata_condition_keys: Key for Custom Process Metadata
        :param Sequence['AutotagRuleConditionCustomProcessMetadataArgs'] custom_process_metadatas: Key for Custom Process Metadata
        :param Sequence['AutotagRuleConditionDatabaseTopologyArgs'] database_topologies: Comparison for `DATABASE_TOPOLOGY` attributes
        :param Sequence['AutotagRuleConditionDatabaseTopologyComparisonArgs'] database_topology_comparisons: Comparison for `DATABASE_TOPOLOGY` attributes
        :param Sequence['AutotagRuleConditionDcrumDecoderComparisonArgs'] dcrum_decoder_comparisons: Comparison for `DCRUM_DECODER_TYPE` attributes
        :param Sequence['AutotagRuleConditionDcrumDecoderArgs'] dcrum_decoders: Comparison for `DCRUM_DECODER_TYPE` attributes
        :param Sequence['AutotagRuleConditionEntityArgs'] entities: Comparison for `ENTITY_ID` attributes
        :param Sequence['AutotagRuleConditionEntityIdComparisonArgs'] entity_id_comparisons: Comparison for `ENTITY_ID` attributes
        :param Sequence['AutotagRuleConditionHostTechArgs'] host_teches: Comparison for `SIMPLE_HOST_TECH` attributes
        :param Sequence['AutotagRuleConditionHypervisorTypeComparisionArgs'] hypervisor_type_comparisions: `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
        :param Sequence['AutotagRuleConditionHypervisorArgs'] hypervisors: Comparison for `HYPERVISOR_TYPE` attributes
        :param Sequence['AutotagRuleConditionIndexedNameComparisonArgs'] indexed_name_comparisons: Comparison for `INDEXED_NAME` attributes
        :param Sequence['AutotagRuleConditionIndexedNameArgs'] indexed_names: Comparison for `INDEXED_NAME` attributes
        :param Sequence['AutotagRuleConditionIndexedStringComparisonArgs'] indexed_string_comparisons: Comparison for `INDEXED_STRING` attributes
        :param Sequence['AutotagRuleConditionIndexedStringArgs'] indexed_strings: Comparison for `INDEXED_STRING` attributes
        :param Sequence['AutotagRuleConditionIndexedTagComparisonArgs'] indexed_tag_comparisons: Comparison for `INDEXED_TAG` attributes
        :param Sequence['AutotagRuleConditionIndexedTagArgs'] indexed_tags: Comparison for `INDEXED_TAG` attributes
        :param Sequence['AutotagRuleConditionIntegerComparisonArgs'] integer_comparisons: Comparison for `INTEGER` attributes
        :param Sequence['AutotagRuleConditionIntegerArgs'] integers: Comparison for `INTEGER` attributes
        :param Sequence['AutotagRuleConditionIpaddressComparisonArgs'] ipaddress_comparisons: Comparison for `IP_ADDRESS` attributes
        :param Sequence['AutotagRuleConditionIpaddressArgs'] ipaddresses: Comparison for `IP_ADDRESS` attributes
        :param Sequence['AutotagRuleConditionKeyArgs'] keys: Fallback for not yet known type
        :param Sequence['AutotagRuleConditionMobilePlatformComparisonArgs'] mobile_platform_comparisons: Comparison for `MOBILE_PLATFORM` attributes
        :param Sequence['AutotagRuleConditionMobilePlatformArgs'] mobile_platforms: Comparison for `MOBILE_PLATFORM` attributes
        :param Sequence['AutotagRuleConditionOsArchArgs'] os_arches: Comparison for `OS_ARCHITECTURE` attributes
        :param Sequence['AutotagRuleConditionOsTypeArgs'] os_types: Comparison for `OS_TYPE` attributes
        :param Sequence['AutotagRuleConditionOsarchitectureComparisonArgs'] osarchitecture_comparisons: Comparison for `OS_ARCHITECTURE` attributes
        :param Sequence['AutotagRuleConditionOstypeComparisonArgs'] ostype_comparisons: Comparison for `OS_TYPE` attributes
        :param Sequence['AutotagRuleConditionPaasTypeComparisonArgs'] paas_type_comparisons: Comparison for `PAAS_TYPE` attributes
        :param Sequence['AutotagRuleConditionPaasTypeArgs'] paas_types: Comparison for `PAAS_TYPE` attributes
        :param Sequence['AutotagRuleConditionProcessMetadataConditionKeyArgs'] process_metadata_condition_keys: The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        :param Sequence['AutotagRuleConditionProcessMetadataArgs'] process_metadatas: The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        :param Sequence['AutotagRuleConditionServiceTopologyArgs'] service_topologies: Comparison for `SERVICE_TOPOLOGY` attributes
        :param Sequence['AutotagRuleConditionServiceTopologyComparisonArgs'] service_topology_comparisons: Comparison for `SERVICE_TOPOLOGY` attributes
        :param Sequence['AutotagRuleConditionServiceTypeComparisonArgs'] service_type_comparisons: Comparison for `SERVICE_TYPE` attributes
        :param Sequence['AutotagRuleConditionServiceTypeArgs'] service_types: Comparison for `SERVICE_TYPE` attributes
        :param Sequence['AutotagRuleConditionSimpleHostTechComparisonArgs'] simple_host_tech_comparisons: Comparison for `SIMPLE_HOST_TECH` attributes
        :param Sequence['AutotagRuleConditionSimpleTechComparisonArgs'] simple_tech_comparisons: Comparison for `SIMPLE_TECH` attributes
        :param Sequence['AutotagRuleConditionStringComparisonArgs'] string_comparisons: Comparison for `STRING` attributes
        :param Sequence['AutotagRuleConditionStringConditionKeyArgs'] string_condition_keys: The key for dynamic attributes of the `STRING` type
        :param Sequence['AutotagRuleConditionStringKeyArgs'] string_keys: The key for dynamic attributes of the `STRING` type
        :param Sequence['AutotagRuleConditionStringArgs'] strings: Comparison for `STRING` attributes
        :param Sequence['AutotagRuleConditionSyntheticEngineTypeComparisonArgs'] synthetic_engine_type_comparisons: Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        :param Sequence['AutotagRuleConditionSyntheticEngineArgs'] synthetic_engines: Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        :param Sequence['AutotagRuleConditionTagComparisonArgs'] tag_comparisons: Comparison for `TAG` attributes
        :param Sequence['AutotagRuleConditionTagArgs'] tags: Comparison for `TAG` attributes
        :param Sequence['AutotagRuleConditionTechArgs'] teches: Comparison for `SIMPLE_TECH` attributes
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if application_type_comparisons is not None:
            pulumi.set(__self__, "application_type_comparisons", application_type_comparisons)
        if application_types is not None:
            pulumi.set(__self__, "application_types", application_types)
        if azure_compute_mode_comparisons is not None:
            pulumi.set(__self__, "azure_compute_mode_comparisons", azure_compute_mode_comparisons)
        if azure_compute_modes is not None:
            pulumi.set(__self__, "azure_compute_modes", azure_compute_modes)
        if azure_sku_comparisions is not None:
            pulumi.set(__self__, "azure_sku_comparisions", azure_sku_comparisions)
        if azure_skus is not None:
            pulumi.set(__self__, "azure_skus", azure_skus)
        if base_comparison_basics is not None:
            pulumi.set(__self__, "base_comparison_basics", base_comparison_basics)
        if base_condition_keys is not None:
            pulumi.set(__self__, "base_condition_keys", base_condition_keys)
        if bitness_comparisions is not None:
            pulumi.set(__self__, "bitness_comparisions", bitness_comparisions)
        if bitnesses is not None:
            pulumi.set(__self__, "bitnesses", bitnesses)
        if cloud_type_comparisons is not None:
            pulumi.set(__self__, "cloud_type_comparisons", cloud_type_comparisons)
        if cloud_types is not None:
            pulumi.set(__self__, "cloud_types", cloud_types)
        if comparisons is not None:
            pulumi.set(__self__, "comparisons", comparisons)
        if custom_application_type_comparisons is not None:
            pulumi.set(__self__, "custom_application_type_comparisons", custom_application_type_comparisons)
        if custom_application_types is not None:
            pulumi.set(__self__, "custom_application_types", custom_application_types)
        if custom_host_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_host_metadata_condition_keys", custom_host_metadata_condition_keys)
        if custom_host_metadatas is not None:
            pulumi.set(__self__, "custom_host_metadatas", custom_host_metadatas)
        if custom_process_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_process_metadata_condition_keys", custom_process_metadata_condition_keys)
        if custom_process_metadatas is not None:
            pulumi.set(__self__, "custom_process_metadatas", custom_process_metadatas)
        if database_topologies is not None:
            pulumi.set(__self__, "database_topologies", database_topologies)
        if database_topology_comparisons is not None:
            pulumi.set(__self__, "database_topology_comparisons", database_topology_comparisons)
        if dcrum_decoder_comparisons is not None:
            pulumi.set(__self__, "dcrum_decoder_comparisons", dcrum_decoder_comparisons)
        if dcrum_decoders is not None:
            pulumi.set(__self__, "dcrum_decoders", dcrum_decoders)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if entity_id_comparisons is not None:
            pulumi.set(__self__, "entity_id_comparisons", entity_id_comparisons)
        if host_teches is not None:
            pulumi.set(__self__, "host_teches", host_teches)
        if hypervisor_type_comparisions is not None:
            pulumi.set(__self__, "hypervisor_type_comparisions", hypervisor_type_comparisions)
        if hypervisors is not None:
            pulumi.set(__self__, "hypervisors", hypervisors)
        if indexed_name_comparisons is not None:
            pulumi.set(__self__, "indexed_name_comparisons", indexed_name_comparisons)
        if indexed_names is not None:
            pulumi.set(__self__, "indexed_names", indexed_names)
        if indexed_string_comparisons is not None:
            pulumi.set(__self__, "indexed_string_comparisons", indexed_string_comparisons)
        if indexed_strings is not None:
            pulumi.set(__self__, "indexed_strings", indexed_strings)
        if indexed_tag_comparisons is not None:
            pulumi.set(__self__, "indexed_tag_comparisons", indexed_tag_comparisons)
        if indexed_tags is not None:
            pulumi.set(__self__, "indexed_tags", indexed_tags)
        if integer_comparisons is not None:
            pulumi.set(__self__, "integer_comparisons", integer_comparisons)
        if integers is not None:
            pulumi.set(__self__, "integers", integers)
        if ipaddress_comparisons is not None:
            pulumi.set(__self__, "ipaddress_comparisons", ipaddress_comparisons)
        if ipaddresses is not None:
            pulumi.set(__self__, "ipaddresses", ipaddresses)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if mobile_platform_comparisons is not None:
            pulumi.set(__self__, "mobile_platform_comparisons", mobile_platform_comparisons)
        if mobile_platforms is not None:
            pulumi.set(__self__, "mobile_platforms", mobile_platforms)
        if os_arches is not None:
            pulumi.set(__self__, "os_arches", os_arches)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if osarchitecture_comparisons is not None:
            pulumi.set(__self__, "osarchitecture_comparisons", osarchitecture_comparisons)
        if ostype_comparisons is not None:
            pulumi.set(__self__, "ostype_comparisons", ostype_comparisons)
        if paas_type_comparisons is not None:
            pulumi.set(__self__, "paas_type_comparisons", paas_type_comparisons)
        if paas_types is not None:
            pulumi.set(__self__, "paas_types", paas_types)
        if process_metadata_condition_keys is not None:
            pulumi.set(__self__, "process_metadata_condition_keys", process_metadata_condition_keys)
        if process_metadatas is not None:
            pulumi.set(__self__, "process_metadatas", process_metadatas)
        if service_topologies is not None:
            pulumi.set(__self__, "service_topologies", service_topologies)
        if service_topology_comparisons is not None:
            pulumi.set(__self__, "service_topology_comparisons", service_topology_comparisons)
        if service_type_comparisons is not None:
            pulumi.set(__self__, "service_type_comparisons", service_type_comparisons)
        if service_types is not None:
            pulumi.set(__self__, "service_types", service_types)
        if simple_host_tech_comparisons is not None:
            pulumi.set(__self__, "simple_host_tech_comparisons", simple_host_tech_comparisons)
        if simple_tech_comparisons is not None:
            pulumi.set(__self__, "simple_tech_comparisons", simple_tech_comparisons)
        if string_comparisons is not None:
            pulumi.set(__self__, "string_comparisons", string_comparisons)
        if string_condition_keys is not None:
            pulumi.set(__self__, "string_condition_keys", string_condition_keys)
        if string_keys is not None:
            pulumi.set(__self__, "string_keys", string_keys)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)
        if synthetic_engine_type_comparisons is not None:
            pulumi.set(__self__, "synthetic_engine_type_comparisons", synthetic_engine_type_comparisons)
        if synthetic_engines is not None:
            pulumi.set(__self__, "synthetic_engines", synthetic_engines)
        if tag_comparisons is not None:
            pulumi.set(__self__, "tag_comparisons", tag_comparisons)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if teches is not None:
            pulumi.set(__self__, "teches", teches)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="applicationTypeComparisons")
    @_utilities.deprecated("""You should use 'application_type' instead of 'application_type_comparison'. This attribute still exists for backwards compatibility.""")
    def application_type_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionApplicationTypeComparison']]:
        """
        Comparison for `APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "application_type_comparisons")

    @property
    @pulumi.getter(name="applicationTypes")
    def application_types(self) -> Optional[Sequence['outputs.AutotagRuleConditionApplicationType']]:
        """
        Comparison for `APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "application_types")

    @property
    @pulumi.getter(name="azureComputeModeComparisons")
    def azure_compute_mode_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionAzureComputeModeComparison']]:
        """
        Comparison for `AZURE_COMPUTE_MODE` attributes
        """
        return pulumi.get(self, "azure_compute_mode_comparisons")

    @property
    @pulumi.getter(name="azureComputeModes")
    @_utilities.deprecated("""You should use 'azure_compute_mode' instead of 'azure_compute_mode_comparison'. This attribute still exists for backwards compatibility.""")
    def azure_compute_modes(self) -> Optional[Sequence['outputs.AutotagRuleConditionAzureComputeMode']]:
        """
        Comparison for `AZURE_COMPUTE_MODE` attributes
        """
        return pulumi.get(self, "azure_compute_modes")

    @property
    @pulumi.getter(name="azureSkuComparisions")
    @_utilities.deprecated("""You should use 'azure_sku' instead of 'azure_sku_comparision'. This attribute still exists for backwards compatibility.""")
    def azure_sku_comparisions(self) -> Optional[Sequence['outputs.AutotagRuleConditionAzureSkuComparision']]:
        """
        Comparison for `AZURE_SKU` attributes
        """
        return pulumi.get(self, "azure_sku_comparisions")

    @property
    @pulumi.getter(name="azureSkus")
    def azure_skus(self) -> Optional[Sequence['outputs.AutotagRuleConditionAzureSkus']]:
        """
        Comparison for `AZURE_SKU` attributes
        """
        return pulumi.get(self, "azure_skus")

    @property
    @pulumi.getter(name="baseComparisonBasics")
    @_utilities.deprecated("""You should use 'comparison' instead of 'base_comparison_basic'. This attribute still exists for backwards compatibility.""")
    def base_comparison_basics(self) -> Optional[Sequence['outputs.AutotagRuleConditionBaseComparisonBasic']]:
        """
        A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        """
        return pulumi.get(self, "base_comparison_basics")

    @property
    @pulumi.getter(name="baseConditionKeys")
    @_utilities.deprecated("""'base_condition_key' is deprecated. You should use 'key'""")
    def base_condition_keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionBaseConditionKey']]:
        """
        Fallback for not yet known type
        """
        return pulumi.get(self, "base_condition_keys")

    @property
    @pulumi.getter(name="bitnessComparisions")
    @_utilities.deprecated("""You should use 'bitness' instead of 'bitness_comparision'. This attribute still exists for backwards compatibility.""")
    def bitness_comparisions(self) -> Optional[Sequence['outputs.AutotagRuleConditionBitnessComparision']]:
        """
        Comparison for `BITNESS` attributes
        """
        return pulumi.get(self, "bitness_comparisions")

    @property
    @pulumi.getter
    def bitnesses(self) -> Optional[Sequence['outputs.AutotagRuleConditionBitness']]:
        """
        Comparison for `BITNESS` attributes
        """
        return pulumi.get(self, "bitnesses")

    @property
    @pulumi.getter(name="cloudTypeComparisons")
    @_utilities.deprecated("""You should use 'cloud_type' instead of 'cloud_type_comparison'. This attribute still exists for backwards compatibility.""")
    def cloud_type_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionCloudTypeComparison']]:
        """
        Comparison for `CLOUD_TYPE` attributes
        """
        return pulumi.get(self, "cloud_type_comparisons")

    @property
    @pulumi.getter(name="cloudTypes")
    def cloud_types(self) -> Optional[Sequence['outputs.AutotagRuleConditionCloudType']]:
        """
        Comparison for `CLOUD_TYPE` attributes
        """
        return pulumi.get(self, "cloud_types")

    @property
    @pulumi.getter
    def comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionComparison']]:
        """
        A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        """
        return pulumi.get(self, "comparisons")

    @property
    @pulumi.getter(name="customApplicationTypeComparisons")
    @_utilities.deprecated("""You should use 'custom_application_type' instead of 'custom_application_type_comparison'. This attribute still exists for backwards compatibility.""")
    def custom_application_type_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionCustomApplicationTypeComparison']]:
        """
        Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "custom_application_type_comparisons")

    @property
    @pulumi.getter(name="customApplicationTypes")
    def custom_application_types(self) -> Optional[Sequence['outputs.AutotagRuleConditionCustomApplicationType']]:
        """
        Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "custom_application_types")

    @property
    @pulumi.getter(name="customHostMetadataConditionKeys")
    @_utilities.deprecated("""'custom_host_metadata_condition_key' is deprecated. You should use 'custom_host_metadata'""")
    def custom_host_metadata_condition_keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionCustomHostMetadataConditionKey']]:
        """
        Key for Custom Host Metadata
        """
        return pulumi.get(self, "custom_host_metadata_condition_keys")

    @property
    @pulumi.getter(name="customHostMetadatas")
    def custom_host_metadatas(self) -> Optional[Sequence['outputs.AutotagRuleConditionCustomHostMetadata']]:
        """
        Key for Custom Host Metadata
        """
        return pulumi.get(self, "custom_host_metadatas")

    @property
    @pulumi.getter(name="customProcessMetadataConditionKeys")
    @_utilities.deprecated("""'custom_process_metadata_condition_key' is deprecated. You should use 'custom_process_metadata'""")
    def custom_process_metadata_condition_keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionCustomProcessMetadataConditionKey']]:
        """
        Key for Custom Process Metadata
        """
        return pulumi.get(self, "custom_process_metadata_condition_keys")

    @property
    @pulumi.getter(name="customProcessMetadatas")
    def custom_process_metadatas(self) -> Optional[Sequence['outputs.AutotagRuleConditionCustomProcessMetadata']]:
        """
        Key for Custom Process Metadata
        """
        return pulumi.get(self, "custom_process_metadatas")

    @property
    @pulumi.getter(name="databaseTopologies")
    def database_topologies(self) -> Optional[Sequence['outputs.AutotagRuleConditionDatabaseTopology']]:
        """
        Comparison for `DATABASE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "database_topologies")

    @property
    @pulumi.getter(name="databaseTopologyComparisons")
    @_utilities.deprecated("""You should use 'database_topology' instead of 'database_topology_comparison'. This attribute still exists for backwards compatibility.""")
    def database_topology_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionDatabaseTopologyComparison']]:
        """
        Comparison for `DATABASE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "database_topology_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoderComparisons")
    @_utilities.deprecated("""You should use 'dcrum_decoder' instead of 'dcrum_decoder_comparison'. This attribute still exists for backwards compatibility.""")
    def dcrum_decoder_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionDcrumDecoderComparison']]:
        """
        Comparison for `DCRUM_DECODER_TYPE` attributes
        """
        return pulumi.get(self, "dcrum_decoder_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoders")
    def dcrum_decoders(self) -> Optional[Sequence['outputs.AutotagRuleConditionDcrumDecoder']]:
        """
        Comparison for `DCRUM_DECODER_TYPE` attributes
        """
        return pulumi.get(self, "dcrum_decoders")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.AutotagRuleConditionEntity']]:
        """
        Comparison for `ENTITY_ID` attributes
        """
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="entityIdComparisons")
    @_utilities.deprecated("""You should use 'entity' instead of 'entity_id_comparison'. This attribute still exists for backwards compatibility.""")
    def entity_id_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionEntityIdComparison']]:
        """
        Comparison for `ENTITY_ID` attributes
        """
        return pulumi.get(self, "entity_id_comparisons")

    @property
    @pulumi.getter(name="hostTeches")
    def host_teches(self) -> Optional[Sequence['outputs.AutotagRuleConditionHostTech']]:
        """
        Comparison for `SIMPLE_HOST_TECH` attributes
        """
        return pulumi.get(self, "host_teches")

    @property
    @pulumi.getter(name="hypervisorTypeComparisions")
    @_utilities.deprecated("""`hypervisor_type_comparision` is deprecated. Use `hypervisor` instead""")
    def hypervisor_type_comparisions(self) -> Optional[Sequence['outputs.AutotagRuleConditionHypervisorTypeComparision']]:
        """
        `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
        """
        return pulumi.get(self, "hypervisor_type_comparisions")

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[Sequence['outputs.AutotagRuleConditionHypervisor']]:
        """
        Comparison for `HYPERVISOR_TYPE` attributes
        """
        return pulumi.get(self, "hypervisors")

    @property
    @pulumi.getter(name="indexedNameComparisons")
    @_utilities.deprecated("""You should use 'indexed_name' instead of 'indexed_name_comparison'. This attribute still exists for backwards compatibility.""")
    def indexed_name_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionIndexedNameComparison']]:
        """
        Comparison for `INDEXED_NAME` attributes
        """
        return pulumi.get(self, "indexed_name_comparisons")

    @property
    @pulumi.getter(name="indexedNames")
    def indexed_names(self) -> Optional[Sequence['outputs.AutotagRuleConditionIndexedName']]:
        """
        Comparison for `INDEXED_NAME` attributes
        """
        return pulumi.get(self, "indexed_names")

    @property
    @pulumi.getter(name="indexedStringComparisons")
    @_utilities.deprecated("""You should use 'indexed_string' instead of 'indexed_string_comparison'. This attribute still exists for backwards compatibility.""")
    def indexed_string_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionIndexedStringComparison']]:
        """
        Comparison for `INDEXED_STRING` attributes
        """
        return pulumi.get(self, "indexed_string_comparisons")

    @property
    @pulumi.getter(name="indexedStrings")
    def indexed_strings(self) -> Optional[Sequence['outputs.AutotagRuleConditionIndexedString']]:
        """
        Comparison for `INDEXED_STRING` attributes
        """
        return pulumi.get(self, "indexed_strings")

    @property
    @pulumi.getter(name="indexedTagComparisons")
    @_utilities.deprecated("""You should use 'indexed_tag' instead of 'indexed_tag_comparison'. This attribute still exists for backwards compatibility.""")
    def indexed_tag_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionIndexedTagComparison']]:
        """
        Comparison for `INDEXED_TAG` attributes
        """
        return pulumi.get(self, "indexed_tag_comparisons")

    @property
    @pulumi.getter(name="indexedTags")
    def indexed_tags(self) -> Optional[Sequence['outputs.AutotagRuleConditionIndexedTag']]:
        """
        Comparison for `INDEXED_TAG` attributes
        """
        return pulumi.get(self, "indexed_tags")

    @property
    @pulumi.getter(name="integerComparisons")
    @_utilities.deprecated("""You should use 'integer' instead of 'integer_comparison'. This attribute still exists for backwards compatibility.""")
    def integer_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionIntegerComparison']]:
        """
        Comparison for `INTEGER` attributes
        """
        return pulumi.get(self, "integer_comparisons")

    @property
    @pulumi.getter
    def integers(self) -> Optional[Sequence['outputs.AutotagRuleConditionInteger']]:
        """
        Comparison for `INTEGER` attributes
        """
        return pulumi.get(self, "integers")

    @property
    @pulumi.getter(name="ipaddressComparisons")
    @_utilities.deprecated("""You should use 'ipaddress' instead of 'ipaddress_comparison'. This attribute still exists for backwards compatibility.""")
    def ipaddress_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionIpaddressComparison']]:
        """
        Comparison for `IP_ADDRESS` attributes
        """
        return pulumi.get(self, "ipaddress_comparisons")

    @property
    @pulumi.getter
    def ipaddresses(self) -> Optional[Sequence['outputs.AutotagRuleConditionIpaddress']]:
        """
        Comparison for `IP_ADDRESS` attributes
        """
        return pulumi.get(self, "ipaddresses")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionKey']]:
        """
        Fallback for not yet known type
        """
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter(name="mobilePlatformComparisons")
    @_utilities.deprecated("""You should use 'mobile_platform' instead of 'mobile_platform_comparison'. This attribute still exists for backwards compatibility.""")
    def mobile_platform_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionMobilePlatformComparison']]:
        """
        Comparison for `MOBILE_PLATFORM` attributes
        """
        return pulumi.get(self, "mobile_platform_comparisons")

    @property
    @pulumi.getter(name="mobilePlatforms")
    def mobile_platforms(self) -> Optional[Sequence['outputs.AutotagRuleConditionMobilePlatform']]:
        """
        Comparison for `MOBILE_PLATFORM` attributes
        """
        return pulumi.get(self, "mobile_platforms")

    @property
    @pulumi.getter(name="osArches")
    def os_arches(self) -> Optional[Sequence['outputs.AutotagRuleConditionOsArch']]:
        """
        Comparison for `OS_ARCHITECTURE` attributes
        """
        return pulumi.get(self, "os_arches")

    @property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[Sequence['outputs.AutotagRuleConditionOsType']]:
        """
        Comparison for `OS_TYPE` attributes
        """
        return pulumi.get(self, "os_types")

    @property
    @pulumi.getter(name="osarchitectureComparisons")
    @_utilities.deprecated("""You should use 'os_arch' instead of 'osarchitecture_comparison'. This attribute still exists for backwards compatibility.""")
    def osarchitecture_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionOsarchitectureComparison']]:
        """
        Comparison for `OS_ARCHITECTURE` attributes
        """
        return pulumi.get(self, "osarchitecture_comparisons")

    @property
    @pulumi.getter(name="ostypeComparisons")
    @_utilities.deprecated("""You should use 'os_type' instead of 'ostype_comparison'. This attribute still exists for backwards compatibility.""")
    def ostype_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionOstypeComparison']]:
        """
        Comparison for `OS_TYPE` attributes
        """
        return pulumi.get(self, "ostype_comparisons")

    @property
    @pulumi.getter(name="paasTypeComparisons")
    @_utilities.deprecated("""You should use 'paas_type' instead of 'paas_type_comparison'. This attribute still exists for backwards compatibility.""")
    def paas_type_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionPaasTypeComparison']]:
        """
        Comparison for `PAAS_TYPE` attributes
        """
        return pulumi.get(self, "paas_type_comparisons")

    @property
    @pulumi.getter(name="paasTypes")
    def paas_types(self) -> Optional[Sequence['outputs.AutotagRuleConditionPaasType']]:
        """
        Comparison for `PAAS_TYPE` attributes
        """
        return pulumi.get(self, "paas_types")

    @property
    @pulumi.getter(name="processMetadataConditionKeys")
    @_utilities.deprecated("""'process_metadata_condition_key' is deprecated. You should use 'process_metadata'""")
    def process_metadata_condition_keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionProcessMetadataConditionKey']]:
        """
        The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        """
        return pulumi.get(self, "process_metadata_condition_keys")

    @property
    @pulumi.getter(name="processMetadatas")
    def process_metadatas(self) -> Optional[Sequence['outputs.AutotagRuleConditionProcessMetadata']]:
        """
        The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        """
        return pulumi.get(self, "process_metadatas")

    @property
    @pulumi.getter(name="serviceTopologies")
    def service_topologies(self) -> Optional[Sequence['outputs.AutotagRuleConditionServiceTopology']]:
        """
        Comparison for `SERVICE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "service_topologies")

    @property
    @pulumi.getter(name="serviceTopologyComparisons")
    @_utilities.deprecated("""You should use 'service_topology' instead of 'service_topology_comparison'. This attribute still exists for backwards compatibility.""")
    def service_topology_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionServiceTopologyComparison']]:
        """
        Comparison for `SERVICE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "service_topology_comparisons")

    @property
    @pulumi.getter(name="serviceTypeComparisons")
    @_utilities.deprecated("""You should use 'service_type' instead of 'service_type_comparison'. This attribute still exists for backwards compatibility.""")
    def service_type_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionServiceTypeComparison']]:
        """
        Comparison for `SERVICE_TYPE` attributes
        """
        return pulumi.get(self, "service_type_comparisons")

    @property
    @pulumi.getter(name="serviceTypes")
    def service_types(self) -> Optional[Sequence['outputs.AutotagRuleConditionServiceType']]:
        """
        Comparison for `SERVICE_TYPE` attributes
        """
        return pulumi.get(self, "service_types")

    @property
    @pulumi.getter(name="simpleHostTechComparisons")
    @_utilities.deprecated("""You should use 'host_tech' instead of 'simple_host_tech_comparison'. This attribute still exists for backwards compatibility.""")
    def simple_host_tech_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionSimpleHostTechComparison']]:
        """
        Comparison for `SIMPLE_HOST_TECH` attributes
        """
        return pulumi.get(self, "simple_host_tech_comparisons")

    @property
    @pulumi.getter(name="simpleTechComparisons")
    @_utilities.deprecated("""You should use 'tech' instead of 'simple_tech_comparison'. This attribute still exists for backwards compatibility.""")
    def simple_tech_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionSimpleTechComparison']]:
        """
        Comparison for `SIMPLE_TECH` attributes
        """
        return pulumi.get(self, "simple_tech_comparisons")

    @property
    @pulumi.getter(name="stringComparisons")
    @_utilities.deprecated("""You should use 'string' instead of 'string_comparison'. This attribute still exists for backwards compatibility.""")
    def string_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionStringComparison']]:
        """
        Comparison for `STRING` attributes
        """
        return pulumi.get(self, "string_comparisons")

    @property
    @pulumi.getter(name="stringConditionKeys")
    @_utilities.deprecated("""'string_condition_key' is deprecated. You should use 'string_key'""")
    def string_condition_keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionStringConditionKey']]:
        """
        The key for dynamic attributes of the `STRING` type
        """
        return pulumi.get(self, "string_condition_keys")

    @property
    @pulumi.getter(name="stringKeys")
    def string_keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionStringKey']]:
        """
        The key for dynamic attributes of the `STRING` type
        """
        return pulumi.get(self, "string_keys")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence['outputs.AutotagRuleConditionString']]:
        """
        Comparison for `STRING` attributes
        """
        return pulumi.get(self, "strings")

    @property
    @pulumi.getter(name="syntheticEngineTypeComparisons")
    @_utilities.deprecated("""You should use 'synthetic_engine' instead of 'synthetic_engine_type_comparison'. This attribute still exists for backwards compatibility.""")
    def synthetic_engine_type_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionSyntheticEngineTypeComparison']]:
        """
        Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        """
        return pulumi.get(self, "synthetic_engine_type_comparisons")

    @property
    @pulumi.getter(name="syntheticEngines")
    def synthetic_engines(self) -> Optional[Sequence['outputs.AutotagRuleConditionSyntheticEngine']]:
        """
        Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        """
        return pulumi.get(self, "synthetic_engines")

    @property
    @pulumi.getter(name="tagComparisons")
    @_utilities.deprecated("""You should use 'tag' instead of 'tag_comparison'. This attribute still exists for backwards compatibility.""")
    def tag_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionTagComparison']]:
        """
        Comparison for `TAG` attributes
        """
        return pulumi.get(self, "tag_comparisons")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.AutotagRuleConditionTag']]:
        """
        Comparison for `TAG` attributes
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def teches(self) -> Optional[Sequence['outputs.AutotagRuleConditionTech']]:
        """
        Comparison for `SIMPLE_TECH` attributes
        """
        return pulumi.get(self, "teches")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be APPLICATION_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be APPLICATION_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionAzureComputeMode(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are DEDICATED or SHARED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are DEDICATED or SHARED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionAzureComputeModeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are DEDICATED or SHARED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are DEDICATED or SHARED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionAzureSkuComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be AZURE_SKU
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be AZURE_SKU
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionAzureSkus(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionBaseComparisonBasic(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str type: The type of comparison
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of comparison
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionBaseConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str type: Defines the actual set of fields depending on the value
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defines the actual set of fields depending on the value
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionBitness(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are 32 and 64.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are 32 and 64.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionBitnessComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be BITNESS
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are 32 and 64.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be BITNESS
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are 32 and 64.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionCloudType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionCloudTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be CLOUD_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be CLOUD_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionComparison(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str type: The type of comparison
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of comparison
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionCustomApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be CUSTOM_APPLICATION_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be CUSTOM_APPLICATION_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionCustomHostMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionCustomHostMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionCustomHostMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionCustomHostMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.AutotagRuleConditionCustomHostMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'AutotagRuleConditionCustomHostMetadataDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.AutotagRuleConditionCustomHostMetadataDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomHostMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionCustomHostMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.AutotagRuleConditionCustomHostMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'AutotagRuleConditionCustomHostMetadataConditionKeyDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str type: if specified, needs to be HOST_CUSTOM_METADATA_KEY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.AutotagRuleConditionCustomHostMetadataConditionKeyDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be HOST_CUSTOM_METADATA_KEY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomHostMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomHostMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionCustomProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionCustomProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionCustomProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.AutotagRuleConditionCustomProcessMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'AutotagRuleConditionCustomProcessMetadataDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.AutotagRuleConditionCustomProcessMetadataDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionCustomProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.AutotagRuleConditionCustomProcessMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'AutotagRuleConditionCustomProcessMetadataConditionKeyDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str type: if specified, needs to be PROCESS_CUSTOM_METADATA_KEY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.AutotagRuleConditionCustomProcessMetadataConditionKeyDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be PROCESS_CUSTOM_METADATA_KEY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomProcessMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomProcessMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionDatabaseTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionDatabaseTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be DATABASE_TOPOLOGY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be DATABASE_TOPOLOGY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionDcrumDecoder(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionDcrumDecoderComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be DCRUM_DECODER_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be DCRUM_DECODER_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionEntity(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionEntityIdComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be ENTITY_ID
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be ENTITY_ID
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionHostTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionHostTechValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'AutotagRuleConditionHostTechValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionHostTechValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionHostTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionHostTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionHostTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionHostTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class AutotagRuleConditionHypervisor(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionHypervisorTypeComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be HYPERVISOR_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be HYPERVISOR_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedName(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedNameComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be INDEXED_NAME
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INDEXED_NAME
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedString(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedStringComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be INDEXED_STRING
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INDEXED_STRING
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionIndexedTagValue'] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param 'AutotagRuleConditionIndexedTagValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionIndexedTagValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionIndexedTagComparisonValue'] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be INDEXED_TAG
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param 'AutotagRuleConditionIndexedTagComparisonValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INDEXED_TAG
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionIndexedTagComparisonValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionInteger(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param int value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIntegerComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be INTEGER
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param int value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INTEGER
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIpaddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionIpaddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionIpaddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionIpaddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIpaddressComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionIpaddressComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionIpaddressComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionIpaddressComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be IP_ADDRESS
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be IP_ADDRESS
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str type: Defines the actual set of fields depending on the value
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defines the actual set of fields depending on the value
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionMobilePlatform(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionMobilePlatformComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be MOBILE_PLATFORM
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be MOBILE_PLATFORM
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionOsArch(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionOsType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionOsarchitectureComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be OS_ARCHITECTURE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be OS_ARCHITECTURE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionOstypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be OS_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be OS_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionPaasType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionPaasTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be PAAS_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be PAAS_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        :param str type: if specified, needs to be PROCESS_PREDEFINED_METADATA_KEY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be PROCESS_PREDEFINED_METADATA_KEY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionServiceTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionServiceTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SERVICE_TOPOLOGY
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SERVICE_TOPOLOGY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionServiceType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionServiceTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SERVICE_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SERVICE_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionSimpleHostTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionSimpleHostTechComparisonValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SIMPLE_HOST_TECH
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'AutotagRuleConditionSimpleHostTechComparisonValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SIMPLE_HOST_TECH
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionSimpleHostTechComparisonValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionSimpleHostTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionSimpleHostTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class AutotagRuleConditionSimpleTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionSimpleTechComparisonValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SIMPLE_TECH
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'AutotagRuleConditionSimpleTechComparisonValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SIMPLE_TECH
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionSimpleTechComparisonValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionSimpleTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionSimpleTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionSimpleTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionSimpleTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class AutotagRuleConditionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionStringComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionStringComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionStringComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionStringComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be STRING
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be STRING
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionStringConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionStringConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionStringConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionStringConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
                  - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
                  - `AMAZON_ECR_IMAGE_REGION`
                  - `AMAZON_LAMBDA_FUNCTION_NAME`
                  - `AMAZON_REGION`
                  - `APACHE_CONFIG_PATH`
                  - `APACHE_SPARK_MASTER_IP_ADDRESS`
                  - `ASP_DOT_NET_CORE_APPLICATION_PATH`
                  - `AWS_ECS_CLUSTER`
                  - `AWS_ECS_CONTAINERNAME`
                  - `AWS_ECS_FAMILY`
                  - `AWS_ECS_REVISION`
                  - `CASSANDRA_CLUSTER_NAME`
                  - `CATALINA_BASE`
                  - `CATALINA_HOME`
                  - `CLOUD_FOUNDRY_APP_ID`
                  - `CLOUD_FOUNDRY_APP_NAME`
                  - `CLOUD_FOUNDRY_INSTANCE_INDEX`
                  - `CLOUD_FOUNDRY_SPACE_ID`
                  - `CLOUD_FOUNDRY_SPACE_NAME`
                  - `COLDFUSION_JVM_CONFIG_FILE`
                  - `COLDFUSION_SERVICE_NAME`
                  - `COMMAND_LINE_ARGS`
                  - `DOTNET_COMMAND`
                  - `DOTNET_COMMAND_PATH`
                  - `DYNATRACE_CLUSTER_ID`
                  - `DYNATRACE_NODE_ID`
                  - `ELASTICSEARCH_CLUSTER_NAME`
                  - `ELASTICSEARCH_NODE_NAME`
                  - `EQUINOX_CONFIG_PATH`
                  - `EXE_NAME`
                  - `EXE_PATH`
                  - `GLASS_FISH_DOMAIN_NAME`
                  - `GLASS_FISH_INSTANCE_NAME`
                  - `GOOGLE_APP_ENGINE_INSTANCE`
                  - `GOOGLE_APP_ENGINE_SERVICE`
                  - `GOOGLE_CLOUD_PROJECT`
                  - `HYBRIS_BIN_DIRECTORY`
                  - `HYBRIS_CONFIG_DIRECTORY`
                  - `HYBRIS_DATA_DIRECTORY`
                  - `IBM_CICS_REGION`
                  - `IBM_CTG_NAME`
                  - `IBM_IMS_CONNECT_REGION`
                  - `IBM_IMS_CONTROL_REGION`
                  - `IBM_IMS_MESSAGE_PROCESSING_REGION`
                  - `IBM_IMS_SOAP_GW_NAME`
                  - `IBM_INTEGRATION_NODE_NAME`
                  - `IBM_INTEGRATION_SERVER_NAME`
                  - `IIS_APP_POOL`
                  - `IIS_ROLE_NAME`
                  - `JAVA_JAR_FILE`
                  - `JAVA_JAR_PATH`
                  - `JAVA_MAIN_CLASS`
                  - `JAVA_MAIN_MODULE`
                  - `JBOSS_HOME`
                  - `JBOSS_MODE`
                  - `JBOSS_SERVER_NAME`
                  - `KUBERNETES_BASE_POD_NAME`
                  - `KUBERNETES_CONTAINER_NAME`
                  - `KUBERNETES_FULL_POD_NAME`
                  - `KUBERNETES_NAMESPACE`
                  - `KUBERNETES_POD_UID`
                  - `MSSQL_INSTANCE_NAME`
                  - `NODE_JS_APP_BASE_DIRECTORY`
                  - `NODE_JS_APP_NAME`
                  - `NODE_JS_SCRIPT_NAME`
                  - `ORACLE_SID`
                  - `PG_ID_CALC_INPUT_KEY_LINKAGE`
                  - `PHP_SCRIPT_PATH`
                  - `PHP_WORKING_DIRECTORY`
                  - `RUBY_APP_ROOT_PATH`
                  - `RUBY_SCRIPT_PATH`
                  - `RULE_RESULT`
                  - `SOFTWAREAG_INSTALL_ROOT`
                  - `SOFTWAREAG_PRODUCTPROPNAME`
                  - `SPRINGBOOT_APP_NAME`
                  - `SPRINGBOOT_PROFILE_NAME`
                  - `SPRINGBOOT_STARTUP_CLASS`
                  - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
                  - `TIBCO_BUSINESSWORKS_CE_VERSION`
                  - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
                  - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
                  - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
                  - `TIBCO_BUSINESS_WORKS_HOME`
                  - `VARNISH_INSTANCE_NAME`
                  - `WEB_LOGIC_CLUSTER_NAME`
                  - `WEB_LOGIC_DOMAIN_NAME`
                  - `WEB_LOGIC_HOME`
                  - `WEB_LOGIC_NAME`
                  - `WEB_SPHERE_CELL_NAME`
                  - `WEB_SPHERE_CLUSTER_NAME`
                  - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        :param str type: if specified, needs to be `STRING`
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
           - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
           - `AMAZON_ECR_IMAGE_REGION`
           - `AMAZON_LAMBDA_FUNCTION_NAME`
           - `AMAZON_REGION`
           - `APACHE_CONFIG_PATH`
           - `APACHE_SPARK_MASTER_IP_ADDRESS`
           - `ASP_DOT_NET_CORE_APPLICATION_PATH`
           - `AWS_ECS_CLUSTER`
           - `AWS_ECS_CONTAINERNAME`
           - `AWS_ECS_FAMILY`
           - `AWS_ECS_REVISION`
           - `CASSANDRA_CLUSTER_NAME`
           - `CATALINA_BASE`
           - `CATALINA_HOME`
           - `CLOUD_FOUNDRY_APP_ID`
           - `CLOUD_FOUNDRY_APP_NAME`
           - `CLOUD_FOUNDRY_INSTANCE_INDEX`
           - `CLOUD_FOUNDRY_SPACE_ID`
           - `CLOUD_FOUNDRY_SPACE_NAME`
           - `COLDFUSION_JVM_CONFIG_FILE`
           - `COLDFUSION_SERVICE_NAME`
           - `COMMAND_LINE_ARGS`
           - `DOTNET_COMMAND`
           - `DOTNET_COMMAND_PATH`
           - `DYNATRACE_CLUSTER_ID`
           - `DYNATRACE_NODE_ID`
           - `ELASTICSEARCH_CLUSTER_NAME`
           - `ELASTICSEARCH_NODE_NAME`
           - `EQUINOX_CONFIG_PATH`
           - `EXE_NAME`
           - `EXE_PATH`
           - `GLASS_FISH_DOMAIN_NAME`
           - `GLASS_FISH_INSTANCE_NAME`
           - `GOOGLE_APP_ENGINE_INSTANCE`
           - `GOOGLE_APP_ENGINE_SERVICE`
           - `GOOGLE_CLOUD_PROJECT`
           - `HYBRIS_BIN_DIRECTORY`
           - `HYBRIS_CONFIG_DIRECTORY`
           - `HYBRIS_DATA_DIRECTORY`
           - `IBM_CICS_REGION`
           - `IBM_CTG_NAME`
           - `IBM_IMS_CONNECT_REGION`
           - `IBM_IMS_CONTROL_REGION`
           - `IBM_IMS_MESSAGE_PROCESSING_REGION`
           - `IBM_IMS_SOAP_GW_NAME`
           - `IBM_INTEGRATION_NODE_NAME`
           - `IBM_INTEGRATION_SERVER_NAME`
           - `IIS_APP_POOL`
           - `IIS_ROLE_NAME`
           - `JAVA_JAR_FILE`
           - `JAVA_JAR_PATH`
           - `JAVA_MAIN_CLASS`
           - `JAVA_MAIN_MODULE`
           - `JBOSS_HOME`
           - `JBOSS_MODE`
           - `JBOSS_SERVER_NAME`
           - `KUBERNETES_BASE_POD_NAME`
           - `KUBERNETES_CONTAINER_NAME`
           - `KUBERNETES_FULL_POD_NAME`
           - `KUBERNETES_NAMESPACE`
           - `KUBERNETES_POD_UID`
           - `MSSQL_INSTANCE_NAME`
           - `NODE_JS_APP_BASE_DIRECTORY`
           - `NODE_JS_APP_NAME`
           - `NODE_JS_SCRIPT_NAME`
           - `ORACLE_SID`
           - `PG_ID_CALC_INPUT_KEY_LINKAGE`
           - `PHP_SCRIPT_PATH`
           - `PHP_WORKING_DIRECTORY`
           - `RUBY_APP_ROOT_PATH`
           - `RUBY_SCRIPT_PATH`
           - `RULE_RESULT`
           - `SOFTWAREAG_INSTALL_ROOT`
           - `SOFTWAREAG_PRODUCTPROPNAME`
           - `SPRINGBOOT_APP_NAME`
           - `SPRINGBOOT_PROFILE_NAME`
           - `SPRINGBOOT_STARTUP_CLASS`
           - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
           - `TIBCO_BUSINESSWORKS_CE_VERSION`
           - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
           - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
           - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
           - `TIBCO_BUSINESS_WORKS_HOME`
           - `VARNISH_INSTANCE_NAME`
           - `WEB_LOGIC_CLUSTER_NAME`
           - `WEB_LOGIC_DOMAIN_NAME`
           - `WEB_LOGIC_HOME`
           - `WEB_LOGIC_NAME`
           - `WEB_SPHERE_CELL_NAME`
           - `WEB_SPHERE_CLUSTER_NAME`
           - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be `STRING`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionStringKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionStringKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionStringKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionStringKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
                  - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
                  - `AMAZON_ECR_IMAGE_REGION`
                  - `AMAZON_LAMBDA_FUNCTION_NAME`
                  - `AMAZON_REGION`
                  - `APACHE_CONFIG_PATH`
                  - `APACHE_SPARK_MASTER_IP_ADDRESS`
                  - `ASP_DOT_NET_CORE_APPLICATION_PATH`
                  - `AWS_ECS_CLUSTER`
                  - `AWS_ECS_CONTAINERNAME`
                  - `AWS_ECS_FAMILY`
                  - `AWS_ECS_REVISION`
                  - `CASSANDRA_CLUSTER_NAME`
                  - `CATALINA_BASE`
                  - `CATALINA_HOME`
                  - `CLOUD_FOUNDRY_APP_ID`
                  - `CLOUD_FOUNDRY_APP_NAME`
                  - `CLOUD_FOUNDRY_INSTANCE_INDEX`
                  - `CLOUD_FOUNDRY_SPACE_ID`
                  - `CLOUD_FOUNDRY_SPACE_NAME`
                  - `COLDFUSION_JVM_CONFIG_FILE`
                  - `COLDFUSION_SERVICE_NAME`
                  - `COMMAND_LINE_ARGS`
                  - `DOTNET_COMMAND`
                  - `DOTNET_COMMAND_PATH`
                  - `DYNATRACE_CLUSTER_ID`
                  - `DYNATRACE_NODE_ID`
                  - `ELASTICSEARCH_CLUSTER_NAME`
                  - `ELASTICSEARCH_NODE_NAME`
                  - `EQUINOX_CONFIG_PATH`
                  - `EXE_NAME`
                  - `EXE_PATH`
                  - `GLASS_FISH_DOMAIN_NAME`
                  - `GLASS_FISH_INSTANCE_NAME`
                  - `GOOGLE_APP_ENGINE_INSTANCE`
                  - `GOOGLE_APP_ENGINE_SERVICE`
                  - `GOOGLE_CLOUD_PROJECT`
                  - `HYBRIS_BIN_DIRECTORY`
                  - `HYBRIS_CONFIG_DIRECTORY`
                  - `HYBRIS_DATA_DIRECTORY`
                  - `IBM_CICS_REGION`
                  - `IBM_CTG_NAME`
                  - `IBM_IMS_CONNECT_REGION`
                  - `IBM_IMS_CONTROL_REGION`
                  - `IBM_IMS_MESSAGE_PROCESSING_REGION`
                  - `IBM_IMS_SOAP_GW_NAME`
                  - `IBM_INTEGRATION_NODE_NAME`
                  - `IBM_INTEGRATION_SERVER_NAME`
                  - `IIS_APP_POOL`
                  - `IIS_ROLE_NAME`
                  - `JAVA_JAR_FILE`
                  - `JAVA_JAR_PATH`
                  - `JAVA_MAIN_CLASS`
                  - `JAVA_MAIN_MODULE`
                  - `JBOSS_HOME`
                  - `JBOSS_MODE`
                  - `JBOSS_SERVER_NAME`
                  - `KUBERNETES_BASE_POD_NAME`
                  - `KUBERNETES_CONTAINER_NAME`
                  - `KUBERNETES_FULL_POD_NAME`
                  - `KUBERNETES_NAMESPACE`
                  - `KUBERNETES_POD_UID`
                  - `MSSQL_INSTANCE_NAME`
                  - `NODE_JS_APP_BASE_DIRECTORY`
                  - `NODE_JS_APP_NAME`
                  - `NODE_JS_SCRIPT_NAME`
                  - `ORACLE_SID`
                  - `PG_ID_CALC_INPUT_KEY_LINKAGE`
                  - `PHP_SCRIPT_PATH`
                  - `PHP_WORKING_DIRECTORY`
                  - `RUBY_APP_ROOT_PATH`
                  - `RUBY_SCRIPT_PATH`
                  - `RULE_RESULT`
                  - `SOFTWAREAG_INSTALL_ROOT`
                  - `SOFTWAREAG_PRODUCTPROPNAME`
                  - `SPRINGBOOT_APP_NAME`
                  - `SPRINGBOOT_PROFILE_NAME`
                  - `SPRINGBOOT_STARTUP_CLASS`
                  - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
                  - `TIBCO_BUSINESSWORKS_CE_VERSION`
                  - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
                  - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
                  - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
                  - `TIBCO_BUSINESS_WORKS_HOME`
                  - `VARNISH_INSTANCE_NAME`
                  - `WEB_LOGIC_CLUSTER_NAME`
                  - `WEB_LOGIC_DOMAIN_NAME`
                  - `WEB_LOGIC_HOME`
                  - `WEB_LOGIC_NAME`
                  - `WEB_SPHERE_CELL_NAME`
                  - `WEB_SPHERE_CLUSTER_NAME`
                  - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
           - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
           - `AMAZON_ECR_IMAGE_REGION`
           - `AMAZON_LAMBDA_FUNCTION_NAME`
           - `AMAZON_REGION`
           - `APACHE_CONFIG_PATH`
           - `APACHE_SPARK_MASTER_IP_ADDRESS`
           - `ASP_DOT_NET_CORE_APPLICATION_PATH`
           - `AWS_ECS_CLUSTER`
           - `AWS_ECS_CONTAINERNAME`
           - `AWS_ECS_FAMILY`
           - `AWS_ECS_REVISION`
           - `CASSANDRA_CLUSTER_NAME`
           - `CATALINA_BASE`
           - `CATALINA_HOME`
           - `CLOUD_FOUNDRY_APP_ID`
           - `CLOUD_FOUNDRY_APP_NAME`
           - `CLOUD_FOUNDRY_INSTANCE_INDEX`
           - `CLOUD_FOUNDRY_SPACE_ID`
           - `CLOUD_FOUNDRY_SPACE_NAME`
           - `COLDFUSION_JVM_CONFIG_FILE`
           - `COLDFUSION_SERVICE_NAME`
           - `COMMAND_LINE_ARGS`
           - `DOTNET_COMMAND`
           - `DOTNET_COMMAND_PATH`
           - `DYNATRACE_CLUSTER_ID`
           - `DYNATRACE_NODE_ID`
           - `ELASTICSEARCH_CLUSTER_NAME`
           - `ELASTICSEARCH_NODE_NAME`
           - `EQUINOX_CONFIG_PATH`
           - `EXE_NAME`
           - `EXE_PATH`
           - `GLASS_FISH_DOMAIN_NAME`
           - `GLASS_FISH_INSTANCE_NAME`
           - `GOOGLE_APP_ENGINE_INSTANCE`
           - `GOOGLE_APP_ENGINE_SERVICE`
           - `GOOGLE_CLOUD_PROJECT`
           - `HYBRIS_BIN_DIRECTORY`
           - `HYBRIS_CONFIG_DIRECTORY`
           - `HYBRIS_DATA_DIRECTORY`
           - `IBM_CICS_REGION`
           - `IBM_CTG_NAME`
           - `IBM_IMS_CONNECT_REGION`
           - `IBM_IMS_CONTROL_REGION`
           - `IBM_IMS_MESSAGE_PROCESSING_REGION`
           - `IBM_IMS_SOAP_GW_NAME`
           - `IBM_INTEGRATION_NODE_NAME`
           - `IBM_INTEGRATION_SERVER_NAME`
           - `IIS_APP_POOL`
           - `IIS_ROLE_NAME`
           - `JAVA_JAR_FILE`
           - `JAVA_JAR_PATH`
           - `JAVA_MAIN_CLASS`
           - `JAVA_MAIN_MODULE`
           - `JBOSS_HOME`
           - `JBOSS_MODE`
           - `JBOSS_SERVER_NAME`
           - `KUBERNETES_BASE_POD_NAME`
           - `KUBERNETES_CONTAINER_NAME`
           - `KUBERNETES_FULL_POD_NAME`
           - `KUBERNETES_NAMESPACE`
           - `KUBERNETES_POD_UID`
           - `MSSQL_INSTANCE_NAME`
           - `NODE_JS_APP_BASE_DIRECTORY`
           - `NODE_JS_APP_NAME`
           - `NODE_JS_SCRIPT_NAME`
           - `ORACLE_SID`
           - `PG_ID_CALC_INPUT_KEY_LINKAGE`
           - `PHP_SCRIPT_PATH`
           - `PHP_WORKING_DIRECTORY`
           - `RUBY_APP_ROOT_PATH`
           - `RUBY_SCRIPT_PATH`
           - `RULE_RESULT`
           - `SOFTWAREAG_INSTALL_ROOT`
           - `SOFTWAREAG_PRODUCTPROPNAME`
           - `SPRINGBOOT_APP_NAME`
           - `SPRINGBOOT_PROFILE_NAME`
           - `SPRINGBOOT_STARTUP_CLASS`
           - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
           - `TIBCO_BUSINESSWORKS_CE_VERSION`
           - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
           - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
           - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
           - `TIBCO_BUSINESS_WORKS_HOME`
           - `VARNISH_INSTANCE_NAME`
           - `WEB_LOGIC_CLUSTER_NAME`
           - `WEB_LOGIC_DOMAIN_NAME`
           - `WEB_LOGIC_HOME`
           - `WEB_LOGIC_NAME`
           - `WEB_SPHERE_CELL_NAME`
           - `WEB_SPHERE_CLUSTER_NAME`
           - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionSyntheticEngine(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionSyntheticEngineTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SYNTHETIC_ENGINE_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SYNTHETIC_ENGINE_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionTagValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'AutotagRuleConditionTagValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionTagValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionTagComparisonValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be TAG
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'AutotagRuleConditionTagComparisonValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be TAG
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionTagComparisonValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionTechValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'AutotagRuleConditionTechValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionTechValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class AutotagRulesRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.AutotagRulesRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.AutotagRulesRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class AutotagRulesRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueNormalization":
            suggest = "value_normalization"
        elif key == "attributeRule":
            suggest = "attribute_rule"
        elif key == "entitySelector":
            suggest = "entity_selector"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRulesRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRulesRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRulesRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 type: str,
                 value_normalization: str,
                 attribute_rule: Optional['outputs.AutotagRulesRulesRuleAttributeRule'] = None,
                 entity_selector: Optional[str] = None,
                 value_format: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param str type: Possible Values: `ME`, `SELECTOR`
        :param str value_normalization: Possible Values: `Leave text as-is`, `To lower case`, `To upper case`
        :param 'AutotagRulesRulesRuleAttributeRuleArgs' attribute_rule: no documentation available
        :param str entity_selector: The documentation of the entity selector can be found [here](https://dt-url.net/apientityselector).
        :param str value_format: Optional tag value
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value_normalization", value_normalization)
        if attribute_rule is not None:
            pulumi.set(__self__, "attribute_rule", attribute_rule)
        if entity_selector is not None:
            pulumi.set(__self__, "entity_selector", entity_selector)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `ME`, `SELECTOR`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="valueNormalization")
    def value_normalization(self) -> str:
        """
        Possible Values: `Leave text as-is`, `To lower case`, `To upper case`
        """
        return pulumi.get(self, "value_normalization")

    @property
    @pulumi.getter(name="attributeRule")
    def attribute_rule(self) -> Optional['outputs.AutotagRulesRulesRuleAttributeRule']:
        """
        no documentation available
        """
        return pulumi.get(self, "attribute_rule")

    @property
    @pulumi.getter(name="entitySelector")
    def entity_selector(self) -> Optional[str]:
        """
        The documentation of the entity selector can be found [here](https://dt-url.net/apientityselector).
        """
        return pulumi.get(self, "entity_selector")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[str]:
        """
        Optional tag value
        """
        return pulumi.get(self, "value_format")


@pulumi.output_type
class AutotagRulesRulesRuleAttributeRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "azureToPgpropagation":
            suggest = "azure_to_pgpropagation"
        elif key == "azureToServicePropagation":
            suggest = "azure_to_service_propagation"
        elif key == "hostToPgpropagation":
            suggest = "host_to_pgpropagation"
        elif key == "pgToHostPropagation":
            suggest = "pg_to_host_propagation"
        elif key == "pgToServicePropagation":
            suggest = "pg_to_service_propagation"
        elif key == "serviceToHostPropagation":
            suggest = "service_to_host_propagation"
        elif key == "serviceToPgpropagation":
            suggest = "service_to_pgpropagation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRulesRulesRuleAttributeRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRulesRulesRuleAttributeRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRulesRulesRuleAttributeRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: 'outputs.AutotagRulesRulesRuleAttributeRuleConditions',
                 entity_type: str,
                 azure_to_pgpropagation: Optional[bool] = None,
                 azure_to_service_propagation: Optional[bool] = None,
                 host_to_pgpropagation: Optional[bool] = None,
                 pg_to_host_propagation: Optional[bool] = None,
                 pg_to_service_propagation: Optional[bool] = None,
                 service_to_host_propagation: Optional[bool] = None,
                 service_to_pgpropagation: Optional[bool] = None):
        """
        :param 'AutotagRulesRulesRuleAttributeRuleConditionsArgs' conditions: no documentation available
        :param str entity_type: Possible Values: `APPLICATION`, `AWS_APPLICATION_LOAD_BALANCER`, `AWS_CLASSIC_LOAD_BALANCER`, `AWS_NETWORK_LOAD_BALANCER`, `AWS_RELATIONAL_DATABASE_SERVICE`, `AZURE`, `CUSTOM_APPLICATION`, `CUSTOM_DEVICE`, `DCRUM_APPLICATION`, `ESXI_HOST`, `EXTERNAL_SYNTHETIC_TEST`, `HOST`, `HTTP_CHECK`, `MOBILE_APPLICATION`, `PROCESS_GROUP`, `SERVICE`, `SYNTHETIC_TEST`
        :param bool azure_to_pgpropagation: Apply to process groups connected to matching Azure entities
        :param bool azure_to_service_propagation: Apply to services provided by matching Azure entities
        :param bool host_to_pgpropagation: Apply to processes running on matching hosts
        :param bool pg_to_host_propagation: Apply to underlying hosts of matching process groups
        :param bool pg_to_service_propagation: Apply to all services provided by the process groups
        :param bool service_to_host_propagation: Apply to underlying hosts of matching services
        :param bool service_to_pgpropagation: Apply to underlying process groups of matching services
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "entity_type", entity_type)
        if azure_to_pgpropagation is not None:
            pulumi.set(__self__, "azure_to_pgpropagation", azure_to_pgpropagation)
        if azure_to_service_propagation is not None:
            pulumi.set(__self__, "azure_to_service_propagation", azure_to_service_propagation)
        if host_to_pgpropagation is not None:
            pulumi.set(__self__, "host_to_pgpropagation", host_to_pgpropagation)
        if pg_to_host_propagation is not None:
            pulumi.set(__self__, "pg_to_host_propagation", pg_to_host_propagation)
        if pg_to_service_propagation is not None:
            pulumi.set(__self__, "pg_to_service_propagation", pg_to_service_propagation)
        if service_to_host_propagation is not None:
            pulumi.set(__self__, "service_to_host_propagation", service_to_host_propagation)
        if service_to_pgpropagation is not None:
            pulumi.set(__self__, "service_to_pgpropagation", service_to_pgpropagation)

    @property
    @pulumi.getter
    def conditions(self) -> 'outputs.AutotagRulesRulesRuleAttributeRuleConditions':
        """
        no documentation available
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Possible Values: `APPLICATION`, `AWS_APPLICATION_LOAD_BALANCER`, `AWS_CLASSIC_LOAD_BALANCER`, `AWS_NETWORK_LOAD_BALANCER`, `AWS_RELATIONAL_DATABASE_SERVICE`, `AZURE`, `CUSTOM_APPLICATION`, `CUSTOM_DEVICE`, `DCRUM_APPLICATION`, `ESXI_HOST`, `EXTERNAL_SYNTHETIC_TEST`, `HOST`, `HTTP_CHECK`, `MOBILE_APPLICATION`, `PROCESS_GROUP`, `SERVICE`, `SYNTHETIC_TEST`
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="azureToPgpropagation")
    def azure_to_pgpropagation(self) -> Optional[bool]:
        """
        Apply to process groups connected to matching Azure entities
        """
        return pulumi.get(self, "azure_to_pgpropagation")

    @property
    @pulumi.getter(name="azureToServicePropagation")
    def azure_to_service_propagation(self) -> Optional[bool]:
        """
        Apply to services provided by matching Azure entities
        """
        return pulumi.get(self, "azure_to_service_propagation")

    @property
    @pulumi.getter(name="hostToPgpropagation")
    def host_to_pgpropagation(self) -> Optional[bool]:
        """
        Apply to processes running on matching hosts
        """
        return pulumi.get(self, "host_to_pgpropagation")

    @property
    @pulumi.getter(name="pgToHostPropagation")
    def pg_to_host_propagation(self) -> Optional[bool]:
        """
        Apply to underlying hosts of matching process groups
        """
        return pulumi.get(self, "pg_to_host_propagation")

    @property
    @pulumi.getter(name="pgToServicePropagation")
    def pg_to_service_propagation(self) -> Optional[bool]:
        """
        Apply to all services provided by the process groups
        """
        return pulumi.get(self, "pg_to_service_propagation")

    @property
    @pulumi.getter(name="serviceToHostPropagation")
    def service_to_host_propagation(self) -> Optional[bool]:
        """
        Apply to underlying hosts of matching services
        """
        return pulumi.get(self, "service_to_host_propagation")

    @property
    @pulumi.getter(name="serviceToPgpropagation")
    def service_to_pgpropagation(self) -> Optional[bool]:
        """
        Apply to underlying process groups of matching services
        """
        return pulumi.get(self, "service_to_pgpropagation")


@pulumi.output_type
class AutotagRulesRulesRuleAttributeRuleConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.AutotagRulesRulesRuleAttributeRuleConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.AutotagRulesRulesRuleAttributeRuleConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class AutotagRulesRulesRuleAttributeRuleConditionsCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "dynamicKey":
            suggest = "dynamic_key"
        elif key == "dynamicKeySource":
            suggest = "dynamic_key_source"
        elif key == "entityId":
            suggest = "entity_id"
        elif key == "enumValue":
            suggest = "enum_value"
        elif key == "integerValue":
            suggest = "integer_value"
        elif key == "stringValue":
            suggest = "string_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRulesRulesRuleAttributeRuleConditionsCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRulesRulesRuleAttributeRuleConditionsCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRulesRulesRuleAttributeRuleConditionsCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 dynamic_key: Optional[str] = None,
                 dynamic_key_source: Optional[str] = None,
                 entity_id: Optional[str] = None,
                 enum_value: Optional[str] = None,
                 integer_value: Optional[int] = None,
                 string_value: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        :param str key: Possible Values: `APPMON_SERVER_NAME`, `APPMON_SYSTEM_PROFILE_NAME`, `AWS_ACCOUNT_ID`, `AWS_ACCOUNT_NAME`, `AWS_APPLICATION_LOAD_BALANCER_NAME`, `AWS_APPLICATION_LOAD_BALANCER_TAGS`, `AWS_AUTO_SCALING_GROUP_NAME`, `AWS_AUTO_SCALING_GROUP_TAGS`, `AWS_AVAILABILITY_ZONE_NAME`, `AWS_CLASSIC_LOAD_BALANCER_FRONTEND_PORTS`, `AWS_CLASSIC_LOAD_BALANCER_NAME`, `AWS_CLASSIC_LOAD_BALANCER_TAGS`, `AWS_NETWORK_LOAD_BALANCER_NAME`, `AWS_NETWORK_LOAD_BALANCER_TAGS`, `AWS_RELATIONAL_DATABASE_SERVICE_DB_NAME`, `AWS_RELATIONAL_DATABASE_SERVICE_ENDPOINT`, `AWS_RELATIONAL_DATABASE_SERVICE_ENGINE`, `AWS_RELATIONAL_DATABASE_SERVICE_INSTANCE_CLASS`, `AWS_RELATIONAL_DATABASE_SERVICE_NAME`, `AWS_RELATIONAL_DATABASE_SERVICE_PORT`, `AWS_RELATIONAL_DATABASE_SERVICE_TAGS`, `AZURE_ENTITY_NAME`, `AZURE_ENTITY_TAGS`, `AZURE_MGMT_GROUP_NAME`, `AZURE_MGMT_GROUP_UUID`, `AZURE_REGION_NAME`, `AZURE_SCALE_SET_NAME`, `AZURE_SUBSCRIPTION_NAME`, `AZURE_SUBSCRIPTION_UUID`, `AZURE_TENANT_NAME`, `AZURE_TENANT_UUID`, `AZURE_VM_NAME`, `BROWSER_MONITOR_NAME`, `BROWSER_MONITOR_TAGS`, `CLOUD_APPLICATION_LABELS`, `CLOUD_APPLICATION_NAME`, `CLOUD_APPLICATION_NAMESPACE_LABELS`, `CLOUD_APPLICATION_NAMESPACE_NAME`, `CLOUD_FOUNDRY_FOUNDATION_NAME`, `CLOUD_FOUNDRY_ORG_NAME`, `CUSTOM_APPLICATION_NAME`, `CUSTOM_APPLICATION_PLATFORM`, `CUSTOM_APPLICATION_TAGS`, `CUSTOM_APPLICATION_TYPE`, `CUSTOM_DEVICE_DNS_ADDRESS`, `CUSTOM_DEVICE_GROUP_NAME`, `CUSTOM_DEVICE_GROUP_TAGS`, `CUSTOM_DEVICE_IP_ADDRESS`, `CUSTOM_DEVICE_METADATA`, `CUSTOM_DEVICE_NAME`, `CUSTOM_DEVICE_PORT`, `CUSTOM_DEVICE_TAGS`, `CUSTOM_DEVICE_TECHNOLOGY`, `DATA_CENTER_SERVICE_DECODER_TYPE`, `DATA_CENTER_SERVICE_IP_ADDRESS`, `DATA_CENTER_SERVICE_METADATA`, `DATA_CENTER_SERVICE_NAME`, `DATA_CENTER_SERVICE_PORT`, `DATA_CENTER_SERVICE_TAGS`, `DOCKER_CONTAINER_NAME`, `DOCKER_FULL_IMAGE_NAME`, `DOCKER_IMAGE_VERSION`, `EC2_INSTANCE_AMI_ID`, `EC2_INSTANCE_AWS_INSTANCE_TYPE`, `EC2_INSTANCE_AWS_SECURITY_GROUP`, `EC2_INSTANCE_BEANSTALK_ENV_NAME`, `EC2_INSTANCE_ID`, `EC2_INSTANCE_NAME`, `EC2_INSTANCE_PRIVATE_HOST_NAME`, `EC2_INSTANCE_PUBLIC_HOST_NAME`, `EC2_INSTANCE_TAGS`, `ENTERPRISE_APPLICATION_DECODER_TYPE`, `ENTERPRISE_APPLICATION_IP_ADDRESS`, `ENTERPRISE_APPLICATION_METADATA`, `ENTERPRISE_APPLICATION_NAME`, `ENTERPRISE_APPLICATION_PORT`, `ENTERPRISE_APPLICATION_TAGS`, `ESXI_HOST_CLUSTER_NAME`, `ESXI_HOST_HARDWARE_MODEL`, `ESXI_HOST_HARDWARE_VENDOR`, `ESXI_HOST_NAME`, `ESXI_HOST_PRODUCT_NAME`, `ESXI_HOST_PRODUCT_VERSION`, `ESXI_HOST_TAGS`, `EXTERNAL_MONITOR_ENGINE_DESCRIPTION`, `EXTERNAL_MONITOR_ENGINE_NAME`, `EXTERNAL_MONITOR_ENGINE_TYPE`, `EXTERNAL_MONITOR_NAME`, `EXTERNAL_MONITOR_TAGS`, `GEOLOCATION_SITE_NAME`, `GOOGLE_CLOUD_PLATFORM_ZONE_NAME`, `GOOGLE_COMPUTE_INSTANCE_ID`, `GOOGLE_COMPUTE_INSTANCE_MACHINE_TYPE`, `GOOGLE_COMPUTE_INSTANCE_NAME`, `GOOGLE_COMPUTE_INSTANCE_PROJECT`, `GOOGLE_COMPUTE_INSTANCE_PROJECT_ID`, `GOOGLE_COMPUTE_INSTANCE_PUBLIC_IP_ADDRESSES`, `HOST_AIX_LOGICAL_CPU_COUNT`, `HOST_AIX_SIMULTANEOUS_THREADS`, `HOST_AIX_VIRTUAL_CPU_COUNT`, `HOST_ARCHITECTURE`, `HOST_AWS_NAME_TAG`, `HOST_AZURE_COMPUTE_MODE`, `HOST_AZURE_SKU`, `HOST_AZURE_WEB_APPLICATION_HOST_NAMES`, `HOST_AZURE_WEB_APPLICATION_SITE_NAMES`, `HOST_BITNESS`, `HOST_BOSH_AVAILABILITY_ZONE`, `HOST_BOSH_DEPLOYMENT_ID`, `HOST_BOSH_INSTANCE_ID`, `HOST_BOSH_INSTANCE_NAME`, `HOST_BOSH_NAME`, `HOST_BOSH_STEMCELL_VERSION`, `HOST_CLOUD_TYPE`, `HOST_CPU_CORES`, `HOST_CUSTOM_METADATA`, `HOST_DETECTED_NAME`, `HOST_GROUP_ID`, `HOST_GROUP_NAME`, `HOST_HYPERVISOR_TYPE`, `HOST_IP_ADDRESS`, `HOST_KUBERNETES_LABELS`, `HOST_LOGICAL_CPU_CORES`, `HOST_NAME`, `HOST_ONEAGENT_CUSTOM_HOST_NAME`, `HOST_OS_TYPE`, `HOST_OS_VERSION`, `HOST_PAAS_MEMORY_LIMIT`, `HOST_PAAS_TYPE`, `HOST_TAGS`, `HOST_TECHNOLOGY`, `HTTP_MONITOR_NAME`, `HTTP_MONITOR_TAGS`, `KUBERNETES_CLUSTER_NAME`, `KUBERNETES_NODE_NAME`, `KUBERNETES_SERVICE_NAME`, `MOBILE_APPLICATION_NAME`, `MOBILE_APPLICATION_PLATFORM`, `MOBILE_APPLICATION_TAGS`, `NAME_OF_COMPUTE_NODE`, `OPENSTACK_ACCOUNT_NAME`, `OPENSTACK_ACCOUNT_PROJECT_NAME`, `OPENSTACK_AVAILABILITY_ZONE_NAME`, `OPENSTACK_PROJECT_NAME`, `OPENSTACK_REGION_NAME`, `OPENSTACK_VM_INSTANCE_TYPE`, `OPENSTACK_VM_NAME`, `OPENSTACK_VM_SECURITY_GROUP`, `PROCESS_GROUP_AZURE_HOST_NAME`, `PROCESS_GROUP_AZURE_SITE_NAME`, `PROCESS_GROUP_CUSTOM_METADATA`, `PROCESS_GROUP_DETECTED_NAME`, `PROCESS_GROUP_ID`, `PROCESS_GROUP_LISTEN_PORT`, `PROCESS_GROUP_NAME`, `PROCESS_GROUP_PREDEFINED_METADATA`, `PROCESS_GROUP_TAGS`, `PROCESS_GROUP_TECHNOLOGY`, `PROCESS_GROUP_TECHNOLOGY_EDITION`, `PROCESS_GROUP_TECHNOLOGY_VERSION`, `QUEUE_NAME`, `QUEUE_TECHNOLOGY`, `QUEUE_VENDOR`, `SERVICE_AKKA_ACTOR_SYSTEM`, `SERVICE_CTG_SERVICE_NAME`, `SERVICE_DATABASE_HOST_NAME`, `SERVICE_DATABASE_NAME`, `SERVICE_DATABASE_TOPOLOGY`, `SERVICE_DATABASE_VENDOR`, `SERVICE_DETECTED_NAME`, `SERVICE_ESB_APPLICATION_NAME`, `SERVICE_IBM_CTG_GATEWAY_URL`, `SERVICE_MESSAGING_LISTENER_CLASS_NAME`, `SERVICE_NAME`, `SERVICE_PORT`, `SERVICE_PUBLIC_DOMAIN_NAME`, `SERVICE_REMOTE_ENDPOINT`, `SERVICE_REMOTE_SERVICE_NAME`, `SERVICE_TAGS`, `SERVICE_TECHNOLOGY`, `SERVICE_TECHNOLOGY_EDITION`, `SERVICE_TECHNOLOGY_VERSION`, `SERVICE_TOPOLOGY`, `SERVICE_TYPE`, `SERVICE_WEB_APPLICATION_ID`, `SERVICE_WEB_CONTEXT_ROOT`, `SERVICE_WEB_SERVER_ENDPOINT`, `SERVICE_WEB_SERVER_NAME`, `SERVICE_WEB_SERVICE_NAME`, `SERVICE_WEB_SERVICE_NAMESPACE`, `VMWARE_DATACENTER_NAME`, `VMWARE_VM_NAME`, `WEB_APPLICATION_NAME`, `WEB_APPLICATION_NAME_PATTERN`, `WEB_APPLICATION_TAGS`, `WEB_APPLICATION_TYPE`
        :param str operator: Possible Values: `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EXISTS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `IS_IP_IN_RANGE`, `LOWER_THAN`, `LOWER_THAN_OR_EQUAL`, `NOT_BEGINS_WITH`, `NOT_CONTAINS`, `NOT_ENDS_WITH`, `NOT_EQUALS`, `NOT_EXISTS`, `NOT_GREATER_THAN`, `NOT_GREATER_THAN_OR_EQUAL`, `NOT_IS_IP_IN_RANGE`, `NOT_LOWER_THAN`, `NOT_LOWER_THAN_OR_EQUAL`, `NOT_REGEX_MATCHES`, `NOT_TAG_KEY_EQUALS`, `REGEX_MATCHES`, `TAG_KEY_EQUALS`
        :param bool case_sensitive: Case sensitive
        :param str dynamic_key: Dynamic key
        :param str dynamic_key_source: Key source
        :param str entity_id: Value
        :param str enum_value: Value
        :param int integer_value: Value
        :param str string_value: Value
        :param str tag: Format: `[CONTEXT]tagKey:tagValue`
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if dynamic_key is not None:
            pulumi.set(__self__, "dynamic_key", dynamic_key)
        if dynamic_key_source is not None:
            pulumi.set(__self__, "dynamic_key_source", dynamic_key_source)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if enum_value is not None:
            pulumi.set(__self__, "enum_value", enum_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Possible Values: `APPMON_SERVER_NAME`, `APPMON_SYSTEM_PROFILE_NAME`, `AWS_ACCOUNT_ID`, `AWS_ACCOUNT_NAME`, `AWS_APPLICATION_LOAD_BALANCER_NAME`, `AWS_APPLICATION_LOAD_BALANCER_TAGS`, `AWS_AUTO_SCALING_GROUP_NAME`, `AWS_AUTO_SCALING_GROUP_TAGS`, `AWS_AVAILABILITY_ZONE_NAME`, `AWS_CLASSIC_LOAD_BALANCER_FRONTEND_PORTS`, `AWS_CLASSIC_LOAD_BALANCER_NAME`, `AWS_CLASSIC_LOAD_BALANCER_TAGS`, `AWS_NETWORK_LOAD_BALANCER_NAME`, `AWS_NETWORK_LOAD_BALANCER_TAGS`, `AWS_RELATIONAL_DATABASE_SERVICE_DB_NAME`, `AWS_RELATIONAL_DATABASE_SERVICE_ENDPOINT`, `AWS_RELATIONAL_DATABASE_SERVICE_ENGINE`, `AWS_RELATIONAL_DATABASE_SERVICE_INSTANCE_CLASS`, `AWS_RELATIONAL_DATABASE_SERVICE_NAME`, `AWS_RELATIONAL_DATABASE_SERVICE_PORT`, `AWS_RELATIONAL_DATABASE_SERVICE_TAGS`, `AZURE_ENTITY_NAME`, `AZURE_ENTITY_TAGS`, `AZURE_MGMT_GROUP_NAME`, `AZURE_MGMT_GROUP_UUID`, `AZURE_REGION_NAME`, `AZURE_SCALE_SET_NAME`, `AZURE_SUBSCRIPTION_NAME`, `AZURE_SUBSCRIPTION_UUID`, `AZURE_TENANT_NAME`, `AZURE_TENANT_UUID`, `AZURE_VM_NAME`, `BROWSER_MONITOR_NAME`, `BROWSER_MONITOR_TAGS`, `CLOUD_APPLICATION_LABELS`, `CLOUD_APPLICATION_NAME`, `CLOUD_APPLICATION_NAMESPACE_LABELS`, `CLOUD_APPLICATION_NAMESPACE_NAME`, `CLOUD_FOUNDRY_FOUNDATION_NAME`, `CLOUD_FOUNDRY_ORG_NAME`, `CUSTOM_APPLICATION_NAME`, `CUSTOM_APPLICATION_PLATFORM`, `CUSTOM_APPLICATION_TAGS`, `CUSTOM_APPLICATION_TYPE`, `CUSTOM_DEVICE_DNS_ADDRESS`, `CUSTOM_DEVICE_GROUP_NAME`, `CUSTOM_DEVICE_GROUP_TAGS`, `CUSTOM_DEVICE_IP_ADDRESS`, `CUSTOM_DEVICE_METADATA`, `CUSTOM_DEVICE_NAME`, `CUSTOM_DEVICE_PORT`, `CUSTOM_DEVICE_TAGS`, `CUSTOM_DEVICE_TECHNOLOGY`, `DATA_CENTER_SERVICE_DECODER_TYPE`, `DATA_CENTER_SERVICE_IP_ADDRESS`, `DATA_CENTER_SERVICE_METADATA`, `DATA_CENTER_SERVICE_NAME`, `DATA_CENTER_SERVICE_PORT`, `DATA_CENTER_SERVICE_TAGS`, `DOCKER_CONTAINER_NAME`, `DOCKER_FULL_IMAGE_NAME`, `DOCKER_IMAGE_VERSION`, `EC2_INSTANCE_AMI_ID`, `EC2_INSTANCE_AWS_INSTANCE_TYPE`, `EC2_INSTANCE_AWS_SECURITY_GROUP`, `EC2_INSTANCE_BEANSTALK_ENV_NAME`, `EC2_INSTANCE_ID`, `EC2_INSTANCE_NAME`, `EC2_INSTANCE_PRIVATE_HOST_NAME`, `EC2_INSTANCE_PUBLIC_HOST_NAME`, `EC2_INSTANCE_TAGS`, `ENTERPRISE_APPLICATION_DECODER_TYPE`, `ENTERPRISE_APPLICATION_IP_ADDRESS`, `ENTERPRISE_APPLICATION_METADATA`, `ENTERPRISE_APPLICATION_NAME`, `ENTERPRISE_APPLICATION_PORT`, `ENTERPRISE_APPLICATION_TAGS`, `ESXI_HOST_CLUSTER_NAME`, `ESXI_HOST_HARDWARE_MODEL`, `ESXI_HOST_HARDWARE_VENDOR`, `ESXI_HOST_NAME`, `ESXI_HOST_PRODUCT_NAME`, `ESXI_HOST_PRODUCT_VERSION`, `ESXI_HOST_TAGS`, `EXTERNAL_MONITOR_ENGINE_DESCRIPTION`, `EXTERNAL_MONITOR_ENGINE_NAME`, `EXTERNAL_MONITOR_ENGINE_TYPE`, `EXTERNAL_MONITOR_NAME`, `EXTERNAL_MONITOR_TAGS`, `GEOLOCATION_SITE_NAME`, `GOOGLE_CLOUD_PLATFORM_ZONE_NAME`, `GOOGLE_COMPUTE_INSTANCE_ID`, `GOOGLE_COMPUTE_INSTANCE_MACHINE_TYPE`, `GOOGLE_COMPUTE_INSTANCE_NAME`, `GOOGLE_COMPUTE_INSTANCE_PROJECT`, `GOOGLE_COMPUTE_INSTANCE_PROJECT_ID`, `GOOGLE_COMPUTE_INSTANCE_PUBLIC_IP_ADDRESSES`, `HOST_AIX_LOGICAL_CPU_COUNT`, `HOST_AIX_SIMULTANEOUS_THREADS`, `HOST_AIX_VIRTUAL_CPU_COUNT`, `HOST_ARCHITECTURE`, `HOST_AWS_NAME_TAG`, `HOST_AZURE_COMPUTE_MODE`, `HOST_AZURE_SKU`, `HOST_AZURE_WEB_APPLICATION_HOST_NAMES`, `HOST_AZURE_WEB_APPLICATION_SITE_NAMES`, `HOST_BITNESS`, `HOST_BOSH_AVAILABILITY_ZONE`, `HOST_BOSH_DEPLOYMENT_ID`, `HOST_BOSH_INSTANCE_ID`, `HOST_BOSH_INSTANCE_NAME`, `HOST_BOSH_NAME`, `HOST_BOSH_STEMCELL_VERSION`, `HOST_CLOUD_TYPE`, `HOST_CPU_CORES`, `HOST_CUSTOM_METADATA`, `HOST_DETECTED_NAME`, `HOST_GROUP_ID`, `HOST_GROUP_NAME`, `HOST_HYPERVISOR_TYPE`, `HOST_IP_ADDRESS`, `HOST_KUBERNETES_LABELS`, `HOST_LOGICAL_CPU_CORES`, `HOST_NAME`, `HOST_ONEAGENT_CUSTOM_HOST_NAME`, `HOST_OS_TYPE`, `HOST_OS_VERSION`, `HOST_PAAS_MEMORY_LIMIT`, `HOST_PAAS_TYPE`, `HOST_TAGS`, `HOST_TECHNOLOGY`, `HTTP_MONITOR_NAME`, `HTTP_MONITOR_TAGS`, `KUBERNETES_CLUSTER_NAME`, `KUBERNETES_NODE_NAME`, `KUBERNETES_SERVICE_NAME`, `MOBILE_APPLICATION_NAME`, `MOBILE_APPLICATION_PLATFORM`, `MOBILE_APPLICATION_TAGS`, `NAME_OF_COMPUTE_NODE`, `OPENSTACK_ACCOUNT_NAME`, `OPENSTACK_ACCOUNT_PROJECT_NAME`, `OPENSTACK_AVAILABILITY_ZONE_NAME`, `OPENSTACK_PROJECT_NAME`, `OPENSTACK_REGION_NAME`, `OPENSTACK_VM_INSTANCE_TYPE`, `OPENSTACK_VM_NAME`, `OPENSTACK_VM_SECURITY_GROUP`, `PROCESS_GROUP_AZURE_HOST_NAME`, `PROCESS_GROUP_AZURE_SITE_NAME`, `PROCESS_GROUP_CUSTOM_METADATA`, `PROCESS_GROUP_DETECTED_NAME`, `PROCESS_GROUP_ID`, `PROCESS_GROUP_LISTEN_PORT`, `PROCESS_GROUP_NAME`, `PROCESS_GROUP_PREDEFINED_METADATA`, `PROCESS_GROUP_TAGS`, `PROCESS_GROUP_TECHNOLOGY`, `PROCESS_GROUP_TECHNOLOGY_EDITION`, `PROCESS_GROUP_TECHNOLOGY_VERSION`, `QUEUE_NAME`, `QUEUE_TECHNOLOGY`, `QUEUE_VENDOR`, `SERVICE_AKKA_ACTOR_SYSTEM`, `SERVICE_CTG_SERVICE_NAME`, `SERVICE_DATABASE_HOST_NAME`, `SERVICE_DATABASE_NAME`, `SERVICE_DATABASE_TOPOLOGY`, `SERVICE_DATABASE_VENDOR`, `SERVICE_DETECTED_NAME`, `SERVICE_ESB_APPLICATION_NAME`, `SERVICE_IBM_CTG_GATEWAY_URL`, `SERVICE_MESSAGING_LISTENER_CLASS_NAME`, `SERVICE_NAME`, `SERVICE_PORT`, `SERVICE_PUBLIC_DOMAIN_NAME`, `SERVICE_REMOTE_ENDPOINT`, `SERVICE_REMOTE_SERVICE_NAME`, `SERVICE_TAGS`, `SERVICE_TECHNOLOGY`, `SERVICE_TECHNOLOGY_EDITION`, `SERVICE_TECHNOLOGY_VERSION`, `SERVICE_TOPOLOGY`, `SERVICE_TYPE`, `SERVICE_WEB_APPLICATION_ID`, `SERVICE_WEB_CONTEXT_ROOT`, `SERVICE_WEB_SERVER_ENDPOINT`, `SERVICE_WEB_SERVER_NAME`, `SERVICE_WEB_SERVICE_NAME`, `SERVICE_WEB_SERVICE_NAMESPACE`, `VMWARE_DATACENTER_NAME`, `VMWARE_VM_NAME`, `WEB_APPLICATION_NAME`, `WEB_APPLICATION_NAME_PATTERN`, `WEB_APPLICATION_TAGS`, `WEB_APPLICATION_TYPE`
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Possible Values: `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EXISTS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `IS_IP_IN_RANGE`, `LOWER_THAN`, `LOWER_THAN_OR_EQUAL`, `NOT_BEGINS_WITH`, `NOT_CONTAINS`, `NOT_ENDS_WITH`, `NOT_EQUALS`, `NOT_EXISTS`, `NOT_GREATER_THAN`, `NOT_GREATER_THAN_OR_EQUAL`, `NOT_IS_IP_IN_RANGE`, `NOT_LOWER_THAN`, `NOT_LOWER_THAN_OR_EQUAL`, `NOT_REGEX_MATCHES`, `NOT_TAG_KEY_EQUALS`, `REGEX_MATCHES`, `TAG_KEY_EQUALS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        Case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> Optional[str]:
        """
        Dynamic key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter(name="dynamicKeySource")
    def dynamic_key_source(self) -> Optional[str]:
        """
        Key source
        """
        return pulumi.get(self, "dynamic_key_source")

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[str]:
        """
        Value
        """
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter(name="enumValue")
    def enum_value(self) -> Optional[str]:
        """
        Value
        """
        return pulumi.get(self, "enum_value")

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[int]:
        """
        Value
        """
        return pulumi.get(self, "integer_value")

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[str]:
        """
        Value
        """
        return pulumi.get(self, "string_value")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Format: `[CONTEXT]tagKey:tagValue`
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class AutotagV2Rules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.AutotagV2RulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.AutotagV2RulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class AutotagV2RulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueNormalization":
            suggest = "value_normalization"
        elif key == "attributeRule":
            suggest = "attribute_rule"
        elif key == "entitySelector":
            suggest = "entity_selector"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagV2RulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagV2RulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagV2RulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 type: str,
                 value_normalization: str,
                 attribute_rule: Optional['outputs.AutotagV2RulesRuleAttributeRule'] = None,
                 entity_selector: Optional[str] = None,
                 value_format: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param str type: Possible Values: `ME`, `SELECTOR`
        :param str value_normalization: Possible Values: `Leave text as-is`, `To lower case`, `To upper case`
        :param 'AutotagV2RulesRuleAttributeRuleArgs' attribute_rule: no documentation available
        :param str entity_selector: The documentation of the entity selector can be found [here](https://dt-url.net/apientityselector).
        :param str value_format: Optional tag value
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value_normalization", value_normalization)
        if attribute_rule is not None:
            pulumi.set(__self__, "attribute_rule", attribute_rule)
        if entity_selector is not None:
            pulumi.set(__self__, "entity_selector", entity_selector)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `ME`, `SELECTOR`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="valueNormalization")
    def value_normalization(self) -> str:
        """
        Possible Values: `Leave text as-is`, `To lower case`, `To upper case`
        """
        return pulumi.get(self, "value_normalization")

    @property
    @pulumi.getter(name="attributeRule")
    def attribute_rule(self) -> Optional['outputs.AutotagV2RulesRuleAttributeRule']:
        """
        no documentation available
        """
        return pulumi.get(self, "attribute_rule")

    @property
    @pulumi.getter(name="entitySelector")
    def entity_selector(self) -> Optional[str]:
        """
        The documentation of the entity selector can be found [here](https://dt-url.net/apientityselector).
        """
        return pulumi.get(self, "entity_selector")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[str]:
        """
        Optional tag value
        """
        return pulumi.get(self, "value_format")


@pulumi.output_type
class AutotagV2RulesRuleAttributeRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "azureToPgpropagation":
            suggest = "azure_to_pgpropagation"
        elif key == "azureToServicePropagation":
            suggest = "azure_to_service_propagation"
        elif key == "hostToPgpropagation":
            suggest = "host_to_pgpropagation"
        elif key == "pgToHostPropagation":
            suggest = "pg_to_host_propagation"
        elif key == "pgToServicePropagation":
            suggest = "pg_to_service_propagation"
        elif key == "serviceToHostPropagation":
            suggest = "service_to_host_propagation"
        elif key == "serviceToPgpropagation":
            suggest = "service_to_pgpropagation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagV2RulesRuleAttributeRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagV2RulesRuleAttributeRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagV2RulesRuleAttributeRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: 'outputs.AutotagV2RulesRuleAttributeRuleConditions',
                 entity_type: str,
                 azure_to_pgpropagation: Optional[bool] = None,
                 azure_to_service_propagation: Optional[bool] = None,
                 host_to_pgpropagation: Optional[bool] = None,
                 pg_to_host_propagation: Optional[bool] = None,
                 pg_to_service_propagation: Optional[bool] = None,
                 service_to_host_propagation: Optional[bool] = None,
                 service_to_pgpropagation: Optional[bool] = None):
        """
        :param 'AutotagV2RulesRuleAttributeRuleConditionsArgs' conditions: no documentation available
        :param str entity_type: Possible Values: `APPLICATION`, `AWS_APPLICATION_LOAD_BALANCER`, `AWS_CLASSIC_LOAD_BALANCER`, `AWS_NETWORK_LOAD_BALANCER`, `AWS_RELATIONAL_DATABASE_SERVICE`, `AZURE`, `CUSTOM_APPLICATION`, `CUSTOM_DEVICE`, `DCRUM_APPLICATION`, `ESXI_HOST`, `EXTERNAL_SYNTHETIC_TEST`, `HOST`, `HTTP_CHECK`, `MOBILE_APPLICATION`, `PROCESS_GROUP`, `SERVICE`, `SYNTHETIC_TEST`
        :param bool azure_to_pgpropagation: Apply to process groups connected to matching Azure entities
        :param bool azure_to_service_propagation: Apply to services provided by matching Azure entities
        :param bool host_to_pgpropagation: Apply to processes running on matching hosts
        :param bool pg_to_host_propagation: Apply to underlying hosts of matching process groups
        :param bool pg_to_service_propagation: Apply to all services provided by the process groups
        :param bool service_to_host_propagation: Apply to underlying hosts of matching services
        :param bool service_to_pgpropagation: Apply to underlying process groups of matching services
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "entity_type", entity_type)
        if azure_to_pgpropagation is not None:
            pulumi.set(__self__, "azure_to_pgpropagation", azure_to_pgpropagation)
        if azure_to_service_propagation is not None:
            pulumi.set(__self__, "azure_to_service_propagation", azure_to_service_propagation)
        if host_to_pgpropagation is not None:
            pulumi.set(__self__, "host_to_pgpropagation", host_to_pgpropagation)
        if pg_to_host_propagation is not None:
            pulumi.set(__self__, "pg_to_host_propagation", pg_to_host_propagation)
        if pg_to_service_propagation is not None:
            pulumi.set(__self__, "pg_to_service_propagation", pg_to_service_propagation)
        if service_to_host_propagation is not None:
            pulumi.set(__self__, "service_to_host_propagation", service_to_host_propagation)
        if service_to_pgpropagation is not None:
            pulumi.set(__self__, "service_to_pgpropagation", service_to_pgpropagation)

    @property
    @pulumi.getter
    def conditions(self) -> 'outputs.AutotagV2RulesRuleAttributeRuleConditions':
        """
        no documentation available
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Possible Values: `APPLICATION`, `AWS_APPLICATION_LOAD_BALANCER`, `AWS_CLASSIC_LOAD_BALANCER`, `AWS_NETWORK_LOAD_BALANCER`, `AWS_RELATIONAL_DATABASE_SERVICE`, `AZURE`, `CUSTOM_APPLICATION`, `CUSTOM_DEVICE`, `DCRUM_APPLICATION`, `ESXI_HOST`, `EXTERNAL_SYNTHETIC_TEST`, `HOST`, `HTTP_CHECK`, `MOBILE_APPLICATION`, `PROCESS_GROUP`, `SERVICE`, `SYNTHETIC_TEST`
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="azureToPgpropagation")
    def azure_to_pgpropagation(self) -> Optional[bool]:
        """
        Apply to process groups connected to matching Azure entities
        """
        return pulumi.get(self, "azure_to_pgpropagation")

    @property
    @pulumi.getter(name="azureToServicePropagation")
    def azure_to_service_propagation(self) -> Optional[bool]:
        """
        Apply to services provided by matching Azure entities
        """
        return pulumi.get(self, "azure_to_service_propagation")

    @property
    @pulumi.getter(name="hostToPgpropagation")
    def host_to_pgpropagation(self) -> Optional[bool]:
        """
        Apply to processes running on matching hosts
        """
        return pulumi.get(self, "host_to_pgpropagation")

    @property
    @pulumi.getter(name="pgToHostPropagation")
    def pg_to_host_propagation(self) -> Optional[bool]:
        """
        Apply to underlying hosts of matching process groups
        """
        return pulumi.get(self, "pg_to_host_propagation")

    @property
    @pulumi.getter(name="pgToServicePropagation")
    def pg_to_service_propagation(self) -> Optional[bool]:
        """
        Apply to all services provided by the process groups
        """
        return pulumi.get(self, "pg_to_service_propagation")

    @property
    @pulumi.getter(name="serviceToHostPropagation")
    def service_to_host_propagation(self) -> Optional[bool]:
        """
        Apply to underlying hosts of matching services
        """
        return pulumi.get(self, "service_to_host_propagation")

    @property
    @pulumi.getter(name="serviceToPgpropagation")
    def service_to_pgpropagation(self) -> Optional[bool]:
        """
        Apply to underlying process groups of matching services
        """
        return pulumi.get(self, "service_to_pgpropagation")


@pulumi.output_type
class AutotagV2RulesRuleAttributeRuleConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.AutotagV2RulesRuleAttributeRuleConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.AutotagV2RulesRuleAttributeRuleConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class AutotagV2RulesRuleAttributeRuleConditionsCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "dynamicKey":
            suggest = "dynamic_key"
        elif key == "dynamicKeySource":
            suggest = "dynamic_key_source"
        elif key == "entityId":
            suggest = "entity_id"
        elif key == "enumValue":
            suggest = "enum_value"
        elif key == "integerValue":
            suggest = "integer_value"
        elif key == "stringValue":
            suggest = "string_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagV2RulesRuleAttributeRuleConditionsCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagV2RulesRuleAttributeRuleConditionsCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagV2RulesRuleAttributeRuleConditionsCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 dynamic_key: Optional[str] = None,
                 dynamic_key_source: Optional[str] = None,
                 entity_id: Optional[str] = None,
                 enum_value: Optional[str] = None,
                 integer_value: Optional[int] = None,
                 string_value: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        :param str key: Possible Values: `APPMON_SERVER_NAME`, `APPMON_SYSTEM_PROFILE_NAME`, `AWS_ACCOUNT_ID`, `AWS_ACCOUNT_NAME`, `AWS_APPLICATION_LOAD_BALANCER_NAME`, `AWS_APPLICATION_LOAD_BALANCER_TAGS`, `AWS_AUTO_SCALING_GROUP_NAME`, `AWS_AUTO_SCALING_GROUP_TAGS`, `AWS_AVAILABILITY_ZONE_NAME`, `AWS_CLASSIC_LOAD_BALANCER_FRONTEND_PORTS`, `AWS_CLASSIC_LOAD_BALANCER_NAME`, `AWS_CLASSIC_LOAD_BALANCER_TAGS`, `AWS_NETWORK_LOAD_BALANCER_NAME`, `AWS_NETWORK_LOAD_BALANCER_TAGS`, `AWS_RELATIONAL_DATABASE_SERVICE_DB_NAME`, `AWS_RELATIONAL_DATABASE_SERVICE_ENDPOINT`, `AWS_RELATIONAL_DATABASE_SERVICE_ENGINE`, `AWS_RELATIONAL_DATABASE_SERVICE_INSTANCE_CLASS`, `AWS_RELATIONAL_DATABASE_SERVICE_NAME`, `AWS_RELATIONAL_DATABASE_SERVICE_PORT`, `AWS_RELATIONAL_DATABASE_SERVICE_TAGS`, `AZURE_ENTITY_NAME`, `AZURE_ENTITY_TAGS`, `AZURE_MGMT_GROUP_NAME`, `AZURE_MGMT_GROUP_UUID`, `AZURE_REGION_NAME`, `AZURE_SCALE_SET_NAME`, `AZURE_SUBSCRIPTION_NAME`, `AZURE_SUBSCRIPTION_UUID`, `AZURE_TENANT_NAME`, `AZURE_TENANT_UUID`, `AZURE_VM_NAME`, `BROWSER_MONITOR_NAME`, `BROWSER_MONITOR_TAGS`, `CLOUD_APPLICATION_LABELS`, `CLOUD_APPLICATION_NAME`, `CLOUD_APPLICATION_NAMESPACE_LABELS`, `CLOUD_APPLICATION_NAMESPACE_NAME`, `CLOUD_FOUNDRY_FOUNDATION_NAME`, `CLOUD_FOUNDRY_ORG_NAME`, `CUSTOM_APPLICATION_NAME`, `CUSTOM_APPLICATION_PLATFORM`, `CUSTOM_APPLICATION_TAGS`, `CUSTOM_APPLICATION_TYPE`, `CUSTOM_DEVICE_DNS_ADDRESS`, `CUSTOM_DEVICE_GROUP_NAME`, `CUSTOM_DEVICE_GROUP_TAGS`, `CUSTOM_DEVICE_IP_ADDRESS`, `CUSTOM_DEVICE_METADATA`, `CUSTOM_DEVICE_NAME`, `CUSTOM_DEVICE_PORT`, `CUSTOM_DEVICE_TAGS`, `CUSTOM_DEVICE_TECHNOLOGY`, `DATA_CENTER_SERVICE_DECODER_TYPE`, `DATA_CENTER_SERVICE_IP_ADDRESS`, `DATA_CENTER_SERVICE_METADATA`, `DATA_CENTER_SERVICE_NAME`, `DATA_CENTER_SERVICE_PORT`, `DATA_CENTER_SERVICE_TAGS`, `DOCKER_CONTAINER_NAME`, `DOCKER_FULL_IMAGE_NAME`, `DOCKER_IMAGE_VERSION`, `EC2_INSTANCE_AMI_ID`, `EC2_INSTANCE_AWS_INSTANCE_TYPE`, `EC2_INSTANCE_AWS_SECURITY_GROUP`, `EC2_INSTANCE_BEANSTALK_ENV_NAME`, `EC2_INSTANCE_ID`, `EC2_INSTANCE_NAME`, `EC2_INSTANCE_PRIVATE_HOST_NAME`, `EC2_INSTANCE_PUBLIC_HOST_NAME`, `EC2_INSTANCE_TAGS`, `ENTERPRISE_APPLICATION_DECODER_TYPE`, `ENTERPRISE_APPLICATION_IP_ADDRESS`, `ENTERPRISE_APPLICATION_METADATA`, `ENTERPRISE_APPLICATION_NAME`, `ENTERPRISE_APPLICATION_PORT`, `ENTERPRISE_APPLICATION_TAGS`, `ESXI_HOST_CLUSTER_NAME`, `ESXI_HOST_HARDWARE_MODEL`, `ESXI_HOST_HARDWARE_VENDOR`, `ESXI_HOST_NAME`, `ESXI_HOST_PRODUCT_NAME`, `ESXI_HOST_PRODUCT_VERSION`, `ESXI_HOST_TAGS`, `EXTERNAL_MONITOR_ENGINE_DESCRIPTION`, `EXTERNAL_MONITOR_ENGINE_NAME`, `EXTERNAL_MONITOR_ENGINE_TYPE`, `EXTERNAL_MONITOR_NAME`, `EXTERNAL_MONITOR_TAGS`, `GEOLOCATION_SITE_NAME`, `GOOGLE_CLOUD_PLATFORM_ZONE_NAME`, `GOOGLE_COMPUTE_INSTANCE_ID`, `GOOGLE_COMPUTE_INSTANCE_MACHINE_TYPE`, `GOOGLE_COMPUTE_INSTANCE_NAME`, `GOOGLE_COMPUTE_INSTANCE_PROJECT`, `GOOGLE_COMPUTE_INSTANCE_PROJECT_ID`, `GOOGLE_COMPUTE_INSTANCE_PUBLIC_IP_ADDRESSES`, `HOST_AIX_LOGICAL_CPU_COUNT`, `HOST_AIX_SIMULTANEOUS_THREADS`, `HOST_AIX_VIRTUAL_CPU_COUNT`, `HOST_ARCHITECTURE`, `HOST_AWS_NAME_TAG`, `HOST_AZURE_COMPUTE_MODE`, `HOST_AZURE_SKU`, `HOST_AZURE_WEB_APPLICATION_HOST_NAMES`, `HOST_AZURE_WEB_APPLICATION_SITE_NAMES`, `HOST_BITNESS`, `HOST_BOSH_AVAILABILITY_ZONE`, `HOST_BOSH_DEPLOYMENT_ID`, `HOST_BOSH_INSTANCE_ID`, `HOST_BOSH_INSTANCE_NAME`, `HOST_BOSH_NAME`, `HOST_BOSH_STEMCELL_VERSION`, `HOST_CLOUD_TYPE`, `HOST_CPU_CORES`, `HOST_CUSTOM_METADATA`, `HOST_DETECTED_NAME`, `HOST_GROUP_ID`, `HOST_GROUP_NAME`, `HOST_HYPERVISOR_TYPE`, `HOST_IP_ADDRESS`, `HOST_KUBERNETES_LABELS`, `HOST_LOGICAL_CPU_CORES`, `HOST_NAME`, `HOST_ONEAGENT_CUSTOM_HOST_NAME`, `HOST_OS_TYPE`, `HOST_OS_VERSION`, `HOST_PAAS_MEMORY_LIMIT`, `HOST_PAAS_TYPE`, `HOST_TAGS`, `HOST_TECHNOLOGY`, `HTTP_MONITOR_NAME`, `HTTP_MONITOR_TAGS`, `KUBERNETES_CLUSTER_NAME`, `KUBERNETES_NODE_NAME`, `KUBERNETES_SERVICE_NAME`, `MOBILE_APPLICATION_NAME`, `MOBILE_APPLICATION_PLATFORM`, `MOBILE_APPLICATION_TAGS`, `NAME_OF_COMPUTE_NODE`, `OPENSTACK_ACCOUNT_NAME`, `OPENSTACK_ACCOUNT_PROJECT_NAME`, `OPENSTACK_AVAILABILITY_ZONE_NAME`, `OPENSTACK_PROJECT_NAME`, `OPENSTACK_REGION_NAME`, `OPENSTACK_VM_INSTANCE_TYPE`, `OPENSTACK_VM_NAME`, `OPENSTACK_VM_SECURITY_GROUP`, `PROCESS_GROUP_AZURE_HOST_NAME`, `PROCESS_GROUP_AZURE_SITE_NAME`, `PROCESS_GROUP_CUSTOM_METADATA`, `PROCESS_GROUP_DETECTED_NAME`, `PROCESS_GROUP_ID`, `PROCESS_GROUP_LISTEN_PORT`, `PROCESS_GROUP_NAME`, `PROCESS_GROUP_PREDEFINED_METADATA`, `PROCESS_GROUP_TAGS`, `PROCESS_GROUP_TECHNOLOGY`, `PROCESS_GROUP_TECHNOLOGY_EDITION`, `PROCESS_GROUP_TECHNOLOGY_VERSION`, `QUEUE_NAME`, `QUEUE_TECHNOLOGY`, `QUEUE_VENDOR`, `SERVICE_AKKA_ACTOR_SYSTEM`, `SERVICE_CTG_SERVICE_NAME`, `SERVICE_DATABASE_HOST_NAME`, `SERVICE_DATABASE_NAME`, `SERVICE_DATABASE_TOPOLOGY`, `SERVICE_DATABASE_VENDOR`, `SERVICE_DETECTED_NAME`, `SERVICE_ESB_APPLICATION_NAME`, `SERVICE_IBM_CTG_GATEWAY_URL`, `SERVICE_MESSAGING_LISTENER_CLASS_NAME`, `SERVICE_NAME`, `SERVICE_PORT`, `SERVICE_PUBLIC_DOMAIN_NAME`, `SERVICE_REMOTE_ENDPOINT`, `SERVICE_REMOTE_SERVICE_NAME`, `SERVICE_TAGS`, `SERVICE_TECHNOLOGY`, `SERVICE_TECHNOLOGY_EDITION`, `SERVICE_TECHNOLOGY_VERSION`, `SERVICE_TOPOLOGY`, `SERVICE_TYPE`, `SERVICE_WEB_APPLICATION_ID`, `SERVICE_WEB_CONTEXT_ROOT`, `SERVICE_WEB_SERVER_ENDPOINT`, `SERVICE_WEB_SERVER_NAME`, `SERVICE_WEB_SERVICE_NAME`, `SERVICE_WEB_SERVICE_NAMESPACE`, `VMWARE_DATACENTER_NAME`, `VMWARE_VM_NAME`, `WEB_APPLICATION_NAME`, `WEB_APPLICATION_NAME_PATTERN`, `WEB_APPLICATION_TAGS`, `WEB_APPLICATION_TYPE`
        :param str operator: Possible Values: `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EXISTS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `IS_IP_IN_RANGE`, `LOWER_THAN`, `LOWER_THAN_OR_EQUAL`, `NOT_BEGINS_WITH`, `NOT_CONTAINS`, `NOT_ENDS_WITH`, `NOT_EQUALS`, `NOT_EXISTS`, `NOT_GREATER_THAN`, `NOT_GREATER_THAN_OR_EQUAL`, `NOT_IS_IP_IN_RANGE`, `NOT_LOWER_THAN`, `NOT_LOWER_THAN_OR_EQUAL`, `NOT_REGEX_MATCHES`, `NOT_TAG_KEY_EQUALS`, `REGEX_MATCHES`, `TAG_KEY_EQUALS`
        :param bool case_sensitive: Case sensitive
        :param str dynamic_key: Dynamic key
        :param str dynamic_key_source: Key source
        :param str entity_id: Value
        :param str enum_value: Value
        :param int integer_value: Value
        :param str string_value: Value
        :param str tag: Format: `[CONTEXT]tagKey:tagValue`
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if dynamic_key is not None:
            pulumi.set(__self__, "dynamic_key", dynamic_key)
        if dynamic_key_source is not None:
            pulumi.set(__self__, "dynamic_key_source", dynamic_key_source)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if enum_value is not None:
            pulumi.set(__self__, "enum_value", enum_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Possible Values: `APPMON_SERVER_NAME`, `APPMON_SYSTEM_PROFILE_NAME`, `AWS_ACCOUNT_ID`, `AWS_ACCOUNT_NAME`, `AWS_APPLICATION_LOAD_BALANCER_NAME`, `AWS_APPLICATION_LOAD_BALANCER_TAGS`, `AWS_AUTO_SCALING_GROUP_NAME`, `AWS_AUTO_SCALING_GROUP_TAGS`, `AWS_AVAILABILITY_ZONE_NAME`, `AWS_CLASSIC_LOAD_BALANCER_FRONTEND_PORTS`, `AWS_CLASSIC_LOAD_BALANCER_NAME`, `AWS_CLASSIC_LOAD_BALANCER_TAGS`, `AWS_NETWORK_LOAD_BALANCER_NAME`, `AWS_NETWORK_LOAD_BALANCER_TAGS`, `AWS_RELATIONAL_DATABASE_SERVICE_DB_NAME`, `AWS_RELATIONAL_DATABASE_SERVICE_ENDPOINT`, `AWS_RELATIONAL_DATABASE_SERVICE_ENGINE`, `AWS_RELATIONAL_DATABASE_SERVICE_INSTANCE_CLASS`, `AWS_RELATIONAL_DATABASE_SERVICE_NAME`, `AWS_RELATIONAL_DATABASE_SERVICE_PORT`, `AWS_RELATIONAL_DATABASE_SERVICE_TAGS`, `AZURE_ENTITY_NAME`, `AZURE_ENTITY_TAGS`, `AZURE_MGMT_GROUP_NAME`, `AZURE_MGMT_GROUP_UUID`, `AZURE_REGION_NAME`, `AZURE_SCALE_SET_NAME`, `AZURE_SUBSCRIPTION_NAME`, `AZURE_SUBSCRIPTION_UUID`, `AZURE_TENANT_NAME`, `AZURE_TENANT_UUID`, `AZURE_VM_NAME`, `BROWSER_MONITOR_NAME`, `BROWSER_MONITOR_TAGS`, `CLOUD_APPLICATION_LABELS`, `CLOUD_APPLICATION_NAME`, `CLOUD_APPLICATION_NAMESPACE_LABELS`, `CLOUD_APPLICATION_NAMESPACE_NAME`, `CLOUD_FOUNDRY_FOUNDATION_NAME`, `CLOUD_FOUNDRY_ORG_NAME`, `CUSTOM_APPLICATION_NAME`, `CUSTOM_APPLICATION_PLATFORM`, `CUSTOM_APPLICATION_TAGS`, `CUSTOM_APPLICATION_TYPE`, `CUSTOM_DEVICE_DNS_ADDRESS`, `CUSTOM_DEVICE_GROUP_NAME`, `CUSTOM_DEVICE_GROUP_TAGS`, `CUSTOM_DEVICE_IP_ADDRESS`, `CUSTOM_DEVICE_METADATA`, `CUSTOM_DEVICE_NAME`, `CUSTOM_DEVICE_PORT`, `CUSTOM_DEVICE_TAGS`, `CUSTOM_DEVICE_TECHNOLOGY`, `DATA_CENTER_SERVICE_DECODER_TYPE`, `DATA_CENTER_SERVICE_IP_ADDRESS`, `DATA_CENTER_SERVICE_METADATA`, `DATA_CENTER_SERVICE_NAME`, `DATA_CENTER_SERVICE_PORT`, `DATA_CENTER_SERVICE_TAGS`, `DOCKER_CONTAINER_NAME`, `DOCKER_FULL_IMAGE_NAME`, `DOCKER_IMAGE_VERSION`, `EC2_INSTANCE_AMI_ID`, `EC2_INSTANCE_AWS_INSTANCE_TYPE`, `EC2_INSTANCE_AWS_SECURITY_GROUP`, `EC2_INSTANCE_BEANSTALK_ENV_NAME`, `EC2_INSTANCE_ID`, `EC2_INSTANCE_NAME`, `EC2_INSTANCE_PRIVATE_HOST_NAME`, `EC2_INSTANCE_PUBLIC_HOST_NAME`, `EC2_INSTANCE_TAGS`, `ENTERPRISE_APPLICATION_DECODER_TYPE`, `ENTERPRISE_APPLICATION_IP_ADDRESS`, `ENTERPRISE_APPLICATION_METADATA`, `ENTERPRISE_APPLICATION_NAME`, `ENTERPRISE_APPLICATION_PORT`, `ENTERPRISE_APPLICATION_TAGS`, `ESXI_HOST_CLUSTER_NAME`, `ESXI_HOST_HARDWARE_MODEL`, `ESXI_HOST_HARDWARE_VENDOR`, `ESXI_HOST_NAME`, `ESXI_HOST_PRODUCT_NAME`, `ESXI_HOST_PRODUCT_VERSION`, `ESXI_HOST_TAGS`, `EXTERNAL_MONITOR_ENGINE_DESCRIPTION`, `EXTERNAL_MONITOR_ENGINE_NAME`, `EXTERNAL_MONITOR_ENGINE_TYPE`, `EXTERNAL_MONITOR_NAME`, `EXTERNAL_MONITOR_TAGS`, `GEOLOCATION_SITE_NAME`, `GOOGLE_CLOUD_PLATFORM_ZONE_NAME`, `GOOGLE_COMPUTE_INSTANCE_ID`, `GOOGLE_COMPUTE_INSTANCE_MACHINE_TYPE`, `GOOGLE_COMPUTE_INSTANCE_NAME`, `GOOGLE_COMPUTE_INSTANCE_PROJECT`, `GOOGLE_COMPUTE_INSTANCE_PROJECT_ID`, `GOOGLE_COMPUTE_INSTANCE_PUBLIC_IP_ADDRESSES`, `HOST_AIX_LOGICAL_CPU_COUNT`, `HOST_AIX_SIMULTANEOUS_THREADS`, `HOST_AIX_VIRTUAL_CPU_COUNT`, `HOST_ARCHITECTURE`, `HOST_AWS_NAME_TAG`, `HOST_AZURE_COMPUTE_MODE`, `HOST_AZURE_SKU`, `HOST_AZURE_WEB_APPLICATION_HOST_NAMES`, `HOST_AZURE_WEB_APPLICATION_SITE_NAMES`, `HOST_BITNESS`, `HOST_BOSH_AVAILABILITY_ZONE`, `HOST_BOSH_DEPLOYMENT_ID`, `HOST_BOSH_INSTANCE_ID`, `HOST_BOSH_INSTANCE_NAME`, `HOST_BOSH_NAME`, `HOST_BOSH_STEMCELL_VERSION`, `HOST_CLOUD_TYPE`, `HOST_CPU_CORES`, `HOST_CUSTOM_METADATA`, `HOST_DETECTED_NAME`, `HOST_GROUP_ID`, `HOST_GROUP_NAME`, `HOST_HYPERVISOR_TYPE`, `HOST_IP_ADDRESS`, `HOST_KUBERNETES_LABELS`, `HOST_LOGICAL_CPU_CORES`, `HOST_NAME`, `HOST_ONEAGENT_CUSTOM_HOST_NAME`, `HOST_OS_TYPE`, `HOST_OS_VERSION`, `HOST_PAAS_MEMORY_LIMIT`, `HOST_PAAS_TYPE`, `HOST_TAGS`, `HOST_TECHNOLOGY`, `HTTP_MONITOR_NAME`, `HTTP_MONITOR_TAGS`, `KUBERNETES_CLUSTER_NAME`, `KUBERNETES_NODE_NAME`, `KUBERNETES_SERVICE_NAME`, `MOBILE_APPLICATION_NAME`, `MOBILE_APPLICATION_PLATFORM`, `MOBILE_APPLICATION_TAGS`, `NAME_OF_COMPUTE_NODE`, `OPENSTACK_ACCOUNT_NAME`, `OPENSTACK_ACCOUNT_PROJECT_NAME`, `OPENSTACK_AVAILABILITY_ZONE_NAME`, `OPENSTACK_PROJECT_NAME`, `OPENSTACK_REGION_NAME`, `OPENSTACK_VM_INSTANCE_TYPE`, `OPENSTACK_VM_NAME`, `OPENSTACK_VM_SECURITY_GROUP`, `PROCESS_GROUP_AZURE_HOST_NAME`, `PROCESS_GROUP_AZURE_SITE_NAME`, `PROCESS_GROUP_CUSTOM_METADATA`, `PROCESS_GROUP_DETECTED_NAME`, `PROCESS_GROUP_ID`, `PROCESS_GROUP_LISTEN_PORT`, `PROCESS_GROUP_NAME`, `PROCESS_GROUP_PREDEFINED_METADATA`, `PROCESS_GROUP_TAGS`, `PROCESS_GROUP_TECHNOLOGY`, `PROCESS_GROUP_TECHNOLOGY_EDITION`, `PROCESS_GROUP_TECHNOLOGY_VERSION`, `QUEUE_NAME`, `QUEUE_TECHNOLOGY`, `QUEUE_VENDOR`, `SERVICE_AKKA_ACTOR_SYSTEM`, `SERVICE_CTG_SERVICE_NAME`, `SERVICE_DATABASE_HOST_NAME`, `SERVICE_DATABASE_NAME`, `SERVICE_DATABASE_TOPOLOGY`, `SERVICE_DATABASE_VENDOR`, `SERVICE_DETECTED_NAME`, `SERVICE_ESB_APPLICATION_NAME`, `SERVICE_IBM_CTG_GATEWAY_URL`, `SERVICE_MESSAGING_LISTENER_CLASS_NAME`, `SERVICE_NAME`, `SERVICE_PORT`, `SERVICE_PUBLIC_DOMAIN_NAME`, `SERVICE_REMOTE_ENDPOINT`, `SERVICE_REMOTE_SERVICE_NAME`, `SERVICE_TAGS`, `SERVICE_TECHNOLOGY`, `SERVICE_TECHNOLOGY_EDITION`, `SERVICE_TECHNOLOGY_VERSION`, `SERVICE_TOPOLOGY`, `SERVICE_TYPE`, `SERVICE_WEB_APPLICATION_ID`, `SERVICE_WEB_CONTEXT_ROOT`, `SERVICE_WEB_SERVER_ENDPOINT`, `SERVICE_WEB_SERVER_NAME`, `SERVICE_WEB_SERVICE_NAME`, `SERVICE_WEB_SERVICE_NAMESPACE`, `VMWARE_DATACENTER_NAME`, `VMWARE_VM_NAME`, `WEB_APPLICATION_NAME`, `WEB_APPLICATION_NAME_PATTERN`, `WEB_APPLICATION_TAGS`, `WEB_APPLICATION_TYPE`
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Possible Values: `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EXISTS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `IS_IP_IN_RANGE`, `LOWER_THAN`, `LOWER_THAN_OR_EQUAL`, `NOT_BEGINS_WITH`, `NOT_CONTAINS`, `NOT_ENDS_WITH`, `NOT_EQUALS`, `NOT_EXISTS`, `NOT_GREATER_THAN`, `NOT_GREATER_THAN_OR_EQUAL`, `NOT_IS_IP_IN_RANGE`, `NOT_LOWER_THAN`, `NOT_LOWER_THAN_OR_EQUAL`, `NOT_REGEX_MATCHES`, `NOT_TAG_KEY_EQUALS`, `REGEX_MATCHES`, `TAG_KEY_EQUALS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        Case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> Optional[str]:
        """
        Dynamic key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter(name="dynamicKeySource")
    def dynamic_key_source(self) -> Optional[str]:
        """
        Key source
        """
        return pulumi.get(self, "dynamic_key_source")

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[str]:
        """
        Value
        """
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter(name="enumValue")
    def enum_value(self) -> Optional[str]:
        """
        Value
        """
        return pulumi.get(self, "enum_value")

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[int]:
        """
        Value
        """
        return pulumi.get(self, "integer_value")

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[str]:
        """
        Value
        """
        return pulumi.get(self, "string_value")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Format: `[CONTEXT]tagKey:tagValue`
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class AwsAnomaliesEc2CandidateHighCpuDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesEc2CandidateHighCpuDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesEc2CandidateHighCpuDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesEc2CandidateHighCpuDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.AwsAnomaliesEc2CandidateHighCpuDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'AwsAnomaliesEc2CandidateHighCpuDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.AwsAnomaliesEc2CandidateHighCpuDetectionCustomThresholds']:
        """
        Alert if the condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class AwsAnomaliesEc2CandidateHighCpuDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuUsage":
            suggest = "cpu_usage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesEc2CandidateHighCpuDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesEc2CandidateHighCpuDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesEc2CandidateHighCpuDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_usage: float):
        """
        :param float cpu_usage: CPU usage is higher than
        """
        pulumi.set(__self__, "cpu_usage", cpu_usage)

    @property
    @pulumi.getter(name="cpuUsage")
    def cpu_usage(self) -> float:
        """
        CPU usage is higher than
        """
        return pulumi.get(self, "cpu_usage")


@pulumi.output_type
class AwsAnomaliesElbHighConnectionErrorsDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesElbHighConnectionErrorsDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesElbHighConnectionErrorsDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesElbHighConnectionErrorsDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.AwsAnomaliesElbHighConnectionErrorsDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'AwsAnomaliesElbHighConnectionErrorsDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.AwsAnomaliesElbHighConnectionErrorsDetectionCustomThresholds']:
        """
        Alert if the condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class AwsAnomaliesElbHighConnectionErrorsDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionErrorsPerMinute":
            suggest = "connection_errors_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesElbHighConnectionErrorsDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesElbHighConnectionErrorsDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesElbHighConnectionErrorsDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_errors_per_minute: int):
        """
        :param int connection_errors_per_minute: Number of backend connection errors is higher than
        """
        pulumi.set(__self__, "connection_errors_per_minute", connection_errors_per_minute)

    @property
    @pulumi.getter(name="connectionErrorsPerMinute")
    def connection_errors_per_minute(self) -> int:
        """
        Number of backend connection errors is higher than
        """
        return pulumi.get(self, "connection_errors_per_minute")


@pulumi.output_type
class AwsAnomaliesLambdaHighErrorRateDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesLambdaHighErrorRateDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesLambdaHighErrorRateDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesLambdaHighErrorRateDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.AwsAnomaliesLambdaHighErrorRateDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'AwsAnomaliesLambdaHighErrorRateDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.AwsAnomaliesLambdaHighErrorRateDetectionCustomThresholds']:
        """
        Alert if the condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class AwsAnomaliesLambdaHighErrorRateDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failedInvocationsRate":
            suggest = "failed_invocations_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesLambdaHighErrorRateDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesLambdaHighErrorRateDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesLambdaHighErrorRateDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failed_invocations_rate: int):
        """
        :param int failed_invocations_rate: Failed invocations rate is higher than
        """
        pulumi.set(__self__, "failed_invocations_rate", failed_invocations_rate)

    @property
    @pulumi.getter(name="failedInvocationsRate")
    def failed_invocations_rate(self) -> int:
        """
        Failed invocations rate is higher than
        """
        return pulumi.get(self, "failed_invocations_rate")


@pulumi.output_type
class AwsAnomaliesRdsHighCpuDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsHighCpuDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsHighCpuDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsHighCpuDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.AwsAnomaliesRdsHighCpuDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'AwsAnomaliesRdsHighCpuDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.AwsAnomaliesRdsHighCpuDetectionCustomThresholds']:
        """
        Alert if the condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class AwsAnomaliesRdsHighCpuDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuUsage":
            suggest = "cpu_usage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsHighCpuDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsHighCpuDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsHighCpuDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_usage: float):
        """
        :param float cpu_usage: CPU usage is higher than
        """
        pulumi.set(__self__, "cpu_usage", cpu_usage)

    @property
    @pulumi.getter(name="cpuUsage")
    def cpu_usage(self) -> float:
        """
        CPU usage is higher than
        """
        return pulumi.get(self, "cpu_usage")


@pulumi.output_type
class AwsAnomaliesRdsHighMemoryDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsHighMemoryDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsHighMemoryDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsHighMemoryDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.AwsAnomaliesRdsHighMemoryDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'AwsAnomaliesRdsHighMemoryDetectionCustomThresholdsArgs' custom_thresholds: Alert if **both** conditions is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.AwsAnomaliesRdsHighMemoryDetectionCustomThresholds']:
        """
        Alert if **both** conditions is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class AwsAnomaliesRdsHighMemoryDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeMemory":
            suggest = "free_memory"
        elif key == "swapUsage":
            suggest = "swap_usage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsHighMemoryDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsHighMemoryDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsHighMemoryDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_memory: float,
                 swap_usage: float):
        """
        :param float free_memory: Freeable memory is lower than
        :param float swap_usage: Swap usage is higher than
        """
        pulumi.set(__self__, "free_memory", free_memory)
        pulumi.set(__self__, "swap_usage", swap_usage)

    @property
    @pulumi.getter(name="freeMemory")
    def free_memory(self) -> float:
        """
        Freeable memory is lower than
        """
        return pulumi.get(self, "free_memory")

    @property
    @pulumi.getter(name="swapUsage")
    def swap_usage(self) -> float:
        """
        Swap usage is higher than
        """
        return pulumi.get(self, "swap_usage")


@pulumi.output_type
class AwsAnomaliesRdsHighWriteReadLatencyDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsHighWriteReadLatencyDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsHighWriteReadLatencyDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsHighWriteReadLatencyDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.AwsAnomaliesRdsHighWriteReadLatencyDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'AwsAnomaliesRdsHighWriteReadLatencyDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.AwsAnomaliesRdsHighWriteReadLatencyDetectionCustomThresholds']:
        """
        Alert if the condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class AwsAnomaliesRdsHighWriteReadLatencyDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readWriteLatency":
            suggest = "read_write_latency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsHighWriteReadLatencyDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsHighWriteReadLatencyDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsHighWriteReadLatencyDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 read_write_latency: int):
        """
        :param int read_write_latency: Read/write latency is higher than
        """
        pulumi.set(__self__, "read_write_latency", read_write_latency)

    @property
    @pulumi.getter(name="readWriteLatency")
    def read_write_latency(self) -> int:
        """
        Read/write latency is higher than
        """
        return pulumi.get(self, "read_write_latency")


@pulumi.output_type
class AwsAnomaliesRdsLowStorageDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsLowStorageDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsLowStorageDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsLowStorageDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.AwsAnomaliesRdsLowStorageDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'AwsAnomaliesRdsLowStorageDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.AwsAnomaliesRdsLowStorageDetectionCustomThresholds']:
        """
        Alert if the condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class AwsAnomaliesRdsLowStorageDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeStoragePercentage":
            suggest = "free_storage_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsLowStorageDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsLowStorageDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsLowStorageDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_storage_percentage: int):
        """
        :param int free_storage_percentage: Free storage space divided by allocated storage is lower than
        """
        pulumi.set(__self__, "free_storage_percentage", free_storage_percentage)

    @property
    @pulumi.getter(name="freeStoragePercentage")
    def free_storage_percentage(self) -> int:
        """
        Free storage space divided by allocated storage is lower than
        """
        return pulumi.get(self, "free_storage_percentage")


@pulumi.output_type
class AwsAnomaliesRdsRestartsSequenceDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsRestartsSequenceDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsRestartsSequenceDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsRestartsSequenceDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.AwsAnomaliesRdsRestartsSequenceDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'AwsAnomaliesRdsRestartsSequenceDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 2 out of 20 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.AwsAnomaliesRdsRestartsSequenceDetectionCustomThresholds']:
        """
        Alert if the condition is met in 2 out of 20 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class AwsAnomaliesRdsRestartsSequenceDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restartsPerMinute":
            suggest = "restarts_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsRestartsSequenceDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsRestartsSequenceDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsRestartsSequenceDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 restarts_per_minute: int):
        """
        :param int restarts_per_minute: Number of restarts per minute is equal or higher than
        """
        pulumi.set(__self__, "restarts_per_minute", restarts_per_minute)

    @property
    @pulumi.getter(name="restartsPerMinute")
    def restarts_per_minute(self) -> int:
        """
        Number of restarts per minute is equal or higher than
        """
        return pulumi.get(self, "restarts_per_minute")


@pulumi.output_type
class AwsCredentialsAuthenticationData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountId":
            suggest = "account_id"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "iamRole":
            suggest = "iam_role"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCredentialsAuthenticationData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCredentialsAuthenticationData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCredentialsAuthenticationData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 account_id: Optional[str] = None,
                 external_id: Optional[str] = None,
                 iam_role: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str access_key: the access key
        :param str account_id: the ID of the Amazon account
        :param str external_id: (Read only) the external ID token for setting an IAM role. You can obtain it with the `GET /aws/iamExternalId` request
        :param str iam_role: the IAM role to be used by Dynatrace to get monitoring data
        :param str secret_key: the secret access key
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if iam_role is not None:
            pulumi.set(__self__, "iam_role", iam_role)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        the access key
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        the ID of the Amazon account
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        (Read only) the external ID token for setting an IAM role. You can obtain it with the `GET /aws/iamExternalId` request
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="iamRole")
    def iam_role(self) -> Optional[str]:
        """
        the IAM role to be used by Dynatrace to get monitoring data
        """
        return pulumi.get(self, "iam_role")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        the secret access key
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AwsCredentialsSupportingServicesToMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitoredMetrics":
            suggest = "monitored_metrics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCredentialsSupportingServicesToMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCredentialsSupportingServicesToMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCredentialsSupportingServicesToMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitored_metrics: Optional[Sequence['outputs.AwsCredentialsSupportingServicesToMonitorMonitoredMetric']] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence['AwsCredentialsSupportingServicesToMonitorMonitoredMetricArgs'] monitored_metrics: a list of metrics to be monitored for this service
        :param str name: the name of the supporting service
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if monitored_metrics is not None:
            pulumi.set(__self__, "monitored_metrics", monitored_metrics)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="monitoredMetrics")
    def monitored_metrics(self) -> Optional[Sequence['outputs.AwsCredentialsSupportingServicesToMonitorMonitoredMetric']]:
        """
        a list of metrics to be monitored for this service
        """
        return pulumi.get(self, "monitored_metrics")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        the name of the supporting service
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AwsCredentialsSupportingServicesToMonitorMonitoredMetric(dict):
    def __init__(__self__, *,
                 dimensions: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 statistic: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence[str] dimensions: a list of metric's dimensions names
        :param str name: the name of the metric of the supporting service
        :param str statistic: the statistic (aggregation) to be used for the metric. AVG*MIN*MAX value is 3 statistics at once: AVERAGE, MINIMUM and MAXIMUM
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence[str]]:
        """
        a list of metric's dimensions names
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        the name of the metric of the supporting service
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        """
        the statistic (aggregation) to be used for the metric. AVG*MIN*MAX value is 3 statistics at once: AVERAGE, MINIMUM and MAXIMUM
        """
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AwsCredentialsTagsToMonitor(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: the key of the AWS tag.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: the value of the AWS tag
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        the key of the AWS tag.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        the value of the AWS tag
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsServiceMetric(dict):
    def __init__(__self__, *,
                 name: str,
                 dimensions: Optional[Sequence[str]] = None,
                 statistic: Optional[str] = None):
        """
        :param str name: the name of the metric of the supporting service
        :param Sequence[str] dimensions: a list of metric's dimensions names
        :param str statistic: Possible values are `AVERAGE`, `AVG_MIN_MAX`, `MAXIMUM`, `MINIMUM`, `SAMPLE_COUNT` and `SUM`
        """
        pulumi.set(__self__, "name", name)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        the name of the metric of the supporting service
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence[str]]:
        """
        a list of metric's dimensions names
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        """
        Possible values are `AVERAGE`, `AVG_MIN_MAX`, `MAXIMUM`, `MINIMUM`, `SAMPLE_COUNT` and `SUM`
        """
        return pulumi.get(self, "statistic")


@pulumi.output_type
class AzureCredentialsMonitorOnlyExcludingTagPair(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the tag.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value of the tag.   If set to `null`, then resources with any value of the tag are monitored.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the tag.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag.   If set to `null`, then resources with any value of the tag are monitored.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AzureCredentialsMonitorOnlyTagPair(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the tag.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value of the tag.   If set to `null`, then resources with any value of the tag are monitored.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the tag.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag.   If set to `null`, then resources with any value of the tag are monitored.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AzureCredentialsSupportingService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitoredMetrics":
            suggest = "monitored_metrics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureCredentialsSupportingService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureCredentialsSupportingService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureCredentialsSupportingService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitored_metrics: Optional[Sequence['outputs.AzureCredentialsSupportingServiceMonitoredMetric']] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence['AzureCredentialsSupportingServiceMonitoredMetricArgs'] monitored_metrics: A list of Azure tags to be monitored.  You can specify up to 10 tags. A resource tagged with *any* of the specified tags is monitored.  Only applicable when the **monitorOnlyTaggedEntities** parameter is set to `true`
        :param str name: The name of the supporting service.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if monitored_metrics is not None:
            pulumi.set(__self__, "monitored_metrics", monitored_metrics)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="monitoredMetrics")
    def monitored_metrics(self) -> Optional[Sequence['outputs.AzureCredentialsSupportingServiceMonitoredMetric']]:
        """
        A list of Azure tags to be monitored.  You can specify up to 10 tags. A resource tagged with *any* of the specified tags is monitored.  Only applicable when the **monitorOnlyTaggedEntities** parameter is set to `true`
        """
        return pulumi.get(self, "monitored_metrics")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the supporting service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AzureCredentialsSupportingServiceMonitoredMetric(dict):
    def __init__(__self__, *,
                 dimensions: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence[str] dimensions: a list of metric's dimensions names
        :param str name: the name of the metric of the supporting service
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence[str]]:
        """
        a list of metric's dimensions names
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        the name of the metric of the supporting service
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AzureServiceMetric(dict):
    def __init__(__self__, *,
                 name: str,
                 dimensions: Optional[Sequence[str]] = None):
        """
        :param str name: the name of the metric of the supporting service
        :param Sequence[str] dimensions: a list of metric's dimensions names
        """
        pulumi.set(__self__, "name", name)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        the name of the metric of the supporting service
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence[str]]:
        """
        a list of metric's dimensions names
        """
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class BrowserMonitorAnomalyDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadingTimeThresholds":
            suggest = "loading_time_thresholds"
        elif key == "outageHandlings":
            suggest = "outage_handlings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorAnomalyDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorAnomalyDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorAnomalyDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 loading_time_thresholds: Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionLoadingTimeThreshold']] = None,
                 outage_handlings: Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionOutageHandling']] = None):
        """
        :param Sequence['BrowserMonitorAnomalyDetectionLoadingTimeThresholdArgs'] loading_time_thresholds: Thresholds for loading times
        :param Sequence['BrowserMonitorAnomalyDetectionOutageHandlingArgs'] outage_handlings: Outage handling configuration
        """
        if loading_time_thresholds is not None:
            pulumi.set(__self__, "loading_time_thresholds", loading_time_thresholds)
        if outage_handlings is not None:
            pulumi.set(__self__, "outage_handlings", outage_handlings)

    @property
    @pulumi.getter(name="loadingTimeThresholds")
    def loading_time_thresholds(self) -> Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionLoadingTimeThreshold']]:
        """
        Thresholds for loading times
        """
        return pulumi.get(self, "loading_time_thresholds")

    @property
    @pulumi.getter(name="outageHandlings")
    def outage_handlings(self) -> Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionOutageHandling']]:
        """
        Outage handling configuration
        """
        return pulumi.get(self, "outage_handlings")


@pulumi.output_type
class BrowserMonitorAnomalyDetectionLoadingTimeThreshold(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 thresholds: Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionLoadingTimeThresholdThreshold']] = None):
        """
        :param bool enabled: Performance threshold is enabled (`true`) or disabled (`false`)
        :param Sequence['BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdArgs'] thresholds: The list of performance threshold rules
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Performance threshold is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionLoadingTimeThresholdThreshold']]:
        """
        The list of performance threshold rules
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class BrowserMonitorAnomalyDetectionLoadingTimeThresholdThreshold(dict):
    def __init__(__self__, *,
                 thresholds: Sequence['outputs.BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold']):
        """
        :param Sequence['BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThresholdArgs'] thresholds: The list of performance threshold rules
        """
        pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold']:
        """
        The list of performance threshold rules
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueMs":
            suggest = "value_ms"
        elif key == "eventIndex":
            suggest = "event_index"
        elif key == "requestIndex":
            suggest = "request_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value_ms: int,
                 event_index: Optional[int] = None,
                 request_index: Optional[int] = None,
                 type: Optional[str] = None):
        """
        :param int value_ms: Notify if monitor takes longer than *X* milliseconds to load
        :param int event_index: Specify the event to which an ACTION threshold applies
        :param int request_index: Specify the request to which an ACTION threshold applies
        :param str type: The type of the threshold: `TOTAL` (total loading time) or `ACTION` (action loading time)
        """
        pulumi.set(__self__, "value_ms", value_ms)
        if event_index is not None:
            pulumi.set(__self__, "event_index", event_index)
        if request_index is not None:
            pulumi.set(__self__, "request_index", request_index)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="valueMs")
    def value_ms(self) -> int:
        """
        Notify if monitor takes longer than *X* milliseconds to load
        """
        return pulumi.get(self, "value_ms")

    @property
    @pulumi.getter(name="eventIndex")
    def event_index(self) -> Optional[int]:
        """
        Specify the event to which an ACTION threshold applies
        """
        return pulumi.get(self, "event_index")

    @property
    @pulumi.getter(name="requestIndex")
    def request_index(self) -> Optional[int]:
        """
        Specify the request to which an ACTION threshold applies
        """
        return pulumi.get(self, "request_index")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the threshold: `TOTAL` (total loading time) or `ACTION` (action loading time)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class BrowserMonitorAnomalyDetectionOutageHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "globalOutage":
            suggest = "global_outage"
        elif key == "globalOutagePolicies":
            suggest = "global_outage_policies"
        elif key == "localOutage":
            suggest = "local_outage"
        elif key == "localOutagePolicies":
            suggest = "local_outage_policies"
        elif key == "retryOnError":
            suggest = "retry_on_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorAnomalyDetectionOutageHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorAnomalyDetectionOutageHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorAnomalyDetectionOutageHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 global_outage: Optional[bool] = None,
                 global_outage_policies: Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy']] = None,
                 local_outage: Optional[bool] = None,
                 local_outage_policies: Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy']] = None,
                 retry_on_error: Optional[bool] = None):
        """
        :param bool global_outage: (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) When enabled (`true`), generate a problem and send an alert when the monitor is unavailable at all configured locations
        :param Sequence['BrowserMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicyArgs'] global_outage_policies: (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) Global outage handling configuration.
        :param bool local_outage: (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) When enabled (`true`), generate a problem and send an alert when the monitor is unavailable for one or more consecutive runs at any location
        :param Sequence['BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicyArgs'] local_outage_policies: (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) Local outage handling configuration. 
               
                Alert if **affectedLocations** of locations are unable to access the web application **consecutiveRuns** times consecutively
        :param bool retry_on_error: (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) Schedule retry if browser monitor execution results in a fail. For HTTP monitors this property is ignored
        """
        if global_outage is not None:
            pulumi.set(__self__, "global_outage", global_outage)
        if global_outage_policies is not None:
            pulumi.set(__self__, "global_outage_policies", global_outage_policies)
        if local_outage is not None:
            pulumi.set(__self__, "local_outage", local_outage)
        if local_outage_policies is not None:
            pulumi.set(__self__, "local_outage_policies", local_outage_policies)
        if retry_on_error is not None:
            pulumi.set(__self__, "retry_on_error", retry_on_error)

    @property
    @pulumi.getter(name="globalOutage")
    def global_outage(self) -> Optional[bool]:
        """
        (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) When enabled (`true`), generate a problem and send an alert when the monitor is unavailable at all configured locations
        """
        return pulumi.get(self, "global_outage")

    @property
    @pulumi.getter(name="globalOutagePolicies")
    def global_outage_policies(self) -> Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy']]:
        """
        (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) Global outage handling configuration.
        """
        return pulumi.get(self, "global_outage_policies")

    @property
    @pulumi.getter(name="localOutage")
    def local_outage(self) -> Optional[bool]:
        """
        (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) When enabled (`true`), generate a problem and send an alert when the monitor is unavailable for one or more consecutive runs at any location
        """
        return pulumi.get(self, "local_outage")

    @property
    @pulumi.getter(name="localOutagePolicies")
    def local_outage_policies(self) -> Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy']]:
        """
        (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) Local outage handling configuration. 

         Alert if **affectedLocations** of locations are unable to access the web application **consecutiveRuns** times consecutively
        """
        return pulumi.get(self, "local_outage_policies")

    @property
    @pulumi.getter(name="retryOnError")
    def retry_on_error(self) -> Optional[bool]:
        """
        (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) Schedule retry if browser monitor execution results in a fail. For HTTP monitors this property is ignored
        """
        return pulumi.get(self, "retry_on_error")


@pulumi.output_type
class BrowserMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consecutiveRuns":
            suggest = "consecutive_runs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consecutive_runs: int):
        """
        :param int consecutive_runs: The number of consecutive fails to trigger an alert
        """
        pulumi.set(__self__, "consecutive_runs", consecutive_runs)

    @property
    @pulumi.getter(name="consecutiveRuns")
    def consecutive_runs(self) -> int:
        """
        The number of consecutive fails to trigger an alert
        """
        return pulumi.get(self, "consecutive_runs")


@pulumi.output_type
class BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "affectedLocations":
            suggest = "affected_locations"
        elif key == "consecutiveRuns":
            suggest = "consecutive_runs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affected_locations: int,
                 consecutive_runs: int):
        """
        :param int affected_locations: The number of affected locations to trigger an alert
        :param int consecutive_runs: The number of consecutive fails to trigger an alert
        """
        pulumi.set(__self__, "affected_locations", affected_locations)
        pulumi.set(__self__, "consecutive_runs", consecutive_runs)

    @property
    @pulumi.getter(name="affectedLocations")
    def affected_locations(self) -> int:
        """
        The number of affected locations to trigger an alert
        """
        return pulumi.get(self, "affected_locations")

    @property
    @pulumi.getter(name="consecutiveRuns")
    def consecutive_runs(self) -> int:
        """
        The number of consecutive fails to trigger an alert
        """
        return pulumi.get(self, "consecutive_runs")


@pulumi.output_type
class BrowserMonitorKeyPerformanceMetrics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadActionKpm":
            suggest = "load_action_kpm"
        elif key == "xhrActionKpm":
            suggest = "xhr_action_kpm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorKeyPerformanceMetrics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorKeyPerformanceMetrics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorKeyPerformanceMetrics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load_action_kpm: str,
                 xhr_action_kpm: str):
        """
        :param str load_action_kpm: Defines the key performance metric for load actions. Supported values are `VISUALLY_COMPLETE`, `SPEED_INDEX`, `USER_ACTION_DURATION`, `TIME_TO_FIRST_BYTE`, `HTML_DOWNLOADED`, `DOM_INTERACTIVE`, `LOAD_EVENT_START` and `LOAD_EVENT_END`.
        :param str xhr_action_kpm: Defines the key performance metric for XHR actions. Supported values are `VISUALLY_COMPLETE`, `USER_ACTION_DURATION`, `TIME_TO_FIRST_BYTE` and `RESPONSE_END`.
        """
        pulumi.set(__self__, "load_action_kpm", load_action_kpm)
        pulumi.set(__self__, "xhr_action_kpm", xhr_action_kpm)

    @property
    @pulumi.getter(name="loadActionKpm")
    def load_action_kpm(self) -> str:
        """
        Defines the key performance metric for load actions. Supported values are `VISUALLY_COMPLETE`, `SPEED_INDEX`, `USER_ACTION_DURATION`, `TIME_TO_FIRST_BYTE`, `HTML_DOWNLOADED`, `DOM_INTERACTIVE`, `LOAD_EVENT_START` and `LOAD_EVENT_END`.
        """
        return pulumi.get(self, "load_action_kpm")

    @property
    @pulumi.getter(name="xhrActionKpm")
    def xhr_action_kpm(self) -> str:
        """
        Defines the key performance metric for XHR actions. Supported values are `VISUALLY_COMPLETE`, `USER_ACTION_DURATION`, `TIME_TO_FIRST_BYTE` and `RESPONSE_END`.
        """
        return pulumi.get(self, "xhr_action_kpm")


@pulumi.output_type
class BrowserMonitorPerformanceThresholds(dict):
    def __init__(__self__, *,
                 thresholds: Sequence['outputs.BrowserMonitorPerformanceThresholdsThreshold']):
        pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.BrowserMonitorPerformanceThresholdsThreshold']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class BrowserMonitorPerformanceThresholdsThreshold(dict):
    def __init__(__self__, *,
                 event: str,
                 threshold: float):
        """
        :param str event: Synthetic event
        :param float threshold: Threshold (in seconds)
        """
        pulumi.set(__self__, "event", event)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def event(self) -> str:
        """
        Synthetic event
        """
        return pulumi.get(self, "event")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Threshold (in seconds)
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class BrowserMonitorScript(dict):
    def __init__(__self__, *,
                 type: str,
                 configuration: Optional['outputs.BrowserMonitorScriptConfiguration'] = None,
                 events: Optional['outputs.BrowserMonitorScriptEvents'] = None):
        """
        :param str type: The type of monitor. Possible values are `clickpath` for clickpath monitors and `availability` for single-URL browser monitors. These monitors are only allowed to have one event of the `navigate` type
        :param 'BrowserMonitorScriptConfigurationArgs' configuration: The setup of the monitor
        :param 'BrowserMonitorScriptEventsArgs' events: Steps of the clickpath—the first step must always be of the `navigate` type
        """
        pulumi.set(__self__, "type", type)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if events is not None:
            pulumi.set(__self__, "events", events)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of monitor. Possible values are `clickpath` for clickpath monitors and `availability` for single-URL browser monitors. These monitors are only allowed to have one event of the `navigate` type
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.BrowserMonitorScriptConfiguration']:
        """
        The setup of the monitor
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def events(self) -> Optional['outputs.BrowserMonitorScriptEvents']:
        """
        Steps of the clickpath—the first step must always be of the `navigate` type
        """
        return pulumi.get(self, "events")


@pulumi.output_type
class BrowserMonitorScriptConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bypassCsp":
            suggest = "bypass_csp"
        elif key == "disableWebSecurity":
            suggest = "disable_web_security"
        elif key == "ignoredErrorCodes":
            suggest = "ignored_error_codes"
        elif key == "javascriptSetttings":
            suggest = "javascript_setttings"
        elif key == "monitorFrames":
            suggest = "monitor_frames"
        elif key == "userAgent":
            suggest = "user_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth: Optional['outputs.BrowserMonitorScriptConfigurationBandwidth'] = None,
                 blocks: Optional[Sequence[str]] = None,
                 bypass_csp: Optional[bool] = None,
                 cookies: Optional['outputs.BrowserMonitorScriptConfigurationCookies'] = None,
                 device: Optional['outputs.BrowserMonitorScriptConfigurationDevice'] = None,
                 disable_web_security: Optional[bool] = None,
                 headers: Optional['outputs.BrowserMonitorScriptConfigurationHeaders'] = None,
                 ignored_error_codes: Optional['outputs.BrowserMonitorScriptConfigurationIgnoredErrorCodes'] = None,
                 javascript_setttings: Optional['outputs.BrowserMonitorScriptConfigurationJavascriptSetttings'] = None,
                 monitor_frames: Optional[bool] = None,
                 user_agent: Optional[str] = None):
        """
        :param 'BrowserMonitorScriptConfigurationBandwidthArgs' bandwidth: The emulated device of the monitor—holds either the parameters of the custom device or the name and orientation of the preconfigured device.
        :param Sequence[str] blocks: Block these URLs
        :param bool bypass_csp: Bypass Content Security Policy of monitored pages
        :param 'BrowserMonitorScriptConfigurationCookiesArgs' cookies: These cookies are added before execution of the first step
        :param 'BrowserMonitorScriptConfigurationDeviceArgs' device: The emulated device of the monitor—holds either the parameters of the custom device or the name and orientation of the preconfigured device.
               
               If not set, then the Desktop preconfigured device is used
        :param bool disable_web_security: No documentation available
        :param 'BrowserMonitorScriptConfigurationHeadersArgs' headers: The list of HTTP headers to be sent with requests of the monitor
        :param 'BrowserMonitorScriptConfigurationIgnoredErrorCodesArgs' ignored_error_codes: Ignore specific status codes
        :param 'BrowserMonitorScriptConfigurationJavascriptSetttingsArgs' javascript_setttings: Custom JavaScript Agent settings
        :param bool monitor_frames: Capture performance metrics for pages loaded in frames
        :param str user_agent: The user agent of the request
        """
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if blocks is not None:
            pulumi.set(__self__, "blocks", blocks)
        if bypass_csp is not None:
            pulumi.set(__self__, "bypass_csp", bypass_csp)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if disable_web_security is not None:
            pulumi.set(__self__, "disable_web_security", disable_web_security)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ignored_error_codes is not None:
            pulumi.set(__self__, "ignored_error_codes", ignored_error_codes)
        if javascript_setttings is not None:
            pulumi.set(__self__, "javascript_setttings", javascript_setttings)
        if monitor_frames is not None:
            pulumi.set(__self__, "monitor_frames", monitor_frames)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional['outputs.BrowserMonitorScriptConfigurationBandwidth']:
        """
        The emulated device of the monitor—holds either the parameters of the custom device or the name and orientation of the preconfigured device.
        """
        return pulumi.get(self, "bandwidth")

    @property
    @pulumi.getter
    def blocks(self) -> Optional[Sequence[str]]:
        """
        Block these URLs
        """
        return pulumi.get(self, "blocks")

    @property
    @pulumi.getter(name="bypassCsp")
    def bypass_csp(self) -> Optional[bool]:
        """
        Bypass Content Security Policy of monitored pages
        """
        return pulumi.get(self, "bypass_csp")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.BrowserMonitorScriptConfigurationCookies']:
        """
        These cookies are added before execution of the first step
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def device(self) -> Optional['outputs.BrowserMonitorScriptConfigurationDevice']:
        """
        The emulated device of the monitor—holds either the parameters of the custom device or the name and orientation of the preconfigured device.

        If not set, then the Desktop preconfigured device is used
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter(name="disableWebSecurity")
    def disable_web_security(self) -> Optional[bool]:
        """
        No documentation available
        """
        return pulumi.get(self, "disable_web_security")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.BrowserMonitorScriptConfigurationHeaders']:
        """
        The list of HTTP headers to be sent with requests of the monitor
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ignoredErrorCodes")
    def ignored_error_codes(self) -> Optional['outputs.BrowserMonitorScriptConfigurationIgnoredErrorCodes']:
        """
        Ignore specific status codes
        """
        return pulumi.get(self, "ignored_error_codes")

    @property
    @pulumi.getter(name="javascriptSetttings")
    def javascript_setttings(self) -> Optional['outputs.BrowserMonitorScriptConfigurationJavascriptSetttings']:
        """
        Custom JavaScript Agent settings
        """
        return pulumi.get(self, "javascript_setttings")

    @property
    @pulumi.getter(name="monitorFrames")
    def monitor_frames(self) -> Optional[bool]:
        """
        Capture performance metrics for pages loaded in frames
        """
        return pulumi.get(self, "monitor_frames")

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[str]:
        """
        The user agent of the request
        """
        return pulumi.get(self, "user_agent")


@pulumi.output_type
class BrowserMonitorScriptConfigurationBandwidth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkType":
            suggest = "network_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfigurationBandwidth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfigurationBandwidth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfigurationBandwidth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 download: Optional[int] = None,
                 latency: Optional[int] = None,
                 network_type: Optional[str] = None,
                 upload: Optional[int] = None):
        """
        :param int download: The download speed of the network, in bytes per second
        :param int latency: The latency of the network, in milliseconds
        :param str network_type: The type of the preconfigured network—when editing in the browser, press `Crtl+Spacebar` to see the list of available networks
        :param int upload: The upload speed of the network, in bytes per second
        """
        if download is not None:
            pulumi.set(__self__, "download", download)
        if latency is not None:
            pulumi.set(__self__, "latency", latency)
        if network_type is not None:
            pulumi.set(__self__, "network_type", network_type)
        if upload is not None:
            pulumi.set(__self__, "upload", upload)

    @property
    @pulumi.getter
    def download(self) -> Optional[int]:
        """
        The download speed of the network, in bytes per second
        """
        return pulumi.get(self, "download")

    @property
    @pulumi.getter
    def latency(self) -> Optional[int]:
        """
        The latency of the network, in milliseconds
        """
        return pulumi.get(self, "latency")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[str]:
        """
        The type of the preconfigured network—when editing in the browser, press `Crtl+Spacebar` to see the list of available networks
        """
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter
    def upload(self) -> Optional[int]:
        """
        The upload speed of the network, in bytes per second
        """
        return pulumi.get(self, "upload")


@pulumi.output_type
class BrowserMonitorScriptConfigurationCookies(dict):
    def __init__(__self__, *,
                 cookies: Sequence['outputs.BrowserMonitorScriptConfigurationCookiesCookie']):
        """
        :param Sequence['BrowserMonitorScriptConfigurationCookiesCookieArgs'] cookies: A request cookie
        """
        pulumi.set(__self__, "cookies", cookies)

    @property
    @pulumi.getter
    def cookies(self) -> Sequence['outputs.BrowserMonitorScriptConfigurationCookiesCookie']:
        """
        A request cookie
        """
        return pulumi.get(self, "cookies")


@pulumi.output_type
class BrowserMonitorScriptConfigurationCookiesCookie(dict):
    def __init__(__self__, *,
                 domain: str,
                 name: str,
                 value: str,
                 path: Optional[str] = None):
        """
        :param str domain: The domain of the cookie.
        :param str name: The name of the cookie. The following cookie names are now allowed: `dtCookie`, `dtLatC`, `dtPC`, `rxVisitor`, `rxlatency`, `rxpc`, `rxsession` and `rxvt`
        :param str value: The value of the cookie. The following symbols are not allowed: `;`, `,`, `\\` and `"`.
        :param str path: The path of the cookie.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The domain of the cookie.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the cookie. The following cookie names are now allowed: `dtCookie`, `dtLatC`, `dtPC`, `rxVisitor`, `rxlatency`, `rxpc`, `rxsession` and `rxvt`
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the cookie. The following symbols are not allowed: `;`, `,`, `\\` and `"`.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path of the cookie.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class BrowserMonitorScriptConfigurationDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleFactor":
            suggest = "scale_factor"
        elif key == "touchEnabled":
            suggest = "touch_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfigurationDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfigurationDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfigurationDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 height: Optional[int] = None,
                 mobile: Optional[bool] = None,
                 name: Optional[str] = None,
                 orientation: Optional[str] = None,
                 scale_factor: Optional[float] = None,
                 touch_enabled: Optional[bool] = None,
                 width: Optional[int] = None):
        """
        :param int height: The height of the screen in pixels.
               The maximum allowed width is `1080`.
        :param bool mobile: The flag of the mobile device.
               Set to `true` for mobile devices or `false` for a desktop or laptop.
        :param str name: The name of the preconfigured device—when editing in the browser, press `Crtl+Spacebar` to see the list of available devices
        :param str orientation: The orientation of the device. Possible values are `portrait` or `landscape`. Desktop and laptop devices are not allowed to use the `portrait` orientation
        :param float scale_factor: The pixel ratio of the device.
        :param bool touch_enabled: The flag of the touchscreen.
               Set to `true` if the device uses touchscreen. In that case, use can set interaction event as `tap`.
        :param int width: The width of the screen in pixels.
               The maximum allowed width is `1920`.
        """
        if height is not None:
            pulumi.set(__self__, "height", height)
        if mobile is not None:
            pulumi.set(__self__, "mobile", mobile)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if orientation is not None:
            pulumi.set(__self__, "orientation", orientation)
        if scale_factor is not None:
            pulumi.set(__self__, "scale_factor", scale_factor)
        if touch_enabled is not None:
            pulumi.set(__self__, "touch_enabled", touch_enabled)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        """
        The height of the screen in pixels.
        The maximum allowed width is `1080`.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def mobile(self) -> Optional[bool]:
        """
        The flag of the mobile device.
        Set to `true` for mobile devices or `false` for a desktop or laptop.
        """
        return pulumi.get(self, "mobile")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the preconfigured device—when editing in the browser, press `Crtl+Spacebar` to see the list of available devices
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def orientation(self) -> Optional[str]:
        """
        The orientation of the device. Possible values are `portrait` or `landscape`. Desktop and laptop devices are not allowed to use the `portrait` orientation
        """
        return pulumi.get(self, "orientation")

    @property
    @pulumi.getter(name="scaleFactor")
    def scale_factor(self) -> Optional[float]:
        """
        The pixel ratio of the device.
        """
        return pulumi.get(self, "scale_factor")

    @property
    @pulumi.getter(name="touchEnabled")
    def touch_enabled(self) -> Optional[bool]:
        """
        The flag of the touchscreen.
        Set to `true` if the device uses touchscreen. In that case, use can set interaction event as `tap`.
        """
        return pulumi.get(self, "touch_enabled")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        """
        The width of the screen in pixels.
        The maximum allowed width is `1920`.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class BrowserMonitorScriptConfigurationHeaders(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.BrowserMonitorScriptConfigurationHeadersHeader'],
                 restrictions: Optional[Sequence[str]] = None):
        """
        :param Sequence['BrowserMonitorScriptConfigurationHeadersHeaderArgs'] headers: contains an HTTP header of the request
        :param Sequence[str] restrictions: Restrict applying headers to a set of URLs
        """
        pulumi.set(__self__, "headers", headers)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.BrowserMonitorScriptConfigurationHeadersHeader']:
        """
        contains an HTTP header of the request
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[Sequence[str]]:
        """
        Restrict applying headers to a set of URLs
        """
        return pulumi.get(self, "restrictions")


@pulumi.output_type
class BrowserMonitorScriptConfigurationHeadersHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The key of the header
        :param str value: The value of the header
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The key of the header
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the header
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptConfigurationIgnoredErrorCodes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodes":
            suggest = "status_codes"
        elif key == "matchingDocumentRequests":
            suggest = "matching_document_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfigurationIgnoredErrorCodes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfigurationIgnoredErrorCodes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfigurationIgnoredErrorCodes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_codes: str,
                 matching_document_requests: Optional[str] = None):
        """
        :param str status_codes: You can use exact number, range or status class mask. Multiple values can be separated by comma, i.e. 404, 405-410, 5xx
        :param str matching_document_requests: Only apply to document request matching this regex
        """
        pulumi.set(__self__, "status_codes", status_codes)
        if matching_document_requests is not None:
            pulumi.set(__self__, "matching_document_requests", matching_document_requests)

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> str:
        """
        You can use exact number, range or status class mask. Multiple values can be separated by comma, i.e. 404, 405-410, 5xx
        """
        return pulumi.get(self, "status_codes")

    @property
    @pulumi.getter(name="matchingDocumentRequests")
    def matching_document_requests(self) -> Optional[str]:
        """
        Only apply to document request matching this regex
        """
        return pulumi.get(self, "matching_document_requests")


@pulumi.output_type
class BrowserMonitorScriptConfigurationJavascriptSetttings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customProperties":
            suggest = "custom_properties"
        elif key == "timeoutSettings":
            suggest = "timeout_settings"
        elif key == "visuallyCompleteOptions":
            suggest = "visually_complete_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfigurationJavascriptSetttings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfigurationJavascriptSetttings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfigurationJavascriptSetttings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_properties: Optional[str] = None,
                 timeout_settings: Optional['outputs.BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings'] = None,
                 visually_complete_options: Optional['outputs.BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions'] = None):
        """
        :param str custom_properties: Additional Javascript Agent Properties
        :param 'BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettingsArgs' timeout_settings: Custom JavaScript Agent settings
        :param 'BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptionsArgs' visually_complete_options: Parameters for Visually complete and Speed index calculation
        """
        if custom_properties is not None:
            pulumi.set(__self__, "custom_properties", custom_properties)
        if timeout_settings is not None:
            pulumi.set(__self__, "timeout_settings", timeout_settings)
        if visually_complete_options is not None:
            pulumi.set(__self__, "visually_complete_options", visually_complete_options)

    @property
    @pulumi.getter(name="customProperties")
    def custom_properties(self) -> Optional[str]:
        """
        Additional Javascript Agent Properties
        """
        return pulumi.get(self, "custom_properties")

    @property
    @pulumi.getter(name="timeoutSettings")
    def timeout_settings(self) -> Optional['outputs.BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings']:
        """
        Custom JavaScript Agent settings
        """
        return pulumi.get(self, "timeout_settings")

    @property
    @pulumi.getter(name="visuallyCompleteOptions")
    def visually_complete_options(self) -> Optional['outputs.BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions']:
        """
        Parameters for Visually complete and Speed index calculation
        """
        return pulumi.get(self, "visually_complete_options")


@pulumi.output_type
class BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionLimit":
            suggest = "action_limit"
        elif key == "totalTimeout":
            suggest = "total_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_limit: int,
                 total_timeout: int):
        """
        :param int action_limit: Track up to n cascading setTimeout calls
        :param int total_timeout: Limit cascading timeouts cumulatively to n ms
        """
        pulumi.set(__self__, "action_limit", action_limit)
        pulumi.set(__self__, "total_timeout", total_timeout)

    @property
    @pulumi.getter(name="actionLimit")
    def action_limit(self) -> int:
        """
        Track up to n cascading setTimeout calls
        """
        return pulumi.get(self, "action_limit")

    @property
    @pulumi.getter(name="totalTimeout")
    def total_timeout(self) -> int:
        """
        Limit cascading timeouts cumulatively to n ms
        """
        return pulumi.get(self, "total_timeout")


@pulumi.output_type
class BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageSizeThreshold":
            suggest = "image_size_threshold"
        elif key == "inactivityTimeout":
            suggest = "inactivity_timeout"
        elif key == "mutationTimeout":
            suggest = "mutation_timeout"
        elif key == "excludedElements":
            suggest = "excluded_elements"
        elif key == "excludedUrls":
            suggest = "excluded_urls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_size_threshold: int,
                 inactivity_timeout: int,
                 mutation_timeout: int,
                 excluded_elements: Optional[Sequence[str]] = None,
                 excluded_urls: Optional[Sequence[str]] = None):
        """
        :param int image_size_threshold: Use this setting to define the minimum visible area per element (in pixels) for an element to be counted towards Visually complete and Speed index
        :param int inactivity_timeout: The time the Visually complete module waits for inactivity and no further mutations on the page after the load action
        :param int mutation_timeout: The time the Visually complete module waits after an XHR or custom action closes to start the calculation
        :param Sequence[str] excluded_elements: Query CSS selectors to specify mutation nodes (elements that change) to ignore in Visually complete and Speed index calculation
        :param Sequence[str] excluded_urls: Parameters for Visually complete and Speed index calculation
        """
        pulumi.set(__self__, "image_size_threshold", image_size_threshold)
        pulumi.set(__self__, "inactivity_timeout", inactivity_timeout)
        pulumi.set(__self__, "mutation_timeout", mutation_timeout)
        if excluded_elements is not None:
            pulumi.set(__self__, "excluded_elements", excluded_elements)
        if excluded_urls is not None:
            pulumi.set(__self__, "excluded_urls", excluded_urls)

    @property
    @pulumi.getter(name="imageSizeThreshold")
    def image_size_threshold(self) -> int:
        """
        Use this setting to define the minimum visible area per element (in pixels) for an element to be counted towards Visually complete and Speed index
        """
        return pulumi.get(self, "image_size_threshold")

    @property
    @pulumi.getter(name="inactivityTimeout")
    def inactivity_timeout(self) -> int:
        """
        The time the Visually complete module waits for inactivity and no further mutations on the page after the load action
        """
        return pulumi.get(self, "inactivity_timeout")

    @property
    @pulumi.getter(name="mutationTimeout")
    def mutation_timeout(self) -> int:
        """
        The time the Visually complete module waits after an XHR or custom action closes to start the calculation
        """
        return pulumi.get(self, "mutation_timeout")

    @property
    @pulumi.getter(name="excludedElements")
    def excluded_elements(self) -> Optional[Sequence[str]]:
        """
        Query CSS selectors to specify mutation nodes (elements that change) to ignore in Visually complete and Speed index calculation
        """
        return pulumi.get(self, "excluded_elements")

    @property
    @pulumi.getter(name="excludedUrls")
    def excluded_urls(self) -> Optional[Sequence[str]]:
        """
        Parameters for Visually complete and Speed index calculation
        """
        return pulumi.get(self, "excluded_urls")


@pulumi.output_type
class BrowserMonitorScriptEvents(dict):
    def __init__(__self__, *,
                 events: Optional[Sequence['outputs.BrowserMonitorScriptEventsEvent']] = None):
        """
        :param Sequence['BrowserMonitorScriptEventsEventArgs'] events: An event
        """
        if events is not None:
            pulumi.set(__self__, "events", events)

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEvent']]:
        """
        An event
        """
        return pulumi.get(self, "events")


@pulumi.output_type
class BrowserMonitorScriptEventsEvent(dict):
    def __init__(__self__, *,
                 description: str,
                 click: Optional['outputs.BrowserMonitorScriptEventsEventClick'] = None,
                 cookie: Optional['outputs.BrowserMonitorScriptEventsEventCookie'] = None,
                 javascript: Optional['outputs.BrowserMonitorScriptEventsEventJavascript'] = None,
                 keystrokes: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokes'] = None,
                 navigate: Optional['outputs.BrowserMonitorScriptEventsEventNavigate'] = None,
                 select: Optional['outputs.BrowserMonitorScriptEventsEventSelect'] = None,
                 tap: Optional['outputs.BrowserMonitorScriptEventsEventTap'] = None):
        """
        :param str description: A short description of the event to appear in the UI
        :param 'BrowserMonitorScriptEventsEventClickArgs' click: Properties specified for a click event
        :param 'BrowserMonitorScriptEventsEventCookieArgs' cookie: Properties specified for a cookie event
        :param 'BrowserMonitorScriptEventsEventJavascriptArgs' javascript: Properties specified for a javascript event
        :param 'BrowserMonitorScriptEventsEventKeystrokesArgs' keystrokes: Properties specified for a key strokes event
        :param 'BrowserMonitorScriptEventsEventNavigateArgs' navigate: Properties specified for a navigation event
        :param 'BrowserMonitorScriptEventsEventSelectArgs' select: Properties specified for a key strokes event.
        :param 'BrowserMonitorScriptEventsEventTapArgs' tap: Properties specified for a tap event
        """
        pulumi.set(__self__, "description", description)
        if click is not None:
            pulumi.set(__self__, "click", click)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if javascript is not None:
            pulumi.set(__self__, "javascript", javascript)
        if keystrokes is not None:
            pulumi.set(__self__, "keystrokes", keystrokes)
        if navigate is not None:
            pulumi.set(__self__, "navigate", navigate)
        if select is not None:
            pulumi.set(__self__, "select", select)
        if tap is not None:
            pulumi.set(__self__, "tap", tap)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A short description of the event to appear in the UI
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def click(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClick']:
        """
        Properties specified for a click event
        """
        return pulumi.get(self, "click")

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.BrowserMonitorScriptEventsEventCookie']:
        """
        Properties specified for a cookie event
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter
    def javascript(self) -> Optional['outputs.BrowserMonitorScriptEventsEventJavascript']:
        """
        Properties specified for a javascript event
        """
        return pulumi.get(self, "javascript")

    @property
    @pulumi.getter
    def keystrokes(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokes']:
        """
        Properties specified for a key strokes event
        """
        return pulumi.get(self, "keystrokes")

    @property
    @pulumi.getter
    def navigate(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigate']:
        """
        Properties specified for a navigation event
        """
        return pulumi.get(self, "navigate")

    @property
    @pulumi.getter
    def select(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelect']:
        """
        Properties specified for a key strokes event.
        """
        return pulumi.get(self, "select")

    @property
    @pulumi.getter
    def tap(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTap']:
        """
        Properties specified for a tap event
        """
        return pulumi.get(self, "tap")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClick(dict):
    def __init__(__self__, *,
                 button: int,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventClickTarget'] = None,
                 validate: Optional['outputs.BrowserMonitorScriptEventsEventClickValidate'] = None,
                 wait: Optional['outputs.BrowserMonitorScriptEventsEventClickWait'] = None):
        """
        :param int button: the mouse button to be used for the click
        :param 'BrowserMonitorScriptEventsEventClickTargetArgs' target: The tab on which the page should open
        :param 'BrowserMonitorScriptEventsEventClickValidateArgs' validate: The validation rules for the event—helps you verify that your browser monitor loads the expected page content or page element
        :param 'BrowserMonitorScriptEventsEventClickWaitArgs' wait: The wait condition for the event—defines how long Dynatrace should wait before the next action is executed
        """
        pulumi.set(__self__, "button", button)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if validate is not None:
            pulumi.set(__self__, "validate", validate)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def button(self) -> int:
        """
        the mouse button to be used for the click
        """
        return pulumi.get(self, "button")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClickTarget']:
        """
        The tab on which the page should open
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def validate(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClickValidate']:
        """
        The validation rules for the event—helps you verify that your browser monitor loads the expected page content or page element
        """
        return pulumi.get(self, "validate")

    @property
    @pulumi.getter
    def wait(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClickWait']:
        """
        The wait condition for the event—defines how long Dynatrace should wait before the next action is executed
        """
        return pulumi.get(self, "wait")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventClickTargetLocator']] = None,
                 window: Optional[str] = None):
        """
        :param Sequence['BrowserMonitorScriptEventsEventClickTargetLocatorArgs'] locators: The list of locators identifying the desired element
        :param str window: The tab of the target
        """
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventClickTargetLocator']]:
        """
        The list of locators identifying the desired element
        """
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        """
        The tab of the target
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventClickTargetLocatorLocator']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventClickTargetLocatorLocatorArgs'] locators: A locator dentifyies the desired element
        """
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventClickTargetLocatorLocator']:
        """
        A locator dentifyies the desired element
        """
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        :param str value: The name of the element to be found
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The name of the element to be found
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickValidate(dict):
    def __init__(__self__, *,
                 validations: Sequence['outputs.BrowserMonitorScriptEventsEventClickValidateValidation']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventClickValidateValidationArgs'] validations: The element to wait for. Required for the `validation` type, not applicable otherwise.
        """
        pulumi.set(__self__, "validations", validations)

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventClickValidateValidation']:
        """
        The element to wait for. Required for the `validation` type, not applicable otherwise.
        """
        return pulumi.get(self, "validations")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickValidateValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventClickValidateValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventClickValidateValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventClickValidateValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventClickValidateValidationTarget'] = None):
        """
        :param str type: The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        :param bool fail_if_found: The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        :param str match: The content to look for on the page.
               Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        :param bool regex: Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        :param 'BrowserMonitorScriptEventsEventClickValidateValidationTargetArgs' target: The elemnt to look for on the page
        """
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        """
        The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        """
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        The content to look for on the page.
        Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        """
        Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClickValidateValidationTarget']:
        """
        The elemnt to look for on the page
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickValidateValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventClickValidateValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        """
        :param Sequence['BrowserMonitorScriptEventsEventClickValidateValidationTargetLocatorArgs'] locators: The list of locators identifying the desired element
        :param str window: The tab of the target
        """
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventClickValidateValidationTargetLocator']]:
        """
        The list of locators identifying the desired element
        """
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        """
        The tab of the target
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickValidateValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventClickValidateValidationTargetLocatorLocator']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventClickValidateValidationTargetLocatorLocatorArgs'] locators: A locator dentifyies the desired element
        """
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventClickValidateValidationTargetLocatorLocator']:
        """
        A locator dentifyies the desired element
        """
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickValidateValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        :param str value: The name of the element to be found
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The name of the element to be found
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickWait(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitFor":
            suggest = "wait_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventClickWait. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventClickWait.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventClickWait.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_for: str,
                 milliseconds: Optional[int] = None,
                 timeout: Optional[int] = None,
                 validation: Optional['outputs.BrowserMonitorScriptEventsEventClickWaitValidation'] = None):
        """
        :param str wait_for: The time to wait before the next event is triggered. Possible values are `page_complete` (wait for the page to load completely), `network` (wait for background network activity to complete), `next_action` (wait for the next action), `time` (wait for a specified periodof time) and `validation` (wait for a specific element to appear)
        :param int milliseconds: The time to wait, in millisencods. The maximum allowed value is `60000`. Required for the type `time`, not applicable otherwise.
        :param int timeout: he maximum amount of time to wait for a certain element to appear, in milliseconds—if exceeded, the action is marked as failed.
               The maximum allowed value is 60000. Required for the type `validation`, not applicable otherwise..
        :param 'BrowserMonitorScriptEventsEventClickWaitValidationArgs' validation: The elements to wait for. Required for the `validation` type, not applicable otherwise.
        """
        pulumi.set(__self__, "wait_for", wait_for)
        if milliseconds is not None:
            pulumi.set(__self__, "milliseconds", milliseconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter(name="waitFor")
    def wait_for(self) -> str:
        """
        The time to wait before the next event is triggered. Possible values are `page_complete` (wait for the page to load completely), `network` (wait for background network activity to complete), `next_action` (wait for the next action), `time` (wait for a specified periodof time) and `validation` (wait for a specific element to appear)
        """
        return pulumi.get(self, "wait_for")

    @property
    @pulumi.getter
    def milliseconds(self) -> Optional[int]:
        """
        The time to wait, in millisencods. The maximum allowed value is `60000`. Required for the type `time`, not applicable otherwise.
        """
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        he maximum amount of time to wait for a certain element to appear, in milliseconds—if exceeded, the action is marked as failed.
        The maximum allowed value is 60000. Required for the type `validation`, not applicable otherwise..
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClickWaitValidation']:
        """
        The elements to wait for. Required for the `validation` type, not applicable otherwise.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickWaitValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventClickWaitValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventClickWaitValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventClickWaitValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventClickWaitValidationTarget'] = None):
        """
        :param str type: The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        :param bool fail_if_found: The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        :param str match: The content to look for on the page.
               Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        :param bool regex: Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        :param 'BrowserMonitorScriptEventsEventClickWaitValidationTargetArgs' target: The elemnt to look for on the page
        """
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        """
        The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        """
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        The content to look for on the page.
        Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        """
        Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClickWaitValidationTarget']:
        """
        The elemnt to look for on the page
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickWaitValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventClickWaitValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        """
        :param Sequence['BrowserMonitorScriptEventsEventClickWaitValidationTargetLocatorArgs'] locators: The list of locators identifying the desired element
        :param str window: The tab of the target
        """
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventClickWaitValidationTargetLocator']]:
        """
        The list of locators identifying the desired element
        """
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        """
        The tab of the target
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickWaitValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventClickWaitValidationTargetLocatorLocator']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventClickWaitValidationTargetLocatorLocatorArgs'] locators: A locator dentifyies the desired element
        """
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventClickWaitValidationTargetLocatorLocator']:
        """
        A locator dentifyies the desired element
        """
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickWaitValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        :param str value: The name of the element to be found
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The name of the element to be found
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventCookie(dict):
    def __init__(__self__, *,
                 cookies: 'outputs.BrowserMonitorScriptEventsEventCookieCookies'):
        """
        :param 'BrowserMonitorScriptEventsEventCookieCookiesArgs' cookies: Every cookie must be unique within the list. However, you can use the same cookie again in other event
        """
        pulumi.set(__self__, "cookies", cookies)

    @property
    @pulumi.getter
    def cookies(self) -> 'outputs.BrowserMonitorScriptEventsEventCookieCookies':
        """
        Every cookie must be unique within the list. However, you can use the same cookie again in other event
        """
        return pulumi.get(self, "cookies")


@pulumi.output_type
class BrowserMonitorScriptEventsEventCookieCookies(dict):
    def __init__(__self__, *,
                 cookies: Sequence['outputs.BrowserMonitorScriptEventsEventCookieCookiesCookie']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventCookieCookiesCookieArgs'] cookies: A request cookie
        """
        pulumi.set(__self__, "cookies", cookies)

    @property
    @pulumi.getter
    def cookies(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventCookieCookiesCookie']:
        """
        A request cookie
        """
        return pulumi.get(self, "cookies")


@pulumi.output_type
class BrowserMonitorScriptEventsEventCookieCookiesCookie(dict):
    def __init__(__self__, *,
                 domain: str,
                 name: str,
                 value: str,
                 path: Optional[str] = None):
        """
        :param str domain: The domain of the cookie.
        :param str name: The name of the cookie. The following cookie names are now allowed: `dtCookie`, `dtLatC`, `dtPC`, `rxVisitor`, `rxlatency`, `rxpc`, `rxsession` and `rxvt`
        :param str value: The value of the cookie. The following symbols are not allowed: `;`, `,`, `\\` and `"`.
        :param str path: The path of the cookie.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The domain of the cookie.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the cookie. The following cookie names are now allowed: `dtCookie`, `dtLatC`, `dtPC`, `rxVisitor`, `rxlatency`, `rxpc`, `rxsession` and `rxvt`
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the cookie. The following symbols are not allowed: `;`, `,`, `\\` and `"`.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path of the cookie.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascript(dict):
    def __init__(__self__, *,
                 code: str,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventJavascriptTarget'] = None,
                 wait: Optional['outputs.BrowserMonitorScriptEventsEventJavascriptWait'] = None):
        """
        :param str code: The JavaScript code to be executed in this event
        :param 'BrowserMonitorScriptEventsEventJavascriptTargetArgs' target: The tab on which the page should open
        :param 'BrowserMonitorScriptEventsEventJavascriptWaitArgs' wait: The wait condition for the event—defines how long Dynatrace should wait before the next action is executed
        """
        pulumi.set(__self__, "code", code)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        The JavaScript code to be executed in this event
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventJavascriptTarget']:
        """
        The tab on which the page should open
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def wait(self) -> Optional['outputs.BrowserMonitorScriptEventsEventJavascriptWait']:
        """
        The wait condition for the event—defines how long Dynatrace should wait before the next action is executed
        """
        return pulumi.get(self, "wait")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptTargetLocator']] = None,
                 window: Optional[str] = None):
        """
        :param Sequence['BrowserMonitorScriptEventsEventJavascriptTargetLocatorArgs'] locators: The list of locators identifying the desired element
        :param str window: The tab of the target
        """
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptTargetLocator']]:
        """
        The list of locators identifying the desired element
        """
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        """
        The tab of the target
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptTargetLocatorLocator']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventJavascriptTargetLocatorLocatorArgs'] locators: A locator dentifyies the desired element
        """
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptTargetLocatorLocator']:
        """
        A locator dentifyies the desired element
        """
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        :param str value: The name of the element to be found
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The name of the element to be found
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptWait(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitFor":
            suggest = "wait_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventJavascriptWait. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventJavascriptWait.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventJavascriptWait.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_for: str,
                 milliseconds: Optional[int] = None,
                 timeout: Optional[int] = None,
                 validation: Optional['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidation'] = None):
        """
        :param str wait_for: The time to wait before the next event is triggered. Possible values are `page_complete` (wait for the page to load completely), `network` (wait for background network activity to complete), `next_action` (wait for the next action), `time` (wait for a specified periodof time) and `validation` (wait for a specific element to appear)
        :param int milliseconds: The time to wait, in millisencods. The maximum allowed value is `60000`. Required for the type `time`, not applicable otherwise.
        :param int timeout: he maximum amount of time to wait for a certain element to appear, in milliseconds—if exceeded, the action is marked as failed.
               The maximum allowed value is 60000. Required for the type `validation`, not applicable otherwise..
        :param 'BrowserMonitorScriptEventsEventJavascriptWaitValidationArgs' validation: The elements to wait for. Required for the `validation` type, not applicable otherwise.
        """
        pulumi.set(__self__, "wait_for", wait_for)
        if milliseconds is not None:
            pulumi.set(__self__, "milliseconds", milliseconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter(name="waitFor")
    def wait_for(self) -> str:
        """
        The time to wait before the next event is triggered. Possible values are `page_complete` (wait for the page to load completely), `network` (wait for background network activity to complete), `next_action` (wait for the next action), `time` (wait for a specified periodof time) and `validation` (wait for a specific element to appear)
        """
        return pulumi.get(self, "wait_for")

    @property
    @pulumi.getter
    def milliseconds(self) -> Optional[int]:
        """
        The time to wait, in millisencods. The maximum allowed value is `60000`. Required for the type `time`, not applicable otherwise.
        """
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        he maximum amount of time to wait for a certain element to appear, in milliseconds—if exceeded, the action is marked as failed.
        The maximum allowed value is 60000. Required for the type `validation`, not applicable otherwise..
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidation']:
        """
        The elements to wait for. Required for the `validation` type, not applicable otherwise.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptWaitValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventJavascriptWaitValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventJavascriptWaitValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventJavascriptWaitValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTarget'] = None):
        """
        :param str type: The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        :param bool fail_if_found: The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        :param str match: The content to look for on the page.
               Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        :param bool regex: Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        :param 'BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetArgs' target: The elemnt to look for on the page
        """
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        """
        The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        """
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        The content to look for on the page.
        Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        """
        Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTarget']:
        """
        The elemnt to look for on the page
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptWaitValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        """
        :param Sequence['BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocatorArgs'] locators: The list of locators identifying the desired element
        :param str window: The tab of the target
        """
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocator']]:
        """
        The list of locators identifying the desired element
        """
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        """
        The tab of the target
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocatorLocator']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocatorLocatorArgs'] locators: A locator dentifyies the desired element
        """
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocatorLocator']:
        """
        A locator dentifyies the desired element
        """
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        :param str value: The name of the element to be found
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The name of the element to be found
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "simulateBlurEvent":
            suggest = "simulate_blur_event"
        elif key == "simulateReturnKey":
            suggest = "simulate_return_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventKeystrokes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventKeystrokes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventKeystrokes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credential: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesCredential'] = None,
                 masked: Optional[bool] = None,
                 simulate_blur_event: Optional[bool] = None,
                 simulate_return_key: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesTarget'] = None,
                 text: Optional[str] = None,
                 validate: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesValidate'] = None,
                 wait: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesWait'] = None):
        """
        :param 'BrowserMonitorScriptEventsEventKeystrokesCredentialArgs' credential: Credentials for this event
        :param bool masked: Indicates whether the `textValue` is encrypted (`true`) or not (`false`). Must not be specified if `credentials` from the vault are being used
        :param bool simulate_blur_event: Defines whether to blur the text field when it loses focus.
               Set to `true` to trigger the blur the `textValue`
        :param bool simulate_return_key: Simulates pressing the 'Return' key after simulating other keystrokes. For example, to submit a form or trigger a login.
        :param 'BrowserMonitorScriptEventsEventKeystrokesTargetArgs' target: The tab on which the page should open
        :param str text: The text to enter. Must not be specified if `credentials` from the vault are being used
        :param 'BrowserMonitorScriptEventsEventKeystrokesValidateArgs' validate: The validation rules for the event—helps you verify that your browser monitor loads the expected page content or page element
        :param 'BrowserMonitorScriptEventsEventKeystrokesWaitArgs' wait: The wait condition for the event—defines how long Dynatrace should wait before the next action is executed
        """
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if masked is not None:
            pulumi.set(__self__, "masked", masked)
        if simulate_blur_event is not None:
            pulumi.set(__self__, "simulate_blur_event", simulate_blur_event)
        if simulate_return_key is not None:
            pulumi.set(__self__, "simulate_return_key", simulate_return_key)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if validate is not None:
            pulumi.set(__self__, "validate", validate)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def credential(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesCredential']:
        """
        Credentials for this event
        """
        return pulumi.get(self, "credential")

    @property
    @pulumi.getter
    def masked(self) -> Optional[bool]:
        """
        Indicates whether the `textValue` is encrypted (`true`) or not (`false`). Must not be specified if `credentials` from the vault are being used
        """
        return pulumi.get(self, "masked")

    @property
    @pulumi.getter(name="simulateBlurEvent")
    def simulate_blur_event(self) -> Optional[bool]:
        """
        Defines whether to blur the text field when it loses focus.
        Set to `true` to trigger the blur the `textValue`
        """
        return pulumi.get(self, "simulate_blur_event")

    @property
    @pulumi.getter(name="simulateReturnKey")
    def simulate_return_key(self) -> Optional[bool]:
        """
        Simulates pressing the 'Return' key after simulating other keystrokes. For example, to submit a form or trigger a login.
        """
        return pulumi.get(self, "simulate_return_key")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesTarget']:
        """
        The tab on which the page should open
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The text to enter. Must not be specified if `credentials` from the vault are being used
        """
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def validate(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesValidate']:
        """
        The validation rules for the event—helps you verify that your browser monitor loads the expected page content or page element
        """
        return pulumi.get(self, "validate")

    @property
    @pulumi.getter
    def wait(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesWait']:
        """
        The wait condition for the event—defines how long Dynatrace should wait before the next action is executed
        """
        return pulumi.get(self, "wait")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesCredential(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vaultId":
            suggest = "vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventKeystrokesCredential. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesCredential.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesCredential.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: str,
                 vault_id: str):
        """
        :param str field: Either `username` or `password`
        :param str vault_id: The ID of the credential within the Credentials Vault
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        Either `username` or `password`
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        """
        The ID of the credential within the Credentials Vault
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesTargetLocator']] = None,
                 window: Optional[str] = None):
        """
        :param Sequence['BrowserMonitorScriptEventsEventKeystrokesTargetLocatorArgs'] locators: The list of locators identifying the desired element
        :param str window: The tab of the target
        """
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesTargetLocator']]:
        """
        The list of locators identifying the desired element
        """
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        """
        The tab of the target
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesTargetLocatorLocator']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventKeystrokesTargetLocatorLocatorArgs'] locators: A locator dentifyies the desired element
        """
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesTargetLocatorLocator']:
        """
        A locator dentifyies the desired element
        """
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        :param str value: The name of the element to be found
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The name of the element to be found
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesValidate(dict):
    def __init__(__self__, *,
                 validations: Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidation']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventKeystrokesValidateValidationArgs'] validations: The element to wait for. Required for the `validation` type, not applicable otherwise.
        """
        pulumi.set(__self__, "validations", validations)

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidation']:
        """
        The element to wait for. Required for the `validation` type, not applicable otherwise.
        """
        return pulumi.get(self, "validations")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesValidateValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventKeystrokesValidateValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesValidateValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesValidateValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTarget'] = None):
        """
        :param str type: The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        :param bool fail_if_found: The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        :param str match: The content to look for on the page.
               Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        :param bool regex: Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        :param 'BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetArgs' target: The elemnt to look for on the page
        """
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        """
        The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        """
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        The content to look for on the page.
        Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        """
        Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTarget']:
        """
        The elemnt to look for on the page
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesValidateValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        """
        :param Sequence['BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocatorArgs'] locators: The list of locators identifying the desired element
        :param str window: The tab of the target
        """
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocator']]:
        """
        The list of locators identifying the desired element
        """
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        """
        The tab of the target
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocatorLocator']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocatorLocatorArgs'] locators: A locator dentifyies the desired element
        """
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocatorLocator']:
        """
        A locator dentifyies the desired element
        """
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        :param str value: The name of the element to be found
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The name of the element to be found
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesWait(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitFor":
            suggest = "wait_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventKeystrokesWait. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesWait.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesWait.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_for: str,
                 milliseconds: Optional[int] = None,
                 timeout: Optional[int] = None,
                 validation: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidation'] = None):
        """
        :param str wait_for: The time to wait before the next event is triggered. Possible values are `page_complete` (wait for the page to load completely), `network` (wait for background network activity to complete), `next_action` (wait for the next action), `time` (wait for a specified periodof time) and `validation` (wait for a specific element to appear)
        :param int milliseconds: The time to wait, in millisencods. The maximum allowed value is `60000`. Required for the type `time`, not applicable otherwise.
        :param int timeout: he maximum amount of time to wait for a certain element to appear, in milliseconds—if exceeded, the action is marked as failed.
               The maximum allowed value is 60000. Required for the type `validation`, not applicable otherwise..
        :param 'BrowserMonitorScriptEventsEventKeystrokesWaitValidationArgs' validation: The elements to wait for. Required for the `validation` type, not applicable otherwise.
        """
        pulumi.set(__self__, "wait_for", wait_for)
        if milliseconds is not None:
            pulumi.set(__self__, "milliseconds", milliseconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter(name="waitFor")
    def wait_for(self) -> str:
        """
        The time to wait before the next event is triggered. Possible values are `page_complete` (wait for the page to load completely), `network` (wait for background network activity to complete), `next_action` (wait for the next action), `time` (wait for a specified periodof time) and `validation` (wait for a specific element to appear)
        """
        return pulumi.get(self, "wait_for")

    @property
    @pulumi.getter
    def milliseconds(self) -> Optional[int]:
        """
        The time to wait, in millisencods. The maximum allowed value is `60000`. Required for the type `time`, not applicable otherwise.
        """
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        he maximum amount of time to wait for a certain element to appear, in milliseconds—if exceeded, the action is marked as failed.
        The maximum allowed value is 60000. Required for the type `validation`, not applicable otherwise..
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidation']:
        """
        The elements to wait for. Required for the `validation` type, not applicable otherwise.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesWaitValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventKeystrokesWaitValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesWaitValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesWaitValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTarget'] = None):
        """
        :param str type: The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        :param bool fail_if_found: The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        :param str match: The content to look for on the page.
               Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        :param bool regex: Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        :param 'BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetArgs' target: The elemnt to look for on the page
        """
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        """
        The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        """
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        The content to look for on the page.
        Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        """
        Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTarget']:
        """
        The elemnt to look for on the page
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesWaitValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        """
        :param Sequence['BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocatorArgs'] locators: The list of locators identifying the desired element
        :param str window: The tab of the target
        """
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocator']]:
        """
        The list of locators identifying the desired element
        """
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        """
        The tab of the target
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocatorLocator']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocatorLocatorArgs'] locators: A locator dentifyies the desired element
        """
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocatorLocator']:
        """
        A locator dentifyies the desired element
        """
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        :param str value: The name of the element to be found
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The name of the element to be found
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigate(dict):
    def __init__(__self__, *,
                 url: str,
                 authentication: Optional['outputs.BrowserMonitorScriptEventsEventNavigateAuthentication'] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventNavigateTarget'] = None,
                 validate: Optional['outputs.BrowserMonitorScriptEventsEventNavigateValidate'] = None,
                 wait: Optional['outputs.BrowserMonitorScriptEventsEventNavigateWait'] = None):
        """
        :param str url: The URL to navigate to
        :param 'BrowserMonitorScriptEventsEventNavigateAuthenticationArgs' authentication: The login credentials to bypass the browser login mask
        :param 'BrowserMonitorScriptEventsEventNavigateTargetArgs' target: The tab on which the page should open
        :param 'BrowserMonitorScriptEventsEventNavigateValidateArgs' validate: The validation rules for the event—helps you verify that your browser monitor loads the expected page content or page element
        :param 'BrowserMonitorScriptEventsEventNavigateWaitArgs' wait: The wait condition for the event—defines how long Dynatrace should wait before the next action is executed
        """
        pulumi.set(__self__, "url", url)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if validate is not None:
            pulumi.set(__self__, "validate", validate)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL to navigate to
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateAuthentication']:
        """
        The login credentials to bypass the browser login mask
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateTarget']:
        """
        The tab on which the page should open
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def validate(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateValidate']:
        """
        The validation rules for the event—helps you verify that your browser monitor loads the expected page content or page element
        """
        return pulumi.get(self, "validate")

    @property
    @pulumi.getter
    def wait(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateWait']:
        """
        The wait condition for the event—defines how long Dynatrace should wait before the next action is executed
        """
        return pulumi.get(self, "wait")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateAuthentication(dict):
    def __init__(__self__, *,
                 creds: str,
                 type: str):
        """
        :param str creds: A reference to the entry within the credential vault
        :param str type: The type of authentication
        """
        pulumi.set(__self__, "creds", creds)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def creds(self) -> str:
        """
        A reference to the entry within the credential vault
        """
        return pulumi.get(self, "creds")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of authentication
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventNavigateTargetLocator']] = None,
                 window: Optional[str] = None):
        """
        :param Sequence['BrowserMonitorScriptEventsEventNavigateTargetLocatorArgs'] locators: The list of locators identifying the desired element
        :param str window: The tab of the target
        """
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventNavigateTargetLocator']]:
        """
        The list of locators identifying the desired element
        """
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        """
        The tab of the target
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventNavigateTargetLocatorLocator']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventNavigateTargetLocatorLocatorArgs'] locators: A locator dentifyies the desired element
        """
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventNavigateTargetLocatorLocator']:
        """
        A locator dentifyies the desired element
        """
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        :param str value: The name of the element to be found
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The name of the element to be found
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateValidate(dict):
    def __init__(__self__, *,
                 validations: Sequence['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidation']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventNavigateValidateValidationArgs'] validations: The element to wait for. Required for the `validation` type, not applicable otherwise.
        """
        pulumi.set(__self__, "validations", validations)

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidation']:
        """
        The element to wait for. Required for the `validation` type, not applicable otherwise.
        """
        return pulumi.get(self, "validations")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateValidateValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventNavigateValidateValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventNavigateValidateValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventNavigateValidateValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTarget'] = None):
        """
        :param str type: The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        :param bool fail_if_found: The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        :param str match: The content to look for on the page.
               Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        :param bool regex: Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        :param 'BrowserMonitorScriptEventsEventNavigateValidateValidationTargetArgs' target: The elemnt to look for on the page
        """
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        """
        The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        """
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        The content to look for on the page.
        Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        """
        Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTarget']:
        """
        The elemnt to look for on the page
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateValidateValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        """
        :param Sequence['BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocatorArgs'] locators: The list of locators identifying the desired element
        :param str window: The tab of the target
        """
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocator']]:
        """
        The list of locators identifying the desired element
        """
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        """
        The tab of the target
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocatorLocator']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocatorLocatorArgs'] locators: A locator dentifyies the desired element
        """
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocatorLocator']:
        """
        A locator dentifyies the desired element
        """
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        :param str value: The name of the element to be found
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The name of the element to be found
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateWait(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitFor":
            suggest = "wait_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventNavigateWait. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventNavigateWait.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventNavigateWait.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_for: str,
                 milliseconds: Optional[int] = None,
                 timeout: Optional[int] = None,
                 validation: Optional['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidation'] = None):
        """
        :param str wait_for: The time to wait before the next event is triggered. Possible values are `page_complete` (wait for the page to load completely), `network` (wait for background network activity to complete), `next_action` (wait for the next action), `time` (wait for a specified periodof time) and `validation` (wait for a specific element to appear)
        :param int milliseconds: The time to wait, in millisencods. The maximum allowed value is `60000`. Required for the type `time`, not applicable otherwise.
        :param int timeout: he maximum amount of time to wait for a certain element to appear, in milliseconds—if exceeded, the action is marked as failed.
               The maximum allowed value is 60000. Required for the type `validation`, not applicable otherwise..
        :param 'BrowserMonitorScriptEventsEventNavigateWaitValidationArgs' validation: The elements to wait for. Required for the `validation` type, not applicable otherwise.
        """
        pulumi.set(__self__, "wait_for", wait_for)
        if milliseconds is not None:
            pulumi.set(__self__, "milliseconds", milliseconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter(name="waitFor")
    def wait_for(self) -> str:
        """
        The time to wait before the next event is triggered. Possible values are `page_complete` (wait for the page to load completely), `network` (wait for background network activity to complete), `next_action` (wait for the next action), `time` (wait for a specified periodof time) and `validation` (wait for a specific element to appear)
        """
        return pulumi.get(self, "wait_for")

    @property
    @pulumi.getter
    def milliseconds(self) -> Optional[int]:
        """
        The time to wait, in millisencods. The maximum allowed value is `60000`. Required for the type `time`, not applicable otherwise.
        """
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        he maximum amount of time to wait for a certain element to appear, in milliseconds—if exceeded, the action is marked as failed.
        The maximum allowed value is 60000. Required for the type `validation`, not applicable otherwise..
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidation']:
        """
        The elements to wait for. Required for the `validation` type, not applicable otherwise.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateWaitValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventNavigateWaitValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventNavigateWaitValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventNavigateWaitValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTarget'] = None):
        """
        :param str type: The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        :param bool fail_if_found: The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        :param str match: The content to look for on the page.
               Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        :param bool regex: Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        :param 'BrowserMonitorScriptEventsEventNavigateWaitValidationTargetArgs' target: The elemnt to look for on the page
        """
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        """
        The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        """
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        The content to look for on the page.
        Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        """
        Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTarget']:
        """
        The elemnt to look for on the page
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateWaitValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        """
        :param Sequence['BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocatorArgs'] locators: The list of locators identifying the desired element
        :param str window: The tab of the target
        """
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocator']]:
        """
        The list of locators identifying the desired element
        """
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        """
        The tab of the target
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocatorLocator']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocatorLocatorArgs'] locators: A locator dentifyies the desired element
        """
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocatorLocator']:
        """
        A locator dentifyies the desired element
        """
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        :param str value: The name of the element to be found
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The name of the element to be found
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelect(dict):
    def __init__(__self__, *,
                 selections: 'outputs.BrowserMonitorScriptEventsEventSelectSelections',
                 target: Optional['outputs.BrowserMonitorScriptEventsEventSelectTarget'] = None,
                 validate: Optional['outputs.BrowserMonitorScriptEventsEventSelectValidate'] = None,
                 wait: Optional['outputs.BrowserMonitorScriptEventsEventSelectWait'] = None):
        """
        :param 'BrowserMonitorScriptEventsEventSelectSelectionsArgs' selections: The options to be selected
        :param 'BrowserMonitorScriptEventsEventSelectTargetArgs' target: The tab on which the page should open
        :param 'BrowserMonitorScriptEventsEventSelectValidateArgs' validate: The validation rules for the event—helps you verify that your browser monitor loads the expected page content or page element
        :param 'BrowserMonitorScriptEventsEventSelectWaitArgs' wait: The wait condition for the event—defines how long Dynatrace should wait before the next action is executed
        """
        pulumi.set(__self__, "selections", selections)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if validate is not None:
            pulumi.set(__self__, "validate", validate)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def selections(self) -> 'outputs.BrowserMonitorScriptEventsEventSelectSelections':
        """
        The options to be selected
        """
        return pulumi.get(self, "selections")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelectTarget']:
        """
        The tab on which the page should open
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def validate(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelectValidate']:
        """
        The validation rules for the event—helps you verify that your browser monitor loads the expected page content or page element
        """
        return pulumi.get(self, "validate")

    @property
    @pulumi.getter
    def wait(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelectWait']:
        """
        The wait condition for the event—defines how long Dynatrace should wait before the next action is executed
        """
        return pulumi.get(self, "wait")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectSelections(dict):
    def __init__(__self__, *,
                 options: Sequence['outputs.BrowserMonitorScriptEventsEventSelectSelectionsOption']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventSelectSelectionsOptionArgs'] options: The option to be selected
        """
        pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def options(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventSelectSelectionsOption']:
        """
        The option to be selected
        """
        return pulumi.get(self, "options")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectSelectionsOption(dict):
    def __init__(__self__, *,
                 index: int,
                 value: str):
        """
        :param int index: The index of the option to be selected
        :param str value: The value of the option to be selected
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def index(self) -> int:
        """
        The index of the option to be selected
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the option to be selected
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventSelectTargetLocator']] = None,
                 window: Optional[str] = None):
        """
        :param Sequence['BrowserMonitorScriptEventsEventSelectTargetLocatorArgs'] locators: The list of locators identifying the desired element
        :param str window: The tab of the target
        """
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventSelectTargetLocator']]:
        """
        The list of locators identifying the desired element
        """
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        """
        The tab of the target
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventSelectTargetLocatorLocator']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventSelectTargetLocatorLocatorArgs'] locators: A locator dentifyies the desired element
        """
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventSelectTargetLocatorLocator']:
        """
        A locator dentifyies the desired element
        """
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        :param str value: The name of the element to be found
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The name of the element to be found
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectValidate(dict):
    def __init__(__self__, *,
                 validations: Sequence['outputs.BrowserMonitorScriptEventsEventSelectValidateValidation']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventSelectValidateValidationArgs'] validations: The element to wait for. Required for the `validation` type, not applicable otherwise.
        """
        pulumi.set(__self__, "validations", validations)

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventSelectValidateValidation']:
        """
        The element to wait for. Required for the `validation` type, not applicable otherwise.
        """
        return pulumi.get(self, "validations")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectValidateValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventSelectValidateValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventSelectValidateValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventSelectValidateValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTarget'] = None):
        """
        :param str type: The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        :param bool fail_if_found: The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        :param str match: The content to look for on the page.
               Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        :param bool regex: Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        :param 'BrowserMonitorScriptEventsEventSelectValidateValidationTargetArgs' target: The elemnt to look for on the page
        """
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        """
        The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        """
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        The content to look for on the page.
        Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        """
        Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTarget']:
        """
        The elemnt to look for on the page
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectValidateValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        """
        :param Sequence['BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocatorArgs'] locators: The list of locators identifying the desired element
        :param str window: The tab of the target
        """
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocator']]:
        """
        The list of locators identifying the desired element
        """
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        """
        The tab of the target
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocatorLocator']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocatorLocatorArgs'] locators: A locator dentifyies the desired element
        """
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocatorLocator']:
        """
        A locator dentifyies the desired element
        """
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        :param str value: The name of the element to be found
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The name of the element to be found
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectWait(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitFor":
            suggest = "wait_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventSelectWait. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventSelectWait.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventSelectWait.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_for: str,
                 milliseconds: Optional[int] = None,
                 timeout: Optional[int] = None,
                 validation: Optional['outputs.BrowserMonitorScriptEventsEventSelectWaitValidation'] = None):
        """
        :param str wait_for: The time to wait before the next event is triggered. Possible values are `page_complete` (wait for the page to load completely), `network` (wait for background network activity to complete), `next_action` (wait for the next action), `time` (wait for a specified periodof time) and `validation` (wait for a specific element to appear)
        :param int milliseconds: The time to wait, in millisencods. The maximum allowed value is `60000`. Required for the type `time`, not applicable otherwise.
        :param int timeout: he maximum amount of time to wait for a certain element to appear, in milliseconds—if exceeded, the action is marked as failed.
               The maximum allowed value is 60000. Required for the type `validation`, not applicable otherwise..
        :param 'BrowserMonitorScriptEventsEventSelectWaitValidationArgs' validation: The elements to wait for. Required for the `validation` type, not applicable otherwise.
        """
        pulumi.set(__self__, "wait_for", wait_for)
        if milliseconds is not None:
            pulumi.set(__self__, "milliseconds", milliseconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter(name="waitFor")
    def wait_for(self) -> str:
        """
        The time to wait before the next event is triggered. Possible values are `page_complete` (wait for the page to load completely), `network` (wait for background network activity to complete), `next_action` (wait for the next action), `time` (wait for a specified periodof time) and `validation` (wait for a specific element to appear)
        """
        return pulumi.get(self, "wait_for")

    @property
    @pulumi.getter
    def milliseconds(self) -> Optional[int]:
        """
        The time to wait, in millisencods. The maximum allowed value is `60000`. Required for the type `time`, not applicable otherwise.
        """
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        he maximum amount of time to wait for a certain element to appear, in milliseconds—if exceeded, the action is marked as failed.
        The maximum allowed value is 60000. Required for the type `validation`, not applicable otherwise..
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelectWaitValidation']:
        """
        The elements to wait for. Required for the `validation` type, not applicable otherwise.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectWaitValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventSelectWaitValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventSelectWaitValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventSelectWaitValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTarget'] = None):
        """
        :param str type: The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        :param bool fail_if_found: The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        :param str match: The content to look for on the page.
               Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        :param bool regex: Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        :param 'BrowserMonitorScriptEventsEventSelectWaitValidationTargetArgs' target: The elemnt to look for on the page
        """
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        """
        The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        """
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        The content to look for on the page.
        Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        """
        Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTarget']:
        """
        The elemnt to look for on the page
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectWaitValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        """
        :param Sequence['BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocatorArgs'] locators: The list of locators identifying the desired element
        :param str window: The tab of the target
        """
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocator']]:
        """
        The list of locators identifying the desired element
        """
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        """
        The tab of the target
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocatorLocator']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocatorLocatorArgs'] locators: A locator dentifyies the desired element
        """
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocatorLocator']:
        """
        A locator dentifyies the desired element
        """
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        :param str value: The name of the element to be found
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The name of the element to be found
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTap(dict):
    def __init__(__self__, *,
                 button: int,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventTapTarget'] = None,
                 validate: Optional['outputs.BrowserMonitorScriptEventsEventTapValidate'] = None,
                 wait: Optional['outputs.BrowserMonitorScriptEventsEventTapWait'] = None):
        """
        :param int button: the mouse button to be used for the click
        :param 'BrowserMonitorScriptEventsEventTapTargetArgs' target: The tab on which the page should open
        :param 'BrowserMonitorScriptEventsEventTapValidateArgs' validate: The validation rules for the event—helps you verify that your browser monitor loads the expected page content or page element
        :param 'BrowserMonitorScriptEventsEventTapWaitArgs' wait: The wait condition for the event—defines how long Dynatrace should wait before the next action is executed
        """
        pulumi.set(__self__, "button", button)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if validate is not None:
            pulumi.set(__self__, "validate", validate)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def button(self) -> int:
        """
        the mouse button to be used for the click
        """
        return pulumi.get(self, "button")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTapTarget']:
        """
        The tab on which the page should open
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def validate(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTapValidate']:
        """
        The validation rules for the event—helps you verify that your browser monitor loads the expected page content or page element
        """
        return pulumi.get(self, "validate")

    @property
    @pulumi.getter
    def wait(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTapWait']:
        """
        The wait condition for the event—defines how long Dynatrace should wait before the next action is executed
        """
        return pulumi.get(self, "wait")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventTapTargetLocator']] = None,
                 window: Optional[str] = None):
        """
        :param Sequence['BrowserMonitorScriptEventsEventTapTargetLocatorArgs'] locators: The list of locators identifying the desired element
        :param str window: The tab of the target
        """
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventTapTargetLocator']]:
        """
        The list of locators identifying the desired element
        """
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        """
        The tab of the target
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventTapTargetLocatorLocator']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventTapTargetLocatorLocatorArgs'] locators: A locator dentifyies the desired element
        """
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventTapTargetLocatorLocator']:
        """
        A locator dentifyies the desired element
        """
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        :param str value: The name of the element to be found
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The name of the element to be found
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapValidate(dict):
    def __init__(__self__, *,
                 validations: Sequence['outputs.BrowserMonitorScriptEventsEventTapValidateValidation']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventTapValidateValidationArgs'] validations: The element to wait for. Required for the `validation` type, not applicable otherwise.
        """
        pulumi.set(__self__, "validations", validations)

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventTapValidateValidation']:
        """
        The element to wait for. Required for the `validation` type, not applicable otherwise.
        """
        return pulumi.get(self, "validations")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapValidateValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventTapValidateValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventTapValidateValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventTapValidateValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventTapValidateValidationTarget'] = None):
        """
        :param str type: The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        :param bool fail_if_found: The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        :param str match: The content to look for on the page.
               Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        :param bool regex: Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        :param 'BrowserMonitorScriptEventsEventTapValidateValidationTargetArgs' target: The elemnt to look for on the page
        """
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        """
        The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        """
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        The content to look for on the page.
        Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        """
        Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTapValidateValidationTarget']:
        """
        The elemnt to look for on the page
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapValidateValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventTapValidateValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        """
        :param Sequence['BrowserMonitorScriptEventsEventTapValidateValidationTargetLocatorArgs'] locators: The list of locators identifying the desired element
        :param str window: The tab of the target
        """
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventTapValidateValidationTargetLocator']]:
        """
        The list of locators identifying the desired element
        """
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        """
        The tab of the target
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapValidateValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventTapValidateValidationTargetLocatorLocator']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventTapValidateValidationTargetLocatorLocatorArgs'] locators: A locator dentifyies the desired element
        """
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventTapValidateValidationTargetLocatorLocator']:
        """
        A locator dentifyies the desired element
        """
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapValidateValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        :param str value: The name of the element to be found
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The name of the element to be found
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapWait(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitFor":
            suggest = "wait_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventTapWait. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventTapWait.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventTapWait.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_for: str,
                 milliseconds: Optional[int] = None,
                 timeout: Optional[int] = None,
                 validation: Optional['outputs.BrowserMonitorScriptEventsEventTapWaitValidation'] = None):
        """
        :param str wait_for: The time to wait before the next event is triggered. Possible values are `page_complete` (wait for the page to load completely), `network` (wait for background network activity to complete), `next_action` (wait for the next action), `time` (wait for a specified periodof time) and `validation` (wait for a specific element to appear)
        :param int milliseconds: The time to wait, in millisencods. The maximum allowed value is `60000`. Required for the type `time`, not applicable otherwise.
        :param int timeout: he maximum amount of time to wait for a certain element to appear, in milliseconds—if exceeded, the action is marked as failed.
               The maximum allowed value is 60000. Required for the type `validation`, not applicable otherwise..
        :param 'BrowserMonitorScriptEventsEventTapWaitValidationArgs' validation: The elements to wait for. Required for the `validation` type, not applicable otherwise.
        """
        pulumi.set(__self__, "wait_for", wait_for)
        if milliseconds is not None:
            pulumi.set(__self__, "milliseconds", milliseconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter(name="waitFor")
    def wait_for(self) -> str:
        """
        The time to wait before the next event is triggered. Possible values are `page_complete` (wait for the page to load completely), `network` (wait for background network activity to complete), `next_action` (wait for the next action), `time` (wait for a specified periodof time) and `validation` (wait for a specific element to appear)
        """
        return pulumi.get(self, "wait_for")

    @property
    @pulumi.getter
    def milliseconds(self) -> Optional[int]:
        """
        The time to wait, in millisencods. The maximum allowed value is `60000`. Required for the type `time`, not applicable otherwise.
        """
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        he maximum amount of time to wait for a certain element to appear, in milliseconds—if exceeded, the action is marked as failed.
        The maximum allowed value is 60000. Required for the type `validation`, not applicable otherwise..
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTapWaitValidation']:
        """
        The elements to wait for. Required for the `validation` type, not applicable otherwise.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapWaitValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventTapWaitValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventTapWaitValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventTapWaitValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventTapWaitValidationTarget'] = None):
        """
        :param str type: The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        :param bool fail_if_found: The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        :param str match: The content to look for on the page.
               Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        :param bool regex: Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        :param 'BrowserMonitorScriptEventsEventTapWaitValidationTargetArgs' target: The elemnt to look for on the page
        """
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        """
        The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
        """
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        The content to look for on the page.
        Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        """
        Defines whether `match` is plain text (`false`) or a regular expression (`true`)
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTapWaitValidationTarget']:
        """
        The elemnt to look for on the page
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapWaitValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventTapWaitValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        """
        :param Sequence['BrowserMonitorScriptEventsEventTapWaitValidationTargetLocatorArgs'] locators: The list of locators identifying the desired element
        :param str window: The tab of the target
        """
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventTapWaitValidationTargetLocator']]:
        """
        The list of locators identifying the desired element
        """
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        """
        The tab of the target
        """
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapWaitValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventTapWaitValidationTargetLocatorLocator']):
        """
        :param Sequence['BrowserMonitorScriptEventsEventTapWaitValidationTargetLocatorLocatorArgs'] locators: A locator dentifyies the desired element
        """
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventTapWaitValidationTargetLocatorLocator']:
        """
        A locator dentifyies the desired element
        """
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapWaitValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        :param str value: The name of the element to be found
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The name of the element to be found
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorTag(dict):
    def __init__(__self__, *,
                 tags: Optional[Sequence['outputs.BrowserMonitorTagTag']] = None):
        """
        :param Sequence['BrowserMonitorTagTagArgs'] tags: Tag with source of a Dynatrace entity.
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.BrowserMonitorTagTag']]:
        """
        Tag with source of a Dynatrace entity.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BrowserMonitorTagTag(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 source: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag. Supported values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_CLOUD` and `KUBERNETES`.
        :param str key: The key of the tag.
               
               Custom tags have the tag value here.
        :param str source: The source of the tag. Supported values are `USER`, `RULE_BASED` and `AUTO`.
        :param str value: The value of the tag.
               
               Not applicable to custom tags.
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag. Supported values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_CLOUD` and `KUBERNETES`.
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag.

        Custom tags have the tag value here.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        The source of the tag. Supported values are `USER`, `RULE_BASED` and `AUTO`.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag.

        Not applicable to custom tags.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BusinessEventsOneagentEvent(dict):
    def __init__(__self__, *,
                 category: 'outputs.BusinessEventsOneagentEventCategory',
                 provider: 'outputs.BusinessEventsOneagentEventProvider',
                 type: 'outputs.BusinessEventsOneagentEventType',
                 data: Optional['outputs.BusinessEventsOneagentEventData'] = None):
        """
        :param 'BusinessEventsOneagentEventCategoryArgs' category: Event category
        :param 'BusinessEventsOneagentEventProviderArgs' provider: Event provider
        :param 'BusinessEventsOneagentEventTypeArgs' type: Event type
        :param 'BusinessEventsOneagentEventDataArgs' data: Additional attributes for the business event.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "type", type)
        if data is not None:
            pulumi.set(__self__, "data", data)

    @property
    @pulumi.getter
    def category(self) -> 'outputs.BusinessEventsOneagentEventCategory':
        """
        Event category
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def provider(self) -> 'outputs.BusinessEventsOneagentEventProvider':
        """
        Event provider
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def type(self) -> 'outputs.BusinessEventsOneagentEventType':
        """
        Event type
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def data(self) -> Optional['outputs.BusinessEventsOneagentEventData']:
        """
        Additional attributes for the business event.
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class BusinessEventsOneagentEventCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentEventCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentEventCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentEventCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 path: Optional[str] = None,
                 source: Optional[str] = None):
        """
        :param str source_type: Possible Values: `Constant_string`, `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        :param str path: [See our documentation](https://dt-url.net/ei034bx)
        :param str source: Fixed value
        """
        pulumi.set(__self__, "source_type", source_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Possible Values: `Constant_string`, `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        [See our documentation](https://dt-url.net/ei034bx)
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Fixed value
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class BusinessEventsOneagentEventData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventDataFieldComplexes":
            suggest = "event_data_field_complexes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentEventData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentEventData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentEventData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_data_field_complexes: Sequence['outputs.BusinessEventsOneagentEventDataEventDataFieldComplex']):
        pulumi.set(__self__, "event_data_field_complexes", event_data_field_complexes)

    @property
    @pulumi.getter(name="eventDataFieldComplexes")
    def event_data_field_complexes(self) -> Sequence['outputs.BusinessEventsOneagentEventDataEventDataFieldComplex']:
        return pulumi.get(self, "event_data_field_complexes")


@pulumi.output_type
class BusinessEventsOneagentEventDataEventDataFieldComplex(dict):
    def __init__(__self__, *,
                 name: str,
                 source: 'outputs.BusinessEventsOneagentEventDataEventDataFieldComplexSource'):
        """
        :param str name: Field name to be added to data.
        :param 'BusinessEventsOneagentEventDataEventDataFieldComplexSourceArgs' source: no documentation available
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Field name to be added to data.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def source(self) -> 'outputs.BusinessEventsOneagentEventDataEventDataFieldComplexSource':
        """
        no documentation available
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class BusinessEventsOneagentEventDataEventDataFieldComplexSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentEventDataEventDataFieldComplexSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentEventDataEventDataFieldComplexSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentEventDataEventDataFieldComplexSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 path: Optional[str] = None,
                 source: Optional[str] = None):
        """
        :param str source_type: Possible Values: `Constant_string`, `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        :param str path: [See our documentation](https://dt-url.net/ei034bx)
        :param str source: Fixed value
        """
        pulumi.set(__self__, "source_type", source_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Possible Values: `Constant_string`, `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        [See our documentation](https://dt-url.net/ei034bx)
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Fixed value
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class BusinessEventsOneagentEventProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentEventProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentEventProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentEventProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 path: Optional[str] = None,
                 source: Optional[str] = None):
        """
        :param str source_type: Possible Values: `Constant_string`, `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        :param str path: [See our documentation](https://dt-url.net/ei034bx)
        :param str source: Fixed value
        """
        pulumi.set(__self__, "source_type", source_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Possible Values: `Constant_string`, `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        [See our documentation](https://dt-url.net/ei034bx)
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Fixed value
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class BusinessEventsOneagentEventType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentEventType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentEventType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentEventType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 path: Optional[str] = None,
                 source: Optional[str] = None):
        """
        :param str source_type: Possible Values: `Constant_string`, `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        :param str path: [See our documentation](https://dt-url.net/ei034bx)
        :param str source: Fixed value
        """
        pulumi.set(__self__, "source_type", source_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Possible Values: `Constant_string`, `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        [See our documentation](https://dt-url.net/ei034bx)
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Fixed value
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class BusinessEventsOneagentOutgoingEvent(dict):
    def __init__(__self__, *,
                 category: 'outputs.BusinessEventsOneagentOutgoingEventCategory',
                 provider: 'outputs.BusinessEventsOneagentOutgoingEventProvider',
                 type: 'outputs.BusinessEventsOneagentOutgoingEventType',
                 data: Optional['outputs.BusinessEventsOneagentOutgoingEventData'] = None):
        """
        :param 'BusinessEventsOneagentOutgoingEventCategoryArgs' category: Event category
        :param 'BusinessEventsOneagentOutgoingEventProviderArgs' provider: Event provider
        :param 'BusinessEventsOneagentOutgoingEventTypeArgs' type: Event type
        :param 'BusinessEventsOneagentOutgoingEventDataArgs' data: Additional attributes for the business event.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "type", type)
        if data is not None:
            pulumi.set(__self__, "data", data)

    @property
    @pulumi.getter
    def category(self) -> 'outputs.BusinessEventsOneagentOutgoingEventCategory':
        """
        Event category
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def provider(self) -> 'outputs.BusinessEventsOneagentOutgoingEventProvider':
        """
        Event provider
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def type(self) -> 'outputs.BusinessEventsOneagentOutgoingEventType':
        """
        Event type
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def data(self) -> Optional['outputs.BusinessEventsOneagentOutgoingEventData']:
        """
        Additional attributes for the business event.
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class BusinessEventsOneagentOutgoingEventCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentOutgoingEventCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentOutgoingEventCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentOutgoingEventCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 path: Optional[str] = None,
                 source: Optional[str] = None):
        """
        :param str source_type: Possible Values: `Constant_string`, `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        :param str path: [See our documentation](https://dt-url.net/ei034bx)
        :param str source: Fixed value
        """
        pulumi.set(__self__, "source_type", source_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Possible Values: `Constant_string`, `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        [See our documentation](https://dt-url.net/ei034bx)
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Fixed value
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class BusinessEventsOneagentOutgoingEventData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventDataFieldComplexes":
            suggest = "event_data_field_complexes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentOutgoingEventData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentOutgoingEventData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentOutgoingEventData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_data_field_complexes: Sequence['outputs.BusinessEventsOneagentOutgoingEventDataEventDataFieldComplex']):
        pulumi.set(__self__, "event_data_field_complexes", event_data_field_complexes)

    @property
    @pulumi.getter(name="eventDataFieldComplexes")
    def event_data_field_complexes(self) -> Sequence['outputs.BusinessEventsOneagentOutgoingEventDataEventDataFieldComplex']:
        return pulumi.get(self, "event_data_field_complexes")


@pulumi.output_type
class BusinessEventsOneagentOutgoingEventDataEventDataFieldComplex(dict):
    def __init__(__self__, *,
                 name: str,
                 source: 'outputs.BusinessEventsOneagentOutgoingEventDataEventDataFieldComplexSource'):
        """
        :param str name: Field name to be added to data.
        :param 'BusinessEventsOneagentOutgoingEventDataEventDataFieldComplexSourceArgs' source: no documentation available
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Field name to be added to data.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def source(self) -> 'outputs.BusinessEventsOneagentOutgoingEventDataEventDataFieldComplexSource':
        """
        no documentation available
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class BusinessEventsOneagentOutgoingEventDataEventDataFieldComplexSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentOutgoingEventDataEventDataFieldComplexSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentOutgoingEventDataEventDataFieldComplexSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentOutgoingEventDataEventDataFieldComplexSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 path: Optional[str] = None,
                 source: Optional[str] = None):
        """
        :param str source_type: Possible Values: `Constant_string`, `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        :param str path: [See our documentation](https://dt-url.net/ei034bx)
        :param str source: Fixed value
        """
        pulumi.set(__self__, "source_type", source_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Possible Values: `Constant_string`, `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        [See our documentation](https://dt-url.net/ei034bx)
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Fixed value
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class BusinessEventsOneagentOutgoingEventProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentOutgoingEventProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentOutgoingEventProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentOutgoingEventProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 path: Optional[str] = None,
                 source: Optional[str] = None):
        """
        :param str source_type: Possible Values: `Constant_string`, `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        :param str path: [See our documentation](https://dt-url.net/ei034bx)
        :param str source: Fixed value
        """
        pulumi.set(__self__, "source_type", source_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Possible Values: `Constant_string`, `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        [See our documentation](https://dt-url.net/ei034bx)
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Fixed value
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class BusinessEventsOneagentOutgoingEventType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentOutgoingEventType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentOutgoingEventType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentOutgoingEventType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 path: Optional[str] = None,
                 source: Optional[str] = None):
        """
        :param str source_type: Possible Values: `Constant_string`, `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        :param str path: [See our documentation](https://dt-url.net/ei034bx)
        :param str source: Fixed value
        """
        pulumi.set(__self__, "source_type", source_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Possible Values: `Constant_string`, `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        [See our documentation](https://dt-url.net/ei034bx)
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Fixed value
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class BusinessEventsOneagentOutgoingTriggers(dict):
    def __init__(__self__, *,
                 triggers: Sequence['outputs.BusinessEventsOneagentOutgoingTriggersTrigger']):
        pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter
    def triggers(self) -> Sequence['outputs.BusinessEventsOneagentOutgoingTriggersTrigger']:
        return pulumi.get(self, "triggers")


@pulumi.output_type
class BusinessEventsOneagentOutgoingTriggersTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentOutgoingTriggersTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentOutgoingTriggersTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentOutgoingTriggersTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: 'outputs.BusinessEventsOneagentOutgoingTriggersTriggerSource',
                 type: str,
                 case_sensitive: Optional[bool] = None,
                 value: Optional[str] = None):
        """
        :param 'BusinessEventsOneagentOutgoingTriggersTriggerSourceArgs' source: no documentation available
        :param str type: Possible Values: `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EXISTS`, `N_CONTAINS`, `N_ENDS_WITH`, `N_EQUALS`, `N_EXISTS`, `N_STARTS_WITH`, `STARTS_WITH`
        :param bool case_sensitive: Case sensitive
        :param str value: no documentation available
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "type", type)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def source(self) -> 'outputs.BusinessEventsOneagentOutgoingTriggersTriggerSource':
        """
        no documentation available
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EXISTS`, `N_CONTAINS`, `N_ENDS_WITH`, `N_EQUALS`, `N_EXISTS`, `N_STARTS_WITH`, `STARTS_WITH`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        Case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BusinessEventsOneagentOutgoingTriggersTriggerSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentOutgoingTriggersTriggerSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentOutgoingTriggersTriggerSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentOutgoingTriggersTriggerSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 path: Optional[str] = None):
        """
        :param str data_source: Possible Values: `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        :param str path: [See our documentation](https://dt-url.net/ei034bx)
        """
        pulumi.set(__self__, "data_source", data_source)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        Possible Values: `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        [See our documentation](https://dt-url.net/ei034bx)
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class BusinessEventsOneagentTriggers(dict):
    def __init__(__self__, *,
                 triggers: Sequence['outputs.BusinessEventsOneagentTriggersTrigger']):
        pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter
    def triggers(self) -> Sequence['outputs.BusinessEventsOneagentTriggersTrigger']:
        return pulumi.get(self, "triggers")


@pulumi.output_type
class BusinessEventsOneagentTriggersTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentTriggersTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentTriggersTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentTriggersTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: 'outputs.BusinessEventsOneagentTriggersTriggerSource',
                 type: str,
                 case_sensitive: Optional[bool] = None,
                 value: Optional[str] = None):
        """
        :param 'BusinessEventsOneagentTriggersTriggerSourceArgs' source: no documentation available
        :param str type: Possible Values: `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EXISTS`, `N_CONTAINS`, `N_ENDS_WITH`, `N_EQUALS`, `N_EXISTS`, `N_STARTS_WITH`, `STARTS_WITH`
        :param bool case_sensitive: Case sensitive
        :param str value: no documentation available
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "type", type)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def source(self) -> 'outputs.BusinessEventsOneagentTriggersTriggerSource':
        """
        no documentation available
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EXISTS`, `N_CONTAINS`, `N_ENDS_WITH`, `N_EQUALS`, `N_EXISTS`, `N_STARTS_WITH`, `STARTS_WITH`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        Case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BusinessEventsOneagentTriggersTriggerSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentTriggersTriggerSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentTriggersTriggerSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentTriggersTriggerSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 path: Optional[str] = None):
        """
        :param str data_source: Possible Values: `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        :param str path: [See our documentation](https://dt-url.net/ei034bx)
        """
        pulumi.set(__self__, "data_source", data_source)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        Possible Values: `Request_body`, `Request_headers`, `Request_method`, `Request_parameters`, `Request_path`, `Request_url`, `Response_body`, `Response_headers`, `Response_statusCode`
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        [See our documentation](https://dt-url.net/ei034bx)
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class BusinessEventsProcessingRuleTesting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sampleEvent":
            suggest = "sample_event"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsProcessingRuleTesting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsProcessingRuleTesting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsProcessingRuleTesting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sample_event: str):
        """
        :param str sample_event: Sample event to use for the test run. Only JSON format is supported.
        """
        pulumi.set(__self__, "sample_event", sample_event)

    @property
    @pulumi.getter(name="sampleEvent")
    def sample_event(self) -> str:
        """
        Sample event to use for the test run. Only JSON format is supported.
        """
        return pulumi.get(self, "sample_event")


@pulumi.output_type
class BusinessEventsProcessingTransformationFields(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationFields":
            suggest = "transformation_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsProcessingTransformationFields. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsProcessingTransformationFields.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsProcessingTransformationFields.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_fields: Sequence['outputs.BusinessEventsProcessingTransformationFieldsTransformationField']):
        pulumi.set(__self__, "transformation_fields", transformation_fields)

    @property
    @pulumi.getter(name="transformationFields")
    def transformation_fields(self) -> Sequence['outputs.BusinessEventsProcessingTransformationFieldsTransformationField']:
        return pulumi.get(self, "transformation_fields")


@pulumi.output_type
class BusinessEventsProcessingTransformationFieldsTransformationField(dict):
    def __init__(__self__, *,
                 array: bool,
                 name: str,
                 optional: bool,
                 readonly: bool,
                 type: str):
        """
        :param bool array: Is Array
        :param str name: no documentation available
        :param bool optional: no documentation available
        :param bool readonly: Read-only
        :param str type: Possible Values: `BOOLEAN`, `DOUBLE`, `DURATION`, `INT`, `IPADDR`, `LONG`, `STRING`, `TIMESTAMP`
        """
        pulumi.set(__self__, "array", array)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "optional", optional)
        pulumi.set(__self__, "readonly", readonly)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def array(self) -> bool:
        """
        Is Array
        """
        return pulumi.get(self, "array")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> bool:
        """
        no documentation available
        """
        return pulumi.get(self, "optional")

    @property
    @pulumi.getter
    def readonly(self) -> bool:
        """
        Read-only
        """
        return pulumi.get(self, "readonly")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `BOOLEAN`, `DOUBLE`, `DURATION`, `INT`, `IPADDR`, `LONG`, `STRING`, `TIMESTAMP`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class BusinessEventsSecurityContextSecurityContextRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleName":
            suggest = "rule_name"
        elif key == "valueSource":
            suggest = "value_source"
        elif key == "valueSourceField":
            suggest = "value_source_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsSecurityContextSecurityContextRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsSecurityContextSecurityContextRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsSecurityContextSecurityContextRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 rule_name: str,
                 value_source: str,
                 value: Optional[str] = None,
                 value_source_field: Optional[str] = None):
        """
        :param str query: Matcher
        :param str rule_name: Rule name
        :param str value_source: Possible Values: `FIELD`, `LITERAL`
        :param str value: Literal value to be set
        :param str value_source_field: Name of field used to copy value
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "rule_name", rule_name)
        pulumi.set(__self__, "value_source", value_source)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_source_field is not None:
            pulumi.set(__self__, "value_source_field", value_source_field)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Matcher
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> str:
        """
        Rule name
        """
        return pulumi.get(self, "rule_name")

    @property
    @pulumi.getter(name="valueSource")
    def value_source(self) -> str:
        """
        Possible Values: `FIELD`, `LITERAL`
        """
        return pulumi.get(self, "value_source")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Literal value to be set
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueSourceField")
    def value_source_field(self) -> Optional[str]:
        """
        Name of field used to copy value
        """
        return pulumi.get(self, "value_source_field")


@pulumi.output_type
class CalculatedMobileMetricDimension(dict):
    def __init__(__self__, *,
                 dimensions: Optional[Sequence['outputs.CalculatedMobileMetricDimensionDimension']] = None):
        """
        :param Sequence['CalculatedMobileMetricDimensionDimensionArgs'] dimensions: A dimensions for the metric usage
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.CalculatedMobileMetricDimensionDimension']]:
        """
        A dimensions for the metric usage
        """
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class CalculatedMobileMetricDimensionDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topX":
            suggest = "top_x"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedMobileMetricDimensionDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedMobileMetricDimensionDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedMobileMetricDimensionDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension: str,
                 top_x: int):
        """
        :param str dimension: The dimension of the metric. Possible values are `ApdexType`, `Browser`, `ErrorContext`, `ErrorOrigin`, `ErrorType`, `GeoLocation`, `StringProperty`, `UserActionType`
        :param int top_x: The number of top values to be calculated
        """
        pulumi.set(__self__, "dimension", dimension)
        pulumi.set(__self__, "top_x", top_x)

    @property
    @pulumi.getter
    def dimension(self) -> str:
        """
        The dimension of the metric. Possible values are `ApdexType`, `Browser`, `ErrorContext`, `ErrorOrigin`, `ErrorType`, `GeoLocation`, `StringProperty`, `UserActionType`
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="topX")
    def top_x(self) -> int:
        """
        The number of top values to be calculated
        """
        return pulumi.get(self, "top_x")


@pulumi.output_type
class CalculatedMobileMetricUserActionFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionDurationFromMilliseconds":
            suggest = "action_duration_from_milliseconds"
        elif key == "actionDurationToMilliseconds":
            suggest = "action_duration_to_milliseconds"
        elif key == "appVersion":
            suggest = "app_version"
        elif key == "connectionType":
            suggest = "connection_type"
        elif key == "hasHttpError":
            suggest = "has_http_error"
        elif key == "hasReportedError":
            suggest = "has_reported_error"
        elif key == "networkTechnology":
            suggest = "network_technology"
        elif key == "osFamily":
            suggest = "os_family"
        elif key == "osVersion":
            suggest = "os_version"
        elif key == "userActionName":
            suggest = "user_action_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedMobileMetricUserActionFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedMobileMetricUserActionFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedMobileMetricUserActionFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_duration_from_milliseconds: Optional[int] = None,
                 action_duration_to_milliseconds: Optional[int] = None,
                 apdex: Optional[str] = None,
                 app_version: Optional[str] = None,
                 carrier: Optional[str] = None,
                 city: Optional[str] = None,
                 connection_type: Optional[str] = None,
                 continent: Optional[str] = None,
                 country: Optional[str] = None,
                 device: Optional[str] = None,
                 has_http_error: Optional[bool] = None,
                 has_reported_error: Optional[bool] = None,
                 isp: Optional[str] = None,
                 manufacturer: Optional[str] = None,
                 network_technology: Optional[str] = None,
                 orientation: Optional[str] = None,
                 os_family: Optional[str] = None,
                 os_version: Optional[str] = None,
                 region: Optional[str] = None,
                 resolution: Optional[str] = None,
                 user_action_name: Optional[str] = None):
        """
        :param int action_duration_from_milliseconds: Only actions with a duration more than or equal to this value (in milliseconds) are included in the metric calculation.
        :param int action_duration_to_milliseconds: Only actions with a duration less than or equal to this value (in milliseconds) are included in the metric calculation.
        :param str apdex: Only actions with the specified Apdex score are included in the metric calculation. Possible values: [ Frustrated, Satisfied, Tolerating, Unknown ]
        :param str app_version: Only actions coming from this app version are included in the metric calculation.
        :param str carrier: Only actions coming from this carrier type are included in the metric calculation.
        :param str city: Only actions of users from this city are included in the metric calculation. Specify geolocation ID here.
        :param str connection_type: Only actions coming from this connection type are included in the metric calculation. Possible values: [ LAN, MOBILE, OFFLINE, UNKNOWN, WIFI ]
        :param str continent: Only actions of users from this continent are included in the metric calculation. Specify geolocation ID here.
        :param str country: Only actions of users from this country are included in the metric calculation. Specify geolocation ID here.
        :param str device: Only actions coming from this app version are included in the metric calculation.
        :param bool has_http_error: The request error status of the actions to be included in the metric calculation: `true` or `false`
        :param bool has_reported_error: The error status of the actions to be included in the metric calculation: `true` or `false`
        :param str isp: Only actions coming from this internet service provider are included in the metric calculation.
        :param str manufacturer: Only actions coming from devices of this manufacturer are included in the metric calculation.
        :param str network_technology: Filter by network technology
        :param str orientation: Only actions coming from devices with this display orientation are included in the metric calculation. Possible values: [ LANDSCAPE, PORTRAIT, UNKNOWN ]
        :param str os_family: Only actions coming from this OS family are included in the metric calculation.
        :param str os_version: Only actions coming from this OS version are included in the metric calculation.
        :param str region: Only actions of users from this region are included in the metric calculation. Specify geolocation ID here.
        :param str resolution: Only actions coming from devices with this display resolution are included in the metric calculation. Possible values: [ CGA, DCI2K, DCI4K, DVGA, FHD, FWVGA, FWXGA, GHDPlus, HD, HQVGA, HQVGA2, HSXGA, HUXGA, HVGA, HXGA, NTSC, PAL, QHD, QQVGA, QSXGA, QUXGA, QVGA, QWXGA, QXGA, SVGA, SXGA, SXGAMinus, SXGAPlus, UGA, UHD16K, UHD4K, UHD8K, UHDPlus, UNKNOWN, UWQHD, UXGA, VGA, WHSXGA, WHUXGA, WHXGA, WQSXGA, WQUXGA, WQVGA, WQVGA2, WQVGA3, WQXGA, WQXGA2, WSVGA, WSVGA2, WSXGA, WSXGAPlus, WUXGA, WVGA, WVGA2, WXGA, WXGA2, WXGA3, WXGAPlus, XGA, XGAPLUS, _1280x854, nHD, qHD ]
        :param str user_action_name: Only actions with this name are included in the metric calculation.
        """
        if action_duration_from_milliseconds is not None:
            pulumi.set(__self__, "action_duration_from_milliseconds", action_duration_from_milliseconds)
        if action_duration_to_milliseconds is not None:
            pulumi.set(__self__, "action_duration_to_milliseconds", action_duration_to_milliseconds)
        if apdex is not None:
            pulumi.set(__self__, "apdex", apdex)
        if app_version is not None:
            pulumi.set(__self__, "app_version", app_version)
        if carrier is not None:
            pulumi.set(__self__, "carrier", carrier)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if connection_type is not None:
            pulumi.set(__self__, "connection_type", connection_type)
        if continent is not None:
            pulumi.set(__self__, "continent", continent)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if has_http_error is not None:
            pulumi.set(__self__, "has_http_error", has_http_error)
        if has_reported_error is not None:
            pulumi.set(__self__, "has_reported_error", has_reported_error)
        if isp is not None:
            pulumi.set(__self__, "isp", isp)
        if manufacturer is not None:
            pulumi.set(__self__, "manufacturer", manufacturer)
        if network_technology is not None:
            pulumi.set(__self__, "network_technology", network_technology)
        if orientation is not None:
            pulumi.set(__self__, "orientation", orientation)
        if os_family is not None:
            pulumi.set(__self__, "os_family", os_family)
        if os_version is not None:
            pulumi.set(__self__, "os_version", os_version)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)
        if user_action_name is not None:
            pulumi.set(__self__, "user_action_name", user_action_name)

    @property
    @pulumi.getter(name="actionDurationFromMilliseconds")
    def action_duration_from_milliseconds(self) -> Optional[int]:
        """
        Only actions with a duration more than or equal to this value (in milliseconds) are included in the metric calculation.
        """
        return pulumi.get(self, "action_duration_from_milliseconds")

    @property
    @pulumi.getter(name="actionDurationToMilliseconds")
    def action_duration_to_milliseconds(self) -> Optional[int]:
        """
        Only actions with a duration less than or equal to this value (in milliseconds) are included in the metric calculation.
        """
        return pulumi.get(self, "action_duration_to_milliseconds")

    @property
    @pulumi.getter
    def apdex(self) -> Optional[str]:
        """
        Only actions with the specified Apdex score are included in the metric calculation. Possible values: [ Frustrated, Satisfied, Tolerating, Unknown ]
        """
        return pulumi.get(self, "apdex")

    @property
    @pulumi.getter(name="appVersion")
    def app_version(self) -> Optional[str]:
        """
        Only actions coming from this app version are included in the metric calculation.
        """
        return pulumi.get(self, "app_version")

    @property
    @pulumi.getter
    def carrier(self) -> Optional[str]:
        """
        Only actions coming from this carrier type are included in the metric calculation.
        """
        return pulumi.get(self, "carrier")

    @property
    @pulumi.getter
    def city(self) -> Optional[str]:
        """
        Only actions of users from this city are included in the metric calculation. Specify geolocation ID here.
        """
        return pulumi.get(self, "city")

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> Optional[str]:
        """
        Only actions coming from this connection type are included in the metric calculation. Possible values: [ LAN, MOBILE, OFFLINE, UNKNOWN, WIFI ]
        """
        return pulumi.get(self, "connection_type")

    @property
    @pulumi.getter
    def continent(self) -> Optional[str]:
        """
        Only actions of users from this continent are included in the metric calculation. Specify geolocation ID here.
        """
        return pulumi.get(self, "continent")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        """
        Only actions of users from this country are included in the metric calculation. Specify geolocation ID here.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def device(self) -> Optional[str]:
        """
        Only actions coming from this app version are included in the metric calculation.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter(name="hasHttpError")
    def has_http_error(self) -> Optional[bool]:
        """
        The request error status of the actions to be included in the metric calculation: `true` or `false`
        """
        return pulumi.get(self, "has_http_error")

    @property
    @pulumi.getter(name="hasReportedError")
    def has_reported_error(self) -> Optional[bool]:
        """
        The error status of the actions to be included in the metric calculation: `true` or `false`
        """
        return pulumi.get(self, "has_reported_error")

    @property
    @pulumi.getter
    def isp(self) -> Optional[str]:
        """
        Only actions coming from this internet service provider are included in the metric calculation.
        """
        return pulumi.get(self, "isp")

    @property
    @pulumi.getter
    def manufacturer(self) -> Optional[str]:
        """
        Only actions coming from devices of this manufacturer are included in the metric calculation.
        """
        return pulumi.get(self, "manufacturer")

    @property
    @pulumi.getter(name="networkTechnology")
    def network_technology(self) -> Optional[str]:
        """
        Filter by network technology
        """
        return pulumi.get(self, "network_technology")

    @property
    @pulumi.getter
    def orientation(self) -> Optional[str]:
        """
        Only actions coming from devices with this display orientation are included in the metric calculation. Possible values: [ LANDSCAPE, PORTRAIT, UNKNOWN ]
        """
        return pulumi.get(self, "orientation")

    @property
    @pulumi.getter(name="osFamily")
    def os_family(self) -> Optional[str]:
        """
        Only actions coming from this OS family are included in the metric calculation.
        """
        return pulumi.get(self, "os_family")

    @property
    @pulumi.getter(name="osVersion")
    def os_version(self) -> Optional[str]:
        """
        Only actions coming from this OS version are included in the metric calculation.
        """
        return pulumi.get(self, "os_version")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Only actions of users from this region are included in the metric calculation. Specify geolocation ID here.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def resolution(self) -> Optional[str]:
        """
        Only actions coming from devices with this display resolution are included in the metric calculation. Possible values: [ CGA, DCI2K, DCI4K, DVGA, FHD, FWVGA, FWXGA, GHDPlus, HD, HQVGA, HQVGA2, HSXGA, HUXGA, HVGA, HXGA, NTSC, PAL, QHD, QQVGA, QSXGA, QUXGA, QVGA, QWXGA, QXGA, SVGA, SXGA, SXGAMinus, SXGAPlus, UGA, UHD16K, UHD4K, UHD8K, UHDPlus, UNKNOWN, UWQHD, UXGA, VGA, WHSXGA, WHUXGA, WHXGA, WQSXGA, WQUXGA, WQVGA, WQVGA2, WQVGA3, WQXGA, WQXGA2, WSVGA, WSVGA2, WSXGA, WSXGAPlus, WUXGA, WVGA, WVGA2, WXGA, WXGA2, WXGA3, WXGAPlus, XGA, XGAPLUS, _1280x854, nHD, qHD ]
        """
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter(name="userActionName")
    def user_action_name(self) -> Optional[str]:
        """
        Only actions with this name are included in the metric calculation.
        """
        return pulumi.get(self, "user_action_name")


@pulumi.output_type
class CalculatedServiceMetricCondition(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.CalculatedServiceMetricConditionCondition']] = None):
        """
        :param Sequence['CalculatedServiceMetricConditionConditionArgs'] conditions: A conditions for the metric usage
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.CalculatedServiceMetricConditionCondition']]:
        """
        A conditions for the metric usage
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class CalculatedServiceMetricConditionCondition(dict):
    def __init__(__self__, *,
                 attribute: str,
                 comparison: 'outputs.CalculatedServiceMetricConditionConditionComparison',
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be matched.  Note that for a service property attribute you must use the comparison of the `FAST_STRING` type. Possible values are `ACTOR_SYSTEM`, `AKKA_ACTOR_CLASS_NAME`, `AKKA_ACTOR_MESSAGE_TYPE`, `AKKA_ACTOR_PATH`, `APPLICATION_BUILD_VERSION`, `APPLICATION_RELEASE_VERSION`, `AZURE_FUNCTIONS_FUNCTION_NAME`, `AZURE_FUNCTIONS_SITE_NAME`, `CICS_PROGRAM_NAME`, `CICS_SYSTEM_ID`, `CICS_TASK_ID`, `CICS_TRANSACTION_ID`, `CICS_USER_ID`, `CPU_TIME`, `CTG_GATEWAY_URL`, `CTG_PROGRAM`, `CTG_SERVER_NAME`, `CTG_TRANSACTION_ID`, `CUSTOMSERVICE_CLASS`, `CUSTOMSERVICE_METHOD`, `DATABASE_CHILD_CALL_COUNT`, `DATABASE_CHILD_CALL_TIME`, `DATABASE_HOST`, `DATABASE_NAME`, `DATABASE_TYPE`, `DATABASE_URL`, `DISK_IO_TIME`, `ERROR_COUNT`, `ESB_APPLICATION_NAME`, `ESB_INPUT_TYPE`, `ESB_LIBRARY_NAME`, `ESB_MESSAGE_FLOW_NAME`, `EXCEPTION_CLASS`, `EXCEPTION_MESSAGE`, `FAILED_STATE`, `FAILURE_REASON`, `FLAW_STATE`, `HTTP_REQUEST_METHOD`, `HTTP_STATUS`, `HTTP_STATUS_CLASS`, `IMS_PROGRAM_NAME`, `IMS_TRANSACTION_ID`, `IMS_USER_ID`, `IO_TIME`, `IS_KEY_REQUEST`, `LAMBDA_COLDSTART`, `LOCK_TIME`, `MESSAGING_DESTINATION_TYPE`, `MESSAGING_IS_TEMPORARY_QUEUE`, `MESSAGING_QUEUE_NAME`, `MESSAGING_QUEUE_VENDOR`, `NETWORK_IO_TIME`, `NON_DATABASE_CHILD_CALL_COUNT`, `NON_DATABASE_CHILD_CALL_TIME`, `PROCESS_GROUP_NAME`, `PROCESS_GROUP_TAG`, `REMOTE_ENDPOINT`, `REMOTE_METHOD`, `REMOTE_SERVICE_NAME`, `REQUEST_NAME`, `REQUEST_TYPE`, `RESPONSE_TIME`, `RESPONSE_TIME_CLIENT`, `RMI_CLASS`, `RMI_METHOD`, `SERVICE_DISPLAY_NAME`, `SERVICE_NAME`, `SERVICE_PORT`, `SERVICE_PUBLIC_DOMAIN_NAME`, `SERVICE_REQUEST_ATTRIBUTE`, `SERVICE_TAG`, `SERVICE_TYPE`, `SERVICE_WEB_APPLICATION_ID`, `SERVICE_WEB_CONTEXT_ROOT`, `SERVICE_WEB_SERVER_NAME`, `SERVICE_WEB_SERVICE_NAME`, `SERVICE_WEB_SERVICE_NAMESPACE`, `SUSPENSION_TIME`, `TOTAL_PROCESSING_TIME`, `WAIT_TIME`, `WEBREQUEST_QUERY`, `WEBREQUEST_RELATIVE_URL`, `WEBREQUEST_URL`, `WEBREQUEST_URL_HOST`, `WEBREQUEST_URL_PATH`, `WEBREQUEST_URL_PORT`, `WEBSERVICE_ENDPOINT`, `WEBSERVICE_METHOD` and `ZOS_CALL_TYPE`
        :param 'CalculatedServiceMetricConditionConditionComparisonArgs' comparison: Type-specific comparison for attributes
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "comparison", comparison)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be matched.  Note that for a service property attribute you must use the comparison of the `FAST_STRING` type. Possible values are `ACTOR_SYSTEM`, `AKKA_ACTOR_CLASS_NAME`, `AKKA_ACTOR_MESSAGE_TYPE`, `AKKA_ACTOR_PATH`, `APPLICATION_BUILD_VERSION`, `APPLICATION_RELEASE_VERSION`, `AZURE_FUNCTIONS_FUNCTION_NAME`, `AZURE_FUNCTIONS_SITE_NAME`, `CICS_PROGRAM_NAME`, `CICS_SYSTEM_ID`, `CICS_TASK_ID`, `CICS_TRANSACTION_ID`, `CICS_USER_ID`, `CPU_TIME`, `CTG_GATEWAY_URL`, `CTG_PROGRAM`, `CTG_SERVER_NAME`, `CTG_TRANSACTION_ID`, `CUSTOMSERVICE_CLASS`, `CUSTOMSERVICE_METHOD`, `DATABASE_CHILD_CALL_COUNT`, `DATABASE_CHILD_CALL_TIME`, `DATABASE_HOST`, `DATABASE_NAME`, `DATABASE_TYPE`, `DATABASE_URL`, `DISK_IO_TIME`, `ERROR_COUNT`, `ESB_APPLICATION_NAME`, `ESB_INPUT_TYPE`, `ESB_LIBRARY_NAME`, `ESB_MESSAGE_FLOW_NAME`, `EXCEPTION_CLASS`, `EXCEPTION_MESSAGE`, `FAILED_STATE`, `FAILURE_REASON`, `FLAW_STATE`, `HTTP_REQUEST_METHOD`, `HTTP_STATUS`, `HTTP_STATUS_CLASS`, `IMS_PROGRAM_NAME`, `IMS_TRANSACTION_ID`, `IMS_USER_ID`, `IO_TIME`, `IS_KEY_REQUEST`, `LAMBDA_COLDSTART`, `LOCK_TIME`, `MESSAGING_DESTINATION_TYPE`, `MESSAGING_IS_TEMPORARY_QUEUE`, `MESSAGING_QUEUE_NAME`, `MESSAGING_QUEUE_VENDOR`, `NETWORK_IO_TIME`, `NON_DATABASE_CHILD_CALL_COUNT`, `NON_DATABASE_CHILD_CALL_TIME`, `PROCESS_GROUP_NAME`, `PROCESS_GROUP_TAG`, `REMOTE_ENDPOINT`, `REMOTE_METHOD`, `REMOTE_SERVICE_NAME`, `REQUEST_NAME`, `REQUEST_TYPE`, `RESPONSE_TIME`, `RESPONSE_TIME_CLIENT`, `RMI_CLASS`, `RMI_METHOD`, `SERVICE_DISPLAY_NAME`, `SERVICE_NAME`, `SERVICE_PORT`, `SERVICE_PUBLIC_DOMAIN_NAME`, `SERVICE_REQUEST_ATTRIBUTE`, `SERVICE_TAG`, `SERVICE_TYPE`, `SERVICE_WEB_APPLICATION_ID`, `SERVICE_WEB_CONTEXT_ROOT`, `SERVICE_WEB_SERVER_NAME`, `SERVICE_WEB_SERVICE_NAME`, `SERVICE_WEB_SERVICE_NAMESPACE`, `SUSPENSION_TIME`, `TOTAL_PROCESSING_TIME`, `WAIT_TIME`, `WEBREQUEST_QUERY`, `WEBREQUEST_RELATIVE_URL`, `WEBREQUEST_URL`, `WEBREQUEST_URL_HOST`, `WEBREQUEST_URL_PATH`, `WEBREQUEST_URL_PORT`, `WEBSERVICE_ENDPOINT`, `WEBSERVICE_METHOD` and `ZOS_CALL_TYPE`
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def comparison(self) -> 'outputs.CalculatedServiceMetricConditionConditionComparison':
        """
        Type-specific comparison for attributes
        """
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "esbInputNodeType":
            suggest = "esb_input_node_type"
        elif key == "failedState":
            suggest = "failed_state"
        elif key == "failureReason":
            suggest = "failure_reason"
        elif key == "fastString":
            suggest = "fast_string"
        elif key == "flawState":
            suggest = "flaw_state"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "httpStatusClass":
            suggest = "http_status_class"
        elif key == "iibInputNodeType":
            suggest = "iib_input_node_type"
        elif key == "numberRequestAttribute":
            suggest = "number_request_attribute"
        elif key == "serviceType":
            suggest = "service_type"
        elif key == "stringRequestAttribute":
            suggest = "string_request_attribute"
        elif key == "zosCallType":
            suggest = "zos_call_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boolean: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonBoolean'] = None,
                 esb_input_node_type: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonEsbInputNodeType'] = None,
                 failed_state: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFailedState'] = None,
                 failure_reason: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFailureReason'] = None,
                 fast_string: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFastString'] = None,
                 flaw_state: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFlawState'] = None,
                 generic: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonGeneric'] = None,
                 http_method: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonHttpMethod'] = None,
                 http_status_class: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonHttpStatusClass'] = None,
                 iib_input_node_type: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonIibInputNodeType'] = None,
                 negate: Optional[bool] = None,
                 number: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumber'] = None,
                 number_request_attribute: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute'] = None,
                 service_type: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonServiceType'] = None,
                 string: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonString'] = None,
                 string_request_attribute: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute'] = None,
                 tag: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonTag'] = None,
                 zos_call_type: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonZosCallType'] = None):
        """
        :param 'CalculatedServiceMetricConditionConditionComparisonBooleanArgs' boolean: Boolean Comparison for `BOOLEAN` attributes
        :param 'CalculatedServiceMetricConditionConditionComparisonEsbInputNodeTypeArgs' esb_input_node_type: Type-specific comparison information for attributes of type 'ESB_INPUT_NODE_TYPE'
        :param 'CalculatedServiceMetricConditionConditionComparisonFailedStateArgs' failed_state: Comparison for `FAILED_STATE` attributes
        :param 'CalculatedServiceMetricConditionConditionComparisonFailureReasonArgs' failure_reason: Comparison for `FAILURE_REASON` attributes
        :param 'CalculatedServiceMetricConditionConditionComparisonFastStringArgs' fast_string: Comparison for `FAST_STRING` attributes. Use it for all service property attributes
        :param 'CalculatedServiceMetricConditionConditionComparisonFlawStateArgs' flaw_state: Comparison for `FLAW_STATE` attributes
        :param 'CalculatedServiceMetricConditionConditionComparisonGenericArgs' generic: Comparison for `NUMBER` attributes
        :param 'CalculatedServiceMetricConditionConditionComparisonHttpMethodArgs' http_method: Comparison for `HTTP_METHOD` attributes
        :param 'CalculatedServiceMetricConditionConditionComparisonHttpStatusClassArgs' http_status_class: Comparison for `HTTP_STATUS_CLASS` attributes
        :param 'CalculatedServiceMetricConditionConditionComparisonIibInputNodeTypeArgs' iib_input_node_type: Comparison for `IIB_INPUT_NODE_TYPE` attributes
        :param bool negate: Reverse the comparison **operator**. For example, it turns **equals** into **does not equal**
        :param 'CalculatedServiceMetricConditionConditionComparisonNumberArgs' number: Comparison for `NUMBER` attributes
        :param 'CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeArgs' number_request_attribute: Comparison for `NUMBER_REQUEST_ATTRIBUTE` attributes
        :param 'CalculatedServiceMetricConditionConditionComparisonServiceTypeArgs' service_type: Comparison for `SERVICE_TYPE` attributes
        :param 'CalculatedServiceMetricConditionConditionComparisonStringArgs' string: Comparison for `STRING` attributes
        :param 'CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeArgs' string_request_attribute: Comparison for `STRING_REQUEST_ATTRIBUTE` attributes
        :param 'CalculatedServiceMetricConditionConditionComparisonTagArgs' tag: Comparison for `TAG` attributes
        :param 'CalculatedServiceMetricConditionConditionComparisonZosCallTypeArgs' zos_call_type: Comparison for `ZOS_CALL_TYPE` attributes
        """
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if esb_input_node_type is not None:
            pulumi.set(__self__, "esb_input_node_type", esb_input_node_type)
        if failed_state is not None:
            pulumi.set(__self__, "failed_state", failed_state)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if fast_string is not None:
            pulumi.set(__self__, "fast_string", fast_string)
        if flaw_state is not None:
            pulumi.set(__self__, "flaw_state", flaw_state)
        if generic is not None:
            pulumi.set(__self__, "generic", generic)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if http_status_class is not None:
            pulumi.set(__self__, "http_status_class", http_status_class)
        if iib_input_node_type is not None:
            pulumi.set(__self__, "iib_input_node_type", iib_input_node_type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if number_request_attribute is not None:
            pulumi.set(__self__, "number_request_attribute", number_request_attribute)
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_request_attribute is not None:
            pulumi.set(__self__, "string_request_attribute", string_request_attribute)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if zos_call_type is not None:
            pulumi.set(__self__, "zos_call_type", zos_call_type)

    @property
    @pulumi.getter
    def boolean(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonBoolean']:
        """
        Boolean Comparison for `BOOLEAN` attributes
        """
        return pulumi.get(self, "boolean")

    @property
    @pulumi.getter(name="esbInputNodeType")
    def esb_input_node_type(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonEsbInputNodeType']:
        """
        Type-specific comparison information for attributes of type 'ESB_INPUT_NODE_TYPE'
        """
        return pulumi.get(self, "esb_input_node_type")

    @property
    @pulumi.getter(name="failedState")
    def failed_state(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFailedState']:
        """
        Comparison for `FAILED_STATE` attributes
        """
        return pulumi.get(self, "failed_state")

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFailureReason']:
        """
        Comparison for `FAILURE_REASON` attributes
        """
        return pulumi.get(self, "failure_reason")

    @property
    @pulumi.getter(name="fastString")
    def fast_string(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFastString']:
        """
        Comparison for `FAST_STRING` attributes. Use it for all service property attributes
        """
        return pulumi.get(self, "fast_string")

    @property
    @pulumi.getter(name="flawState")
    def flaw_state(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFlawState']:
        """
        Comparison for `FLAW_STATE` attributes
        """
        return pulumi.get(self, "flaw_state")

    @property
    @pulumi.getter
    def generic(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonGeneric']:
        """
        Comparison for `NUMBER` attributes
        """
        return pulumi.get(self, "generic")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonHttpMethod']:
        """
        Comparison for `HTTP_METHOD` attributes
        """
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter(name="httpStatusClass")
    def http_status_class(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonHttpStatusClass']:
        """
        Comparison for `HTTP_STATUS_CLASS` attributes
        """
        return pulumi.get(self, "http_status_class")

    @property
    @pulumi.getter(name="iibInputNodeType")
    def iib_input_node_type(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonIibInputNodeType']:
        """
        Comparison for `IIB_INPUT_NODE_TYPE` attributes
        """
        return pulumi.get(self, "iib_input_node_type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverse the comparison **operator**. For example, it turns **equals** into **does not equal**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def number(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumber']:
        """
        Comparison for `NUMBER` attributes
        """
        return pulumi.get(self, "number")

    @property
    @pulumi.getter(name="numberRequestAttribute")
    def number_request_attribute(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute']:
        """
        Comparison for `NUMBER_REQUEST_ATTRIBUTE` attributes
        """
        return pulumi.get(self, "number_request_attribute")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonServiceType']:
        """
        Comparison for `SERVICE_TYPE` attributes
        """
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def string(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonString']:
        """
        Comparison for `STRING` attributes
        """
        return pulumi.get(self, "string")

    @property
    @pulumi.getter(name="stringRequestAttribute")
    def string_request_attribute(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute']:
        """
        Comparison for `STRING_REQUEST_ATTRIBUTE` attributes
        """
        return pulumi.get(self, "string_request_attribute")

    @property
    @pulumi.getter
    def tag(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonTag']:
        """
        Comparison for `TAG` attributes
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="zosCallType")
    def zos_call_type(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonZosCallType']:
        """
        Comparison for `ZOS_CALL_TYPE` attributes
        """
        return pulumi.get(self, "zos_call_type")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonBoolean(dict):
    def __init__(__self__, *,
                 value: bool,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 values: Optional[Sequence[bool]] = None):
        """
        :param bool value: The value to compare to
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param Sequence[bool] values: The values to compare to
        """
        pulumi.set(__self__, "value", value)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def value(self) -> bool:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[bool]]:
        """
        The values to compare to
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonEsbInputNodeType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
        :param Sequence[str] values: The values to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonFailedState(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to. Possible values are `FAILED` and `FAILED`
        :param Sequence[str] values: The values to compare to. Possible values are `FAILED` and `FAILED`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are `FAILED` and `FAILED`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to. Possible values are `FAILED` and `FAILED`
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonFailureReason(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to. Possible values are `EXCEPTION_AT_ENTRY_NODE`, `EXCEPTION_ON_ANY_NODE`, `HTTP_CODE` and `REQUEST_ATTRIBUTE`
        :param Sequence[str] values: The values to compare to. Possible values are `EXCEPTION_AT_ENTRY_NODE`, `EXCEPTION_ON_ANY_NODE`, `HTTP_CODE` and `REQUEST_ATTRIBUTE`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are `EXCEPTION_AT_ENTRY_NODE`, `EXCEPTION_ON_ANY_NODE`, `HTTP_CODE` and `REQUEST_ATTRIBUTE`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to. Possible values are `EXCEPTION_AT_ENTRY_NODE`, `EXCEPTION_ON_ANY_NODE`, `HTTP_CODE` and `REQUEST_ATTRIBUTE`
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonFastString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonFastString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonFastString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonFastString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or not case-sensitive (`false`)
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `CONTAINS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to
        :param Sequence[str] values: The values to compare to
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or not case-sensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `CONTAINS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonFlawState(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to. Possible values are `FLAWED` and `NOT_FLAWED`
        :param Sequence[str] values: The values to compare to. Possible values are `FLAWED` and `NOT_FLAWED`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are `FLAWED` and `NOT_FLAWED`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to. Possible values are `FLAWED` and `NOT_FLAWED`
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonGeneric(dict):
    def __init__(__self__, *,
                 type: str,
                 unknowns: Optional[str] = None):
        """
        :param str type: Defines the actual set of fields depending on the value
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines the actual set of fields depending on the value
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonHttpMethod(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to. Possible values are `CONNECT`, `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, `PUT` and `TRACE`
        :param Sequence[str] values: The values to compare to. Possible values are `CONNECT`, `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, `PUT` and `TRACE`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are `CONNECT`, `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, `PUT` and `TRACE`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to. Possible values are `CONNECT`, `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, `PUT` and `TRACE`
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonHttpStatusClass(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to. Possible values are `C_1XX`, `C_2XX`, `C_3XX`, `C_4XX`, `C_5XX` and `NO_RESPONSE`
        :param Sequence[str] values: The values to compare to. Possible values are `C_1XX`, `C_2XX`, `C_3XX`, `C_4XX`, `C_5XX` and `NO_RESPONSE`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are `C_1XX`, `C_2XX`, `C_3XX`, `C_4XX`, `C_5XX` and `NO_RESPONSE`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to. Possible values are `C_1XX`, `C_2XX`, `C_3XX`, `C_4XX`, `C_5XX` and `NO_RESPONSE`
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonIibInputNodeType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
        :param Sequence[str] values: The values to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonNumber(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[float] = None,
                 values: Optional[Sequence[float]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF`, `EXISTS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LOWER_THAN` and `LOWER_THAN_OR_EQUAL`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param float value: The value to compare to
        :param Sequence[float] values: The values to compare to
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF`, `EXISTS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LOWER_THAN` and `LOWER_THAN_OR_EQUAL`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[float]]:
        """
        The values to compare to
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"
        elif key == "matchOnChildCalls":
            suggest = "match_on_child_calls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_attribute: str,
                 match_on_child_calls: Optional[bool] = None,
                 operator: Optional[str] = None,
                 source: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource'] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[float] = None,
                 values: Optional[Sequence[float]] = None):
        """
        :param str request_attribute: No documentation available for this attribute
        :param bool match_on_child_calls: If `true`, the request attribute is matched on child service calls. Default is `false`
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF`, `EXISTS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LOWER_THAN` and `LOWER_THAN_OR_EQUAL`
        :param 'CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceArgs' source: Defines valid sources of request attributes for conditions or placeholders
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param float value: The value to compare to
        :param Sequence[float] values: The values to compare to
        """
        pulumi.set(__self__, "request_attribute", request_attribute)
        if match_on_child_calls is not None:
            pulumi.set(__self__, "match_on_child_calls", match_on_child_calls)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> str:
        """
        No documentation available for this attribute
        """
        return pulumi.get(self, "request_attribute")

    @property
    @pulumi.getter(name="matchOnChildCalls")
    def match_on_child_calls(self) -> Optional[bool]:
        """
        If `true`, the request attribute is matched on child service calls. Default is `false`
        """
        return pulumi.get(self, "match_on_child_calls")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF`, `EXISTS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LOWER_THAN` and `LOWER_THAN_OR_EQUAL`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource']:
        """
        Defines valid sources of request attributes for conditions or placeholders
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[float]]:
        """
        The values to compare to
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZone":
            suggest = "management_zone"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zone: Optional[str] = None,
                 service_tag: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag'] = None,
                 unknowns: Optional[str] = None):
        """
        :param str management_zone: Use only request attributes from services that belong to this management zone.. Use either this or `serviceTag`
        :param 'CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTagArgs' service_tag: Use only request attributes from services that have this tag. Use either this or `managementZone`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        """
        Use only request attributes from services that belong to this management zone.. Use either this or `serviceTag`
        """
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag']:
        """
        Use only request attributes from services that have this tag. Use either this or `managementZone`
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 tag_key: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTagTagKey'] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key of the tag. For custom tags, put the tag value here. The key allows categorization of multiple tags. It is possible that there are multiple values for a single key which will all be represented as standalone tags. Therefore, the key does not have the semantic of a map key but is more like a key of a key-value tuple. In some cases, for example custom tags, the key represents the actual tag value and the value field is not set – those are called valueless tags
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. For custom tags use the `CONTEXTLESS` value. The context is set for tags that are automatically imported by OneAgent (for example, from the AWS console or environment variables). It’s useful for determining the origin of tags when not manually defined, and it also helps to prevent clashes with other existing tags. If the tag is not automatically imported, `CONTEXTLESS` set. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_COMPUTE_ENGINE` and `KUBERNETES`
        :param 'CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTagTagKeyArgs' tag_key: has no documentation
        :param str value: The value of the tag. Not applicable to custom tags. If a tag does have a separate key and value (in the textual representation they are split by the colon ‘:’), this field is set with the actual value. Key-value pairs can occur for automatically imported tags and tags set by rules if extractors are used
        """
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. For custom tags, put the tag value here. The key allows categorization of multiple tags. It is possible that there are multiple values for a single key which will all be represented as standalone tags. Therefore, the key does not have the semantic of a map key but is more like a key of a key-value tuple. In some cases, for example custom tags, the key represents the actual tag value and the value field is not set – those are called valueless tags
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        The origin of the tag, such as AWS or Cloud Foundry. For custom tags use the `CONTEXTLESS` value. The context is set for tags that are automatically imported by OneAgent (for example, from the AWS console or environment variables). It’s useful for determining the origin of tags when not manually defined, and it also helps to prevent clashes with other existing tags. If the tag is not automatically imported, `CONTEXTLESS` set. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_COMPUTE_ENGINE` and `KUBERNETES`
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTagTagKey']:
        """
        has no documentation
        """
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags. If a tag does have a separate key and value (in the textual representation they are split by the colon ‘:’), this field is set with the actual value. Key-value pairs can occur for automatically imported tags and tags set by rules if extractors are used
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTagTagKey(dict):
    def __init__(__self__, *,
                 context: Optional[str] = None,
                 key: Optional[str] = None):
        """
        :param str context: has no documentation
        :param str key: has no documentation
        """
        if context is not None:
            pulumi.set(__self__, "context", context)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        has no documentation
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        has no documentation
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonServiceType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to. Possible values are `BACKGROUND_ACTIVITY`, `CICS_SERVICE`, `CUSTOM_SERVICE`, `DATABASE_SERVICE`, `ENTERPRISE_SERVICE_BUS_SERVICE`, `EXTERNAL`, `IBM_INTEGRATION_BUS_SERVICE`, `IMS_SERVICE`, `MESSAGING_SERVICE`, `RMI_SERVICE`, `RPC_SERVICE`, `WEB_REQUEST_SERVICE` and `WEB_SERVICE`
        :param Sequence[str] values: The values to compare to. Possible values are `BACKGROUND_ACTIVITY`, `CICS_SERVICE`, `CUSTOM_SERVICE`, `DATABASE_SERVICE`, `ENTERPRISE_SERVICE_BUS_SERVICE`, `EXTERNAL`, `IBM_INTEGRATION_BUS_SERVICE`, `IMS_SERVICE`, `MESSAGING_SERVICE`, `RMI_SERVICE`, `RPC_SERVICE`, `WEB_REQUEST_SERVICE` and `WEB_SERVICE`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are `BACKGROUND_ACTIVITY`, `CICS_SERVICE`, `CUSTOM_SERVICE`, `DATABASE_SERVICE`, `ENTERPRISE_SERVICE_BUS_SERVICE`, `EXTERNAL`, `IBM_INTEGRATION_BUS_SERVICE`, `IMS_SERVICE`, `MESSAGING_SERVICE`, `RMI_SERVICE`, `RPC_SERVICE`, `WEB_REQUEST_SERVICE` and `WEB_SERVICE`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to. Possible values are `BACKGROUND_ACTIVITY`, `CICS_SERVICE`, `CUSTOM_SERVICE`, `DATABASE_SERVICE`, `ENTERPRISE_SERVICE_BUS_SERVICE`, `EXTERNAL`, `IBM_INTEGRATION_BUS_SERVICE`, `IMS_SERVICE`, `MESSAGING_SERVICE`, `RMI_SERVICE`, `RPC_SERVICE`, `WEB_REQUEST_SERVICE` and `WEB_SERVICE`
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or not case-sensitive (`false`)
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `BEGINS_WITH`, `BEGINS_WITH_ANY_OF`, `CONTAINS`, `ENDS_WITH`, `ENDS_WITH_ANY_OF`, `EQUALS`, `EQUALS_ANY_OF`, `EXISTS` and `REGEX_MATCHES`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to
        :param Sequence[str] values: The values to compare to
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or not case-sensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `BEGINS_WITH`, `BEGINS_WITH_ANY_OF`, `CONTAINS`, `ENDS_WITH`, `ENDS_WITH_ANY_OF`, `EQUALS`, `EQUALS_ANY_OF`, `EXISTS` and `REGEX_MATCHES`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchOnChildCalls":
            suggest = "match_on_child_calls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_attribute: str,
                 case_sensitive: Optional[bool] = None,
                 match_on_child_calls: Optional[bool] = None,
                 operator: Optional[str] = None,
                 source: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource'] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str request_attribute: No documentation available for this attribute
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or not case-sensitive (`false`)
        :param bool match_on_child_calls: If `true`, the request attribute is matched on child service calls. Default is `false`
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `BEGINS_WITH`, `BEGINS_WITH_ANY_OF`, `CONTAINS`, `ENDS_WITH`, `ENDS_WITH_ANY_OF`, `EQUALS`, `EQUALS_ANY_OF`, `EXISTS` and `REGEX_MATCHES`
        :param 'CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceArgs' source: Defines valid sources of request attributes for conditions or placeholders
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to
        :param Sequence[str] values: The values to compare to
        """
        pulumi.set(__self__, "request_attribute", request_attribute)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_on_child_calls is not None:
            pulumi.set(__self__, "match_on_child_calls", match_on_child_calls)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> str:
        """
        No documentation available for this attribute
        """
        return pulumi.get(self, "request_attribute")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or not case-sensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchOnChildCalls")
    def match_on_child_calls(self) -> Optional[bool]:
        """
        If `true`, the request attribute is matched on child service calls. Default is `false`
        """
        return pulumi.get(self, "match_on_child_calls")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `BEGINS_WITH`, `BEGINS_WITH_ANY_OF`, `CONTAINS`, `ENDS_WITH`, `ENDS_WITH_ANY_OF`, `EQUALS`, `EQUALS_ANY_OF`, `EXISTS` and `REGEX_MATCHES`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource']:
        """
        Defines valid sources of request attributes for conditions or placeholders
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZone":
            suggest = "management_zone"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zone: Optional[str] = None,
                 service_tag: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag'] = None,
                 unknowns: Optional[str] = None):
        """
        :param str management_zone: Use only request attributes from services that belong to this management zone.. Use either this or `serviceTag`
        :param 'CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTagArgs' service_tag: Use only request attributes from services that have this tag. Use either this or `managementZone`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        """
        Use only request attributes from services that belong to this management zone.. Use either this or `serviceTag`
        """
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag']:
        """
        Use only request attributes from services that have this tag. Use either this or `managementZone`
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 tag_key: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTagTagKey'] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key of the tag. For custom tags, put the tag value here. The key allows categorization of multiple tags. It is possible that there are multiple values for a single key which will all be represented as standalone tags. Therefore, the key does not have the semantic of a map key but is more like a key of a key-value tuple. In some cases, for example custom tags, the key represents the actual tag value and the value field is not set – those are called valueless tags
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. For custom tags use the `CONTEXTLESS` value. The context is set for tags that are automatically imported by OneAgent (for example, from the AWS console or environment variables). It’s useful for determining the origin of tags when not manually defined, and it also helps to prevent clashes with other existing tags. If the tag is not automatically imported, `CONTEXTLESS` set. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_COMPUTE_ENGINE` and `KUBERNETES`
        :param 'CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTagTagKeyArgs' tag_key: has no documentation
        :param str value: The value of the tag. Not applicable to custom tags. If a tag does have a separate key and value (in the textual representation they are split by the colon ‘:’), this field is set with the actual value. Key-value pairs can occur for automatically imported tags and tags set by rules if extractors are used
        """
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. For custom tags, put the tag value here. The key allows categorization of multiple tags. It is possible that there are multiple values for a single key which will all be represented as standalone tags. Therefore, the key does not have the semantic of a map key but is more like a key of a key-value tuple. In some cases, for example custom tags, the key represents the actual tag value and the value field is not set – those are called valueless tags
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        The origin of the tag, such as AWS or Cloud Foundry. For custom tags use the `CONTEXTLESS` value. The context is set for tags that are automatically imported by OneAgent (for example, from the AWS console or environment variables). It’s useful for determining the origin of tags when not manually defined, and it also helps to prevent clashes with other existing tags. If the tag is not automatically imported, `CONTEXTLESS` set. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_COMPUTE_ENGINE` and `KUBERNETES`
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTagTagKey']:
        """
        has no documentation
        """
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags. If a tag does have a separate key and value (in the textual representation they are split by the colon ‘:’), this field is set with the actual value. Key-value pairs can occur for automatically imported tags and tags set by rules if extractors are used
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTagTagKey(dict):
    def __init__(__self__, *,
                 context: Optional[str] = None,
                 key: Optional[str] = None):
        """
        :param str context: has no documentation
        :param str key: has no documentation
        """
        if context is not None:
            pulumi.set(__self__, "context", context)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        has no documentation
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        has no documentation
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonTag(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonTagValue'] = None,
                 values: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonTagValues'] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF`, `TAG_KEY_EQUALS` and `TAG_KEY_EQUALS_ANY_OF`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param 'CalculatedServiceMetricConditionConditionComparisonTagValueArgs' value: The values to compare to
        :param 'CalculatedServiceMetricConditionConditionComparisonTagValuesArgs' values: The values to compare to
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF`, `TAG_KEY_EQUALS` and `TAG_KEY_EQUALS_ANY_OF`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonTagValue']:
        """
        The values to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonTagValues']:
        """
        The values to compare to
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_CLOUD` and `KUBERNETES`
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_CLOUD` and `KUBERNETES`
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonTagValues(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence['outputs.CalculatedServiceMetricConditionConditionComparisonTagValuesValue']] = None):
        """
        :param Sequence['CalculatedServiceMetricConditionConditionComparisonTagValuesValueArgs'] values: The values to compare to
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.CalculatedServiceMetricConditionConditionComparisonTagValuesValue']]:
        """
        The values to compare to
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonTagValuesValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_CLOUD` and `KUBERNETES`
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_CLOUD` and `KUBERNETES`
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonZosCallType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to. Possible values are `CTG`, `DPL`, `EXPLICIT_ADK`, `IMS_CONNECT`, `IMS_CONNECT_API`, `IMS_ITRA`, `IMS_MSC`, `IMS_PGM_SWITCH`, `IMS_SHARED_QUEUES`, `IMS_TRANS_EXEC`, `MQ`, `SOAP`, `START`, `TX` and `UNKNOWN`
        :param Sequence[str] values: The values to compare to. Possible values are `CTG`, `DPL`, `EXPLICIT_ADK`, `IMS_CONNECT`, `IMS_CONNECT_API`, `IMS_ITRA`, `IMS_MSC`, `IMS_PGM_SWITCH`, `IMS_SHARED_QUEUES`, `IMS_TRANS_EXEC`, `MQ`, `SOAP`, `START`, `TX` and `UNKNOWN`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are `CTG`, `DPL`, `EXPLICIT_ADK`, `IMS_CONNECT`, `IMS_CONNECT_API`, `IMS_ITRA`, `IMS_MSC`, `IMS_PGM_SWITCH`, `IMS_SHARED_QUEUES`, `IMS_TRANS_EXEC`, `MQ`, `SOAP`, `START`, `TX` and `UNKNOWN`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to. Possible values are `CTG`, `DPL`, `EXPLICIT_ADK`, `IMS_CONNECT`, `IMS_CONNECT_API`, `IMS_ITRA`, `IMS_MSC`, `IMS_PGM_SWITCH`, `IMS_SHARED_QUEUES`, `IMS_TRANS_EXEC`, `MQ`, `SOAP`, `START`, `TX` and `UNKNOWN`
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricDimensionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topX":
            suggest = "top_x"
        elif key == "topXAggregation":
            suggest = "top_x_aggregation"
        elif key == "topXDirection":
            suggest = "top_x_direction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricDimensionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricDimensionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricDimensionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension: str,
                 name: str,
                 top_x: int,
                 top_x_aggregation: str,
                 top_x_direction: str,
                 placeholders: Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholders'] = None,
                 unknowns: Optional[str] = None):
        """
        :param str dimension: The dimension value pattern. You can define custom placeholders in the `placeholders` field and use them here
        :param str name: The name of the dimension
        :param int top_x: The number of top values to be calculated
        :param str top_x_aggregation: The aggregation of the dimension. Possible values are `AVERAGE`, `COUNT`, `MAX`, `MIN`, `OF_INTEREST_RATIO`, `OTHER_RATIO`, `SINGLE_VALUE` and `SUM`
        :param str top_x_direction: How to calculate the **topX** values. Possible values are `ASCENDING` and `DESCENDING`
        :param 'CalculatedServiceMetricDimensionDefinitionPlaceholdersArgs' placeholders: The list of custom placeholders to be used in a dimension value pattern
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "dimension", dimension)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "top_x", top_x)
        pulumi.set(__self__, "top_x_aggregation", top_x_aggregation)
        pulumi.set(__self__, "top_x_direction", top_x_direction)
        if placeholders is not None:
            pulumi.set(__self__, "placeholders", placeholders)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def dimension(self) -> str:
        """
        The dimension value pattern. You can define custom placeholders in the `placeholders` field and use them here
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the dimension
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="topX")
    def top_x(self) -> int:
        """
        The number of top values to be calculated
        """
        return pulumi.get(self, "top_x")

    @property
    @pulumi.getter(name="topXAggregation")
    def top_x_aggregation(self) -> str:
        """
        The aggregation of the dimension. Possible values are `AVERAGE`, `COUNT`, `MAX`, `MIN`, `OF_INTEREST_RATIO`, `OTHER_RATIO`, `SINGLE_VALUE` and `SUM`
        """
        return pulumi.get(self, "top_x_aggregation")

    @property
    @pulumi.getter(name="topXDirection")
    def top_x_direction(self) -> str:
        """
        How to calculate the **topX** values. Possible values are `ASCENDING` and `DESCENDING`
        """
        return pulumi.get(self, "top_x_direction")

    @property
    @pulumi.getter
    def placeholders(self) -> Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholders']:
        """
        The list of custom placeholders to be used in a dimension value pattern
        """
        return pulumi.get(self, "placeholders")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CalculatedServiceMetricDimensionDefinitionPlaceholders(dict):
    def __init__(__self__, *,
                 placeholders: Optional[Sequence['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder']] = None):
        """
        :param Sequence['CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderArgs'] placeholders: A custom placeholder to be used in a dimension value pattern
        """
        if placeholders is not None:
            pulumi.set(__self__, "placeholders", placeholders)

    @property
    @pulumi.getter
    def placeholders(self) -> Optional[Sequence['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder']]:
        """
        A custom placeholder to be used in a dimension value pattern
        """
        return pulumi.get(self, "placeholders")


@pulumi.output_type
class CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delimiterOrRegex":
            suggest = "delimiter_or_regex"
        elif key == "endDelimiter":
            suggest = "end_delimiter"
        elif key == "requestAttribute":
            suggest = "request_attribute"
        elif key == "useFromChildCalls":
            suggest = "use_from_child_calls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 kind: str,
                 name: str,
                 aggregation: Optional[str] = None,
                 delimiter_or_regex: Optional[str] = None,
                 end_delimiter: Optional[str] = None,
                 normalization: Optional[str] = None,
                 request_attribute: Optional[str] = None,
                 source: Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource'] = None,
                 unknowns: Optional[str] = None,
                 use_from_child_calls: Optional[bool] = None):
        """
        :param str attribute: The attribute to extract from. You can only use attributes of the **string** type. Possible values are `ACTOR_SYSTEM`, `AKKA_ACTOR_CLASS_NAME`, `AKKA_ACTOR_MESSAGE_TYPE`, `AKKA_ACTOR_PATH`, `APPLICATION_BUILD_VERSION`, `APPLICATION_RELEASE_VERSION`, `AZURE_FUNCTIONS_FUNCTION_NAME`, `AZURE_FUNCTIONS_SITE_NAME`, `CICS_PROGRAM_NAME`, `CICS_SYSTEM_ID`, `CICS_TASK_ID`, `CICS_TRANSACTION_ID`, `CICS_USER_ID`, `CPU_TIME`, `CTG_GATEWAY_URL`, `CTG_PROGRAM`, `CTG_SERVER_NAME`, `CTG_TRANSACTION_ID`, `CUSTOMSERVICE_CLASS`, `CUSTOMSERVICE_METHOD`, `DATABASE_CHILD_CALL_COUNT`, `DATABASE_CHILD_CALL_TIME`, `DATABASE_HOST`, `DATABASE_NAME`, `DATABASE_TYPE`, `DATABASE_URL`, `DISK_IO_TIME`, `ERROR_COUNT`, `ESB_APPLICATION_NAME`, `ESB_INPUT_TYPE`, `ESB_LIBRARY_NAME`, `ESB_MESSAGE_FLOW_NAME`, `EXCEPTION_CLASS`, `EXCEPTION_MESSAGE`, `FAILED_STATE`, `FAILURE_REASON`, `FLAW_STATE`, `HTTP_REQUEST_METHOD`, `HTTP_STATUS`, `HTTP_STATUS_CLASS`, `IMS_PROGRAM_NAME`, `IMS_TRANSACTION_ID`, `IMS_USER_ID`, `IO_TIME`, `IS_KEY_REQUEST`, `LAMBDA_COLDSTART`, `LOCK_TIME`, `MESSAGING_DESTINATION_TYPE`, `MESSAGING_IS_TEMPORARY_QUEUE`, `MESSAGING_QUEUE_NAME`, `MESSAGING_QUEUE_VENDOR`, `NETWORK_IO_TIME`, `NON_DATABASE_CHILD_CALL_COUNT`, `NON_DATABASE_CHILD_CALL_TIME`, `PROCESS_GROUP_NAME`, `PROCESS_GROUP_TAG`, `REMOTE_ENDPOINT`, `REMOTE_METHOD`, `REMOTE_SERVICE_NAME`, `REQUEST_NAME`, `REQUEST_TYPE`, `RESPONSE_TIME`, `RESPONSE_TIME_CLIENT`, `RMI_CLASS`, `RMI_METHOD`, `SERVICE_DISPLAY_NAME`, `SERVICE_NAME`, `SERVICE_PORT`, `SERVICE_PUBLIC_DOMAIN_NAME`, `SERVICE_REQUEST_ATTRIBUTE`, `SERVICE_TAG`, `SERVICE_TYPE`, `SERVICE_WEB_APPLICATION_ID`, `SERVICE_WEB_CONTEXT_ROOT`, `SERVICE_WEB_SERVER_NAME`, `SERVICE_WEB_SERVICE_NAME`, `SERVICE_WEB_SERVICE_NAMESPACE`, `SUSPENSION_TIME`, `TOTAL_PROCESSING_TIME`, `WAIT_TIME`, `WEBREQUEST_QUERY`, `WEBREQUEST_RELATIVE_URL`, `WEBREQUEST_URL`, `WEBREQUEST_URL_HOST`, `WEBREQUEST_URL_PATH`, `WEBREQUEST_URL_PORT`, `WEBSERVICE_ENDPOINT`, `WEBSERVICE_METHOD` and `ZOS_CALL_TYPE`
        :param str kind: The type of extraction. Defines either usage of regular expression (`regex`) or the position of request attribute value to be extracted. When the `attribute` is `SERVICE_REQUEST_ATTRIBUTE` attribute and `aggregation` is `COUNT`, needs to be set to `ORIGINAL_TEXT`. Possible values are 	`AFTER_DELIMITER`, `BEFORE_DELIMITER`, `BETWEEN_DELIMITER`, `ORIGINAL_TEXT` and `REGEX_EXTRACTION`
        :param str name: The name of the placeholder. Use it in the naming pattern as `{name}`
        :param str aggregation: Which value of the request attribute must be used when it occurs across multiple child requests. Only applicable for the `SERVICE_REQUEST_ATTRIBUTE` attribute, when **useFromChildCalls** is `true`. For the `COUNT` aggregation, the **kind** field is not applicable. Possible values are `COUNT`, `FIRST` and `LAST`.
        :param str delimiter_or_regex: Depending on the `kind` value:
               
               
               * `REGEX_EXTRACTION`: The regular expression.
               
               
               * `BETWEEN_DELIMITER`: The opening delimiter string to look for.
               
               
               * All other values: The delimiter string to look for
        :param str end_delimiter: The closing delimiter string to look for. Required if the `kind` value is `BETWEEN_DELIMITER`. Not applicable otherwise
        :param str normalization: The format of the extracted string. Possible values are `ORIGINAL`, `TO_LOWER_CASE` and `TO_UPPER_CASE`
        :param str request_attribute: The request attribute to extract from. Required if the `kind` value is `SERVICE_REQUEST_ATTRIBUTE`. Not applicable otherwise
        :param 'CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceArgs' source: Defines valid sources of request attributes for conditions or placeholders
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param bool use_from_child_calls: If `true` request attribute will be taken from a child service call. Only applicable for the `SERVICE_REQUEST_ATTRIBUTE` attribute. Defaults to `false`
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if delimiter_or_regex is not None:
            pulumi.set(__self__, "delimiter_or_regex", delimiter_or_regex)
        if end_delimiter is not None:
            pulumi.set(__self__, "end_delimiter", end_delimiter)
        if normalization is not None:
            pulumi.set(__self__, "normalization", normalization)
        if request_attribute is not None:
            pulumi.set(__self__, "request_attribute", request_attribute)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if use_from_child_calls is not None:
            pulumi.set(__self__, "use_from_child_calls", use_from_child_calls)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to extract from. You can only use attributes of the **string** type. Possible values are `ACTOR_SYSTEM`, `AKKA_ACTOR_CLASS_NAME`, `AKKA_ACTOR_MESSAGE_TYPE`, `AKKA_ACTOR_PATH`, `APPLICATION_BUILD_VERSION`, `APPLICATION_RELEASE_VERSION`, `AZURE_FUNCTIONS_FUNCTION_NAME`, `AZURE_FUNCTIONS_SITE_NAME`, `CICS_PROGRAM_NAME`, `CICS_SYSTEM_ID`, `CICS_TASK_ID`, `CICS_TRANSACTION_ID`, `CICS_USER_ID`, `CPU_TIME`, `CTG_GATEWAY_URL`, `CTG_PROGRAM`, `CTG_SERVER_NAME`, `CTG_TRANSACTION_ID`, `CUSTOMSERVICE_CLASS`, `CUSTOMSERVICE_METHOD`, `DATABASE_CHILD_CALL_COUNT`, `DATABASE_CHILD_CALL_TIME`, `DATABASE_HOST`, `DATABASE_NAME`, `DATABASE_TYPE`, `DATABASE_URL`, `DISK_IO_TIME`, `ERROR_COUNT`, `ESB_APPLICATION_NAME`, `ESB_INPUT_TYPE`, `ESB_LIBRARY_NAME`, `ESB_MESSAGE_FLOW_NAME`, `EXCEPTION_CLASS`, `EXCEPTION_MESSAGE`, `FAILED_STATE`, `FAILURE_REASON`, `FLAW_STATE`, `HTTP_REQUEST_METHOD`, `HTTP_STATUS`, `HTTP_STATUS_CLASS`, `IMS_PROGRAM_NAME`, `IMS_TRANSACTION_ID`, `IMS_USER_ID`, `IO_TIME`, `IS_KEY_REQUEST`, `LAMBDA_COLDSTART`, `LOCK_TIME`, `MESSAGING_DESTINATION_TYPE`, `MESSAGING_IS_TEMPORARY_QUEUE`, `MESSAGING_QUEUE_NAME`, `MESSAGING_QUEUE_VENDOR`, `NETWORK_IO_TIME`, `NON_DATABASE_CHILD_CALL_COUNT`, `NON_DATABASE_CHILD_CALL_TIME`, `PROCESS_GROUP_NAME`, `PROCESS_GROUP_TAG`, `REMOTE_ENDPOINT`, `REMOTE_METHOD`, `REMOTE_SERVICE_NAME`, `REQUEST_NAME`, `REQUEST_TYPE`, `RESPONSE_TIME`, `RESPONSE_TIME_CLIENT`, `RMI_CLASS`, `RMI_METHOD`, `SERVICE_DISPLAY_NAME`, `SERVICE_NAME`, `SERVICE_PORT`, `SERVICE_PUBLIC_DOMAIN_NAME`, `SERVICE_REQUEST_ATTRIBUTE`, `SERVICE_TAG`, `SERVICE_TYPE`, `SERVICE_WEB_APPLICATION_ID`, `SERVICE_WEB_CONTEXT_ROOT`, `SERVICE_WEB_SERVER_NAME`, `SERVICE_WEB_SERVICE_NAME`, `SERVICE_WEB_SERVICE_NAMESPACE`, `SUSPENSION_TIME`, `TOTAL_PROCESSING_TIME`, `WAIT_TIME`, `WEBREQUEST_QUERY`, `WEBREQUEST_RELATIVE_URL`, `WEBREQUEST_URL`, `WEBREQUEST_URL_HOST`, `WEBREQUEST_URL_PATH`, `WEBREQUEST_URL_PORT`, `WEBSERVICE_ENDPOINT`, `WEBSERVICE_METHOD` and `ZOS_CALL_TYPE`
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The type of extraction. Defines either usage of regular expression (`regex`) or the position of request attribute value to be extracted. When the `attribute` is `SERVICE_REQUEST_ATTRIBUTE` attribute and `aggregation` is `COUNT`, needs to be set to `ORIGINAL_TEXT`. Possible values are 	`AFTER_DELIMITER`, `BEFORE_DELIMITER`, `BETWEEN_DELIMITER`, `ORIGINAL_TEXT` and `REGEX_EXTRACTION`
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the placeholder. Use it in the naming pattern as `{name}`
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        Which value of the request attribute must be used when it occurs across multiple child requests. Only applicable for the `SERVICE_REQUEST_ATTRIBUTE` attribute, when **useFromChildCalls** is `true`. For the `COUNT` aggregation, the **kind** field is not applicable. Possible values are `COUNT`, `FIRST` and `LAST`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="delimiterOrRegex")
    def delimiter_or_regex(self) -> Optional[str]:
        """
        Depending on the `kind` value:


        * `REGEX_EXTRACTION`: The regular expression.


        * `BETWEEN_DELIMITER`: The opening delimiter string to look for.


        * All other values: The delimiter string to look for
        """
        return pulumi.get(self, "delimiter_or_regex")

    @property
    @pulumi.getter(name="endDelimiter")
    def end_delimiter(self) -> Optional[str]:
        """
        The closing delimiter string to look for. Required if the `kind` value is `BETWEEN_DELIMITER`. Not applicable otherwise
        """
        return pulumi.get(self, "end_delimiter")

    @property
    @pulumi.getter
    def normalization(self) -> Optional[str]:
        """
        The format of the extracted string. Possible values are `ORIGINAL`, `TO_LOWER_CASE` and `TO_UPPER_CASE`
        """
        return pulumi.get(self, "normalization")

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> Optional[str]:
        """
        The request attribute to extract from. Required if the `kind` value is `SERVICE_REQUEST_ATTRIBUTE`. Not applicable otherwise
        """
        return pulumi.get(self, "request_attribute")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource']:
        """
        Defines valid sources of request attributes for conditions or placeholders
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="useFromChildCalls")
    def use_from_child_calls(self) -> Optional[bool]:
        """
        If `true` request attribute will be taken from a child service call. Only applicable for the `SERVICE_REQUEST_ATTRIBUTE` attribute. Defaults to `false`
        """
        return pulumi.get(self, "use_from_child_calls")


@pulumi.output_type
class CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZone":
            suggest = "management_zone"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zone: Optional[str] = None,
                 service_tag: Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag'] = None,
                 unknowns: Optional[str] = None):
        """
        :param str management_zone: Use only request attributes from services that belong to this management zone.. Use either this or `serviceTag`
        :param 'CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagArgs' service_tag: Use only request attributes from services that have this tag. Use either this or `managementZone`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        """
        Use only request attributes from services that belong to this management zone.. Use either this or `serviceTag`
        """
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag']:
        """
        Use only request attributes from services that have this tag. Use either this or `managementZone`
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 tag_key: Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKey'] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key of the tag. For custom tags, put the tag value here. The key allows categorization of multiple tags. It is possible that there are multiple values for a single key which will all be represented as standalone tags. Therefore, the key does not have the semantic of a map key but is more like a key of a key-value tuple. In some cases, for example custom tags, the key represents the actual tag value and the value field is not set – those are called valueless tags
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. For custom tags use the `CONTEXTLESS` value. The context is set for tags that are automatically imported by OneAgent (for example, from the AWS console or environment variables). It’s useful for determining the origin of tags when not manually defined, and it also helps to prevent clashes with other existing tags. If the tag is not automatically imported, `CONTEXTLESS` set. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_COMPUTE_ENGINE` and `KUBERNETES`
        :param 'CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKeyArgs' tag_key: has no documentation
        :param str value: The value of the tag. Not applicable to custom tags. If a tag does have a separate key and value (in the textual representation they are split by the colon ‘:’), this field is set with the actual value. Key-value pairs can occur for automatically imported tags and tags set by rules if extractors are used
        """
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. For custom tags, put the tag value here. The key allows categorization of multiple tags. It is possible that there are multiple values for a single key which will all be represented as standalone tags. Therefore, the key does not have the semantic of a map key but is more like a key of a key-value tuple. In some cases, for example custom tags, the key represents the actual tag value and the value field is not set – those are called valueless tags
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        The origin of the tag, such as AWS or Cloud Foundry. For custom tags use the `CONTEXTLESS` value. The context is set for tags that are automatically imported by OneAgent (for example, from the AWS console or environment variables). It’s useful for determining the origin of tags when not manually defined, and it also helps to prevent clashes with other existing tags. If the tag is not automatically imported, `CONTEXTLESS` set. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_COMPUTE_ENGINE` and `KUBERNETES`
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKey']:
        """
        has no documentation
        """
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags. If a tag does have a separate key and value (in the textual representation they are split by the colon ‘:’), this field is set with the actual value. Key-value pairs can occur for automatically imported tags and tags set by rules if extractors are used
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKey(dict):
    def __init__(__self__, *,
                 context: Optional[str] = None,
                 key: Optional[str] = None):
        """
        :param str context: has no documentation
        :param str key: has no documentation
        """
        if context is not None:
            pulumi.set(__self__, "context", context)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        has no documentation
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        has no documentation
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class CalculatedServiceMetricMetricDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricMetricDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricMetricDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricMetricDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 request_attribute: Optional[str] = None):
        """
        :param str metric: The metric to be captured. Possible values are `CPU_TIME`, `DATABASE_CHILD_CALL_COUNT`, `DATABASE_CHILD_CALL_TIME`, `DISK_IO_TIME`, `EXCEPTION_COUNT`, `FAILED_REQUEST_COUNT`, `FAILED_REQUEST_COUNT_CLIENT`, `FAILURE_RATE`, `FAILURE_RATE_CLIENT`, `HTTP_4XX_ERROR_COUNT`, `HTTP_4XX_ERROR_COUNT_CLIENT`, `HTTP_5XX_ERROR_COUNT`, `HTTP_5XX_ERROR_COUNT_CLIENT`, `IO_TIME`, `LOCK_TIME`, `NETWORK_IO_TIME`, `NON_DATABASE_CHILD_CALL_COUNT`, `NON_DATABASE_CHILD_CALL_TIME`, `PROCESSING_TIME`, `REQUEST_ATTRIBUTE`, `REQUEST_COUNT`, `RESPONSE_TIME`, `RESPONSE_TIME_CLIENT`, `SUCCESSFUL_REQUEST_COUNT`, `SUCCESSFUL_REQUEST_COUNT_CLIENT` and `WAIT_TIME`
        :param str request_attribute: The request attribute to be captured. Only applicable when the **metric** parameter is set to `REQUEST_ATTRIBUTE`
        """
        pulumi.set(__self__, "metric", metric)
        if request_attribute is not None:
            pulumi.set(__self__, "request_attribute", request_attribute)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric to be captured. Possible values are `CPU_TIME`, `DATABASE_CHILD_CALL_COUNT`, `DATABASE_CHILD_CALL_TIME`, `DISK_IO_TIME`, `EXCEPTION_COUNT`, `FAILED_REQUEST_COUNT`, `FAILED_REQUEST_COUNT_CLIENT`, `FAILURE_RATE`, `FAILURE_RATE_CLIENT`, `HTTP_4XX_ERROR_COUNT`, `HTTP_4XX_ERROR_COUNT_CLIENT`, `HTTP_5XX_ERROR_COUNT`, `HTTP_5XX_ERROR_COUNT_CLIENT`, `IO_TIME`, `LOCK_TIME`, `NETWORK_IO_TIME`, `NON_DATABASE_CHILD_CALL_COUNT`, `NON_DATABASE_CHILD_CALL_TIME`, `PROCESSING_TIME`, `REQUEST_ATTRIBUTE`, `REQUEST_COUNT`, `RESPONSE_TIME`, `RESPONSE_TIME_CLIENT`, `SUCCESSFUL_REQUEST_COUNT`, `SUCCESSFUL_REQUEST_COUNT_CLIENT` and `WAIT_TIME`
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> Optional[str]:
        """
        The request attribute to be captured. Only applicable when the **metric** parameter is set to `REQUEST_ATTRIBUTE`
        """
        return pulumi.get(self, "request_attribute")


@pulumi.output_type
class CalculatedSyntheticMetricDimension(dict):
    def __init__(__self__, *,
                 dimensions: Optional[Sequence['outputs.CalculatedSyntheticMetricDimensionDimension']] = None):
        """
        :param Sequence['CalculatedSyntheticMetricDimensionDimensionArgs'] dimensions: A dimensions for the metric usage
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.CalculatedSyntheticMetricDimensionDimension']]:
        """
        A dimensions for the metric usage
        """
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class CalculatedSyntheticMetricDimensionDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topX":
            suggest = "top_x"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedSyntheticMetricDimensionDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedSyntheticMetricDimensionDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedSyntheticMetricDimensionDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension: str,
                 top_x: Optional[int] = None):
        """
        :param str dimension: The dimension of the metric. Possible values are `Event`, `Location`, `ResourceOrigin`
        :param int top_x: The number of top values to be calculated
        """
        pulumi.set(__self__, "dimension", dimension)
        if top_x is not None:
            pulumi.set(__self__, "top_x", top_x)

    @property
    @pulumi.getter
    def dimension(self) -> str:
        """
        The dimension of the metric. Possible values are `Event`, `Location`, `ResourceOrigin`
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="topX")
    def top_x(self) -> Optional[int]:
        """
        The number of top values to be calculated
        """
        return pulumi.get(self, "top_x")


@pulumi.output_type
class CalculatedSyntheticMetricFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "errorCode":
            suggest = "error_code"
        elif key == "hasError":
            suggest = "has_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedSyntheticMetricFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedSyntheticMetricFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedSyntheticMetricFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: Optional[str] = None,
                 error_code: Optional[int] = None,
                 event: Optional[str] = None,
                 has_error: Optional[bool] = None,
                 location: Optional[str] = None):
        """
        :param str action_type: Only user actions of the specified type are included in the metric calculation
        :param int error_code: Only executions finished with the specified error code are included in the metric calculation.
        :param str event: Only the specified browser clickpath event is included in the metric calculation. Specify the Dynatrace entity ID of the event here.
        :param bool has_error: The execution status of the monitors to be included in the metric calculation: `true` or `false`
        :param str location: Only executions from the specified location are included in the metric calculation. Specify the Dynatrace entity ID of the location here.
        """
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if event is not None:
            pulumi.set(__self__, "event", event)
        if has_error is not None:
            pulumi.set(__self__, "has_error", has_error)
        if location is not None:
            pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        """
        Only user actions of the specified type are included in the metric calculation
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[int]:
        """
        Only executions finished with the specified error code are included in the metric calculation.
        """
        return pulumi.get(self, "error_code")

    @property
    @pulumi.getter
    def event(self) -> Optional[str]:
        """
        Only the specified browser clickpath event is included in the metric calculation. Specify the Dynatrace entity ID of the event here.
        """
        return pulumi.get(self, "event")

    @property
    @pulumi.getter(name="hasError")
    def has_error(self) -> Optional[bool]:
        """
        The execution status of the monitors to be included in the metric calculation: `true` or `false`
        """
        return pulumi.get(self, "has_error")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Only executions from the specified location are included in the metric calculation. Specify the Dynatrace entity ID of the location here.
        """
        return pulumi.get(self, "location")


@pulumi.output_type
class CalculatedWebMetricDimension(dict):
    def __init__(__self__, *,
                 dimensions: Optional[Sequence['outputs.CalculatedWebMetricDimensionDimension']] = None):
        """
        :param Sequence['CalculatedWebMetricDimensionDimensionArgs'] dimensions: A dimensions for the metric usage
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.CalculatedWebMetricDimensionDimension']]:
        """
        A dimensions for the metric usage
        """
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class CalculatedWebMetricDimensionDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topX":
            suggest = "top_x"
        elif key == "propertyKey":
            suggest = "property_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedWebMetricDimensionDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedWebMetricDimensionDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedWebMetricDimensionDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension: str,
                 top_x: int,
                 property_key: Optional[str] = None):
        """
        :param str dimension: The dimension of the metric. Possible values are `ApdexType`, `Browser`, `ErrorContext`, `ErrorOrigin`, `ErrorType`, `GeoLocation`, `StringProperty`, `UserActionType`
        :param int top_x: The number of top values to be calculated
        :param str property_key: The key of the user action property. Only applicable for the StringProperty dimension.
        """
        pulumi.set(__self__, "dimension", dimension)
        pulumi.set(__self__, "top_x", top_x)
        if property_key is not None:
            pulumi.set(__self__, "property_key", property_key)

    @property
    @pulumi.getter
    def dimension(self) -> str:
        """
        The dimension of the metric. Possible values are `ApdexType`, `Browser`, `ErrorContext`, `ErrorOrigin`, `ErrorType`, `GeoLocation`, `StringProperty`, `UserActionType`
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="topX")
    def top_x(self) -> int:
        """
        The number of top values to be calculated
        """
        return pulumi.get(self, "top_x")

    @property
    @pulumi.getter(name="propertyKey")
    def property_key(self) -> Optional[str]:
        """
        The key of the user action property. Only applicable for the StringProperty dimension.
        """
        return pulumi.get(self, "property_key")


@pulumi.output_type
class CalculatedWebMetricMetricDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertyKey":
            suggest = "property_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedWebMetricMetricDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedWebMetricMetricDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedWebMetricMetricDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 property_key: Optional[str] = None):
        """
        :param str metric: The metric to be captured. Possible values are `Apdex`, `ApplicationCache`, `Callback`, `CumulativeLayoutShift`, `DNSLookup`, `DOMComplete`, `DOMContentLoaded`, `DOMInteractive`, `DoubleProperty`, `ErrorCount`, `FirstContentfulPaint`, `FirstInputDelay`, `FirstInputStart`, `FirstPaint`, `HTMLDownloaded`, `LargestContentfulPaint`, `LoadEventEnd`, `LoadEventStart`, `LongProperty`, `LongTasksTime`, `NavigationStart`, `OnDOMContentLoaded`, `OnLoad`, `Processing`, `RedirectTime`, `Request`, `RequestStart`, `Response`, `SecureConnect`, `SpeedIndex`, `TCPConnect`, `TimeToFirstByte`, `UserActionDuration`, `VisuallyComplete`
        :param str property_key: The key of the user action property. Only applicable for DoubleProperty and LongProperty metrics.
        """
        pulumi.set(__self__, "metric", metric)
        if property_key is not None:
            pulumi.set(__self__, "property_key", property_key)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric to be captured. Possible values are `Apdex`, `ApplicationCache`, `Callback`, `CumulativeLayoutShift`, `DNSLookup`, `DOMComplete`, `DOMContentLoaded`, `DOMInteractive`, `DoubleProperty`, `ErrorCount`, `FirstContentfulPaint`, `FirstInputDelay`, `FirstInputStart`, `FirstPaint`, `HTMLDownloaded`, `LargestContentfulPaint`, `LoadEventEnd`, `LoadEventStart`, `LongProperty`, `LongTasksTime`, `NavigationStart`, `OnDOMContentLoaded`, `OnLoad`, `Processing`, `RedirectTime`, `Request`, `RequestStart`, `Response`, `SecureConnect`, `SpeedIndex`, `TCPConnect`, `TimeToFirstByte`, `UserActionDuration`, `VisuallyComplete`
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="propertyKey")
    def property_key(self) -> Optional[str]:
        """
        The key of the user action property. Only applicable for DoubleProperty and LongProperty metrics.
        """
        return pulumi.get(self, "property_key")


@pulumi.output_type
class CalculatedWebMetricUserActionFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionDurationFromMilliseconds":
            suggest = "action_duration_from_milliseconds"
        elif key == "actionDurationToMilliseconds":
            suggest = "action_duration_to_milliseconds"
        elif key == "browserFamily":
            suggest = "browser_family"
        elif key == "browserType":
            suggest = "browser_type"
        elif key == "browserVersion":
            suggest = "browser_version"
        elif key == "customAction":
            suggest = "custom_action"
        elif key == "customErrorName":
            suggest = "custom_error_name"
        elif key == "customErrorType":
            suggest = "custom_error_type"
        elif key == "hasAnyError":
            suggest = "has_any_error"
        elif key == "hasCustomErrors":
            suggest = "has_custom_errors"
        elif key == "hasHttpErrors":
            suggest = "has_http_errors"
        elif key == "hasJavascriptErrors":
            suggest = "has_javascript_errors"
        elif key == "httpErrorCode":
            suggest = "http_error_code"
        elif key == "httpErrorCodeTo":
            suggest = "http_error_code_to"
        elif key == "httpPath":
            suggest = "http_path"
        elif key == "ipV6Traffic":
            suggest = "ip_v6_traffic"
        elif key == "loadAction":
            suggest = "load_action"
        elif key == "osFamily":
            suggest = "os_family"
        elif key == "osVersion":
            suggest = "os_version"
        elif key == "realUser":
            suggest = "real_user"
        elif key == "targetViewGroup":
            suggest = "target_view_group"
        elif key == "targetViewGroupNameMatchType":
            suggest = "target_view_group_name_match_type"
        elif key == "targetViewName":
            suggest = "target_view_name"
        elif key == "targetViewNameMatchType":
            suggest = "target_view_name_match_type"
        elif key == "userActionName":
            suggest = "user_action_name"
        elif key == "userActionProperties":
            suggest = "user_action_properties"
        elif key == "xhrAction":
            suggest = "xhr_action"
        elif key == "xhrRouteChangeAction":
            suggest = "xhr_route_change_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedWebMetricUserActionFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedWebMetricUserActionFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedWebMetricUserActionFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_duration_from_milliseconds: Optional[int] = None,
                 action_duration_to_milliseconds: Optional[int] = None,
                 apdex: Optional[str] = None,
                 browser_family: Optional[str] = None,
                 browser_type: Optional[str] = None,
                 browser_version: Optional[str] = None,
                 city: Optional[str] = None,
                 continent: Optional[str] = None,
                 country: Optional[str] = None,
                 custom_action: Optional[bool] = None,
                 custom_error_name: Optional[str] = None,
                 custom_error_type: Optional[str] = None,
                 domain: Optional[str] = None,
                 has_any_error: Optional[bool] = None,
                 has_custom_errors: Optional[bool] = None,
                 has_http_errors: Optional[bool] = None,
                 has_javascript_errors: Optional[bool] = None,
                 http_error_code: Optional[int] = None,
                 http_error_code_to: Optional[int] = None,
                 http_path: Optional[str] = None,
                 ip: Optional[str] = None,
                 ip_v6_traffic: Optional[bool] = None,
                 load_action: Optional[bool] = None,
                 os_family: Optional[str] = None,
                 os_version: Optional[str] = None,
                 real_user: Optional[bool] = None,
                 region: Optional[str] = None,
                 robot: Optional[bool] = None,
                 synthetic: Optional[bool] = None,
                 target_view_group: Optional[str] = None,
                 target_view_group_name_match_type: Optional[str] = None,
                 target_view_name: Optional[str] = None,
                 target_view_name_match_type: Optional[str] = None,
                 user_action_name: Optional[str] = None,
                 user_action_properties: Optional[Sequence['outputs.CalculatedWebMetricUserActionFilterUserActionProperty']] = None,
                 xhr_action: Optional[bool] = None,
                 xhr_route_change_action: Optional[bool] = None):
        """
        :param int action_duration_from_milliseconds: Only actions with a duration more than or equal to this value (in milliseconds) are included in the metric calculation.
        :param int action_duration_to_milliseconds: Only actions with a duration less than or equal to this value (in milliseconds) are included in the metric calculation.
        :param str apdex: Only actions with the specified Apdex score are included in the metric calculation. Possible values: [ Frustrated, Satisfied, Tolerating, Unknown ]
        :param str browser_family: Only user actions coming from the specified browser family are included in the metric calculation.
        :param str browser_type: Only user actions coming from the specified browser type are included in the metric calculation.
        :param str browser_version: Only user actions coming from the specified browser version are included in the metric calculation.
        :param str city: Only actions of users from this city are included in the metric calculation. Specify geolocation ID here.
        :param str continent: Only actions of users from this continent are included in the metric calculation. Specify geolocation ID here.
        :param str country: Only actions of users from this country are included in the metric calculation. Specify geolocation ID here.
        :param bool custom_action: The status of custom actions in the metric calculation: `true` or `false`
        :param str custom_error_name: The custom error name of the actions to be included in the metric calculation.
        :param str custom_error_type: The custom error type of the actions to be included in the metric calculation.
        :param str domain: Only user actions coming from the specified domain are included in the metric calculation.
        :param bool has_any_error: The error status of the actions to be included in the metric calculation: `true` or `false`
        :param bool has_custom_errors: The custom error status of the actions to be included in the metric calculation: `true` or `false`
        :param bool has_http_errors: The request error status of the actions to be included in the metric calculation: `true` or `false`
        :param bool has_javascript_errors: The JavaScript error status of the actions to be included in the metric calculation: `true` or `false`
        :param int http_error_code: The HTTP error status code of the actions to be included in the metric calculation.
        :param int http_error_code_to: Can be used in combination with httpErrorCode to define a range of error codes that will be included in the metric calculation.
        :param str http_path: The request path that has been determined to be the origin of an HTTP error of the actions to be included in the metric calculation.
        :param str ip: Only actions coming from this IP address are included in the metric calculation.
        :param bool ip_v6_traffic: The IPv6 status of the actions to be included in the metric calculation: `true` or `false`
        :param bool load_action: The status of load actions in the metric calculation: `true` or `false`
        :param str os_family: Only actions coming from this OS family are included in the metric calculation.
        :param str os_version: Only actions coming from this OS version are included in the metric calculation.
        :param bool real_user: The status of actions coming from real users in the metric calculation: `true` or `false`
        :param str region: Only actions of users from this region are included in the metric calculation. Specify geolocation ID here.
        :param bool robot: The status of actions coming from robots in the metric calculation: `true` or `false`
        :param bool synthetic: The status of actions coming from synthetic monitors in the metric calculation: `true` or `false`
        :param str target_view_group: Only actions on the specified group of views are included in the metric calculation.
        :param str target_view_group_name_match_type: Specifies the match type of the view group filter, e.g. using Contains or Equals. Defaults to Equals.
        :param str target_view_name: Only actions on the specified view are included in the metric calculation.
        :param str target_view_name_match_type: Specifies the match type of the view name filter, e.g. using Contains or Equals. Defaults to Equals.
        :param str user_action_name: Only actions with this name are included in the metric calculation.
        :param Sequence['CalculatedWebMetricUserActionFilterUserActionPropertyArgs'] user_action_properties: The definition of a calculated web metric.
        :param bool xhr_action: The status of xhr actions in the metric calculation: `true` or `false`
        :param bool xhr_route_change_action: The status of route actions in the metric calculation: `true` or `false`
        """
        if action_duration_from_milliseconds is not None:
            pulumi.set(__self__, "action_duration_from_milliseconds", action_duration_from_milliseconds)
        if action_duration_to_milliseconds is not None:
            pulumi.set(__self__, "action_duration_to_milliseconds", action_duration_to_milliseconds)
        if apdex is not None:
            pulumi.set(__self__, "apdex", apdex)
        if browser_family is not None:
            pulumi.set(__self__, "browser_family", browser_family)
        if browser_type is not None:
            pulumi.set(__self__, "browser_type", browser_type)
        if browser_version is not None:
            pulumi.set(__self__, "browser_version", browser_version)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if continent is not None:
            pulumi.set(__self__, "continent", continent)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if custom_action is not None:
            pulumi.set(__self__, "custom_action", custom_action)
        if custom_error_name is not None:
            pulumi.set(__self__, "custom_error_name", custom_error_name)
        if custom_error_type is not None:
            pulumi.set(__self__, "custom_error_type", custom_error_type)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if has_any_error is not None:
            pulumi.set(__self__, "has_any_error", has_any_error)
        if has_custom_errors is not None:
            pulumi.set(__self__, "has_custom_errors", has_custom_errors)
        if has_http_errors is not None:
            pulumi.set(__self__, "has_http_errors", has_http_errors)
        if has_javascript_errors is not None:
            pulumi.set(__self__, "has_javascript_errors", has_javascript_errors)
        if http_error_code is not None:
            pulumi.set(__self__, "http_error_code", http_error_code)
        if http_error_code_to is not None:
            pulumi.set(__self__, "http_error_code_to", http_error_code_to)
        if http_path is not None:
            pulumi.set(__self__, "http_path", http_path)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_v6_traffic is not None:
            pulumi.set(__self__, "ip_v6_traffic", ip_v6_traffic)
        if load_action is not None:
            pulumi.set(__self__, "load_action", load_action)
        if os_family is not None:
            pulumi.set(__self__, "os_family", os_family)
        if os_version is not None:
            pulumi.set(__self__, "os_version", os_version)
        if real_user is not None:
            pulumi.set(__self__, "real_user", real_user)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if robot is not None:
            pulumi.set(__self__, "robot", robot)
        if synthetic is not None:
            pulumi.set(__self__, "synthetic", synthetic)
        if target_view_group is not None:
            pulumi.set(__self__, "target_view_group", target_view_group)
        if target_view_group_name_match_type is not None:
            pulumi.set(__self__, "target_view_group_name_match_type", target_view_group_name_match_type)
        if target_view_name is not None:
            pulumi.set(__self__, "target_view_name", target_view_name)
        if target_view_name_match_type is not None:
            pulumi.set(__self__, "target_view_name_match_type", target_view_name_match_type)
        if user_action_name is not None:
            pulumi.set(__self__, "user_action_name", user_action_name)
        if user_action_properties is not None:
            pulumi.set(__self__, "user_action_properties", user_action_properties)
        if xhr_action is not None:
            pulumi.set(__self__, "xhr_action", xhr_action)
        if xhr_route_change_action is not None:
            pulumi.set(__self__, "xhr_route_change_action", xhr_route_change_action)

    @property
    @pulumi.getter(name="actionDurationFromMilliseconds")
    def action_duration_from_milliseconds(self) -> Optional[int]:
        """
        Only actions with a duration more than or equal to this value (in milliseconds) are included in the metric calculation.
        """
        return pulumi.get(self, "action_duration_from_milliseconds")

    @property
    @pulumi.getter(name="actionDurationToMilliseconds")
    def action_duration_to_milliseconds(self) -> Optional[int]:
        """
        Only actions with a duration less than or equal to this value (in milliseconds) are included in the metric calculation.
        """
        return pulumi.get(self, "action_duration_to_milliseconds")

    @property
    @pulumi.getter
    def apdex(self) -> Optional[str]:
        """
        Only actions with the specified Apdex score are included in the metric calculation. Possible values: [ Frustrated, Satisfied, Tolerating, Unknown ]
        """
        return pulumi.get(self, "apdex")

    @property
    @pulumi.getter(name="browserFamily")
    def browser_family(self) -> Optional[str]:
        """
        Only user actions coming from the specified browser family are included in the metric calculation.
        """
        return pulumi.get(self, "browser_family")

    @property
    @pulumi.getter(name="browserType")
    def browser_type(self) -> Optional[str]:
        """
        Only user actions coming from the specified browser type are included in the metric calculation.
        """
        return pulumi.get(self, "browser_type")

    @property
    @pulumi.getter(name="browserVersion")
    def browser_version(self) -> Optional[str]:
        """
        Only user actions coming from the specified browser version are included in the metric calculation.
        """
        return pulumi.get(self, "browser_version")

    @property
    @pulumi.getter
    def city(self) -> Optional[str]:
        """
        Only actions of users from this city are included in the metric calculation. Specify geolocation ID here.
        """
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def continent(self) -> Optional[str]:
        """
        Only actions of users from this continent are included in the metric calculation. Specify geolocation ID here.
        """
        return pulumi.get(self, "continent")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        """
        Only actions of users from this country are included in the metric calculation. Specify geolocation ID here.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter(name="customAction")
    def custom_action(self) -> Optional[bool]:
        """
        The status of custom actions in the metric calculation: `true` or `false`
        """
        return pulumi.get(self, "custom_action")

    @property
    @pulumi.getter(name="customErrorName")
    def custom_error_name(self) -> Optional[str]:
        """
        The custom error name of the actions to be included in the metric calculation.
        """
        return pulumi.get(self, "custom_error_name")

    @property
    @pulumi.getter(name="customErrorType")
    def custom_error_type(self) -> Optional[str]:
        """
        The custom error type of the actions to be included in the metric calculation.
        """
        return pulumi.get(self, "custom_error_type")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Only user actions coming from the specified domain are included in the metric calculation.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="hasAnyError")
    def has_any_error(self) -> Optional[bool]:
        """
        The error status of the actions to be included in the metric calculation: `true` or `false`
        """
        return pulumi.get(self, "has_any_error")

    @property
    @pulumi.getter(name="hasCustomErrors")
    def has_custom_errors(self) -> Optional[bool]:
        """
        The custom error status of the actions to be included in the metric calculation: `true` or `false`
        """
        return pulumi.get(self, "has_custom_errors")

    @property
    @pulumi.getter(name="hasHttpErrors")
    def has_http_errors(self) -> Optional[bool]:
        """
        The request error status of the actions to be included in the metric calculation: `true` or `false`
        """
        return pulumi.get(self, "has_http_errors")

    @property
    @pulumi.getter(name="hasJavascriptErrors")
    def has_javascript_errors(self) -> Optional[bool]:
        """
        The JavaScript error status of the actions to be included in the metric calculation: `true` or `false`
        """
        return pulumi.get(self, "has_javascript_errors")

    @property
    @pulumi.getter(name="httpErrorCode")
    def http_error_code(self) -> Optional[int]:
        """
        The HTTP error status code of the actions to be included in the metric calculation.
        """
        return pulumi.get(self, "http_error_code")

    @property
    @pulumi.getter(name="httpErrorCodeTo")
    def http_error_code_to(self) -> Optional[int]:
        """
        Can be used in combination with httpErrorCode to define a range of error codes that will be included in the metric calculation.
        """
        return pulumi.get(self, "http_error_code_to")

    @property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> Optional[str]:
        """
        The request path that has been determined to be the origin of an HTTP error of the actions to be included in the metric calculation.
        """
        return pulumi.get(self, "http_path")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Only actions coming from this IP address are included in the metric calculation.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipV6Traffic")
    def ip_v6_traffic(self) -> Optional[bool]:
        """
        The IPv6 status of the actions to be included in the metric calculation: `true` or `false`
        """
        return pulumi.get(self, "ip_v6_traffic")

    @property
    @pulumi.getter(name="loadAction")
    def load_action(self) -> Optional[bool]:
        """
        The status of load actions in the metric calculation: `true` or `false`
        """
        return pulumi.get(self, "load_action")

    @property
    @pulumi.getter(name="osFamily")
    def os_family(self) -> Optional[str]:
        """
        Only actions coming from this OS family are included in the metric calculation.
        """
        return pulumi.get(self, "os_family")

    @property
    @pulumi.getter(name="osVersion")
    def os_version(self) -> Optional[str]:
        """
        Only actions coming from this OS version are included in the metric calculation.
        """
        return pulumi.get(self, "os_version")

    @property
    @pulumi.getter(name="realUser")
    def real_user(self) -> Optional[bool]:
        """
        The status of actions coming from real users in the metric calculation: `true` or `false`
        """
        return pulumi.get(self, "real_user")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Only actions of users from this region are included in the metric calculation. Specify geolocation ID here.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def robot(self) -> Optional[bool]:
        """
        The status of actions coming from robots in the metric calculation: `true` or `false`
        """
        return pulumi.get(self, "robot")

    @property
    @pulumi.getter
    def synthetic(self) -> Optional[bool]:
        """
        The status of actions coming from synthetic monitors in the metric calculation: `true` or `false`
        """
        return pulumi.get(self, "synthetic")

    @property
    @pulumi.getter(name="targetViewGroup")
    def target_view_group(self) -> Optional[str]:
        """
        Only actions on the specified group of views are included in the metric calculation.
        """
        return pulumi.get(self, "target_view_group")

    @property
    @pulumi.getter(name="targetViewGroupNameMatchType")
    def target_view_group_name_match_type(self) -> Optional[str]:
        """
        Specifies the match type of the view group filter, e.g. using Contains or Equals. Defaults to Equals.
        """
        return pulumi.get(self, "target_view_group_name_match_type")

    @property
    @pulumi.getter(name="targetViewName")
    def target_view_name(self) -> Optional[str]:
        """
        Only actions on the specified view are included in the metric calculation.
        """
        return pulumi.get(self, "target_view_name")

    @property
    @pulumi.getter(name="targetViewNameMatchType")
    def target_view_name_match_type(self) -> Optional[str]:
        """
        Specifies the match type of the view name filter, e.g. using Contains or Equals. Defaults to Equals.
        """
        return pulumi.get(self, "target_view_name_match_type")

    @property
    @pulumi.getter(name="userActionName")
    def user_action_name(self) -> Optional[str]:
        """
        Only actions with this name are included in the metric calculation.
        """
        return pulumi.get(self, "user_action_name")

    @property
    @pulumi.getter(name="userActionProperties")
    def user_action_properties(self) -> Optional[Sequence['outputs.CalculatedWebMetricUserActionFilterUserActionProperty']]:
        """
        The definition of a calculated web metric.
        """
        return pulumi.get(self, "user_action_properties")

    @property
    @pulumi.getter(name="xhrAction")
    def xhr_action(self) -> Optional[bool]:
        """
        The status of xhr actions in the metric calculation: `true` or `false`
        """
        return pulumi.get(self, "xhr_action")

    @property
    @pulumi.getter(name="xhrRouteChangeAction")
    def xhr_route_change_action(self) -> Optional[bool]:
        """
        The status of route actions in the metric calculation: `true` or `false`
        """
        return pulumi.get(self, "xhr_route_change_action")


@pulumi.output_type
class CalculatedWebMetricUserActionFilterUserActionProperty(dict):
    def __init__(__self__, *,
                 properties: Optional[Sequence['outputs.CalculatedWebMetricUserActionFilterUserActionPropertyProperty']] = None):
        """
        :param Sequence['CalculatedWebMetricUserActionFilterUserActionPropertyPropertyArgs'] properties: User Action Property
        """
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def properties(self) -> Optional[Sequence['outputs.CalculatedWebMetricUserActionFilterUserActionPropertyProperty']]:
        """
        User Action Property
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class CalculatedWebMetricUserActionFilterUserActionPropertyProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"
        elif key == "matchType":
            suggest = "match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedWebMetricUserActionFilterUserActionPropertyProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedWebMetricUserActionFilterUserActionPropertyProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedWebMetricUserActionFilterUserActionPropertyProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[float] = None,
                 key: Optional[str] = None,
                 match_type: Optional[str] = None,
                 to: Optional[float] = None,
                 value: Optional[str] = None):
        """
        :param float from_: Only actions that have a value greater than or equal to this are included in the metric calculation.
        :param str key: The key of the action property we're checking.
        :param str match_type: Specifies the match type of a string filter, e.g. using Contains or Equals.
        :param float to: Only actions that have a value less than or equal to this are included in the metric calculation.
        :param str value: Only actions that have this value in the specified property are included in the metric calculation.
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if to is not None:
            pulumi.set(__self__, "to", to)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[float]:
        """
        Only actions that have a value greater than or equal to this are included in the metric calculation.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key of the action property we're checking.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        Specifies the match type of a string filter, e.g. using Contains or Equals.
        """
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter
    def to(self) -> Optional[float]:
        """
        Only actions that have a value less than or equal to this are included in the metric calculation.
        """
        return pulumi.get(self, "to")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Only actions that have this value in the specified property are included in the metric calculation.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CloudappWorkloaddetectionCloudFoundry(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class CloudappWorkloaddetectionDocker(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class CloudappWorkloaddetectionKubernetes(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 filters: Optional['outputs.CloudappWorkloaddetectionKubernetesFilters'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'CloudappWorkloaddetectionKubernetesFiltersArgs' filters: Define rules to merge similar Kubernetes workloads into process groups. 
               
                You can use workload properties like namespace name, base pod name or container name as well as the [environment variables DT_RELEASE_STAGE and DT_RELEASE_PRODUCT](https://dt-url.net/sb02v2a) for grouping processes of similar workloads. The first applicable rule will be applied. If no rule matches, “Namespace name” + “Base pod name” + “Container name” is used as fallback.
        """
        pulumi.set(__self__, "enabled", enabled)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def filters(self) -> Optional['outputs.CloudappWorkloaddetectionKubernetesFilters']:
        """
        Define rules to merge similar Kubernetes workloads into process groups. 

         You can use workload properties like namespace name, base pod name or container name as well as the [environment variables DT_RELEASE_STAGE and DT_RELEASE_PRODUCT](https://dt-url.net/sb02v2a) for grouping processes of similar workloads. The first applicable rule will be applied. If no rule matches, “Namespace name” + “Base pod name” + “Container name” is used as fallback.
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class CloudappWorkloaddetectionKubernetesFilters(dict):
    def __init__(__self__, *,
                 filters: Sequence['outputs.CloudappWorkloaddetectionKubernetesFiltersFilter']):
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.CloudappWorkloaddetectionKubernetesFiltersFilter']:
        return pulumi.get(self, "filters")


@pulumi.output_type
class CloudappWorkloaddetectionKubernetesFiltersFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inclusionToggles":
            suggest = "inclusion_toggles"
        elif key == "matchFilter":
            suggest = "match_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudappWorkloaddetectionKubernetesFiltersFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudappWorkloaddetectionKubernetesFiltersFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudappWorkloaddetectionKubernetesFiltersFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 inclusion_toggles: 'outputs.CloudappWorkloaddetectionKubernetesFiltersFilterInclusionToggles',
                 match_filter: 'outputs.CloudappWorkloaddetectionKubernetesFiltersFilterMatchFilter'):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'CloudappWorkloaddetectionKubernetesFiltersFilterInclusionTogglesArgs' inclusion_toggles: ID calculation based on
        :param 'CloudappWorkloaddetectionKubernetesFiltersFilterMatchFilterArgs' match_filter: When namespace
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "inclusion_toggles", inclusion_toggles)
        pulumi.set(__self__, "match_filter", match_filter)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="inclusionToggles")
    def inclusion_toggles(self) -> 'outputs.CloudappWorkloaddetectionKubernetesFiltersFilterInclusionToggles':
        """
        ID calculation based on
        """
        return pulumi.get(self, "inclusion_toggles")

    @property
    @pulumi.getter(name="matchFilter")
    def match_filter(self) -> 'outputs.CloudappWorkloaddetectionKubernetesFiltersFilterMatchFilter':
        """
        When namespace
        """
        return pulumi.get(self, "match_filter")


@pulumi.output_type
class CloudappWorkloaddetectionKubernetesFiltersFilterInclusionToggles(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incBasepod":
            suggest = "inc_basepod"
        elif key == "incContainer":
            suggest = "inc_container"
        elif key == "incNamespace":
            suggest = "inc_namespace"
        elif key == "incProduct":
            suggest = "inc_product"
        elif key == "incStage":
            suggest = "inc_stage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudappWorkloaddetectionKubernetesFiltersFilterInclusionToggles. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudappWorkloaddetectionKubernetesFiltersFilterInclusionToggles.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudappWorkloaddetectionKubernetesFiltersFilterInclusionToggles.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inc_basepod: bool,
                 inc_container: bool,
                 inc_namespace: bool,
                 inc_product: bool,
                 inc_stage: bool):
        """
        :param bool inc_basepod: E.g. "cloud-credential-operator-" for "cloud-credential-operator-5ff6dbff57-gszgq"
        :param bool inc_container: Container name
        :param bool inc_namespace: Namespace name
        :param bool inc_product: If Product is enabled and has no value, it defaults to Base pod name
        :param bool inc_stage: Stage
        """
        pulumi.set(__self__, "inc_basepod", inc_basepod)
        pulumi.set(__self__, "inc_container", inc_container)
        pulumi.set(__self__, "inc_namespace", inc_namespace)
        pulumi.set(__self__, "inc_product", inc_product)
        pulumi.set(__self__, "inc_stage", inc_stage)

    @property
    @pulumi.getter(name="incBasepod")
    def inc_basepod(self) -> bool:
        """
        E.g. "cloud-credential-operator-" for "cloud-credential-operator-5ff6dbff57-gszgq"
        """
        return pulumi.get(self, "inc_basepod")

    @property
    @pulumi.getter(name="incContainer")
    def inc_container(self) -> bool:
        """
        Container name
        """
        return pulumi.get(self, "inc_container")

    @property
    @pulumi.getter(name="incNamespace")
    def inc_namespace(self) -> bool:
        """
        Namespace name
        """
        return pulumi.get(self, "inc_namespace")

    @property
    @pulumi.getter(name="incProduct")
    def inc_product(self) -> bool:
        """
        If Product is enabled and has no value, it defaults to Base pod name
        """
        return pulumi.get(self, "inc_product")

    @property
    @pulumi.getter(name="incStage")
    def inc_stage(self) -> bool:
        """
        Stage
        """
        return pulumi.get(self, "inc_stage")


@pulumi.output_type
class CloudappWorkloaddetectionKubernetesFiltersFilterMatchFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOperator":
            suggest = "match_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudappWorkloaddetectionKubernetesFiltersFilterMatchFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudappWorkloaddetectionKubernetesFiltersFilterMatchFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudappWorkloaddetectionKubernetesFiltersFilterMatchFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_operator: str,
                 namespace: Optional[str] = None):
        """
        :param str match_operator: Possible Values: `CONTAINS`, `ENDS`, `EQUALS`, `EXISTS`, `NOT_CONTAINS`, `NOT_ENDS`, `NOT_EQUALS`, `NOT_STARTS`, `STARTS`
        :param str namespace: Namespace name
        """
        pulumi.set(__self__, "match_operator", match_operator)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> str:
        """
        Possible Values: `CONTAINS`, `ENDS`, `EQUALS`, `EXISTS`, `NOT_CONTAINS`, `NOT_ENDS`, `NOT_EQUALS`, `NOT_STARTS`, `STARTS`
        """
        return pulumi.get(self, "match_operator")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace name
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class CloudappWorkloaddetectionServerless(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class CredentialsAllowedEntities(dict):
    def __init__(__self__, *,
                 entities: Sequence['outputs.CredentialsAllowedEntitiesEntity']):
        """
        :param Sequence['CredentialsAllowedEntitiesEntityArgs'] entities: The set of entities allowed to use the credential.
        """
        pulumi.set(__self__, "entities", entities)

    @property
    @pulumi.getter
    def entities(self) -> Sequence['outputs.CredentialsAllowedEntitiesEntity']:
        """
        The set of entities allowed to use the credential.
        """
        return pulumi.get(self, "entities")


@pulumi.output_type
class CredentialsAllowedEntitiesEntity(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: ID of the entity
        :param str type: Type of entity. Possible values: `USER`, `APPLICATION`, `UNKNOWN`
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the entity
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of entity. Possible values: `USER`, `APPLICATION`, `UNKNOWN`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CredentialsCredentialUsageSummary(dict):
    def __init__(__self__, *,
                 count: int,
                 type: str):
        """
        :param int count: The number of uses
        :param str type: Type of usage, `HTTP_MONITOR` or `BROWSER_MONITOR`
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of uses
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of usage, `HTTP_MONITOR` or `BROWSER_MONITOR`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CredentialsExternal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientSecret":
            suggest = "client_secret"
        elif key == "credentialsUsedForExternalSynchronizations":
            suggest = "credentials_used_for_external_synchronizations"
        elif key == "passwordSecretName":
            suggest = "password_secret_name"
        elif key == "pathToCredentials":
            suggest = "path_to_credentials"
        elif key == "tokenSecretName":
            suggest = "token_secret_name"
        elif key == "usernameSecretName":
            suggest = "username_secret_name"
        elif key == "vaultNamespace":
            suggest = "vault_namespace"
        elif key == "vaultUrl":
            suggest = "vault_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CredentialsExternal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CredentialsExternal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CredentialsExternal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 clientid: Optional[str] = None,
                 credentials_used_for_external_synchronizations: Optional[Sequence[str]] = None,
                 password_secret_name: Optional[str] = None,
                 path_to_credentials: Optional[str] = None,
                 roleid: Optional[str] = None,
                 secretid: Optional[str] = None,
                 tenantid: Optional[str] = None,
                 token_secret_name: Optional[str] = None,
                 username_secret_name: Optional[str] = None,
                 vault_namespace: Optional[str] = None,
                 vault_url: Optional[str] = None):
        """
        :param str client_secret: Required for Azure Client Secret. No further documentation available
        :param str clientid: Required for Azure Client Secret. No further documentation available
        :param Sequence[str] credentials_used_for_external_synchronizations: No documentation available
        :param str password_secret_name: No documentation available
        :param str tenantid: Required for Azure Client Secret. No further documentation available
        :param str token_secret_name: No documentation available
        :param str username_secret_name: No documentation available
        :param str vault_url: No documentation available
        """
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if clientid is not None:
            pulumi.set(__self__, "clientid", clientid)
        if credentials_used_for_external_synchronizations is not None:
            pulumi.set(__self__, "credentials_used_for_external_synchronizations", credentials_used_for_external_synchronizations)
        if password_secret_name is not None:
            pulumi.set(__self__, "password_secret_name", password_secret_name)
        if path_to_credentials is not None:
            pulumi.set(__self__, "path_to_credentials", path_to_credentials)
        if roleid is not None:
            pulumi.set(__self__, "roleid", roleid)
        if secretid is not None:
            pulumi.set(__self__, "secretid", secretid)
        if tenantid is not None:
            pulumi.set(__self__, "tenantid", tenantid)
        if token_secret_name is not None:
            pulumi.set(__self__, "token_secret_name", token_secret_name)
        if username_secret_name is not None:
            pulumi.set(__self__, "username_secret_name", username_secret_name)
        if vault_namespace is not None:
            pulumi.set(__self__, "vault_namespace", vault_namespace)
        if vault_url is not None:
            pulumi.set(__self__, "vault_url", vault_url)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        Required for Azure Client Secret. No further documentation available
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def clientid(self) -> Optional[str]:
        """
        Required for Azure Client Secret. No further documentation available
        """
        return pulumi.get(self, "clientid")

    @property
    @pulumi.getter(name="credentialsUsedForExternalSynchronizations")
    def credentials_used_for_external_synchronizations(self) -> Optional[Sequence[str]]:
        """
        No documentation available
        """
        return pulumi.get(self, "credentials_used_for_external_synchronizations")

    @property
    @pulumi.getter(name="passwordSecretName")
    def password_secret_name(self) -> Optional[str]:
        """
        No documentation available
        """
        return pulumi.get(self, "password_secret_name")

    @property
    @pulumi.getter(name="pathToCredentials")
    def path_to_credentials(self) -> Optional[str]:
        return pulumi.get(self, "path_to_credentials")

    @property
    @pulumi.getter
    def roleid(self) -> Optional[str]:
        return pulumi.get(self, "roleid")

    @property
    @pulumi.getter
    def secretid(self) -> Optional[str]:
        return pulumi.get(self, "secretid")

    @property
    @pulumi.getter
    def tenantid(self) -> Optional[str]:
        """
        Required for Azure Client Secret. No further documentation available
        """
        return pulumi.get(self, "tenantid")

    @property
    @pulumi.getter(name="tokenSecretName")
    def token_secret_name(self) -> Optional[str]:
        """
        No documentation available
        """
        return pulumi.get(self, "token_secret_name")

    @property
    @pulumi.getter(name="usernameSecretName")
    def username_secret_name(self) -> Optional[str]:
        """
        No documentation available
        """
        return pulumi.get(self, "username_secret_name")

    @property
    @pulumi.getter(name="vaultNamespace")
    def vault_namespace(self) -> Optional[str]:
        return pulumi.get(self, "vault_namespace")

    @property
    @pulumi.getter(name="vaultUrl")
    def vault_url(self) -> Optional[str]:
        """
        No documentation available
        """
        return pulumi.get(self, "vault_url")


@pulumi.output_type
class CustomAnomaliesDimension(dict):
    def __init__(__self__, *,
                 dimensions: Optional[Sequence['outputs.CustomAnomaliesDimensionDimension']] = None,
                 entities: Optional[Sequence['outputs.CustomAnomaliesDimensionEntity']] = None,
                 strings: Optional[Sequence['outputs.CustomAnomaliesDimensionString']] = None):
        """
        :param Sequence['CustomAnomaliesDimensionDimensionArgs'] dimensions: A generic definition for a filter
        :param Sequence['CustomAnomaliesDimensionEntityArgs'] entities: A filter for the metrics entity dimensions
        :param Sequence['CustomAnomaliesDimensionStringArgs'] strings: A filter for the metrics string dimensions
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.CustomAnomaliesDimensionDimension']]:
        """
        A generic definition for a filter
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.CustomAnomaliesDimensionEntity']]:
        """
        A filter for the metrics entity dimensions
        """
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence['outputs.CustomAnomaliesDimensionString']]:
        """
        A filter for the metrics string dimensions
        """
        return pulumi.get(self, "strings")


@pulumi.output_type
class CustomAnomaliesDimensionDimension(dict):
    def __init__(__self__, *,
                 type: str,
                 index: Optional[int] = None,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str type: Defines the actual set of fields depending on the value
        :param int index: No documentation available
        :param str key: The dimensions key on the metric
        :param str name: No documentation available
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "type", type)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines the actual set of fields depending on the value
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def index(self) -> Optional[int]:
        """
        No documentation available
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The dimensions key on the metric
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        No documentation available
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesDimensionEntity(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesDimensionEntityFilter',
                 key: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param 'CustomAnomaliesDimensionEntityFilterArgs' filter: A filter for a string value based on the given operator
        :param str key: The dimensions key on the metric
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesDimensionEntityFilter':
        """
        A filter for a string value based on the given operator
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The dimensions key on the metric
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesDimensionEntityFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        """
        :param str operator: The operator to match on
        :param str value: The value to match on
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator to match on
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to match on
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesDimensionString(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesDimensionStringFilter',
                 index: Optional[int] = None,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param 'CustomAnomaliesDimensionStringFilterArgs' filter: A filter for a string value based on the given operator
        :param int index: No documentation available
        :param str key: The dimensions key on the metric
        :param str name: No documentation available
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesDimensionStringFilter':
        """
        A filter for a string value based on the given operator
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def index(self) -> Optional[int]:
        """
        No documentation available
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The dimensions key on the metric
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        No documentation available
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesDimensionStringFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        """
        :param str operator: The operator to match on
        :param str value: The value to match on
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator to match on
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to match on
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDeviceGroupNames":
            suggest = "custom_device_group_names"
        elif key == "hostGroupNames":
            suggest = "host_group_names"
        elif key == "hostNames":
            suggest = "host_names"
        elif key == "managementZones":
            suggest = "management_zones"
        elif key == "processGroupIds":
            suggest = "process_group_ids"
        elif key == "processGroupNames":
            suggest = "process_group_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAnomaliesScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAnomaliesScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAnomaliesScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_device_group_names: Optional[Sequence['outputs.CustomAnomaliesScopeCustomDeviceGroupName']] = None,
                 entities: Optional[Sequence['outputs.CustomAnomaliesScopeEntity']] = None,
                 host_group_names: Optional[Sequence['outputs.CustomAnomaliesScopeHostGroupName']] = None,
                 host_names: Optional[Sequence['outputs.CustomAnomaliesScopeHostName']] = None,
                 management_zones: Optional[Sequence['outputs.CustomAnomaliesScopeManagementZone']] = None,
                 names: Optional[Sequence['outputs.CustomAnomaliesScopeName']] = None,
                 process_group_ids: Optional[Sequence['outputs.CustomAnomaliesScopeProcessGroupId']] = None,
                 process_group_names: Optional[Sequence['outputs.CustomAnomaliesScopeProcessGroupName']] = None,
                 scopes: Optional[Sequence['outputs.CustomAnomaliesScopeScope']] = None,
                 tags: Optional[Sequence['outputs.CustomAnomaliesScopeTag']] = None):
        """
        :param Sequence['CustomAnomaliesScopeCustomDeviceGroupNameArgs'] custom_device_group_names: A scope filter for the related custom device group name
        :param Sequence['CustomAnomaliesScopeEntityArgs'] entities: A scope filter for a monitored entity identifier
        :param Sequence['CustomAnomaliesScopeHostGroupNameArgs'] host_group_names: A scope filter for the related host group name
        :param Sequence['CustomAnomaliesScopeHostNameArgs'] host_names: A scope filter for the related host name
        :param Sequence['CustomAnomaliesScopeManagementZoneArgs'] management_zones: A scope filter for a management zone identifier
        :param Sequence['CustomAnomaliesScopeNameArgs'] names: A scope filter for a monitored entity name
        :param Sequence['CustomAnomaliesScopeProcessGroupIdArgs'] process_group_ids: A scope filter for a process group identifier
        :param Sequence['CustomAnomaliesScopeProcessGroupNameArgs'] process_group_names: A scope filter for the related process group name
        :param Sequence['CustomAnomaliesScopeScopeArgs'] scopes: A generic scope filter
        :param Sequence['CustomAnomaliesScopeTagArgs'] tags: A scope filter for tags on entities
        """
        if custom_device_group_names is not None:
            pulumi.set(__self__, "custom_device_group_names", custom_device_group_names)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if host_group_names is not None:
            pulumi.set(__self__, "host_group_names", host_group_names)
        if host_names is not None:
            pulumi.set(__self__, "host_names", host_names)
        if management_zones is not None:
            pulumi.set(__self__, "management_zones", management_zones)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if process_group_ids is not None:
            pulumi.set(__self__, "process_group_ids", process_group_ids)
        if process_group_names is not None:
            pulumi.set(__self__, "process_group_names", process_group_names)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="customDeviceGroupNames")
    def custom_device_group_names(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeCustomDeviceGroupName']]:
        """
        A scope filter for the related custom device group name
        """
        return pulumi.get(self, "custom_device_group_names")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeEntity']]:
        """
        A scope filter for a monitored entity identifier
        """
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="hostGroupNames")
    def host_group_names(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeHostGroupName']]:
        """
        A scope filter for the related host group name
        """
        return pulumi.get(self, "host_group_names")

    @property
    @pulumi.getter(name="hostNames")
    def host_names(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeHostName']]:
        """
        A scope filter for the related host name
        """
        return pulumi.get(self, "host_names")

    @property
    @pulumi.getter(name="managementZones")
    def management_zones(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeManagementZone']]:
        """
        A scope filter for a management zone identifier
        """
        return pulumi.get(self, "management_zones")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeName']]:
        """
        A scope filter for a monitored entity name
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter(name="processGroupIds")
    def process_group_ids(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeProcessGroupId']]:
        """
        A scope filter for a process group identifier
        """
        return pulumi.get(self, "process_group_ids")

    @property
    @pulumi.getter(name="processGroupNames")
    def process_group_names(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeProcessGroupName']]:
        """
        A scope filter for the related process group name
        """
        return pulumi.get(self, "process_group_names")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeScope']]:
        """
        A generic scope filter
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeTag']]:
        """
        A scope filter for tags on entities
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CustomAnomaliesScopeCustomDeviceGroupName(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesScopeCustomDeviceGroupNameFilter',
                 unknowns: Optional[str] = None):
        """
        :param 'CustomAnomaliesScopeCustomDeviceGroupNameFilterArgs' filter: A filter for a string value based on the given operator
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesScopeCustomDeviceGroupNameFilter':
        """
        A filter for a string value based on the given operator
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeCustomDeviceGroupNameFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        """
        :param str operator: The operator to match on
        :param str value: The value to match on
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator to match on
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to match on
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesScopeEntity(dict):
    def __init__(__self__, *,
                 id: str,
                 unknowns: Optional[str] = None):
        """
        :param str id: The monitored entities id to match on
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "id", id)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The monitored entities id to match on
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeHostGroupName(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesScopeHostGroupNameFilter',
                 unknowns: Optional[str] = None):
        """
        :param 'CustomAnomaliesScopeHostGroupNameFilterArgs' filter: A filter for a string value based on the given operator
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesScopeHostGroupNameFilter':
        """
        A filter for a string value based on the given operator
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeHostGroupNameFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        """
        :param str operator: The operator to match on
        :param str value: The value to match on
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator to match on
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to match on
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesScopeHostName(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesScopeHostNameFilter',
                 unknowns: Optional[str] = None):
        """
        :param 'CustomAnomaliesScopeHostNameFilterArgs' filter: A filter for a string value based on the given operator
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesScopeHostNameFilter':
        """
        A filter for a string value based on the given operator
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeHostNameFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        """
        :param str operator: The operator to match on
        :param str value: The value to match on
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator to match on
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to match on
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesScopeManagementZone(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str id: The management zone id to match on
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The management zone id to match on
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeName(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesScopeNameFilter',
                 unknowns: Optional[str] = None):
        """
        :param 'CustomAnomaliesScopeNameFilterArgs' filter: A filter for a string value based on the given operator
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesScopeNameFilter':
        """
        A filter for a string value based on the given operator
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeNameFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        """
        :param str operator: The operator to match on
        :param str value: The value to match on
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator to match on
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to match on
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesScopeProcessGroupId(dict):
    def __init__(__self__, *,
                 id: str,
                 unknowns: Optional[str] = None):
        """
        :param str id: The process groups id to match on
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "id", id)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The process groups id to match on
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeProcessGroupName(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesScopeProcessGroupNameFilter',
                 unknowns: Optional[str] = None):
        """
        :param 'CustomAnomaliesScopeProcessGroupNameFilterArgs' filter: A filter for a string value based on the given operator
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesScopeProcessGroupNameFilter':
        """
        A filter for a string value based on the given operator
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeProcessGroupNameFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        """
        :param str operator: The operator to match on
        :param str value: The value to match on
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator to match on
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to match on
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesScopeScope(dict):
    def __init__(__self__, *,
                 type: str,
                 unknowns: Optional[str] = None):
        """
        :param str type: Defines the actual set of fields depending on the value
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines the actual set of fields depending on the value
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeTag(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesScopeTagFilter',
                 unknowns: Optional[str] = None):
        """
        :param 'CustomAnomaliesScopeTagFilterArgs' filter: A filter for a string value based on the given operator
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesScopeTagFilter':
        """
        A filter for a string value based on the given operator
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeTagFilter(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesStrategy(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.CustomAnomaliesStrategyAuto'] = None,
                 generics: Optional[Sequence['outputs.CustomAnomaliesStrategyGeneric']] = None,
                 static: Optional['outputs.CustomAnomaliesStrategyStatic'] = None):
        """
        :param 'CustomAnomaliesStrategyAutoArgs' auto: An auto-adaptive baseline strategy to detect anomalies within metrics that show a regular change over time, as the baseline is also updated automatically. An example is to detect an anomaly in the number of received network packets or within the number of user actions over time
        :param Sequence['CustomAnomaliesStrategyGenericArgs'] generics: A generic monitoring strategy
        :param 'CustomAnomaliesStrategyStaticArgs' static: A static threshold monitoring strategy to alert on hard limits within a given metric. An example is the violation of a critical memory limit
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if generics is not None:
            pulumi.set(__self__, "generics", generics)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.CustomAnomaliesStrategyAuto']:
        """
        An auto-adaptive baseline strategy to detect anomalies within metrics that show a regular change over time, as the baseline is also updated automatically. An example is to detect an anomaly in the number of received network packets or within the number of user actions over time
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def generics(self) -> Optional[Sequence['outputs.CustomAnomaliesStrategyGeneric']]:
        """
        A generic monitoring strategy
        """
        return pulumi.get(self, "generics")

    @property
    @pulumi.getter
    def static(self) -> Optional['outputs.CustomAnomaliesStrategyStatic']:
        """
        A static threshold monitoring strategy to alert on hard limits within a given metric. An example is the violation of a critical memory limit
        """
        return pulumi.get(self, "static")


@pulumi.output_type
class CustomAnomaliesStrategyAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertCondition":
            suggest = "alert_condition"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "signalFluctuations":
            suggest = "signal_fluctuations"
        elif key == "violatingSamples":
            suggest = "violating_samples"
        elif key == "alertingOnMissingData":
            suggest = "alerting_on_missing_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAnomaliesStrategyAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAnomaliesStrategyAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAnomaliesStrategyAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_condition: str,
                 dealerting_samples: int,
                 samples: int,
                 signal_fluctuations: float,
                 violating_samples: int,
                 alerting_on_missing_data: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str alert_condition: The condition for the **threshold** value check: `ABOVE` or `BELOW`
        :param int dealerting_samples: The number of one-minute samples within the evaluation window that must go back to normal to close the event
        :param int samples: The number of one-minute samples that form the sliding evaluation window
        :param float signal_fluctuations: Defines the factor of how many signal fluctuations are valid. Values above the baseline plus the signal fluctuation times the number of tolerated signal fluctuations are alerted
        :param int violating_samples: The number of one-minute samples within the evaluation window that must violate the threshold to trigger an event
        :param bool alerting_on_missing_data: If true, also one-minute samples without data are counted as violating samples
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "alert_condition", alert_condition)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "samples", samples)
        pulumi.set(__self__, "signal_fluctuations", signal_fluctuations)
        pulumi.set(__self__, "violating_samples", violating_samples)
        if alerting_on_missing_data is not None:
            pulumi.set(__self__, "alerting_on_missing_data", alerting_on_missing_data)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="alertCondition")
    def alert_condition(self) -> str:
        """
        The condition for the **threshold** value check: `ABOVE` or `BELOW`
        """
        return pulumi.get(self, "alert_condition")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        """
        The number of one-minute samples within the evaluation window that must go back to normal to close the event
        """
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter
    def samples(self) -> int:
        """
        The number of one-minute samples that form the sliding evaluation window
        """
        return pulumi.get(self, "samples")

    @property
    @pulumi.getter(name="signalFluctuations")
    def signal_fluctuations(self) -> float:
        """
        Defines the factor of how many signal fluctuations are valid. Values above the baseline plus the signal fluctuation times the number of tolerated signal fluctuations are alerted
        """
        return pulumi.get(self, "signal_fluctuations")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        The number of one-minute samples within the evaluation window that must violate the threshold to trigger an event
        """
        return pulumi.get(self, "violating_samples")

    @property
    @pulumi.getter(name="alertingOnMissingData")
    def alerting_on_missing_data(self) -> Optional[bool]:
        """
        If true, also one-minute samples without data are counted as violating samples
        """
        return pulumi.get(self, "alerting_on_missing_data")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesStrategyGeneric(dict):
    def __init__(__self__, *,
                 type: str,
                 unknowns: Optional[str] = None):
        """
        :param str type: Defines the actual set of fields depending on the value
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines the actual set of fields depending on the value
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesStrategyStatic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertCondition":
            suggest = "alert_condition"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingSamples":
            suggest = "violating_samples"
        elif key == "alertingOnMissingData":
            suggest = "alerting_on_missing_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAnomaliesStrategyStatic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAnomaliesStrategyStatic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAnomaliesStrategyStatic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_condition: str,
                 dealerting_samples: int,
                 samples: int,
                 threshold: float,
                 unit: str,
                 violating_samples: int,
                 alerting_on_missing_data: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str alert_condition: The condition for the **threshold** value check: `ABOVE` or `BELOW`
        :param int dealerting_samples: The number of one-minute samples within the evaluation window that must go back to normal to close the event
        :param int samples: The number of one-minute samples that form the sliding evaluation window
        :param float threshold: The value of the static threshold based on the specified unit
        :param str unit: The unit of the threshold, matching the metric definition
        :param int violating_samples: The number of one-minute samples within the evaluation window that must violate the threshold to trigger an event
        :param bool alerting_on_missing_data: If true, also one-minute samples without data are counted as violating samples
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "alert_condition", alert_condition)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "samples", samples)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "violating_samples", violating_samples)
        if alerting_on_missing_data is not None:
            pulumi.set(__self__, "alerting_on_missing_data", alerting_on_missing_data)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="alertCondition")
    def alert_condition(self) -> str:
        """
        The condition for the **threshold** value check: `ABOVE` or `BELOW`
        """
        return pulumi.get(self, "alert_condition")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        """
        The number of one-minute samples within the evaluation window that must go back to normal to close the event
        """
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter
    def samples(self) -> int:
        """
        The number of one-minute samples that form the sliding evaluation window
        """
        return pulumi.get(self, "samples")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        The value of the static threshold based on the specified unit
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        The unit of the threshold, matching the metric definition
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        The number of one-minute samples within the evaluation window that must violate the threshold to trigger an event
        """
        return pulumi.get(self, "violating_samples")

    @property
    @pulumi.getter(name="alertingOnMissingData")
    def alerting_on_missing_data(self) -> Optional[bool]:
        """
        If true, also one-minute samples without data are counted as violating samples
        """
        return pulumi.get(self, "alerting_on_missing_data")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAppAnomaliesErrorRateIncrease(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectionMode":
            suggest = "detection_mode"
        elif key == "errorRateIncreaseAuto":
            suggest = "error_rate_increase_auto"
        elif key == "errorRateIncreaseFixed":
            suggest = "error_rate_increase_fixed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesErrorRateIncrease. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesErrorRateIncrease.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesErrorRateIncrease.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 detection_mode: Optional[str] = None,
                 error_rate_increase_auto: Optional['outputs.CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto'] = None,
                 error_rate_increase_fixed: Optional['outputs.CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param str detection_mode: Possible Values: `Auto`, `Fixed`
        :param 'CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseAutoArgs' error_rate_increase_auto: Alert if the percentage of user actions affected by reported errors exceeds **both** the absolute threshold and the relative threshold
        :param 'CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixedArgs' error_rate_increase_fixed: Alert if the custom reported error rate threshold is exceeded during any 5-minute period
        """
        pulumi.set(__self__, "enabled", enabled)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if error_rate_increase_auto is not None:
            pulumi.set(__self__, "error_rate_increase_auto", error_rate_increase_auto)
        if error_rate_increase_fixed is not None:
            pulumi.set(__self__, "error_rate_increase_fixed", error_rate_increase_fixed)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Fixed`
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter(name="errorRateIncreaseAuto")
    def error_rate_increase_auto(self) -> Optional['outputs.CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto']:
        """
        Alert if the percentage of user actions affected by reported errors exceeds **both** the absolute threshold and the relative threshold
        """
        return pulumi.get(self, "error_rate_increase_auto")

    @property
    @pulumi.getter(name="errorRateIncreaseFixed")
    def error_rate_increase_fixed(self) -> Optional['outputs.CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed']:
        """
        Alert if the custom reported error rate threshold is exceeded during any 5-minute period
        """
        return pulumi.get(self, "error_rate_increase_fixed")


@pulumi.output_type
class CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdAbsolute":
            suggest = "threshold_absolute"
        elif key == "thresholdRelative":
            suggest = "threshold_relative"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 threshold_absolute: float,
                 threshold_relative: float):
        """
        :param float threshold_absolute: Absolute threshold
        :param float threshold_relative: Relative threshold
        """
        pulumi.set(__self__, "threshold_absolute", threshold_absolute)
        pulumi.set(__self__, "threshold_relative", threshold_relative)

    @property
    @pulumi.getter(name="thresholdAbsolute")
    def threshold_absolute(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "threshold_absolute")

    @property
    @pulumi.getter(name="thresholdRelative")
    def threshold_relative(self) -> float:
        """
        Relative threshold
        """
        return pulumi.get(self, "threshold_relative")


@pulumi.output_type
class CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdAbsolute":
            suggest = "threshold_absolute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sensitivity: str,
                 threshold_absolute: float):
        """
        :param str sensitivity: Possible Values: `Low`, `Medium`, `High`
        :param float threshold_absolute: Absolute threshold
        """
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold_absolute", threshold_absolute)

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        """
        Possible Values: `Low`, `Medium`, `High`
        """
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter(name="thresholdAbsolute")
    def threshold_absolute(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "threshold_absolute")


@pulumi.output_type
class CustomAppAnomaliesSlowUserActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectionMode":
            suggest = "detection_mode"
        elif key == "slowUserActionsAuto":
            suggest = "slow_user_actions_auto"
        elif key == "slowUserActionsFixed":
            suggest = "slow_user_actions_fixed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesSlowUserActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesSlowUserActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesSlowUserActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 detection_mode: Optional[str] = None,
                 slow_user_actions_auto: Optional['outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAuto'] = None,
                 slow_user_actions_fixed: Optional['outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixed'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param str detection_mode: Possible Values: `Auto`, `Fixed`
        :param 'CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoArgs' slow_user_actions_auto: no documentation available
        :param 'CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedArgs' slow_user_actions_fixed: no documentation available
        """
        pulumi.set(__self__, "enabled", enabled)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if slow_user_actions_auto is not None:
            pulumi.set(__self__, "slow_user_actions_auto", slow_user_actions_auto)
        if slow_user_actions_fixed is not None:
            pulumi.set(__self__, "slow_user_actions_fixed", slow_user_actions_fixed)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Fixed`
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter(name="slowUserActionsAuto")
    def slow_user_actions_auto(self) -> Optional['outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAuto']:
        """
        no documentation available
        """
        return pulumi.get(self, "slow_user_actions_auto")

    @property
    @pulumi.getter(name="slowUserActionsFixed")
    def slow_user_actions_fixed(self) -> Optional['outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixed']:
        """
        no documentation available
        """
        return pulumi.get(self, "slow_user_actions_fixed")


@pulumi.output_type
class CustomAppAnomaliesSlowUserActionsSlowUserActionsAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationAvoidOveralerting":
            suggest = "duration_avoid_overalerting"
        elif key == "durationThresholdAll":
            suggest = "duration_threshold_all"
        elif key == "durationThresholdSlowest":
            suggest = "duration_threshold_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesSlowUserActionsSlowUserActionsAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_avoid_overalerting: 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting',
                 duration_threshold_all: 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll',
                 duration_threshold_slowest: 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest'):
        """
        :param 'CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralertingArgs' duration_avoid_overalerting: To avoid over-alerting do not alert for low traffic applications with less than
        :param 'CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAllArgs' duration_threshold_all: Alert if the action duration of all user actions degrades beyond **both** the absolute and relative threshold:
        :param 'CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowestArgs' duration_threshold_slowest: Alert if the action duration of the slowest 10% of user actions degrades beyond **both** the absolute and relative threshold:
        """
        pulumi.set(__self__, "duration_avoid_overalerting", duration_avoid_overalerting)
        pulumi.set(__self__, "duration_threshold_all", duration_threshold_all)
        pulumi.set(__self__, "duration_threshold_slowest", duration_threshold_slowest)

    @property
    @pulumi.getter(name="durationAvoidOveralerting")
    def duration_avoid_overalerting(self) -> 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting':
        """
        To avoid over-alerting do not alert for low traffic applications with less than
        """
        return pulumi.get(self, "duration_avoid_overalerting")

    @property
    @pulumi.getter(name="durationThresholdAll")
    def duration_threshold_all(self) -> 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll':
        """
        Alert if the action duration of all user actions degrades beyond **both** the absolute and relative threshold:
        """
        return pulumi.get(self, "duration_threshold_all")

    @property
    @pulumi.getter(name="durationThresholdSlowest")
    def duration_threshold_slowest(self) -> 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest':
        """
        Alert if the action duration of the slowest 10% of user actions degrades beyond **both** the absolute and relative threshold:
        """
        return pulumi.get(self, "duration_threshold_slowest")


@pulumi.output_type
class CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minActionRate":
            suggest = "min_action_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_action_rate: int):
        """
        :param int min_action_rate: no documentation available
        """
        pulumi.set(__self__, "min_action_rate", min_action_rate)

    @property
    @pulumi.getter(name="minActionRate")
    def min_action_rate(self) -> int:
        """
        no documentation available
        """
        return pulumi.get(self, "min_action_rate")


@pulumi.output_type
class CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationThreshold":
            suggest = "duration_threshold"
        elif key == "slowdownPercentage":
            suggest = "slowdown_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_threshold: float,
                 slowdown_percentage: float):
        """
        :param float duration_threshold: Absolute threshold
        :param float slowdown_percentage: Relative threshold
        """
        pulumi.set(__self__, "duration_threshold", duration_threshold)
        pulumi.set(__self__, "slowdown_percentage", slowdown_percentage)

    @property
    @pulumi.getter(name="durationThreshold")
    def duration_threshold(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "duration_threshold")

    @property
    @pulumi.getter(name="slowdownPercentage")
    def slowdown_percentage(self) -> float:
        """
        Relative threshold
        """
        return pulumi.get(self, "slowdown_percentage")


@pulumi.output_type
class CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationThreshold":
            suggest = "duration_threshold"
        elif key == "slowdownPercentage":
            suggest = "slowdown_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_threshold: float,
                 slowdown_percentage: float):
        """
        :param float duration_threshold: Absolute threshold
        :param float slowdown_percentage: Relative threshold
        """
        pulumi.set(__self__, "duration_threshold", duration_threshold)
        pulumi.set(__self__, "slowdown_percentage", slowdown_percentage)

    @property
    @pulumi.getter(name="durationThreshold")
    def duration_threshold(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "duration_threshold")

    @property
    @pulumi.getter(name="slowdownPercentage")
    def slowdown_percentage(self) -> float:
        """
        Relative threshold
        """
        return pulumi.get(self, "slowdown_percentage")


@pulumi.output_type
class CustomAppAnomaliesSlowUserActionsSlowUserActionsFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationAvoidOveralerting":
            suggest = "duration_avoid_overalerting"
        elif key == "durationThresholdAllFixed":
            suggest = "duration_threshold_all_fixed"
        elif key == "durationThresholdSlowest":
            suggest = "duration_threshold_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesSlowUserActionsSlowUserActionsFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_avoid_overalerting: 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting',
                 duration_threshold_all_fixed: 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed',
                 duration_threshold_slowest: 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest',
                 sensitivity: str):
        """
        :param 'CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralertingArgs' duration_avoid_overalerting: To avoid over-alerting do not alert for low traffic applications with less than
        :param 'CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixedArgs' duration_threshold_all_fixed: Alert if the action duration of all user actions degrades beyond the absolute threshold:
        :param 'CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowestArgs' duration_threshold_slowest: Alert if the action duration of the slowest 10% of user actions degrades beyond the absolute threshold:
        :param str sensitivity: Possible Values: `Medium`, `High`, `Low`
        """
        pulumi.set(__self__, "duration_avoid_overalerting", duration_avoid_overalerting)
        pulumi.set(__self__, "duration_threshold_all_fixed", duration_threshold_all_fixed)
        pulumi.set(__self__, "duration_threshold_slowest", duration_threshold_slowest)
        pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="durationAvoidOveralerting")
    def duration_avoid_overalerting(self) -> 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting':
        """
        To avoid over-alerting do not alert for low traffic applications with less than
        """
        return pulumi.get(self, "duration_avoid_overalerting")

    @property
    @pulumi.getter(name="durationThresholdAllFixed")
    def duration_threshold_all_fixed(self) -> 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed':
        """
        Alert if the action duration of all user actions degrades beyond the absolute threshold:
        """
        return pulumi.get(self, "duration_threshold_all_fixed")

    @property
    @pulumi.getter(name="durationThresholdSlowest")
    def duration_threshold_slowest(self) -> 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest':
        """
        Alert if the action duration of the slowest 10% of user actions degrades beyond the absolute threshold:
        """
        return pulumi.get(self, "duration_threshold_slowest")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        """
        Possible Values: `Medium`, `High`, `Low`
        """
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minActionRate":
            suggest = "min_action_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_action_rate: int):
        """
        :param int min_action_rate: no documentation available
        """
        pulumi.set(__self__, "min_action_rate", min_action_rate)

    @property
    @pulumi.getter(name="minActionRate")
    def min_action_rate(self) -> int:
        """
        no documentation available
        """
        return pulumi.get(self, "min_action_rate")


@pulumi.output_type
class CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationThreshold":
            suggest = "duration_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_threshold: float):
        """
        :param float duration_threshold: Absolute threshold
        """
        pulumi.set(__self__, "duration_threshold", duration_threshold)

    @property
    @pulumi.getter(name="durationThreshold")
    def duration_threshold(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "duration_threshold")


@pulumi.output_type
class CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationThreshold":
            suggest = "duration_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_threshold: float):
        """
        :param float duration_threshold: Absolute threshold
        """
        pulumi.set(__self__, "duration_threshold", duration_threshold)

    @property
    @pulumi.getter(name="durationThreshold")
    def duration_threshold(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "duration_threshold")


@pulumi.output_type
class CustomAppAnomaliesUnexpectedHighLoad(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdPercentage":
            suggest = "threshold_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesUnexpectedHighLoad. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesUnexpectedHighLoad.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesUnexpectedHighLoad.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 threshold_percentage: Optional[float] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param float threshold_percentage: Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic spikes within your application.
        """
        pulumi.set(__self__, "enabled", enabled)
        if threshold_percentage is not None:
            pulumi.set(__self__, "threshold_percentage", threshold_percentage)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="thresholdPercentage")
    def threshold_percentage(self) -> Optional[float]:
        """
        Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic spikes within your application.
        """
        return pulumi.get(self, "threshold_percentage")


@pulumi.output_type
class CustomAppAnomaliesUnexpectedLowLoad(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdPercentage":
            suggest = "threshold_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesUnexpectedLowLoad. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesUnexpectedLowLoad.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesUnexpectedLowLoad.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 threshold_percentage: Optional[float] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param float threshold_percentage: Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic drops within your application.
        """
        pulumi.set(__self__, "enabled", enabled)
        if threshold_percentage is not None:
            pulumi.set(__self__, "threshold_percentage", threshold_percentage)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="thresholdPercentage")
    def threshold_percentage(self) -> Optional[float]:
        """
        Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic drops within your application.
        """
        return pulumi.get(self, "threshold_percentage")


@pulumi.output_type
class CustomAppCrashRateCrashRateIncrease(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crashRateIncreaseAuto":
            suggest = "crash_rate_increase_auto"
        elif key == "crashRateIncreaseFixed":
            suggest = "crash_rate_increase_fixed"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppCrashRateCrashRateIncrease. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppCrashRateCrashRateIncrease.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppCrashRateCrashRateIncrease.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 crash_rate_increase_auto: Optional['outputs.CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto'] = None,
                 crash_rate_increase_fixed: Optional['outputs.CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseAutoArgs' crash_rate_increase_auto: Alert crash rate increases when auto-detected baseline is exceeded by a certain number of users
        :param 'CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseFixedArgs' crash_rate_increase_fixed: Alert crash rate increases when the defined threshold is exceeded by a certain number of users
        :param str detection_mode: Possible Values: `Auto`, `Fixed`
        """
        pulumi.set(__self__, "enabled", enabled)
        if crash_rate_increase_auto is not None:
            pulumi.set(__self__, "crash_rate_increase_auto", crash_rate_increase_auto)
        if crash_rate_increase_fixed is not None:
            pulumi.set(__self__, "crash_rate_increase_fixed", crash_rate_increase_fixed)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="crashRateIncreaseAuto")
    def crash_rate_increase_auto(self) -> Optional['outputs.CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto']:
        """
        Alert crash rate increases when auto-detected baseline is exceeded by a certain number of users
        """
        return pulumi.get(self, "crash_rate_increase_auto")

    @property
    @pulumi.getter(name="crashRateIncreaseFixed")
    def crash_rate_increase_fixed(self) -> Optional['outputs.CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed']:
        """
        Alert crash rate increases when the defined threshold is exceeded by a certain number of users
        """
        return pulumi.get(self, "crash_rate_increase_fixed")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Fixed`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baselineViolationPercentage":
            suggest = "baseline_violation_percentage"
        elif key == "concurrentUsers":
            suggest = "concurrent_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 baseline_violation_percentage: float,
                 concurrent_users: float,
                 sensitivity: str):
        """
        :param float baseline_violation_percentage: Dynatrace learns the typical crash rate for all app versions and will create an alert if the baseline is violated by more than a specified threshold. Analysis happens based on a sliding window of 10 minutes.
        :param float concurrent_users: Amount of users
        :param str sensitivity: Possible Values: `Low`, `Medium`, `High`
        """
        pulumi.set(__self__, "baseline_violation_percentage", baseline_violation_percentage)
        pulumi.set(__self__, "concurrent_users", concurrent_users)
        pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="baselineViolationPercentage")
    def baseline_violation_percentage(self) -> float:
        """
        Dynatrace learns the typical crash rate for all app versions and will create an alert if the baseline is violated by more than a specified threshold. Analysis happens based on a sliding window of 10 minutes.
        """
        return pulumi.get(self, "baseline_violation_percentage")

    @property
    @pulumi.getter(name="concurrentUsers")
    def concurrent_users(self) -> float:
        """
        Amount of users
        """
        return pulumi.get(self, "concurrent_users")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        """
        Possible Values: `Low`, `Medium`, `High`
        """
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "absoluteCrashRate":
            suggest = "absolute_crash_rate"
        elif key == "concurrentUsers":
            suggest = "concurrent_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 absolute_crash_rate: float,
                 concurrent_users: int):
        """
        :param float absolute_crash_rate: Absolute threshold
        :param int concurrent_users: Amount of users
        """
        pulumi.set(__self__, "absolute_crash_rate", absolute_crash_rate)
        pulumi.set(__self__, "concurrent_users", concurrent_users)

    @property
    @pulumi.getter(name="absoluteCrashRate")
    def absolute_crash_rate(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "absolute_crash_rate")

    @property
    @pulumi.getter(name="concurrentUsers")
    def concurrent_users(self) -> int:
        """
        Amount of users
        """
        return pulumi.get(self, "concurrent_users")


@pulumi.output_type
class CustomAppEnablementRum(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costAndTrafficControl":
            suggest = "cost_and_traffic_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppEnablementRum. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppEnablementRum.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppEnablementRum.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_and_traffic_control: int,
                 enabled: bool):
        """
        :param int cost_and_traffic_control: (Field has overlap with `MobileApplication`) Percentage of user sessions captured and analyzed. By default, Dynatrace captures all user actions and user sessions for analysis. This approach ensures complete insight into your application’s performance and customer experience. You can optionally reduce the granularity of user-action and user-session analysis by capturing a lower percentage of user sessions. While this approach can reduce monitoring costs, it also results in lower visibility into how your customers are using your applications. For example, a setting of 10% results in Dynatrace analyzing only every tenth user session.
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        """
        pulumi.set(__self__, "cost_and_traffic_control", cost_and_traffic_control)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="costAndTrafficControl")
    def cost_and_traffic_control(self) -> int:
        """
        (Field has overlap with `MobileApplication`) Percentage of user sessions captured and analyzed. By default, Dynatrace captures all user actions and user sessions for analysis. This approach ensures complete insight into your application’s performance and customer experience. You can optionally reduce the granularity of user-action and user-session analysis by capturing a lower percentage of user sessions. While this approach can reduce monitoring costs, it also results in lower visibility into how your customers are using your applications. For example, a setting of 10% results in Dynatrace analyzing only every tenth user session.
        """
        return pulumi.get(self, "cost_and_traffic_control")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class CustomServiceRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "class":
            suggest = "class_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomServiceRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomServiceRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomServiceRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 methods: Sequence['outputs.CustomServiceRuleMethod'],
                 annotations: Optional[Sequence[str]] = None,
                 class_: Optional['outputs.CustomServiceRuleClass'] = None,
                 file: Optional['outputs.CustomServiceRuleFile'] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool enabled: Rule enabled/disabled
        :param Sequence['CustomServiceRuleMethodArgs'] methods: methods to instrument
        :param Sequence[str] annotations: Additional annotations filter of the rule. Only classes where all listed annotations are available in the class itself or any of its superclasses are instrumented. Not applicable to PHP
        :param 'CustomServiceRuleClassArgs' class_: The fully qualified class or interface to instrument (or a substring if matching to a string). Required for Java and .NET custom services. Not applicable to PHP
        :param 'CustomServiceRuleFileArgs' file: The PHP file containing the class or methods to instrument. Required for PHP custom service. Not applicable to Java and .NET
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "methods", methods)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Rule enabled/disabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def methods(self) -> Sequence['outputs.CustomServiceRuleMethod']:
        """
        methods to instrument
        """
        return pulumi.get(self, "methods")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[str]]:
        """
        Additional annotations filter of the rule. Only classes where all listed annotations are available in the class itself or any of its superclasses are instrumented. Not applicable to PHP
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional['outputs.CustomServiceRuleClass']:
        """
        The fully qualified class or interface to instrument (or a substring if matching to a string). Required for Java and .NET custom services. Not applicable to PHP
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.CustomServiceRuleFile']:
        """
        The PHP file containing the class or methods to instrument. Required for PHP custom service. Not applicable to Java and .NET
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomServiceRuleClass(dict):
    def __init__(__self__, *,
                 name: str,
                 match: Optional[str] = None):
        """
        :param str name: The full name of the class / the name to match the class name with
        :param str match: Matcher applying to the class name (ENDS*WITH, EQUALS or STARTS*WITH). STARTS_WITH can only be used if there is at least one annotation defined. Default value is EQUALS
        """
        pulumi.set(__self__, "name", name)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The full name of the class / the name to match the class name with
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        Matcher applying to the class name (ENDS*WITH, EQUALS or STARTS*WITH). STARTS_WITH can only be used if there is at least one annotation defined. Default value is EQUALS
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class CustomServiceRuleFile(dict):
    def __init__(__self__, *,
                 name: str,
                 match: Optional[str] = None):
        """
        :param str name: The full name of the file / the name to match the file name with
        :param str match: Matcher applying to the file name (ENDS*WITH, EQUALS or STARTS*WITH). Default value is ENDS_WITH (if applicable)
        """
        pulumi.set(__self__, "name", name)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The full name of the file / the name to match the file name with
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        Matcher applying to the file name (ENDS*WITH, EQUALS or STARTS*WITH). Default value is ENDS_WITH (if applicable)
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class CustomServiceRuleMethod(dict):
    def __init__(__self__, *,
                 name: str,
                 arguments: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 modifiers: Optional[Sequence[str]] = None,
                 returns: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 visibility: Optional[str] = None):
        """
        :param str name: The method to instrument
        :param Sequence[str] arguments: Fully qualified types of argument the method expects
        :param str id: The ID of the method rule
        :param Sequence[str] modifiers: The modifiers of the method rule. Possible values are `ABSTRACT`, `EXTERN`, `FINAL`, `NATIVE` and `STATIC`
        :param str returns: Fully qualified type the method returns
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str visibility: The visibility of the method rule. Possible values are `INTERNAL`, `PACKAGE_PROTECTED`, `PRIVATE`, `PROTECTED` and `PUBLIC`
        """
        pulumi.set(__self__, "name", name)
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if modifiers is not None:
            pulumi.set(__self__, "modifiers", modifiers)
        if returns is not None:
            pulumi.set(__self__, "returns", returns)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The method to instrument
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def arguments(self) -> Optional[Sequence[str]]:
        """
        Fully qualified types of argument the method expects
        """
        return pulumi.get(self, "arguments")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the method rule
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def modifiers(self) -> Optional[Sequence[str]]:
        """
        The modifiers of the method rule. Possible values are `ABSTRACT`, `EXTERN`, `FINAL`, `NATIVE` and `STATIC`
        """
        return pulumi.get(self, "modifiers")

    @property
    @pulumi.getter
    def returns(self) -> Optional[str]:
        """
        Fully qualified type the method returns
        """
        return pulumi.get(self, "returns")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def visibility(self) -> Optional[str]:
        """
        The visibility of the method rule. Possible values are `INTERNAL`, `PACKAGE_PROTECTED`, `PRIVATE`, `PROTECTED` and `PUBLIC`
        """
        return pulumi.get(self, "visibility")


@pulumi.output_type
class CustomTagsTags(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.CustomTagsTagsFilter']] = None):
        """
        :param Sequence['CustomTagsTagsFilterArgs'] filters: A Tag Filter
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.CustomTagsTagsFilter']]:
        """
        A Tag Filter
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class CustomTagsTagsFilter(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardDashboardMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consistentColors":
            suggest = "consistent_colors"
        elif key == "dynamicFilters":
            suggest = "dynamic_filters"
        elif key == "sharingDetails":
            suggest = "sharing_details"
        elif key == "tilesNameSize":
            suggest = "tiles_name_size"
        elif key == "validFilterKeys":
            suggest = "valid_filter_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 owner: str,
                 consistent_colors: Optional[bool] = None,
                 dynamic_filters: Optional['outputs.DashboardDashboardMetadataDynamicFilters'] = None,
                 filter: Optional['outputs.DashboardDashboardMetadataFilter'] = None,
                 preset: Optional[bool] = None,
                 shared: Optional[bool] = None,
                 sharing_details: Optional['outputs.DashboardDashboardMetadataSharingDetails'] = None,
                 tags: Optional[Sequence[str]] = None,
                 tiles_name_size: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 valid_filter_keys: Optional[Sequence[str]] = None):
        """
        :param str name: the name of the dashboard
        :param str owner: the owner of the dashboard
        :param bool consistent_colors: The tile uses consistent colors when rendering its content
        :param 'DashboardDashboardMetadataDynamicFiltersArgs' dynamic_filters: Dashboard filter configuration of a dashboard
        :param 'DashboardDashboardMetadataFilterArgs' filter: Global filter Settings for the Dashboard
        :param bool preset: the dashboard is a preset (`true`) or not (`false`). Default is `false`.
        :param bool shared: the dashboard is shared (`true`) or private (`false`)
        :param 'DashboardDashboardMetadataSharingDetailsArgs' sharing_details: represents sharing configuration of a dashboard
        :param Sequence[str] tags: a set of tags assigned to the dashboard
        :param str tiles_name_size: No documentation available
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param Sequence[str] valid_filter_keys: a set of all possible global dashboard filters that can be applied to dashboard
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner", owner)
        if consistent_colors is not None:
            pulumi.set(__self__, "consistent_colors", consistent_colors)
        if dynamic_filters is not None:
            pulumi.set(__self__, "dynamic_filters", dynamic_filters)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)
        if shared is not None:
            pulumi.set(__self__, "shared", shared)
        if sharing_details is not None:
            pulumi.set(__self__, "sharing_details", sharing_details)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tiles_name_size is not None:
            pulumi.set(__self__, "tiles_name_size", tiles_name_size)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if valid_filter_keys is not None:
            pulumi.set(__self__, "valid_filter_keys", valid_filter_keys)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        the name of the dashboard
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def owner(self) -> str:
        """
        the owner of the dashboard
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="consistentColors")
    def consistent_colors(self) -> Optional[bool]:
        """
        The tile uses consistent colors when rendering its content
        """
        return pulumi.get(self, "consistent_colors")

    @property
    @pulumi.getter(name="dynamicFilters")
    def dynamic_filters(self) -> Optional['outputs.DashboardDashboardMetadataDynamicFilters']:
        """
        Dashboard filter configuration of a dashboard
        """
        return pulumi.get(self, "dynamic_filters")

    @property
    @pulumi.getter
    def filter(self) -> Optional['outputs.DashboardDashboardMetadataFilter']:
        """
        Global filter Settings for the Dashboard
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def preset(self) -> Optional[bool]:
        """
        the dashboard is a preset (`true`) or not (`false`). Default is `false`.
        """
        return pulumi.get(self, "preset")

    @property
    @pulumi.getter
    @_utilities.deprecated("""Please use the resource `DashboardSharing` to configure share settings""")
    def shared(self) -> Optional[bool]:
        """
        the dashboard is shared (`true`) or private (`false`)
        """
        return pulumi.get(self, "shared")

    @property
    @pulumi.getter(name="sharingDetails")
    @_utilities.deprecated("""Please use the resource `DashboardSharing` to configure share settings""")
    def sharing_details(self) -> Optional['outputs.DashboardDashboardMetadataSharingDetails']:
        """
        represents sharing configuration of a dashboard
        """
        return pulumi.get(self, "sharing_details")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        a set of tags assigned to the dashboard
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tilesNameSize")
    def tiles_name_size(self) -> Optional[str]:
        """
        No documentation available
        """
        return pulumi.get(self, "tiles_name_size")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="validFilterKeys")
    def valid_filter_keys(self) -> Optional[Sequence[str]]:
        """
        a set of all possible global dashboard filters that can be applied to dashboard
        """
        return pulumi.get(self, "valid_filter_keys")


@pulumi.output_type
class DashboardDashboardMetadataDynamicFilters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "genericTagFilters":
            suggest = "generic_tag_filters"
        elif key == "tagSuggestionTypes":
            suggest = "tag_suggestion_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardMetadataDynamicFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardMetadataDynamicFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardMetadataDynamicFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Sequence[str],
                 generic_tag_filters: Optional['outputs.DashboardDashboardMetadataDynamicFiltersGenericTagFilters'] = None,
                 tag_suggestion_types: Optional[Sequence[str]] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence[str] filters: A set of all possible global dashboard filters that can be applied to a dashboard
        :param 'DashboardDashboardMetadataDynamicFiltersGenericTagFiltersArgs' generic_tag_filters: A set of generic tag filters that can be applied to a dashboard
        :param Sequence[str] tag_suggestion_types: A set of entities applied for tag filter suggestions. You can fetch the list of possible values with the [GET all entity types](https://dt-url.net/dw03s7h)request. 
               
               Only applicable if the **filters** set includes `TAG_KEY:<tagname>`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filters", filters)
        if generic_tag_filters is not None:
            pulumi.set(__self__, "generic_tag_filters", generic_tag_filters)
        if tag_suggestion_types is not None:
            pulumi.set(__self__, "tag_suggestion_types", tag_suggestion_types)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filters(self) -> Sequence[str]:
        """
        A set of all possible global dashboard filters that can be applied to a dashboard
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="genericTagFilters")
    def generic_tag_filters(self) -> Optional['outputs.DashboardDashboardMetadataDynamicFiltersGenericTagFilters']:
        """
        A set of generic tag filters that can be applied to a dashboard
        """
        return pulumi.get(self, "generic_tag_filters")

    @property
    @pulumi.getter(name="tagSuggestionTypes")
    def tag_suggestion_types(self) -> Optional[Sequence[str]]:
        """
        A set of entities applied for tag filter suggestions. You can fetch the list of possible values with the [GET all entity types](https://dt-url.net/dw03s7h)request. 

        Only applicable if the **filters** set includes `TAG_KEY:<tagname>`
        """
        return pulumi.get(self, "tag_suggestion_types")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardDashboardMetadataDynamicFiltersGenericTagFilters(dict):
    def __init__(__self__, *,
                 filters: Sequence['outputs.DashboardDashboardMetadataDynamicFiltersGenericTagFiltersFilter']):
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.DashboardDashboardMetadataDynamicFiltersGenericTagFiltersFilter']:
        return pulumi.get(self, "filters")


@pulumi.output_type
class DashboardDashboardMetadataDynamicFiltersGenericTagFiltersFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityTypes":
            suggest = "entity_types"
        elif key == "suggestionsFromEntityType":
            suggest = "suggestions_from_entity_type"
        elif key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardMetadataDynamicFiltersGenericTagFiltersFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardMetadataDynamicFiltersGenericTagFiltersFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardMetadataDynamicFiltersGenericTagFiltersFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_types: Sequence[str],
                 name: Optional[str] = None,
                 suggestions_from_entity_type: Optional[str] = None,
                 tag_key: Optional[str] = None):
        """
        :param Sequence[str] entity_types: Entity types affected by tag
        :param str name: The display name used to identify this generic filter
        :param str suggestions_from_entity_type: The entity type for which the suggestions should be provided.
        :param str tag_key: The tag key for this filter
        """
        pulumi.set(__self__, "entity_types", entity_types)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if suggestions_from_entity_type is not None:
            pulumi.set(__self__, "suggestions_from_entity_type", suggestions_from_entity_type)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)

    @property
    @pulumi.getter(name="entityTypes")
    def entity_types(self) -> Sequence[str]:
        """
        Entity types affected by tag
        """
        return pulumi.get(self, "entity_types")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The display name used to identify this generic filter
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="suggestionsFromEntityType")
    def suggestions_from_entity_type(self) -> Optional[str]:
        """
        The entity type for which the suggestions should be provided.
        """
        return pulumi.get(self, "suggestions_from_entity_type")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[str]:
        """
        The tag key for this filter
        """
        return pulumi.get(self, "tag_key")


@pulumi.output_type
class DashboardDashboardMetadataFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZones":
            suggest = "management_zones"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardMetadataFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardMetadataFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardMetadataFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zones: Optional[Sequence['outputs.DashboardDashboardMetadataFilterManagementZone']] = None,
                 timeframe: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence['DashboardDashboardMetadataFilterManagementZoneArgs'] management_zones: the management zone this dashboard applies to
        :param str timeframe: the default timeframe of the dashboard
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if management_zones is not None:
            pulumi.set(__self__, "management_zones", management_zones)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZones")
    def management_zones(self) -> Optional[Sequence['outputs.DashboardDashboardMetadataFilterManagementZone']]:
        """
        the management zone this dashboard applies to
        """
        return pulumi.get(self, "management_zones")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        the default timeframe of the dashboard
        """
        return pulumi.get(self, "timeframe")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardDashboardMetadataFilterManagementZone(dict):
    def __init__(__self__, *,
                 id: str,
                 description: Optional[str] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str id: the ID of the Dynatrace entity
        :param str description: a short description of the Dynatrace entity
        :param str name: the name of the Dynatrace entity
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "id", id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the ID of the Dynatrace entity
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        a short description of the Dynatrace entity
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        the name of the Dynatrace entity
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardDashboardMetadataSharingDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkShared":
            suggest = "link_shared"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardMetadataSharingDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardMetadataSharingDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardMetadataSharingDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 link_shared: Optional[bool] = None,
                 published: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool link_shared: If `true`, the dashboard is shared via link and authenticated users with the link can view
        :param bool published: If `true`, the dashboard is published to anyone on this environment
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if link_shared is not None:
            pulumi.set(__self__, "link_shared", link_shared)
        if published is not None:
            pulumi.set(__self__, "published", published)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="linkShared")
    def link_shared(self) -> Optional[bool]:
        """
        If `true`, the dashboard is shared via link and authenticated users with the link can view
        """
        return pulumi.get(self, "link_shared")

    @property
    @pulumi.getter
    def published(self) -> Optional[bool]:
        """
        If `true`, the dashboard is published to anyone on this environment
        """
        return pulumi.get(self, "published")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "configurationVersions":
            suggest = "configuration_versions"
        elif key == "currentConfigurationVersions":
            suggest = "current_configuration_versions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_version: Optional[str] = None,
                 configuration_versions: Optional[Sequence[int]] = None,
                 current_configuration_versions: Optional[Sequence[str]] = None):
        """
        :param str cluster_version: Dynatrace server version
        :param Sequence[int] configuration_versions: A Sorted list of the version numbers of the configuration
        :param Sequence[str] current_configuration_versions: A Sorted list of the version numbers of the configuration
        """
        if cluster_version is not None:
            pulumi.set(__self__, "cluster_version", cluster_version)
        if configuration_versions is not None:
            pulumi.set(__self__, "configuration_versions", configuration_versions)
        if current_configuration_versions is not None:
            pulumi.set(__self__, "current_configuration_versions", current_configuration_versions)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> Optional[str]:
        """
        Dynatrace server version
        """
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter(name="configurationVersions")
    def configuration_versions(self) -> Optional[Sequence[int]]:
        """
        A Sorted list of the version numbers of the configuration
        """
        return pulumi.get(self, "configuration_versions")

    @property
    @pulumi.getter(name="currentConfigurationVersions")
    def current_configuration_versions(self) -> Optional[Sequence[str]]:
        """
        A Sorted list of the version numbers of the configuration
        """
        return pulumi.get(self, "current_configuration_versions")


@pulumi.output_type
class DashboardSharingPermissions(dict):
    def __init__(__self__, *,
                 permissions: Optional[Sequence['outputs.DashboardSharingPermissionsPermission']] = None):
        """
        :param Sequence['DashboardSharingPermissionsPermissionArgs'] permissions: Access permissions of the dashboard
        """
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['outputs.DashboardSharingPermissionsPermission']]:
        """
        Access permissions of the dashboard
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class DashboardSharingPermissionsPermission(dict):
    def __init__(__self__, *,
                 level: str,
                 type: str,
                 id: Optional[str] = None):
        """
        :param str level: The level of the permission:
        :param str type: The type of the permission:
        :param str id: The ID of the user or group to whom the permission is granted.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        The level of the permission:
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the permission:
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the user or group to whom the permission is granted.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DashboardSharingPublic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZones":
            suggest = "management_zones"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSharingPublic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSharingPublic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSharingPublic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zones: Sequence[str],
                 urls: Optional[Mapping[str, str]] = None):
        """
        :param Sequence[str] management_zones: A list of management zones that can display data on the publicly shared dashboard.
        :param Mapping[str, str] urls: A list of URLs for anonymous access to the dashboard indexed by management zone name
        """
        pulumi.set(__self__, "management_zones", management_zones)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter(name="managementZones")
    def management_zones(self) -> Sequence[str]:
        """
        A list of management zones that can display data on the publicly shared dashboard.
        """
        return pulumi.get(self, "management_zones")

    @property
    @pulumi.getter
    def urls(self) -> Optional[Mapping[str, str]]:
        """
        A list of URLs for anonymous access to the dashboard indexed by management zone name
        """
        return pulumi.get(self, "urls")


@pulumi.output_type
class DashboardTile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tileType":
            suggest = "tile_type"
        elif key == "assignedEntities":
            suggest = "assigned_entities"
        elif key == "autoRefreshDisabled":
            suggest = "auto_refresh_disabled"
        elif key == "chartVisible":
            suggest = "chart_visible"
        elif key == "customName":
            suggest = "custom_name"
        elif key == "excludeMaintenanceWindows":
            suggest = "exclude_maintenance_windows"
        elif key == "filterConfig":
            suggest = "filter_config"
        elif key == "nameSize":
            suggest = "name_size"
        elif key == "timeFrameShift":
            suggest = "time_frame_shift"
        elif key == "visualizationConfig":
            suggest = "visualization_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 tile_type: str,
                 assigned_entities: Optional[Sequence[str]] = None,
                 auto_refresh_disabled: Optional[bool] = None,
                 bounds: Optional['outputs.DashboardTileBounds'] = None,
                 chart_visible: Optional[bool] = None,
                 configured: Optional[bool] = None,
                 custom_name: Optional[str] = None,
                 exclude_maintenance_windows: Optional[bool] = None,
                 filter: Optional['outputs.DashboardTileFilter'] = None,
                 filter_config: Optional['outputs.DashboardTileFilterConfig'] = None,
                 limit: Optional[int] = None,
                 markdown: Optional[str] = None,
                 metric: Optional[str] = None,
                 name_size: Optional[str] = None,
                 query: Optional[str] = None,
                 time_frame_shift: Optional[str] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 visualization: Optional[str] = None,
                 visualization_config: Optional['outputs.DashboardTileVisualizationConfig'] = None):
        """
        :param str name: the name of the tile
        :param str tile_type: the type of the tile. Must be either `APPLICATION_WORLDMAP`, `RESOURCES`, `THIRD_PARTY_MOST_ACTIVE`, `UEM_CONVERSIONS_PER_GOAL`, `PROCESS_GROUPS_ONE` or `HOST` .
        :param Sequence[str] assigned_entities: The list of Dynatrace entities, assigned to the tile
        :param bool auto_refresh_disabled: Auto Refresh is disabled (`true`)
        :param 'DashboardTileBoundsArgs' bounds: the position and size of a tile
        :param bool configured: The tile is configured and ready to use (`true`) or just placed on the dashboard (`false`)
        :param str custom_name: The name of the tile, set by user
        :param bool exclude_maintenance_windows: Include (`false') or exclude (`true`) maintenance windows from availability calculations
        :param 'DashboardTileFilterArgs' filter: is filter applied to a tile. It overrides dashboard's filter
        :param 'DashboardTileFilterConfigArgs' filter_config: the position and size of a tile
        :param int limit: The limit of the results, if not set will use the default value of the system
        :param str markdown: The markdown-formatted content of the tile
        :param str metric: The metric assigned to the tile
        :param str name_size: The size of the tile name. Possible values are `small`, `medium` and `large`.
        :param str query: A [user session query](https://www.dynatrace.com/support/help/shortlink/usql-info) executed by the tile
        :param str time_frame_shift: The comparison timeframe of the query. If specified, you additionally get the results of the same query with the specified time shift
        :param str type: The attribute `type` exists for backwards compatibilty. Usage is discouraged. You should use `visualization` instead.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str visualization: The visualization of the tile. Possible values are: `COLUMN_CHART`, `FUNNEL`, `LINE_CHART`, `PIE_CHART`, `SINGLE_VALUE`, `TABLE`
        :param 'DashboardTileVisualizationConfigArgs' visualization_config: Configuration of a User session query visualization tile
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tile_type", tile_type)
        if assigned_entities is not None:
            pulumi.set(__self__, "assigned_entities", assigned_entities)
        if auto_refresh_disabled is not None:
            pulumi.set(__self__, "auto_refresh_disabled", auto_refresh_disabled)
        if bounds is not None:
            pulumi.set(__self__, "bounds", bounds)
        if chart_visible is not None:
            pulumi.set(__self__, "chart_visible", chart_visible)
        if configured is not None:
            pulumi.set(__self__, "configured", configured)
        if custom_name is not None:
            pulumi.set(__self__, "custom_name", custom_name)
        if exclude_maintenance_windows is not None:
            pulumi.set(__self__, "exclude_maintenance_windows", exclude_maintenance_windows)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if filter_config is not None:
            pulumi.set(__self__, "filter_config", filter_config)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if markdown is not None:
            pulumi.set(__self__, "markdown", markdown)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if name_size is not None:
            pulumi.set(__self__, "name_size", name_size)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if time_frame_shift is not None:
            pulumi.set(__self__, "time_frame_shift", time_frame_shift)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if visualization is not None:
            pulumi.set(__self__, "visualization", visualization)
        if visualization_config is not None:
            pulumi.set(__self__, "visualization_config", visualization_config)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        the name of the tile
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="tileType")
    def tile_type(self) -> str:
        """
        the type of the tile. Must be either `APPLICATION_WORLDMAP`, `RESOURCES`, `THIRD_PARTY_MOST_ACTIVE`, `UEM_CONVERSIONS_PER_GOAL`, `PROCESS_GROUPS_ONE` or `HOST` .
        """
        return pulumi.get(self, "tile_type")

    @property
    @pulumi.getter(name="assignedEntities")
    def assigned_entities(self) -> Optional[Sequence[str]]:
        """
        The list of Dynatrace entities, assigned to the tile
        """
        return pulumi.get(self, "assigned_entities")

    @property
    @pulumi.getter(name="autoRefreshDisabled")
    def auto_refresh_disabled(self) -> Optional[bool]:
        """
        Auto Refresh is disabled (`true`)
        """
        return pulumi.get(self, "auto_refresh_disabled")

    @property
    @pulumi.getter
    def bounds(self) -> Optional['outputs.DashboardTileBounds']:
        """
        the position and size of a tile
        """
        return pulumi.get(self, "bounds")

    @property
    @pulumi.getter(name="chartVisible")
    def chart_visible(self) -> Optional[bool]:
        return pulumi.get(self, "chart_visible")

    @property
    @pulumi.getter
    def configured(self) -> Optional[bool]:
        """
        The tile is configured and ready to use (`true`) or just placed on the dashboard (`false`)
        """
        return pulumi.get(self, "configured")

    @property
    @pulumi.getter(name="customName")
    def custom_name(self) -> Optional[str]:
        """
        The name of the tile, set by user
        """
        return pulumi.get(self, "custom_name")

    @property
    @pulumi.getter(name="excludeMaintenanceWindows")
    def exclude_maintenance_windows(self) -> Optional[bool]:
        """
        Include (`false') or exclude (`true`) maintenance windows from availability calculations
        """
        return pulumi.get(self, "exclude_maintenance_windows")

    @property
    @pulumi.getter
    def filter(self) -> Optional['outputs.DashboardTileFilter']:
        """
        is filter applied to a tile. It overrides dashboard's filter
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="filterConfig")
    def filter_config(self) -> Optional['outputs.DashboardTileFilterConfig']:
        """
        the position and size of a tile
        """
        return pulumi.get(self, "filter_config")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The limit of the results, if not set will use the default value of the system
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def markdown(self) -> Optional[str]:
        """
        The markdown-formatted content of the tile
        """
        return pulumi.get(self, "markdown")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric assigned to the tile
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="nameSize")
    def name_size(self) -> Optional[str]:
        """
        The size of the tile name. Possible values are `small`, `medium` and `large`.
        """
        return pulumi.get(self, "name_size")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        A [user session query](https://www.dynatrace.com/support/help/shortlink/usql-info) executed by the tile
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="timeFrameShift")
    def time_frame_shift(self) -> Optional[str]:
        """
        The comparison timeframe of the query. If specified, you additionally get the results of the same query with the specified time shift
        """
        return pulumi.get(self, "time_frame_shift")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The attribute `type` exists for backwards compatibilty. Usage is discouraged. You should use `visualization` instead.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def visualization(self) -> Optional[str]:
        """
        The visualization of the tile. Possible values are: `COLUMN_CHART`, `FUNNEL`, `LINE_CHART`, `PIE_CHART`, `SINGLE_VALUE`, `TABLE`
        """
        return pulumi.get(self, "visualization")

    @property
    @pulumi.getter(name="visualizationConfig")
    def visualization_config(self) -> Optional['outputs.DashboardTileVisualizationConfig']:
        """
        Configuration of a User session query visualization tile
        """
        return pulumi.get(self, "visualization_config")


@pulumi.output_type
class DashboardTileBounds(dict):
    def __init__(__self__, *,
                 height: int,
                 left: int,
                 top: int,
                 width: int,
                 unknowns: Optional[str] = None):
        """
        :param int height: the height of the tile, in pixels
        :param int left: the horizontal distance from the top left corner of the dashboard to the top left corner of the tile, in pixels
        :param int top: the vertical distance from the top left corner of the dashboard to the top left corner of the tile, in pixels
        :param int width: the width of the tile, in pixels
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "left", left)
        pulumi.set(__self__, "top", top)
        pulumi.set(__self__, "width", width)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def height(self) -> int:
        """
        the height of the tile, in pixels
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def left(self) -> int:
        """
        the horizontal distance from the top left corner of the dashboard to the top left corner of the tile, in pixels
        """
        return pulumi.get(self, "left")

    @property
    @pulumi.getter
    def top(self) -> int:
        """
        the vertical distance from the top left corner of the dashboard to the top left corner of the tile, in pixels
        """
        return pulumi.get(self, "top")

    @property
    @pulumi.getter
    def width(self) -> int:
        """
        the width of the tile, in pixels
        """
        return pulumi.get(self, "width")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZones":
            suggest = "management_zones"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zones: Optional[Sequence['outputs.DashboardTileFilterManagementZone']] = None,
                 timeframe: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence['DashboardTileFilterManagementZoneArgs'] management_zones: the management zone this tile applies to
        :param str timeframe: the default timeframe of the tile
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if management_zones is not None:
            pulumi.set(__self__, "management_zones", management_zones)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZones")
    def management_zones(self) -> Optional[Sequence['outputs.DashboardTileFilterManagementZone']]:
        """
        the management zone this tile applies to
        """
        return pulumi.get(self, "management_zones")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        the default timeframe of the tile
        """
        return pulumi.get(self, "timeframe")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileFilterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customName":
            suggest = "custom_name"
        elif key == "defaultName":
            suggest = "default_name"
        elif key == "chartConfig":
            suggest = "chart_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_name: str,
                 default_name: str,
                 type: str,
                 chart_config: Optional['outputs.DashboardTileFilterConfigChartConfig'] = None,
                 filters: Optional['outputs.DashboardTileFilterConfigFilters'] = None,
                 unknowns: Optional[str] = None):
        """
        :param str custom_name: The name of the tile, set by user
        :param str default_name: The default name of the tile
        :param str type: The type of the filter. Possible values are `ALB`, `APPLICATION`, `APPLICATION_METHOD`, `APPMON`, `ASG`, `AWS_CREDENTIALS`, `AWS_CUSTOM_SERVICE`, `AWS_LAMBDA_FUNCTION`, `CLOUD_APPLICATION`, `CLOUD_APPLICATION_INSTANCE`, `CLOUD_APPLICATION_NAMESPACE`, `CONTAINER_GROUP_INSTANCE`, `CUSTOM_APPLICATION`, `CUSTOM_DEVICES`, `CUSTOM_SERVICES`, `DATABASE`, `DATABASE_KEY_REQUEST`, `DCRUM_APPLICATION`, `DCRUM_ENTITY`, `DYNAMO_DB`, `EBS`, `EC2`, `ELB`, `ENVIRONMENT`, `ESXI`, `EXTERNAL_SYNTHETIC_TEST`, `GLOBAL_BACKGROUND_ACTIVITY`, `HOST`, `IOT`, `KUBERNETES_CLUSTER`, `KUBERNETES_NODE`, `MDA_SERVICE`, `MIXED`, `MOBILE_APPLICATION`, `MONITORED_ENTITY`, `NLB`, `PG_BACKGROUND_ACTIVITY`, `PROBLEM`, `PROCESS_GROUP_INSTANCE`, `RDS`, `REMOTE_PLUGIN`, `SERVICE`, `SERVICE_KEY_REQUEST`, `SYNTHETIC_BROWSER_MONITOR`, `SYNTHETIC_HTTPCHECK`, `SYNTHETIC_HTTPCHECK_STEP`, `SYNTHETIC_LOCATION`, `SYNTHETIC_TEST`, `SYNTHETIC_TEST_STEP`, `UI_ENTITY`, `VIRTUAL_MACHINE`, `WEB_CHECK`.
        :param 'DashboardTileFilterConfigChartConfigArgs' chart_config: Configuration of a custom chart
        :param 'DashboardTileFilterConfigFiltersArgs' filters: Configuration of a custom chart
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "custom_name", custom_name)
        pulumi.set(__self__, "default_name", default_name)
        pulumi.set(__self__, "type", type)
        if chart_config is not None:
            pulumi.set(__self__, "chart_config", chart_config)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="customName")
    def custom_name(self) -> str:
        """
        The name of the tile, set by user
        """
        return pulumi.get(self, "custom_name")

    @property
    @pulumi.getter(name="defaultName")
    def default_name(self) -> str:
        """
        The default name of the tile
        """
        return pulumi.get(self, "default_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the filter. Possible values are `ALB`, `APPLICATION`, `APPLICATION_METHOD`, `APPMON`, `ASG`, `AWS_CREDENTIALS`, `AWS_CUSTOM_SERVICE`, `AWS_LAMBDA_FUNCTION`, `CLOUD_APPLICATION`, `CLOUD_APPLICATION_INSTANCE`, `CLOUD_APPLICATION_NAMESPACE`, `CONTAINER_GROUP_INSTANCE`, `CUSTOM_APPLICATION`, `CUSTOM_DEVICES`, `CUSTOM_SERVICES`, `DATABASE`, `DATABASE_KEY_REQUEST`, `DCRUM_APPLICATION`, `DCRUM_ENTITY`, `DYNAMO_DB`, `EBS`, `EC2`, `ELB`, `ENVIRONMENT`, `ESXI`, `EXTERNAL_SYNTHETIC_TEST`, `GLOBAL_BACKGROUND_ACTIVITY`, `HOST`, `IOT`, `KUBERNETES_CLUSTER`, `KUBERNETES_NODE`, `MDA_SERVICE`, `MIXED`, `MOBILE_APPLICATION`, `MONITORED_ENTITY`, `NLB`, `PG_BACKGROUND_ACTIVITY`, `PROBLEM`, `PROCESS_GROUP_INSTANCE`, `RDS`, `REMOTE_PLUGIN`, `SERVICE`, `SERVICE_KEY_REQUEST`, `SYNTHETIC_BROWSER_MONITOR`, `SYNTHETIC_HTTPCHECK`, `SYNTHETIC_HTTPCHECK_STEP`, `SYNTHETIC_LOCATION`, `SYNTHETIC_TEST`, `SYNTHETIC_TEST_STEP`, `UI_ENTITY`, `VIRTUAL_MACHINE`, `WEB_CHECK`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="chartConfig")
    def chart_config(self) -> Optional['outputs.DashboardTileFilterConfigChartConfig']:
        """
        Configuration of a custom chart
        """
        return pulumi.get(self, "chart_config")

    @property
    @pulumi.getter
    def filters(self) -> Optional['outputs.DashboardTileFilterConfigFilters']:
        """
        Configuration of a custom chart
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileFilterConfigChartConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisLimits":
            suggest = "axis_limits"
        elif key == "leftAxisCustomUnit":
            suggest = "left_axis_custom_unit"
        elif key == "resultMetadatas":
            suggest = "result_metadatas"
        elif key == "rightAxisCustomUnit":
            suggest = "right_axis_custom_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilterConfigChartConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilterConfigChartConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilterConfigChartConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 axis_limits: Optional[Mapping[str, float]] = None,
                 left_axis_custom_unit: Optional[str] = None,
                 legend: Optional[bool] = None,
                 result_metadatas: Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigResultMetadata']] = None,
                 right_axis_custom_unit: Optional[str] = None,
                 series: Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigSeries']] = None,
                 unknowns: Optional[str] = None):
        """
        :param str type: The type of the chart
        :param Mapping[str, float] axis_limits: The optional custom y-axis limits
        :param str left_axis_custom_unit: Either one of `Bit`, `BitPerHour`, `BitPerMinute`, `BitPerSecond`, `Byte`, `BytePerHour`, `BytePerMinute`, `BytePerSecond`, `Cores`, `Count`, `Day`, `DecibelMilliWatt`, `GibiByte`, `Giga`, `GigaByte`, `Hour`, `KibiByte`, `KibiBytePerHour`, `KibiBytePerMinute`, `KibiBytePerSecond`, `Kilo`, `KiloByte`, `KiloBytePerHour`, `KiloBytePerMinute`, `KiloBytePerSecond`, `MebiByte`, `MebiBytePerHour`, `MebiBytePerMinute`, `MebiBytePerSecond`, `Mega`, `MegaByte`, `MegaBytePerHour`, `MegaBytePerMinute`, `MegaBytePerSecond`, `MicroSecond`, `MilliCores`, `MilliSecond`, `MilliSecondPerMinute`, `Minute`, `Month`, `NanoSecond`, `NanoSecondPerMinute`, `NotApplicable`, `PerHour`, `PerMinute`, `PerSecond`, `Percent`, `Pixel`, `Promille`, `Ratio`, `Second`, `State`, `Unspecified`, `Week`, `Year`
        :param bool legend: Defines if a legend should be shown
        :param Sequence['DashboardTileFilterConfigChartConfigResultMetadataArgs'] result_metadatas: Additional information about charted metric
        :param str right_axis_custom_unit: Either one of `Bit`, `BitPerHour`, `BitPerMinute`, `BitPerSecond`, `Byte`, `BytePerHour`, `BytePerMinute`, `BytePerSecond`, `Cores`, `Count`, `Day`, `DecibelMilliWatt`, `GibiByte`, `Giga`, `GigaByte`, `Hour`, `KibiByte`, `KibiBytePerHour`, `KibiBytePerMinute`, `KibiBytePerSecond`, `Kilo`, `KiloByte`, `KiloBytePerHour`, `KiloBytePerMinute`, `KiloBytePerSecond`, `MebiByte`, `MebiBytePerHour`, `MebiBytePerMinute`, `MebiBytePerSecond`, `Mega`, `MegaByte`, `MegaBytePerHour`, `MegaBytePerMinute`, `MegaBytePerSecond`, `MicroSecond`, `MilliCores`, `MilliSecond`, `MilliSecondPerMinute`, `Minute`, `Month`, `NanoSecond`, `NanoSecondPerMinute`, `NotApplicable`, `PerHour`, `PerMinute`, `PerSecond`, `Percent`, `Pixel`, `Promille`, `Ratio`, `Second`, `State`, `Unspecified`, `Week`, `Year`
        :param Sequence['DashboardTileFilterConfigChartConfigSeriesArgs'] series: A list of charted metrics
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "type", type)
        if axis_limits is not None:
            pulumi.set(__self__, "axis_limits", axis_limits)
        if left_axis_custom_unit is not None:
            pulumi.set(__self__, "left_axis_custom_unit", left_axis_custom_unit)
        if legend is not None:
            pulumi.set(__self__, "legend", legend)
        if result_metadatas is not None:
            pulumi.set(__self__, "result_metadatas", result_metadatas)
        if right_axis_custom_unit is not None:
            pulumi.set(__self__, "right_axis_custom_unit", right_axis_custom_unit)
        if series is not None:
            pulumi.set(__self__, "series", series)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the chart
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="axisLimits")
    def axis_limits(self) -> Optional[Mapping[str, float]]:
        """
        The optional custom y-axis limits
        """
        return pulumi.get(self, "axis_limits")

    @property
    @pulumi.getter(name="leftAxisCustomUnit")
    def left_axis_custom_unit(self) -> Optional[str]:
        """
        Either one of `Bit`, `BitPerHour`, `BitPerMinute`, `BitPerSecond`, `Byte`, `BytePerHour`, `BytePerMinute`, `BytePerSecond`, `Cores`, `Count`, `Day`, `DecibelMilliWatt`, `GibiByte`, `Giga`, `GigaByte`, `Hour`, `KibiByte`, `KibiBytePerHour`, `KibiBytePerMinute`, `KibiBytePerSecond`, `Kilo`, `KiloByte`, `KiloBytePerHour`, `KiloBytePerMinute`, `KiloBytePerSecond`, `MebiByte`, `MebiBytePerHour`, `MebiBytePerMinute`, `MebiBytePerSecond`, `Mega`, `MegaByte`, `MegaBytePerHour`, `MegaBytePerMinute`, `MegaBytePerSecond`, `MicroSecond`, `MilliCores`, `MilliSecond`, `MilliSecondPerMinute`, `Minute`, `Month`, `NanoSecond`, `NanoSecondPerMinute`, `NotApplicable`, `PerHour`, `PerMinute`, `PerSecond`, `Percent`, `Pixel`, `Promille`, `Ratio`, `Second`, `State`, `Unspecified`, `Week`, `Year`
        """
        return pulumi.get(self, "left_axis_custom_unit")

    @property
    @pulumi.getter
    def legend(self) -> Optional[bool]:
        """
        Defines if a legend should be shown
        """
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="resultMetadatas")
    def result_metadatas(self) -> Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigResultMetadata']]:
        """
        Additional information about charted metric
        """
        return pulumi.get(self, "result_metadatas")

    @property
    @pulumi.getter(name="rightAxisCustomUnit")
    def right_axis_custom_unit(self) -> Optional[str]:
        """
        Either one of `Bit`, `BitPerHour`, `BitPerMinute`, `BitPerSecond`, `Byte`, `BytePerHour`, `BytePerMinute`, `BytePerSecond`, `Cores`, `Count`, `Day`, `DecibelMilliWatt`, `GibiByte`, `Giga`, `GigaByte`, `Hour`, `KibiByte`, `KibiBytePerHour`, `KibiBytePerMinute`, `KibiBytePerSecond`, `Kilo`, `KiloByte`, `KiloBytePerHour`, `KiloBytePerMinute`, `KiloBytePerSecond`, `MebiByte`, `MebiBytePerHour`, `MebiBytePerMinute`, `MebiBytePerSecond`, `Mega`, `MegaByte`, `MegaBytePerHour`, `MegaBytePerMinute`, `MegaBytePerSecond`, `MicroSecond`, `MilliCores`, `MilliSecond`, `MilliSecondPerMinute`, `Minute`, `Month`, `NanoSecond`, `NanoSecondPerMinute`, `NotApplicable`, `PerHour`, `PerMinute`, `PerSecond`, `Percent`, `Pixel`, `Promille`, `Ratio`, `Second`, `State`, `Unspecified`, `Week`, `Year`
        """
        return pulumi.get(self, "right_axis_custom_unit")

    @property
    @pulumi.getter
    def series(self) -> Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigSeries']]:
        """
        A list of charted metrics
        """
        return pulumi.get(self, "series")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileFilterConfigChartConfigResultMetadata(dict):
    def __init__(__self__, *,
                 configs: Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigResultMetadataConfig']] = None):
        """
        :param Sequence['DashboardTileFilterConfigChartConfigResultMetadataConfigArgs'] configs: Additional metadata for charted metric
        """
        if configs is not None:
            pulumi.set(__self__, "configs", configs)

    @property
    @pulumi.getter
    def configs(self) -> Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigResultMetadataConfig']]:
        """
        Additional metadata for charted metric
        """
        return pulumi.get(self, "configs")


@pulumi.output_type
class DashboardTileFilterConfigChartConfigResultMetadataConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customColor":
            suggest = "custom_color"
        elif key == "lastModified":
            suggest = "last_modified"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilterConfigChartConfigResultMetadataConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilterConfigChartConfigResultMetadataConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilterConfigChartConfigResultMetadataConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_color: Optional[str] = None,
                 key: Optional[str] = None,
                 last_modified: Optional[int] = None,
                 unknowns: Optional[str] = None):
        """
        :param str custom_color: The color of the metric in the chart, hex format
        :param str key: A generated key by the Dynatrace Server
        :param int last_modified: The timestamp of the last metadata modification, in UTC milliseconds
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if custom_color is not None:
            pulumi.set(__self__, "custom_color", custom_color)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if last_modified is not None:
            pulumi.set(__self__, "last_modified", last_modified)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="customColor")
    def custom_color(self) -> Optional[str]:
        """
        The color of the metric in the chart, hex format
        """
        return pulumi.get(self, "custom_color")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        A generated key by the Dynatrace Server
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="lastModified")
    def last_modified(self) -> Optional[int]:
        """
        The timestamp of the last metadata modification, in UTC milliseconds
        """
        return pulumi.get(self, "last_modified")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileFilterConfigChartConfigSeries(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "aggregationRate":
            suggest = "aggregation_rate"
        elif key == "sortAscending":
            suggest = "sort_ascending"
        elif key == "sortColumn":
            suggest = "sort_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilterConfigChartConfigSeries. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilterConfigChartConfigSeries.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilterConfigChartConfigSeries.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation: str,
                 entity_type: str,
                 metric: str,
                 type: str,
                 aggregation_rate: Optional[str] = None,
                 dimensions: Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigSeriesDimension']] = None,
                 percentile: Optional[int] = None,
                 sort_ascending: Optional[bool] = None,
                 sort_column: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str aggregation: The charted aggregation of the metric
        :param str entity_type: The visualization of the timeseries chart
        :param str metric: The name of the charted metric
        :param str type: The visualization of the timeseries chart. Possible values are `AREA`, `BAR` and `LINE`.
        :param Sequence['DashboardTileFilterConfigChartConfigSeriesDimensionArgs'] dimensions: Configuration of the charted metric splitting
        :param int percentile: The charted percentile. Only applicable if the **aggregation** is set to `PERCENTILE`
        :param bool sort_ascending: Sort ascending (`true`) or descending (`false`)
        :param bool sort_column: Sort the column (`true`) or (`false`)
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "type", type)
        if aggregation_rate is not None:
            pulumi.set(__self__, "aggregation_rate", aggregation_rate)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if percentile is not None:
            pulumi.set(__self__, "percentile", percentile)
        if sort_ascending is not None:
            pulumi.set(__self__, "sort_ascending", sort_ascending)
        if sort_column is not None:
            pulumi.set(__self__, "sort_column", sort_column)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The charted aggregation of the metric
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        The visualization of the timeseries chart
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The name of the charted metric
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The visualization of the timeseries chart. Possible values are `AREA`, `BAR` and `LINE`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="aggregationRate")
    def aggregation_rate(self) -> Optional[str]:
        return pulumi.get(self, "aggregation_rate")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigSeriesDimension']]:
        """
        Configuration of the charted metric splitting
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def percentile(self) -> Optional[int]:
        """
        The charted percentile. Only applicable if the **aggregation** is set to `PERCENTILE`
        """
        return pulumi.get(self, "percentile")

    @property
    @pulumi.getter(name="sortAscending")
    def sort_ascending(self) -> Optional[bool]:
        """
        Sort ascending (`true`) or descending (`false`)
        """
        return pulumi.get(self, "sort_ascending")

    @property
    @pulumi.getter(name="sortColumn")
    def sort_column(self) -> Optional[bool]:
        """
        Sort the column (`true`) or (`false`)
        """
        return pulumi.get(self, "sort_column")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileFilterConfigChartConfigSeriesDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityDimension":
            suggest = "entity_dimension"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilterConfigChartConfigSeriesDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilterConfigChartConfigSeriesDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilterConfigChartConfigSeriesDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 entity_dimension: Optional[bool] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str id: The ID of the dimension by which the metric is split
        :param str name: The name of the dimension by which the metric is split
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param Sequence[str] values: The splitting value
        """
        pulumi.set(__self__, "id", id)
        if entity_dimension is not None:
            pulumi.set(__self__, "entity_dimension", entity_dimension)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the dimension by which the metric is split
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="entityDimension")
    def entity_dimension(self) -> Optional[bool]:
        return pulumi.get(self, "entity_dimension")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the dimension by which the metric is split
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The splitting value
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardTileFilterConfigFilters(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.DashboardTileFilterConfigFiltersFilter']] = None):
        """
        :param Sequence['DashboardTileFilterConfigFiltersFilterArgs'] filters: the tiles this Dashboard consist of
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.DashboardTileFilterConfigFiltersFilter']]:
        """
        the tiles this Dashboard consist of
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class DashboardTileFilterConfigFiltersFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilterConfigFiltersFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilterConfigFiltersFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilterConfigFiltersFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 matches: Optional[Sequence['outputs.DashboardTileFilterConfigFiltersFilterMatch']] = None):
        """
        :param str entity_type: The entity type (e.g. HOST, SERVICE, ...)
        :param Sequence['DashboardTileFilterConfigFiltersFilterMatchArgs'] matches: the tiles this Dashboard consist of
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        The entity type (e.g. HOST, SERVICE, ...)
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.DashboardTileFilterConfigFiltersFilterMatch']]:
        """
        the tiles this Dashboard consist of
        """
        return pulumi.get(self, "matches")


@pulumi.output_type
class DashboardTileFilterConfigFiltersFilterMatch(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The entity type (e.g. HOST, SERVICE, ...)
        :param Sequence[str] values: the tiles this Dashboard consist of
        """
        pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The entity type (e.g. HOST, SERVICE, ...)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        the tiles this Dashboard consist of
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardTileFilterManagementZone(dict):
    def __init__(__self__, *,
                 id: str,
                 description: Optional[str] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str id: the ID of the Dynatrace entity
        :param str description: a short description of the Dynatrace entity
        :param str name: the name of the Dynatrace entity
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "id", id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the ID of the Dynatrace entity
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        a short description of the Dynatrace entity
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        the name of the Dynatrace entity
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileVisualizationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hasAxisBucketing":
            suggest = "has_axis_bucketing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileVisualizationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileVisualizationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileVisualizationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 has_axis_bucketing: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool has_axis_bucketing: The axis bucketing when enabled groups similar series in the same virtual axis
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if has_axis_bucketing is not None:
            pulumi.set(__self__, "has_axis_bucketing", has_axis_bucketing)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="hasAxisBucketing")
    def has_axis_bucketing(self) -> Optional[bool]:
        """
        The axis bucketing when enabled groups similar series in the same virtual axis
        """
        return pulumi.get(self, "has_axis_bucketing")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardsAllowlistAllowlist(dict):
    def __init__(__self__, *,
                 urlpatterns: Sequence['outputs.DashboardsAllowlistAllowlistUrlpattern']):
        pulumi.set(__self__, "urlpatterns", urlpatterns)

    @property
    @pulumi.getter
    def urlpatterns(self) -> Sequence['outputs.DashboardsAllowlistAllowlistUrlpattern']:
        return pulumi.get(self, "urlpatterns")


@pulumi.output_type
class DashboardsAllowlistAllowlistUrlpattern(dict):
    def __init__(__self__, *,
                 rule: str,
                 template: str):
        """
        :param str rule: Possible Values: `Equals`, `StartsWith`
        :param str template: Pattern
        """
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def rule(self) -> str:
        """
        Possible Values: `Equals`, `StartsWith`
        """
        return pulumi.get(self, "rule")

    @property
    @pulumi.getter
    def template(self) -> str:
        """
        Pattern
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class DashboardsGeneralDefaultDashboardList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDashboards":
            suggest = "default_dashboards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardsGeneralDefaultDashboardList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardsGeneralDefaultDashboardList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardsGeneralDefaultDashboardList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_dashboards: Sequence['outputs.DashboardsGeneralDefaultDashboardListDefaultDashboard']):
        pulumi.set(__self__, "default_dashboards", default_dashboards)

    @property
    @pulumi.getter(name="defaultDashboards")
    def default_dashboards(self) -> Sequence['outputs.DashboardsGeneralDefaultDashboardListDefaultDashboard']:
        return pulumi.get(self, "default_dashboards")


@pulumi.output_type
class DashboardsGeneralDefaultDashboardListDefaultDashboard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userGroup":
            suggest = "user_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardsGeneralDefaultDashboardListDefaultDashboard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardsGeneralDefaultDashboardListDefaultDashboard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardsGeneralDefaultDashboardListDefaultDashboard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboard: str,
                 user_group: str):
        """
        :param str dashboard: Preset dashboard to show as default landing page
        :param str user_group: Show selected dashboard by default for this user group
        """
        pulumi.set(__self__, "dashboard", dashboard)
        pulumi.set(__self__, "user_group", user_group)

    @property
    @pulumi.getter
    def dashboard(self) -> str:
        """
        Preset dashboard to show as default landing page
        """
        return pulumi.get(self, "dashboard")

    @property
    @pulumi.getter(name="userGroup")
    def user_group(self) -> str:
        """
        Show selected dashboard by default for this user group
        """
        return pulumi.get(self, "user_group")


@pulumi.output_type
class DashboardsPresetsDashboardPresetsList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dashboardPresets":
            suggest = "dashboard_presets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardsPresetsDashboardPresetsList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardsPresetsDashboardPresetsList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardsPresetsDashboardPresetsList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboard_presets: Sequence['outputs.DashboardsPresetsDashboardPresetsListDashboardPreset']):
        pulumi.set(__self__, "dashboard_presets", dashboard_presets)

    @property
    @pulumi.getter(name="dashboardPresets")
    def dashboard_presets(self) -> Sequence['outputs.DashboardsPresetsDashboardPresetsListDashboardPreset']:
        return pulumi.get(self, "dashboard_presets")


@pulumi.output_type
class DashboardsPresetsDashboardPresetsListDashboardPreset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dashboardPreset":
            suggest = "dashboard_preset"
        elif key == "userGroup":
            suggest = "user_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardsPresetsDashboardPresetsListDashboardPreset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardsPresetsDashboardPresetsListDashboardPreset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardsPresetsDashboardPresetsListDashboardPreset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboard_preset: str,
                 user_group: str):
        """
        :param str dashboard_preset: Dashboard preset to limit visibility for
        :param str user_group: User group to show selected dashboard preset to
        """
        pulumi.set(__self__, "dashboard_preset", dashboard_preset)
        pulumi.set(__self__, "user_group", user_group)

    @property
    @pulumi.getter(name="dashboardPreset")
    def dashboard_preset(self) -> str:
        """
        Dashboard preset to limit visibility for
        """
        return pulumi.get(self, "dashboard_preset")

    @property
    @pulumi.getter(name="userGroup")
    def user_group(self) -> str:
        """
        User group to show selected dashboard preset to
        """
        return pulumi.get(self, "user_group")


@pulumi.output_type
class DataPrivacyDataCollection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optInModeEnabled":
            suggest = "opt_in_mode_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataPrivacyDataCollection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataPrivacyDataCollection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataPrivacyDataCollection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 opt_in_mode_enabled: bool):
        """
        :param bool opt_in_mode_enabled: With [Data-collection and opt-in mode](https://dt-url.net/7l3p0p3h) enabled, Real User Monitoring data isn't captured until dtrum.enable() is called for specific user sessions.
        """
        pulumi.set(__self__, "opt_in_mode_enabled", opt_in_mode_enabled)

    @property
    @pulumi.getter(name="optInModeEnabled")
    def opt_in_mode_enabled(self) -> bool:
        """
        With [Data-collection and opt-in mode](https://dt-url.net/7l3p0p3h) enabled, Real User Monitoring data isn't captured until dtrum.enable() is called for specific user sessions.
        """
        return pulumi.get(self, "opt_in_mode_enabled")


@pulumi.output_type
class DataPrivacyDoNotTrack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "complyWithDoNotTrack":
            suggest = "comply_with_do_not_track"
        elif key == "doNotTrack":
            suggest = "do_not_track"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataPrivacyDoNotTrack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataPrivacyDoNotTrack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataPrivacyDoNotTrack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comply_with_do_not_track: bool,
                 do_not_track: Optional[str] = None):
        """
        :param bool comply_with_do_not_track: Comply with "Do Not Track" browser settings
        :param str do_not_track: Possible Values: `Anonymous`, `Disable_rum`
        """
        pulumi.set(__self__, "comply_with_do_not_track", comply_with_do_not_track)
        if do_not_track is not None:
            pulumi.set(__self__, "do_not_track", do_not_track)

    @property
    @pulumi.getter(name="complyWithDoNotTrack")
    def comply_with_do_not_track(self) -> bool:
        """
        Comply with "Do Not Track" browser settings
        """
        return pulumi.get(self, "comply_with_do_not_track")

    @property
    @pulumi.getter(name="doNotTrack")
    def do_not_track(self) -> Optional[str]:
        """
        Possible Values: `Anonymous`, `Disable_rum`
        """
        return pulumi.get(self, "do_not_track")


@pulumi.output_type
class DataPrivacyMasking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "personalDataUriMaskingEnabled":
            suggest = "personal_data_uri_masking_enabled"
        elif key == "userActionMaskingEnabled":
            suggest = "user_action_masking_enabled"
        elif key == "ipAddressMasking":
            suggest = "ip_address_masking"
        elif key == "ipAddressMaskingEnabled":
            suggest = "ip_address_masking_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataPrivacyMasking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataPrivacyMasking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataPrivacyMasking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 personal_data_uri_masking_enabled: bool,
                 user_action_masking_enabled: bool,
                 ip_address_masking: Optional[str] = None,
                 ip_address_masking_enabled: Optional[bool] = None):
        """
        :param bool personal_data_uri_masking_enabled: Dynatrace captures the URIs and request headers sent from desktop and mobile browsers. Dynatrace also captures full URIs on the server-side to enable detailed performance analysis of your applications. For complete details, visit [Mask personal data in URIs](https://dt-url.net/mask-personal-data-in-URIs).. URIs and request headers contain personal data. When this setting is enabled, Dynatrace automatically detects UUIDs, credit card numbers, email addresses, IP addresses, and other IDs and replaces those values with placeholders. The personal data is then masked in PurePath analysis, error analysis, user action naming for RUM, and elsewhere in Dynatrace.
        :param bool user_action_masking_enabled: When Dynatrace detects a user action that triggers a page load or an AJAX/XHR action. To learn more about masking user actions, visit [Mask user actions](https://dt-url.net/mask-user-action).. When Dynatrace detects a user action that triggers a page load or an AJAX/XHR action, it constructs a name for the user action based on:
               
               - User event type (click on..., loading of page..., or keypress on...)
               - Title, caption, label, value, ID, className, or other available property of the related HTML element (for example, an image, button, checkbox, or text input field).
               
               In most instances, the default approach to user-action naming works well, resulting in user-action names such as:
               
               - click on "Search" on page /search.html
               - keypress on "Feedback" on page /contact.html
               - touch on "Homescreen" of page /list.jsf
               
               In rare circumstances, confidential data (for example, email addresses, usernames, or account numbers) can be unintentionally included in user action names because the confidential data itself is included in an HTML element label, attribute, or other value (for example, click on "my Account Number: 1231231"...). If such confidential data appears in your application's user action names, enable the Mask user action names setting. This setting replaces specific HTML element names and values with generic HTML element names. With user-action name masking enabled, the user action names listed above appear as:
               
               - click on INPUT on page /search.html
               - keypress on TEXTAREA on page /contact.html
               - touch on DIV of page /list.jsf
        :param str ip_address_masking: Possible Values: `All`, `Public`
        :param bool ip_address_masking_enabled: Dynatrace captures the IP addresses of your end-users to determine the regions from which they access your application. To learn more, visit [Mask IPs and GPS coordinates](https://dt-url.net/mask-end-users-ip-addresses).. Dynatrace also captures GPS data from mobile apps that provide their users with the option of sharing geolocation data. On the server side, Dynatrace captures IP addresses to enable detailed troubleshooting for Dynatrace service calls.
               
               Once enabled, IP address masking sets the last octet of monitored IPv4 addresses and the last 80 bits of IPv6 addresses to zeroes. GPS coordinates are rounded up to 1 decimal place (~10 km). This masking occurs in memory. Full IP addresses are never written to disk. Location lookups are made using anonymized IP addresses and GPS coordinates.
        """
        pulumi.set(__self__, "personal_data_uri_masking_enabled", personal_data_uri_masking_enabled)
        pulumi.set(__self__, "user_action_masking_enabled", user_action_masking_enabled)
        if ip_address_masking is not None:
            pulumi.set(__self__, "ip_address_masking", ip_address_masking)
        if ip_address_masking_enabled is not None:
            pulumi.set(__self__, "ip_address_masking_enabled", ip_address_masking_enabled)

    @property
    @pulumi.getter(name="personalDataUriMaskingEnabled")
    def personal_data_uri_masking_enabled(self) -> bool:
        """
        Dynatrace captures the URIs and request headers sent from desktop and mobile browsers. Dynatrace also captures full URIs on the server-side to enable detailed performance analysis of your applications. For complete details, visit [Mask personal data in URIs](https://dt-url.net/mask-personal-data-in-URIs).. URIs and request headers contain personal data. When this setting is enabled, Dynatrace automatically detects UUIDs, credit card numbers, email addresses, IP addresses, and other IDs and replaces those values with placeholders. The personal data is then masked in PurePath analysis, error analysis, user action naming for RUM, and elsewhere in Dynatrace.
        """
        return pulumi.get(self, "personal_data_uri_masking_enabled")

    @property
    @pulumi.getter(name="userActionMaskingEnabled")
    def user_action_masking_enabled(self) -> bool:
        """
        When Dynatrace detects a user action that triggers a page load or an AJAX/XHR action. To learn more about masking user actions, visit [Mask user actions](https://dt-url.net/mask-user-action).. When Dynatrace detects a user action that triggers a page load or an AJAX/XHR action, it constructs a name for the user action based on:

        - User event type (click on..., loading of page..., or keypress on...)
        - Title, caption, label, value, ID, className, or other available property of the related HTML element (for example, an image, button, checkbox, or text input field).

        In most instances, the default approach to user-action naming works well, resulting in user-action names such as:

        - click on "Search" on page /search.html
        - keypress on "Feedback" on page /contact.html
        - touch on "Homescreen" of page /list.jsf

        In rare circumstances, confidential data (for example, email addresses, usernames, or account numbers) can be unintentionally included in user action names because the confidential data itself is included in an HTML element label, attribute, or other value (for example, click on "my Account Number: 1231231"...). If such confidential data appears in your application's user action names, enable the Mask user action names setting. This setting replaces specific HTML element names and values with generic HTML element names. With user-action name masking enabled, the user action names listed above appear as:

        - click on INPUT on page /search.html
        - keypress on TEXTAREA on page /contact.html
        - touch on DIV of page /list.jsf
        """
        return pulumi.get(self, "user_action_masking_enabled")

    @property
    @pulumi.getter(name="ipAddressMasking")
    @_utilities.deprecated("""This property is not supported anymore by the Dynatrace REST API (since schema version 4)""")
    def ip_address_masking(self) -> Optional[str]:
        """
        Possible Values: `All`, `Public`
        """
        return pulumi.get(self, "ip_address_masking")

    @property
    @pulumi.getter(name="ipAddressMaskingEnabled")
    @_utilities.deprecated("""This property is not supported anymore by the Dynatrace REST API (since schema version 4)""")
    def ip_address_masking_enabled(self) -> Optional[bool]:
        """
        Dynatrace captures the IP addresses of your end-users to determine the regions from which they access your application. To learn more, visit [Mask IPs and GPS coordinates](https://dt-url.net/mask-end-users-ip-addresses).. Dynatrace also captures GPS data from mobile apps that provide their users with the option of sharing geolocation data. On the server side, Dynatrace captures IP addresses to enable detailed troubleshooting for Dynatrace service calls.

        Once enabled, IP address masking sets the last octet of monitored IPv4 addresses and the last 80 bits of IPv6 addresses to zeroes. GPS coordinates are rounded up to 1 decimal place (~10 km). This masking occurs in memory. Full IP addresses are never written to disk. Location lookups are made using anonymized IP addresses and GPS coordinates.
        """
        return pulumi.get(self, "ip_address_masking_enabled")


@pulumi.output_type
class DataPrivacyUserTracking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "persistentCookieEnabled":
            suggest = "persistent_cookie_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataPrivacyUserTracking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataPrivacyUserTracking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataPrivacyUserTracking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 persistent_cookie_enabled: bool):
        """
        :param bool persistent_cookie_enabled: When enabled, Dynatrace places a [persistent cookie](https://dt-url.net/313o0p4n) on all end-user devices to identify returning users.
        """
        pulumi.set(__self__, "persistent_cookie_enabled", persistent_cookie_enabled)

    @property
    @pulumi.getter(name="persistentCookieEnabled")
    def persistent_cookie_enabled(self) -> bool:
        """
        When enabled, Dynatrace places a [persistent cookie](https://dt-url.net/313o0p4n) on all end-user devices to identify returning users.
        """
        return pulumi.get(self, "persistent_cookie_enabled")


@pulumi.output_type
class DatabaseAnomaliesDbConnectFailures(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionFailsCount":
            suggest = "connection_fails_count"
        elif key == "evalPeriod":
            suggest = "eval_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesDbConnectFailures. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesDbConnectFailures.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesDbConnectFailures.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_fails_count: Optional[int] = None,
                 eval_period: Optional[int] = None):
        """
        :param int connection_fails_count: Number of failed database connections during any **eval_period** minutes period to trigger an alert
        :param int eval_period: The *X* minutes time period during which the **connection*fails*count** is evaluated
        """
        if connection_fails_count is not None:
            pulumi.set(__self__, "connection_fails_count", connection_fails_count)
        if eval_period is not None:
            pulumi.set(__self__, "eval_period", eval_period)

    @property
    @pulumi.getter(name="connectionFailsCount")
    def connection_fails_count(self) -> Optional[int]:
        """
        Number of failed database connections during any **eval_period** minutes period to trigger an alert
        """
        return pulumi.get(self, "connection_fails_count")

    @property
    @pulumi.getter(name="evalPeriod")
    def eval_period(self) -> Optional[int]:
        """
        The *X* minutes time period during which the **connection*fails*count** is evaluated
        """
        return pulumi.get(self, "eval_period")


@pulumi.output_type
class DatabaseAnomaliesFailureRate(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.DatabaseAnomaliesFailureRateAuto'] = None,
                 thresholds: Optional['outputs.DatabaseAnomaliesFailureRateThresholds'] = None):
        """
        :param 'DatabaseAnomaliesFailureRateAutoArgs' auto: Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
        :param 'DatabaseAnomaliesFailureRateThresholdsArgs' thresholds: Fixed thresholds for failure rate increase detection
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.DatabaseAnomaliesFailureRateAuto']:
        """
        Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.DatabaseAnomaliesFailureRateThresholds']:
        """
        Fixed thresholds for failure rate increase detection
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class DatabaseAnomaliesFailureRateAuto(dict):
    def __init__(__self__, *,
                 absolute: int,
                 relative: int,
                 unknowns: Optional[str] = None):
        """
        :param int absolute: Absolute increase of failing service calls to trigger an alert, %
        :param int relative: Relative increase of failing service calls to trigger an alert, %
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "absolute", absolute)
        pulumi.set(__self__, "relative", relative)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def absolute(self) -> int:
        """
        Absolute increase of failing service calls to trigger an alert, %
        """
        return pulumi.get(self, "absolute")

    @property
    @pulumi.getter
    def relative(self) -> int:
        """
        Relative increase of failing service calls to trigger an alert, %
        """
        return pulumi.get(self, "relative")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DatabaseAnomaliesFailureRateThresholds(dict):
    def __init__(__self__, *,
                 sensitivity: str,
                 threshold: int,
                 unknowns: Optional[str] = None):
        """
        :param str sensitivity: Sensitivity of the threshold.  With `low` sensitivity, high statistical confidence is used. Brief violations (for example, due to a surge in load) won't trigger alerts.  With `high` sensitivity, no statistical confidence is used. Each violation triggers alert
        :param int threshold: Failure rate during any 5-minute period to trigger an alert, %
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold", threshold)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        """
        Sensitivity of the threshold.  With `low` sensitivity, high statistical confidence is used. Brief violations (for example, due to a surge in load) won't trigger alerts.  With `high` sensitivity, no statistical confidence is used. Each violation triggers alert
        """
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        Failure rate during any 5-minute period to trigger an alert, %
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DatabaseAnomaliesLoad(dict):
    def __init__(__self__, *,
                 drops: Optional['outputs.DatabaseAnomaliesLoadDrops'] = None,
                 spikes: Optional['outputs.DatabaseAnomaliesLoadSpikes'] = None):
        """
        :param 'DatabaseAnomaliesLoadDropsArgs' drops: The configuration of traffic drops detection
        :param 'DatabaseAnomaliesLoadSpikesArgs' spikes: The configuration of traffic spikes detection
        """
        if drops is not None:
            pulumi.set(__self__, "drops", drops)
        if spikes is not None:
            pulumi.set(__self__, "spikes", spikes)

    @property
    @pulumi.getter
    def drops(self) -> Optional['outputs.DatabaseAnomaliesLoadDrops']:
        """
        The configuration of traffic drops detection
        """
        return pulumi.get(self, "drops")

    @property
    @pulumi.getter
    def spikes(self) -> Optional['outputs.DatabaseAnomaliesLoadSpikes']:
        """
        The configuration of traffic spikes detection
        """
        return pulumi.get(self, "spikes")


@pulumi.output_type
class DatabaseAnomaliesLoadDrops(dict):
    def __init__(__self__, *,
                 minutes: Optional[int] = None,
                 percent: Optional[int] = None):
        """
        :param int minutes: Alert if the service stays in abnormal state for at least *X* minutes
        :param int percent: Alert if the observed load is more than *X* % of the expected value
        """
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        Alert if the service stays in abnormal state for at least *X* minutes
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        """
        Alert if the observed load is more than *X* % of the expected value
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class DatabaseAnomaliesLoadSpikes(dict):
    def __init__(__self__, *,
                 minutes: Optional[int] = None,
                 percent: Optional[int] = None,
                 unknowns: Optional[str] = None):
        """
        :param int minutes: Alert if the service stays in abnormal state for at least *X* minutes
        :param int percent: Alert if the observed load is more than *X* % of the expected value
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        Alert if the service stays in abnormal state for at least *X* minutes
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        """
        Alert if the observed load is more than *X* % of the expected value
        """
        return pulumi.get(self, "percent")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DatabaseAnomaliesResponseTime(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.DatabaseAnomaliesResponseTimeAuto'] = None,
                 thresholds: Optional['outputs.DatabaseAnomaliesResponseTimeThresholds'] = None):
        """
        :param 'DatabaseAnomaliesResponseTimeAutoArgs' auto: Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
        :param 'DatabaseAnomaliesResponseTimeThresholdsArgs' thresholds: Fixed thresholds for response time degradation detection
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.DatabaseAnomaliesResponseTimeAuto']:
        """
        Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.DatabaseAnomaliesResponseTimeThresholds']:
        """
        Fixed thresholds for response time degradation detection
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class DatabaseAnomaliesResponseTimeAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestMilliseconds":
            suggest = "slowest_milliseconds"
        elif key == "slowestPercent":
            suggest = "slowest_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesResponseTimeAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesResponseTimeAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesResponseTimeAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load: str,
                 milliseconds: int,
                 percent: int,
                 slowest_milliseconds: int,
                 slowest_percent: int,
                 unknowns: Optional[str] = None):
        """
        :param str load: Minimal service load to detect response time degradation. Response time degradation of services with smaller load won't trigger alerts. Possible values are `FIFTEEN_REQUESTS_PER_MINUTE`, `FIVE_REQUESTS_PER_MINUTE`, `ONE_REQUEST_PER_MINUTE` and `TEN_REQUESTS_PER_MINUTE`
        :param int milliseconds: Alert if the response time degrades by more than *X* milliseconds
        :param int percent: Alert if the response time degrades by more than *X* %
        :param int slowest_milliseconds: Alert if the response time of the slowest 10% degrades by more than *X* milliseconds
        :param int slowest_percent: Alert if the response time of the slowest 10% degrades by more than *X* milliseconds
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "load", load)
        pulumi.set(__self__, "milliseconds", milliseconds)
        pulumi.set(__self__, "percent", percent)
        pulumi.set(__self__, "slowest_milliseconds", slowest_milliseconds)
        pulumi.set(__self__, "slowest_percent", slowest_percent)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def load(self) -> str:
        """
        Minimal service load to detect response time degradation. Response time degradation of services with smaller load won't trigger alerts. Possible values are `FIFTEEN_REQUESTS_PER_MINUTE`, `FIVE_REQUESTS_PER_MINUTE`, `ONE_REQUEST_PER_MINUTE` and `TEN_REQUESTS_PER_MINUTE`
        """
        return pulumi.get(self, "load")

    @property
    @pulumi.getter
    def milliseconds(self) -> int:
        """
        Alert if the response time degrades by more than *X* milliseconds
        """
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def percent(self) -> int:
        """
        Alert if the response time degrades by more than *X* %
        """
        return pulumi.get(self, "percent")

    @property
    @pulumi.getter(name="slowestMilliseconds")
    def slowest_milliseconds(self) -> int:
        """
        Alert if the response time of the slowest 10% degrades by more than *X* milliseconds
        """
        return pulumi.get(self, "slowest_milliseconds")

    @property
    @pulumi.getter(name="slowestPercent")
    def slowest_percent(self) -> int:
        """
        Alert if the response time of the slowest 10% degrades by more than *X* milliseconds
        """
        return pulumi.get(self, "slowest_percent")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DatabaseAnomaliesResponseTimeThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestMilliseconds":
            suggest = "slowest_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesResponseTimeThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesResponseTimeThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesResponseTimeThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load: str,
                 milliseconds: int,
                 sensitivity: str,
                 slowest_milliseconds: int,
                 unknowns: Optional[str] = None):
        """
        :param str load: Minimal service load to detect response time degradation. Response time degradation of services with smaller load won't trigger alerts. Possible values are `FIFTEEN_REQUESTS_PER_MINUTE`, `FIVE_REQUESTS_PER_MINUTE`, `ONE_REQUEST_PER_MINUTE` and `TEN_REQUESTS_PER_MINUTE`
        :param int milliseconds: Response time during any 5-minute period to trigger an alert, in milliseconds
        :param str sensitivity: Sensitivity of the threshold.  With `low` sensitivity, high statistical confidence is used. Brief violations (for example, due to a surge in load) won't trigger alerts.  With `high` sensitivity, no statistical confidence is used. Each violation triggers an alert
        :param int slowest_milliseconds: Response time of the 10% slowest during any 5-minute period to trigger an alert, in milliseconds
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "load", load)
        pulumi.set(__self__, "milliseconds", milliseconds)
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "slowest_milliseconds", slowest_milliseconds)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def load(self) -> str:
        """
        Minimal service load to detect response time degradation. Response time degradation of services with smaller load won't trigger alerts. Possible values are `FIFTEEN_REQUESTS_PER_MINUTE`, `FIVE_REQUESTS_PER_MINUTE`, `ONE_REQUEST_PER_MINUTE` and `TEN_REQUESTS_PER_MINUTE`
        """
        return pulumi.get(self, "load")

    @property
    @pulumi.getter
    def milliseconds(self) -> int:
        """
        Response time during any 5-minute period to trigger an alert, in milliseconds
        """
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        """
        Sensitivity of the threshold.  With `low` sensitivity, high statistical confidence is used. Brief violations (for example, due to a surge in load) won't trigger alerts.  With `high` sensitivity, no statistical confidence is used. Each violation triggers an alert
        """
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter(name="slowestMilliseconds")
    def slowest_milliseconds(self) -> int:
        """
        Response time of the 10% slowest during any 5-minute period to trigger an alert, in milliseconds
        """
        return pulumi.get(self, "slowest_milliseconds")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DatabaseAnomaliesV2DatabaseConnections(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxFailedConnects":
            suggest = "max_failed_connects"
        elif key == "timePeriod":
            suggest = "time_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2DatabaseConnections. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2DatabaseConnections.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2DatabaseConnections.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 max_failed_connects: Optional[int] = None,
                 time_period: Optional[int] = None):
        """
        :param bool enabled: Detect failed database connects
        :param int max_failed_connects: Threshold
        :param int time_period: Time span
        """
        pulumi.set(__self__, "enabled", enabled)
        if max_failed_connects is not None:
            pulumi.set(__self__, "max_failed_connects", max_failed_connects)
        if time_period is not None:
            pulumi.set(__self__, "time_period", time_period)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect failed database connects
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxFailedConnects")
    def max_failed_connects(self) -> Optional[int]:
        """
        Threshold
        """
        return pulumi.get(self, "max_failed_connects")

    @property
    @pulumi.getter(name="timePeriod")
    def time_period(self) -> Optional[int]:
        """
        Time span
        """
        return pulumi.get(self, "time_period")


@pulumi.output_type
class DatabaseAnomaliesV2FailureRate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDetection":
            suggest = "auto_detection"
        elif key == "detectionMode":
            suggest = "detection_mode"
        elif key == "fixedDetection":
            suggest = "fixed_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2FailureRate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2FailureRate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2FailureRate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 auto_detection: Optional['outputs.DatabaseAnomaliesV2FailureRateAutoDetection'] = None,
                 detection_mode: Optional[str] = None,
                 fixed_detection: Optional['outputs.DatabaseAnomaliesV2FailureRateFixedDetection'] = None):
        """
        :param bool enabled: Detect increases in failure rate
        :param 'DatabaseAnomaliesV2FailureRateAutoDetectionArgs' auto_detection: Alert if the percentage of failing service calls increases by **both** the absolute and relative thresholds:
        :param str detection_mode: Detection mode for increases in failure rate
        :param 'DatabaseAnomaliesV2FailureRateFixedDetectionArgs' fixed_detection: Alert if a given failure rate is exceeded during any 5-minute-period
        """
        pulumi.set(__self__, "enabled", enabled)
        if auto_detection is not None:
            pulumi.set(__self__, "auto_detection", auto_detection)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if fixed_detection is not None:
            pulumi.set(__self__, "fixed_detection", fixed_detection)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect increases in failure rate
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="autoDetection")
    def auto_detection(self) -> Optional['outputs.DatabaseAnomaliesV2FailureRateAutoDetection']:
        """
        Alert if the percentage of failing service calls increases by **both** the absolute and relative thresholds:
        """
        return pulumi.get(self, "auto_detection")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for increases in failure rate
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter(name="fixedDetection")
    def fixed_detection(self) -> Optional['outputs.DatabaseAnomaliesV2FailureRateFixedDetection']:
        """
        Alert if a given failure rate is exceeded during any 5-minute-period
        """
        return pulumi.get(self, "fixed_detection")


@pulumi.output_type
class DatabaseAnomaliesV2FailureRateAutoDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "absoluteIncrease":
            suggest = "absolute_increase"
        elif key == "overAlertingProtection":
            suggest = "over_alerting_protection"
        elif key == "relativeIncrease":
            suggest = "relative_increase"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2FailureRateAutoDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2FailureRateAutoDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2FailureRateAutoDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 absolute_increase: float,
                 over_alerting_protection: 'outputs.DatabaseAnomaliesV2FailureRateAutoDetectionOverAlertingProtection',
                 relative_increase: float):
        """
        :param float absolute_increase: Absolute threshold
        :param 'DatabaseAnomaliesV2FailureRateAutoDetectionOverAlertingProtectionArgs' over_alerting_protection: Avoid over-alerting
        :param float relative_increase: Relative threshold
        """
        pulumi.set(__self__, "absolute_increase", absolute_increase)
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "relative_increase", relative_increase)

    @property
    @pulumi.getter(name="absoluteIncrease")
    def absolute_increase(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "absolute_increase")

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.DatabaseAnomaliesV2FailureRateAutoDetectionOverAlertingProtection':
        """
        Avoid over-alerting
        """
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter(name="relativeIncrease")
    def relative_increase(self) -> float:
        """
        Relative threshold
        """
        return pulumi.get(self, "relative_increase")


@pulumi.output_type
class DatabaseAnomaliesV2FailureRateAutoDetectionOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"
        elif key == "requestsPerMinute":
            suggest = "requests_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2FailureRateAutoDetectionOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2FailureRateAutoDetectionOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2FailureRateAutoDetectionOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_abnormal_state: int,
                 requests_per_minute: float):
        """
        :param int minutes_abnormal_state: Only alert if the abnormal state remains for at least
        :param float requests_per_minute: Only alert if there are at least
        """
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)
        pulumi.set(__self__, "requests_per_minute", requests_per_minute)

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> int:
        """
        Only alert if the abnormal state remains for at least
        """
        return pulumi.get(self, "minutes_abnormal_state")

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> float:
        """
        Only alert if there are at least
        """
        return pulumi.get(self, "requests_per_minute")


@pulumi.output_type
class DatabaseAnomaliesV2FailureRateFixedDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overAlertingProtection":
            suggest = "over_alerting_protection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2FailureRateFixedDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2FailureRateFixedDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2FailureRateFixedDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 over_alerting_protection: 'outputs.DatabaseAnomaliesV2FailureRateFixedDetectionOverAlertingProtection',
                 sensitivity: str,
                 threshold: float):
        """
        :param 'DatabaseAnomaliesV2FailureRateFixedDetectionOverAlertingProtectionArgs' over_alerting_protection: Avoid over-alerting
        :param str sensitivity: no documentation available
        :param float threshold: no documentation available
        """
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.DatabaseAnomaliesV2FailureRateFixedDetectionOverAlertingProtection':
        """
        Avoid over-alerting
        """
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        no documentation available
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class DatabaseAnomaliesV2FailureRateFixedDetectionOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"
        elif key == "requestsPerMinute":
            suggest = "requests_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2FailureRateFixedDetectionOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2FailureRateFixedDetectionOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2FailureRateFixedDetectionOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_abnormal_state: int,
                 requests_per_minute: float):
        """
        :param int minutes_abnormal_state: Only alert if the abnormal state remains for at least
        :param float requests_per_minute: Only alert if there are at least
        """
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)
        pulumi.set(__self__, "requests_per_minute", requests_per_minute)

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> int:
        """
        Only alert if the abnormal state remains for at least
        """
        return pulumi.get(self, "minutes_abnormal_state")

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> float:
        """
        Only alert if there are at least
        """
        return pulumi.get(self, "requests_per_minute")


@pulumi.output_type
class DatabaseAnomaliesV2LoadDrops(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadDropPercent":
            suggest = "load_drop_percent"
        elif key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2LoadDrops. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2LoadDrops.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2LoadDrops.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 load_drop_percent: Optional[float] = None,
                 minutes_abnormal_state: Optional[int] = None):
        """
        :param bool enabled: Detect service load drops
        :param float load_drop_percent: Threshold
        :param int minutes_abnormal_state: Time span
        """
        pulumi.set(__self__, "enabled", enabled)
        if load_drop_percent is not None:
            pulumi.set(__self__, "load_drop_percent", load_drop_percent)
        if minutes_abnormal_state is not None:
            pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect service load drops
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="loadDropPercent")
    def load_drop_percent(self) -> Optional[float]:
        """
        Threshold
        """
        return pulumi.get(self, "load_drop_percent")

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> Optional[int]:
        """
        Time span
        """
        return pulumi.get(self, "minutes_abnormal_state")


@pulumi.output_type
class DatabaseAnomaliesV2LoadSpikes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadSpikePercent":
            suggest = "load_spike_percent"
        elif key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2LoadSpikes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2LoadSpikes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2LoadSpikes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 load_spike_percent: Optional[float] = None,
                 minutes_abnormal_state: Optional[int] = None):
        """
        :param bool enabled: Detect service load spikes
        :param float load_spike_percent: Threshold
        :param int minutes_abnormal_state: Time span
        """
        pulumi.set(__self__, "enabled", enabled)
        if load_spike_percent is not None:
            pulumi.set(__self__, "load_spike_percent", load_spike_percent)
        if minutes_abnormal_state is not None:
            pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect service load spikes
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="loadSpikePercent")
    def load_spike_percent(self) -> Optional[float]:
        """
        Threshold
        """
        return pulumi.get(self, "load_spike_percent")

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> Optional[int]:
        """
        Time span
        """
        return pulumi.get(self, "minutes_abnormal_state")


@pulumi.output_type
class DatabaseAnomaliesV2ResponseTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDetection":
            suggest = "auto_detection"
        elif key == "detectionMode":
            suggest = "detection_mode"
        elif key == "fixedDetection":
            suggest = "fixed_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2ResponseTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2ResponseTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2ResponseTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 auto_detection: Optional['outputs.DatabaseAnomaliesV2ResponseTimeAutoDetection'] = None,
                 detection_mode: Optional[str] = None,
                 fixed_detection: Optional['outputs.DatabaseAnomaliesV2ResponseTimeFixedDetection'] = None):
        """
        :param bool enabled: Detect response time degradations
        :param 'DatabaseAnomaliesV2ResponseTimeAutoDetectionArgs' auto_detection: no documentation available
        :param str detection_mode: Detection mode for response time degradations
        :param 'DatabaseAnomaliesV2ResponseTimeFixedDetectionArgs' fixed_detection: no documentation available
        """
        pulumi.set(__self__, "enabled", enabled)
        if auto_detection is not None:
            pulumi.set(__self__, "auto_detection", auto_detection)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if fixed_detection is not None:
            pulumi.set(__self__, "fixed_detection", fixed_detection)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect response time degradations
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="autoDetection")
    def auto_detection(self) -> Optional['outputs.DatabaseAnomaliesV2ResponseTimeAutoDetection']:
        """
        no documentation available
        """
        return pulumi.get(self, "auto_detection")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for response time degradations
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter(name="fixedDetection")
    def fixed_detection(self) -> Optional['outputs.DatabaseAnomaliesV2ResponseTimeFixedDetection']:
        """
        no documentation available
        """
        return pulumi.get(self, "fixed_detection")


@pulumi.output_type
class DatabaseAnomaliesV2ResponseTimeAutoDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overAlertingProtection":
            suggest = "over_alerting_protection"
        elif key == "responseTimeAll":
            suggest = "response_time_all"
        elif key == "responseTimeSlowest":
            suggest = "response_time_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2ResponseTimeAutoDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2ResponseTimeAutoDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2ResponseTimeAutoDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 over_alerting_protection: 'outputs.DatabaseAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection',
                 response_time_all: 'outputs.DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll',
                 response_time_slowest: 'outputs.DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest'):
        """
        :param 'DatabaseAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtectionArgs' over_alerting_protection: Avoid over-alerting
        :param 'DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeAllArgs' response_time_all: Alert if the median response time of all requests degrades beyond **both** the absolute and relative thresholds:
        :param 'DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowestArgs' response_time_slowest: Alert if the response time of the slowest 10% of requests degrades beyond **both** the absolute and relative thresholds:
        """
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "response_time_all", response_time_all)
        pulumi.set(__self__, "response_time_slowest", response_time_slowest)

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.DatabaseAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection':
        """
        Avoid over-alerting
        """
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter(name="responseTimeAll")
    def response_time_all(self) -> 'outputs.DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll':
        """
        Alert if the median response time of all requests degrades beyond **both** the absolute and relative thresholds:
        """
        return pulumi.get(self, "response_time_all")

    @property
    @pulumi.getter(name="responseTimeSlowest")
    def response_time_slowest(self) -> 'outputs.DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest':
        """
        Alert if the response time of the slowest 10% of requests degrades beyond **both** the absolute and relative thresholds:
        """
        return pulumi.get(self, "response_time_slowest")


@pulumi.output_type
class DatabaseAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"
        elif key == "requestsPerMinute":
            suggest = "requests_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_abnormal_state: int,
                 requests_per_minute: float):
        """
        :param int minutes_abnormal_state: Only alert if the abnormal state remains for at least
        :param float requests_per_minute: Only alert if there are at least
        """
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)
        pulumi.set(__self__, "requests_per_minute", requests_per_minute)

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> int:
        """
        Only alert if the abnormal state remains for at least
        """
        return pulumi.get(self, "minutes_abnormal_state")

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> float:
        """
        Only alert if there are at least
        """
        return pulumi.get(self, "requests_per_minute")


@pulumi.output_type
class DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "degradationMilliseconds":
            suggest = "degradation_milliseconds"
        elif key == "degradationPercent":
            suggest = "degradation_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 degradation_milliseconds: float,
                 degradation_percent: float):
        """
        :param float degradation_milliseconds: Absolute threshold
        :param float degradation_percent: Relative threshold
        """
        pulumi.set(__self__, "degradation_milliseconds", degradation_milliseconds)
        pulumi.set(__self__, "degradation_percent", degradation_percent)

    @property
    @pulumi.getter(name="degradationMilliseconds")
    def degradation_milliseconds(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "degradation_milliseconds")

    @property
    @pulumi.getter(name="degradationPercent")
    def degradation_percent(self) -> float:
        """
        Relative threshold
        """
        return pulumi.get(self, "degradation_percent")


@pulumi.output_type
class DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestDegradationMilliseconds":
            suggest = "slowest_degradation_milliseconds"
        elif key == "slowestDegradationPercent":
            suggest = "slowest_degradation_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slowest_degradation_milliseconds: float,
                 slowest_degradation_percent: float):
        """
        :param float slowest_degradation_milliseconds: Absolute threshold
        :param float slowest_degradation_percent: Relative threshold
        """
        pulumi.set(__self__, "slowest_degradation_milliseconds", slowest_degradation_milliseconds)
        pulumi.set(__self__, "slowest_degradation_percent", slowest_degradation_percent)

    @property
    @pulumi.getter(name="slowestDegradationMilliseconds")
    def slowest_degradation_milliseconds(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "slowest_degradation_milliseconds")

    @property
    @pulumi.getter(name="slowestDegradationPercent")
    def slowest_degradation_percent(self) -> float:
        """
        Relative threshold
        """
        return pulumi.get(self, "slowest_degradation_percent")


@pulumi.output_type
class DatabaseAnomaliesV2ResponseTimeFixedDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overAlertingProtection":
            suggest = "over_alerting_protection"
        elif key == "responseTimeAll":
            suggest = "response_time_all"
        elif key == "responseTimeSlowest":
            suggest = "response_time_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2ResponseTimeFixedDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2ResponseTimeFixedDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2ResponseTimeFixedDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 over_alerting_protection: 'outputs.DatabaseAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection',
                 response_time_all: 'outputs.DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll',
                 response_time_slowest: 'outputs.DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest',
                 sensitivity: str):
        """
        :param 'DatabaseAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtectionArgs' over_alerting_protection: Avoid over-alerting
        :param 'DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeAllArgs' response_time_all: Alert if the median response time of all requests degrades beyond this threshold within an observation period of 5 minutes:
        :param 'DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowestArgs' response_time_slowest: Alert if the response time of the slowest 10% of requests degrades beyond this threshold within an observation period of 5 minutes:
        :param str sensitivity: no documentation available
        """
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "response_time_all", response_time_all)
        pulumi.set(__self__, "response_time_slowest", response_time_slowest)
        pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.DatabaseAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection':
        """
        Avoid over-alerting
        """
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter(name="responseTimeAll")
    def response_time_all(self) -> 'outputs.DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll':
        """
        Alert if the median response time of all requests degrades beyond this threshold within an observation period of 5 minutes:
        """
        return pulumi.get(self, "response_time_all")

    @property
    @pulumi.getter(name="responseTimeSlowest")
    def response_time_slowest(self) -> 'outputs.DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest':
        """
        Alert if the response time of the slowest 10% of requests degrades beyond this threshold within an observation period of 5 minutes:
        """
        return pulumi.get(self, "response_time_slowest")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class DatabaseAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"
        elif key == "requestsPerMinute":
            suggest = "requests_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_abnormal_state: int,
                 requests_per_minute: float):
        """
        :param int minutes_abnormal_state: Only alert if the abnormal state remains for at least
        :param float requests_per_minute: Only alert if there are at least
        """
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)
        pulumi.set(__self__, "requests_per_minute", requests_per_minute)

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> int:
        """
        Only alert if the abnormal state remains for at least
        """
        return pulumi.get(self, "minutes_abnormal_state")

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> float:
        """
        Only alert if there are at least
        """
        return pulumi.get(self, "requests_per_minute")


@pulumi.output_type
class DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "degradationMilliseconds":
            suggest = "degradation_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 degradation_milliseconds: float):
        """
        :param float degradation_milliseconds: Threshold
        """
        pulumi.set(__self__, "degradation_milliseconds", degradation_milliseconds)

    @property
    @pulumi.getter(name="degradationMilliseconds")
    def degradation_milliseconds(self) -> float:
        """
        Threshold
        """
        return pulumi.get(self, "degradation_milliseconds")


@pulumi.output_type
class DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestDegradationMilliseconds":
            suggest = "slowest_degradation_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slowest_degradation_milliseconds: float):
        """
        :param float slowest_degradation_milliseconds: Threshold
        """
        pulumi.set(__self__, "slowest_degradation_milliseconds", slowest_degradation_milliseconds)

    @property
    @pulumi.getter(name="slowestDegradationMilliseconds")
    def slowest_degradation_milliseconds(self) -> float:
        """
        Threshold
        """
        return pulumi.get(self, "slowest_degradation_milliseconds")


@pulumi.output_type
class DavisAnomalyDetectorsAnalyzer(dict):
    def __init__(__self__, *,
                 name: str,
                 input: Optional['outputs.DavisAnomalyDetectorsAnalyzerInput'] = None):
        """
        :param str name: Fully qualified name of the analyzer
        :param 'DavisAnomalyDetectorsAnalyzerInputArgs' input: Input fields for the specified analyzer
        """
        pulumi.set(__self__, "name", name)
        if input is not None:
            pulumi.set(__self__, "input", input)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Fully qualified name of the analyzer
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.DavisAnomalyDetectorsAnalyzerInput']:
        """
        Input fields for the specified analyzer
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class DavisAnomalyDetectorsAnalyzerInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "analyzerInputFields":
            suggest = "analyzer_input_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DavisAnomalyDetectorsAnalyzerInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DavisAnomalyDetectorsAnalyzerInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DavisAnomalyDetectorsAnalyzerInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 analyzer_input_fields: Sequence['outputs.DavisAnomalyDetectorsAnalyzerInputAnalyzerInputField']):
        pulumi.set(__self__, "analyzer_input_fields", analyzer_input_fields)

    @property
    @pulumi.getter(name="analyzerInputFields")
    def analyzer_input_fields(self) -> Sequence['outputs.DavisAnomalyDetectorsAnalyzerInputAnalyzerInputField']:
        return pulumi.get(self, "analyzer_input_fields")


@pulumi.output_type
class DavisAnomalyDetectorsAnalyzerInputAnalyzerInputField(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: no documentation available
        :param str value: no documentation available
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DavisAnomalyDetectorsEventTemplate(dict):
    def __init__(__self__, *,
                 properties: Optional['outputs.DavisAnomalyDetectorsEventTemplateProperties'] = None):
        """
        :param 'DavisAnomalyDetectorsEventTemplatePropertiesArgs' properties: Set of additional key-value properties to be attached to the triggered event.
        """
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.DavisAnomalyDetectorsEventTemplateProperties']:
        """
        Set of additional key-value properties to be attached to the triggered event.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class DavisAnomalyDetectorsEventTemplateProperties(dict):
    def __init__(__self__, *,
                 properties: Sequence['outputs.DavisAnomalyDetectorsEventTemplatePropertiesProperty']):
        pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def properties(self) -> Sequence['outputs.DavisAnomalyDetectorsEventTemplatePropertiesProperty']:
        return pulumi.get(self, "properties")


@pulumi.output_type
class DavisAnomalyDetectorsEventTemplatePropertiesProperty(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: no documentation available
        :param str value: no documentation available
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DavisAnomalyDetectorsExecutionSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryOffset":
            suggest = "query_offset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DavisAnomalyDetectorsExecutionSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DavisAnomalyDetectorsExecutionSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DavisAnomalyDetectorsExecutionSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_offset: Optional[int] = None):
        """
        :param int query_offset: Minute offset of sliding evaluation window for metrics with latency
        """
        if query_offset is not None:
            pulumi.set(__self__, "query_offset", query_offset)

    @property
    @pulumi.getter(name="queryOffset")
    def query_offset(self) -> Optional[int]:
        """
        Minute offset of sliding evaluation window for metrics with latency
        """
        return pulumi.get(self, "query_offset")


@pulumi.output_type
class DavisCopilotBlocklistEntries(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blocklistEntries":
            suggest = "blocklist_entries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DavisCopilotBlocklistEntries. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DavisCopilotBlocklistEntries.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DavisCopilotBlocklistEntries.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blocklist_entries: Sequence['outputs.DavisCopilotBlocklistEntriesBlocklistEntry']):
        pulumi.set(__self__, "blocklist_entries", blocklist_entries)

    @property
    @pulumi.getter(name="blocklistEntries")
    def blocklist_entries(self) -> Sequence['outputs.DavisCopilotBlocklistEntriesBlocklistEntry']:
        return pulumi.get(self, "blocklist_entries")


@pulumi.output_type
class DavisCopilotBlocklistEntriesBlocklistEntry(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: no documentation available
        :param str type: Possible Values: `BUCKET`, `TABLE`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `BUCKET`, `TABLE`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DduPoolEvents(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 type: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param bool enabled: Is the limit configuration enabled
        :param str type: Type of the limit applied: MONTHLY or ANNUAL
        :param int value: Value of the DDU limit applied for provided timerange
        """
        pulumi.set(__self__, "enabled", enabled)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the limit configuration enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the limit applied: MONTHLY or ANNUAL
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        Value of the DDU limit applied for provided timerange
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DduPoolLogMonitoring(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 type: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param bool enabled: Is the limit configuration enabled
        :param str type: Type of the limit applied: MONTHLY or ANNUAL
        :param int value: Value of the DDU limit applied for provided timerange
        """
        pulumi.set(__self__, "enabled", enabled)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the limit configuration enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the limit applied: MONTHLY or ANNUAL
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        Value of the DDU limit applied for provided timerange
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DduPoolMetrics(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 type: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param bool enabled: Is the limit configuration enabled
        :param str type: Type of the limit applied: MONTHLY or ANNUAL
        :param int value: Value of the DDU limit applied for provided timerange
        """
        pulumi.set(__self__, "enabled", enabled)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the limit configuration enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the limit applied: MONTHLY or ANNUAL
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        Value of the DDU limit applied for provided timerange
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DduPoolServerless(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 type: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param bool enabled: Is the limit configuration enabled
        :param str type: Type of the limit applied: MONTHLY or ANNUAL
        :param int value: Value of the DDU limit applied for provided timerange
        """
        pulumi.set(__self__, "enabled", enabled)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the limit configuration enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the limit applied: MONTHLY or ANNUAL
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        Value of the DDU limit applied for provided timerange
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DduPoolTraces(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 type: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param bool enabled: Is the limit configuration enabled
        :param str type: Type of the limit applied: MONTHLY or ANNUAL
        :param int value: Value of the DDU limit applied for provided timerange
        """
        pulumi.set(__self__, "enabled", enabled)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the limit configuration enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the limit applied: MONTHLY or ANNUAL
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        Value of the DDU limit applied for provided timerange
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DeclarativeGroupingDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "processDefinitions":
            suggest = "process_definitions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeclarativeGroupingDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeclarativeGroupingDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeclarativeGroupingDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 process_definitions: Sequence['outputs.DeclarativeGroupingDetectionProcessDefinition']):
        pulumi.set(__self__, "process_definitions", process_definitions)

    @property
    @pulumi.getter(name="processDefinitions")
    def process_definitions(self) -> Sequence['outputs.DeclarativeGroupingDetectionProcessDefinition']:
        return pulumi.get(self, "process_definitions")


@pulumi.output_type
class DeclarativeGroupingDetectionProcessDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "processGroupName":
            suggest = "process_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeclarativeGroupingDetectionProcessDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeclarativeGroupingDetectionProcessDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeclarativeGroupingDetectionProcessDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 process_group_name: str,
                 report: str,
                 rules: Optional['outputs.DeclarativeGroupingDetectionProcessDefinitionRules'] = None):
        """
        :param str id: Process group identifier
        :param str process_group_name: This identifier is used by Dynatrace to recognize this process group.
        :param str report: Possible Values: `never`, `always`, `highResourceUsage`
        :param 'DeclarativeGroupingDetectionProcessDefinitionRulesArgs' rules: Define process detection rules by selecting a process property and a condition. Each process group can have multiple detection rules associated with it.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "process_group_name", process_group_name)
        pulumi.set(__self__, "report", report)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Process group identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="processGroupName")
    def process_group_name(self) -> str:
        """
        This identifier is used by Dynatrace to recognize this process group.
        """
        return pulumi.get(self, "process_group_name")

    @property
    @pulumi.getter
    def report(self) -> str:
        """
        Possible Values: `never`, `always`, `highResourceUsage`
        """
        return pulumi.get(self, "report")

    @property
    @pulumi.getter
    def rules(self) -> Optional['outputs.DeclarativeGroupingDetectionProcessDefinitionRules']:
        """
        Define process detection rules by selecting a process property and a condition. Each process group can have multiple detection rules associated with it.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class DeclarativeGroupingDetectionProcessDefinitionRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.DeclarativeGroupingDetectionProcessDefinitionRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.DeclarativeGroupingDetectionProcessDefinitionRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class DeclarativeGroupingDetectionProcessDefinitionRulesRule(dict):
    def __init__(__self__, *,
                 condition: str,
                 property: str):
        """
        :param str condition: - $contains(svc) – Matches if svc appears anywhere in the process property value.
               - $eq(svc.exe) – Matches if svc.exe matches the process property value exactly.
               - $prefix(svc) – Matches if app matches the prefix of the process property value.
               - $suffix(svc.py) – Matches if svc.py matches the suffix of the process property value.
               
               For example, $suffix(svc.py) would detect processes named loyaltysvc.py and paymentssvc.py.
               
               For more details, see [Declarative process grouping](https://dt-url.net/j142w57).
        :param str property: Possible Values: `Executable`, `ExecutablePath`, `CommandLine`
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "property", property)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        - $contains(svc) – Matches if svc appears anywhere in the process property value.
        - $eq(svc.exe) – Matches if svc.exe matches the process property value exactly.
        - $prefix(svc) – Matches if app matches the prefix of the process property value.
        - $suffix(svc.py) – Matches if svc.py matches the suffix of the process property value.

        For example, $suffix(svc.py) would detect processes named loyaltysvc.py and paymentssvc.py.

        For more details, see [Declarative process grouping](https://dt-url.net/j142w57).
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def property(self) -> str:
        """
        Possible Values: `Executable`, `ExecutablePath`, `CommandLine`
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class DirectSharesRecipients(dict):
    def __init__(__self__, *,
                 recipients: Optional[Sequence['outputs.DirectSharesRecipientsRecipient']] = None):
        """
        :param Sequence['DirectSharesRecipientsRecipientArgs'] recipients: Recipient of the direct share
        """
        if recipients is not None:
            pulumi.set(__self__, "recipients", recipients)

    @property
    @pulumi.getter
    def recipients(self) -> Optional[Sequence['outputs.DirectSharesRecipientsRecipient']]:
        """
        Recipient of the direct share
        """
        return pulumi.get(self, "recipients")


@pulumi.output_type
class DirectSharesRecipientsRecipient(dict):
    def __init__(__self__, *,
                 id: str,
                 type: Optional[str] = None):
        """
        :param str id: Identifier of the recipient
        :param str type: Type of the recipient. Possible values are `group' and`user'
        """
        pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of the recipient
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the recipient. Possible values are `group' and`user'
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DiscoveryDefaultRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentScope":
            suggest = "environment_scope"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiscoveryDefaultRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiscoveryDefaultRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiscoveryDefaultRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: str,
                 description: str,
                 environment_scope: bool,
                 id: str,
                 priority: str,
                 query: str,
                 title: str,
                 actions: Optional['outputs.DiscoveryDefaultRulesRuleActions'] = None):
        """
        :param str category: no documentation available
        :param str description: no documentation available
        :param bool environment_scope: Environment scope
        :param str id: no documentation available
        :param str priority: no documentation available
        :param str query: Rule query
        :param str title: no documentation available
        :param 'DiscoveryDefaultRulesRuleActionsArgs' actions: no documentation available
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "environment_scope", environment_scope)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "title", title)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="environmentScope")
    def environment_scope(self) -> bool:
        """
        Environment scope
        """
        return pulumi.get(self, "environment_scope")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def priority(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Rule query
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.DiscoveryDefaultRulesRuleActions']:
        """
        no documentation available
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class DiscoveryDefaultRulesRuleActions(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.DiscoveryDefaultRulesRuleActionsAction']):
        pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.DiscoveryDefaultRulesRuleActionsAction']:
        return pulumi.get(self, "actions")


@pulumi.output_type
class DiscoveryDefaultRulesRuleActionsAction(dict):
    def __init__(__self__, *,
                 name: str,
                 parameters: Optional['outputs.DiscoveryDefaultRulesRuleActionsActionParameters'] = None):
        """
        :param str name: no documentation available
        :param 'DiscoveryDefaultRulesRuleActionsActionParametersArgs' parameters: no documentation available
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional['outputs.DiscoveryDefaultRulesRuleActionsActionParameters']:
        """
        no documentation available
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DiscoveryDefaultRulesRuleActionsActionParameters(dict):
    def __init__(__self__, *,
                 parameters: Sequence['outputs.DiscoveryDefaultRulesRuleActionsActionParametersParameter']):
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def parameters(self) -> Sequence['outputs.DiscoveryDefaultRulesRuleActionsActionParametersParameter']:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DiscoveryDefaultRulesRuleActionsActionParametersParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: no documentation available
        :param str value: no documentation available
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DiscoveryDefaultRulesSettings(dict):
    def __init__(__self__, *,
                 muted: bool):
        """
        :param bool muted: no documentation available
        """
        pulumi.set(__self__, "muted", muted)

    @property
    @pulumi.getter
    def muted(self) -> bool:
        """
        no documentation available
        """
        return pulumi.get(self, "muted")


@pulumi.output_type
class DiskAnomaliesDiskName(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        """
        :param str operator: Possible values are: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_EQUAL`, `DOES_NOT_START_WITH`, `EQUALS` and `STARTS_WITH`
        :param str value: Value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Possible values are: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_EQUAL`, `DOES_NOT_START_WITH`, `EQUALS` and `STARTS_WITH`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DiskAnomaliesTags(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.DiskAnomaliesTagsFilter']] = None):
        """
        :param Sequence['DiskAnomaliesTagsFilterArgs'] filters: A Tag Filter
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.DiskAnomaliesTagsFilter']]:
        """
        A Tag Filter
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class DiskAnomaliesTagsFilter(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DiskAnomaliesV2Disk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskLowInodesDetection":
            suggest = "disk_low_inodes_detection"
        elif key == "diskLowSpaceDetection":
            suggest = "disk_low_space_detection"
        elif key == "diskSlowWritesAndReadsDetection":
            suggest = "disk_slow_writes_and_reads_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskAnomaliesV2Disk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskAnomaliesV2Disk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskAnomaliesV2Disk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_low_inodes_detection: 'outputs.DiskAnomaliesV2DiskDiskLowInodesDetection',
                 disk_low_space_detection: 'outputs.DiskAnomaliesV2DiskDiskLowSpaceDetection',
                 disk_slow_writes_and_reads_detection: 'outputs.DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetection'):
        """
        :param 'DiskAnomaliesV2DiskDiskLowInodesDetectionArgs' disk_low_inodes_detection: no documentation available
        :param 'DiskAnomaliesV2DiskDiskLowSpaceDetectionArgs' disk_low_space_detection: no documentation available
        :param 'DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionArgs' disk_slow_writes_and_reads_detection: no documentation available
        """
        pulumi.set(__self__, "disk_low_inodes_detection", disk_low_inodes_detection)
        pulumi.set(__self__, "disk_low_space_detection", disk_low_space_detection)
        pulumi.set(__self__, "disk_slow_writes_and_reads_detection", disk_slow_writes_and_reads_detection)

    @property
    @pulumi.getter(name="diskLowInodesDetection")
    def disk_low_inodes_detection(self) -> 'outputs.DiskAnomaliesV2DiskDiskLowInodesDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "disk_low_inodes_detection")

    @property
    @pulumi.getter(name="diskLowSpaceDetection")
    def disk_low_space_detection(self) -> 'outputs.DiskAnomaliesV2DiskDiskLowSpaceDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "disk_low_space_detection")

    @property
    @pulumi.getter(name="diskSlowWritesAndReadsDetection")
    def disk_slow_writes_and_reads_detection(self) -> 'outputs.DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "disk_slow_writes_and_reads_detection")


@pulumi.output_type
class DiskAnomaliesV2DiskDiskLowInodesDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskAnomaliesV2DiskDiskLowInodesDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskAnomaliesV2DiskDiskLowInodesDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskAnomaliesV2DiskDiskLowInodesDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.DiskAnomaliesV2DiskDiskLowInodesDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: Detect low inodes number available
        :param 'DiskAnomaliesV2DiskDiskLowInodesDetectionCustomThresholdsArgs' custom_thresholds: no documentation available
        :param str detection_mode: Detection mode for low inodes number available
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect low inodes number available
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.DiskAnomaliesV2DiskDiskLowInodesDetectionCustomThresholds']:
        """
        no documentation available
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for low inodes number available
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class DiskAnomaliesV2DiskDiskLowInodesDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeInodesPercentage":
            suggest = "free_inodes_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskAnomaliesV2DiskDiskLowInodesDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskAnomaliesV2DiskDiskLowInodesDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskAnomaliesV2DiskDiskLowInodesDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_inodes_percentage: int):
        """
        :param int free_inodes_percentage: Alert if the percentage of available inodes is lower than this threshold in 3 out of 5 samples
        """
        pulumi.set(__self__, "free_inodes_percentage", free_inodes_percentage)

    @property
    @pulumi.getter(name="freeInodesPercentage")
    def free_inodes_percentage(self) -> int:
        """
        Alert if the percentage of available inodes is lower than this threshold in 3 out of 5 samples
        """
        return pulumi.get(self, "free_inodes_percentage")


@pulumi.output_type
class DiskAnomaliesV2DiskDiskLowSpaceDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskAnomaliesV2DiskDiskLowSpaceDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskAnomaliesV2DiskDiskLowSpaceDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskAnomaliesV2DiskDiskLowSpaceDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.DiskAnomaliesV2DiskDiskLowSpaceDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: Detect low disk space
        :param 'DiskAnomaliesV2DiskDiskLowSpaceDetectionCustomThresholdsArgs' custom_thresholds: no documentation available
        :param str detection_mode: Detection mode for low disk space
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect low disk space
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.DiskAnomaliesV2DiskDiskLowSpaceDetectionCustomThresholds']:
        """
        no documentation available
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for low disk space
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class DiskAnomaliesV2DiskDiskLowSpaceDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeSpacePercentage":
            suggest = "free_space_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskAnomaliesV2DiskDiskLowSpaceDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskAnomaliesV2DiskDiskLowSpaceDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskAnomaliesV2DiskDiskLowSpaceDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_space_percentage: int):
        """
        :param int free_space_percentage: Alert if free disk space is lower than this percentage in 3 out of 5 samples
        """
        pulumi.set(__self__, "free_space_percentage", free_space_percentage)

    @property
    @pulumi.getter(name="freeSpacePercentage")
    def free_space_percentage(self) -> int:
        """
        Alert if free disk space is lower than this percentage in 3 out of 5 samples
        """
        return pulumi.get(self, "free_space_percentage")


@pulumi.output_type
class DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: Detect slow-running disks
        :param 'DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionCustomThresholdsArgs' custom_thresholds: no documentation available
        :param str detection_mode: Detection mode for slow running disks
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect slow-running disks
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionCustomThresholds']:
        """
        no documentation available
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for slow running disks
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "writeAndReadTime":
            suggest = "write_and_read_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 write_and_read_time: int):
        """
        :param int write_and_read_time: Alert if disk read time or write time is higher than this threshold in 3 out of 5 samples
        """
        pulumi.set(__self__, "write_and_read_time", write_and_read_time)

    @property
    @pulumi.getter(name="writeAndReadTime")
    def write_and_read_time(self) -> int:
        """
        Alert if disk read time or write time is higher than this threshold in 3 out of 5 samples
        """
        return pulumi.get(self, "write_and_read_time")


@pulumi.output_type
class DiskAnomalyRulesDiskNameFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: Optional[str] = None):
        """
        :param str operator: Possible Values: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_EQUAL`, `DOES_NOT_START_WITH`, `EQUALS`, `STARTS_WITH`
        :param str value: Matching text
        """
        pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Possible Values: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_EQUAL`, `DOES_NOT_START_WITH`, `EQUALS`, `STARTS_WITH`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Matching text
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DiskAnomalyRulesSampleLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskAnomalyRulesSampleLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskAnomalyRulesSampleLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskAnomalyRulesSampleLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 samples: int,
                 violating_samples: int):
        """
        :param int samples: .. within the last
        :param int violating_samples: Minimum number of violating samples
        """
        pulumi.set(__self__, "samples", samples)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter
    def samples(self) -> int:
        """
        .. within the last
        """
        return pulumi.get(self, "samples")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        Minimum number of violating samples
        """
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class DiskEdgeAnomalyDetectorsAlerts(dict):
    def __init__(__self__, *,
                 alerts: Sequence['outputs.DiskEdgeAnomalyDetectorsAlertsAlert']):
        pulumi.set(__self__, "alerts", alerts)

    @property
    @pulumi.getter
    def alerts(self) -> Sequence['outputs.DiskEdgeAnomalyDetectorsAlertsAlert']:
        return pulumi.get(self, "alerts")


@pulumi.output_type
class DiskEdgeAnomalyDetectorsAlertsAlert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sampleCountThresholds":
            suggest = "sample_count_thresholds"
        elif key == "sampleCountThresholdsImmediately":
            suggest = "sample_count_thresholds_immediately"
        elif key == "thresholdMebibytes":
            suggest = "threshold_mebibytes"
        elif key == "thresholdMilliseconds":
            suggest = "threshold_milliseconds"
        elif key == "thresholdNumber":
            suggest = "threshold_number"
        elif key == "thresholdPercent":
            suggest = "threshold_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskEdgeAnomalyDetectorsAlertsAlert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskEdgeAnomalyDetectorsAlertsAlert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskEdgeAnomalyDetectorsAlertsAlert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trigger: str,
                 sample_count_thresholds: Optional['outputs.DiskEdgeAnomalyDetectorsAlertsAlertSampleCountThresholds'] = None,
                 sample_count_thresholds_immediately: Optional['outputs.DiskEdgeAnomalyDetectorsAlertsAlertSampleCountThresholdsImmediately'] = None,
                 threshold_mebibytes: Optional[float] = None,
                 threshold_milliseconds: Optional[float] = None,
                 threshold_number: Optional[float] = None,
                 threshold_percent: Optional[float] = None):
        """
        :param str trigger: Possible Values: `AVAILABLE_DISK_SPACE_MEBIBYTES_BELOW`, `AVAILABLE_DISK_SPACE_PERCENT_BELOW`, `AVAILABLE_INODES_NUMBER_BELOW`, `AVAILABLE_INODES_PERCENT_BELOW`, `READ_ONLY_FILE_SYSTEM`, `READ_TIME_EXCEEDING`, `WRITE_TIME_EXCEEDING`
        :param 'DiskEdgeAnomalyDetectorsAlertsAlertSampleCountThresholdsArgs' sample_count_thresholds: no documentation available
        :param 'DiskEdgeAnomalyDetectorsAlertsAlertSampleCountThresholdsImmediatelyArgs' sample_count_thresholds_immediately: no documentation available
        :param float threshold_mebibytes: no documentation available
        :param float threshold_milliseconds: no documentation available
        :param float threshold_number: no documentation available
        :param float threshold_percent: no documentation available
        """
        pulumi.set(__self__, "trigger", trigger)
        if sample_count_thresholds is not None:
            pulumi.set(__self__, "sample_count_thresholds", sample_count_thresholds)
        if sample_count_thresholds_immediately is not None:
            pulumi.set(__self__, "sample_count_thresholds_immediately", sample_count_thresholds_immediately)
        if threshold_mebibytes is not None:
            pulumi.set(__self__, "threshold_mebibytes", threshold_mebibytes)
        if threshold_milliseconds is not None:
            pulumi.set(__self__, "threshold_milliseconds", threshold_milliseconds)
        if threshold_number is not None:
            pulumi.set(__self__, "threshold_number", threshold_number)
        if threshold_percent is not None:
            pulumi.set(__self__, "threshold_percent", threshold_percent)

    @property
    @pulumi.getter
    def trigger(self) -> str:
        """
        Possible Values: `AVAILABLE_DISK_SPACE_MEBIBYTES_BELOW`, `AVAILABLE_DISK_SPACE_PERCENT_BELOW`, `AVAILABLE_INODES_NUMBER_BELOW`, `AVAILABLE_INODES_PERCENT_BELOW`, `READ_ONLY_FILE_SYSTEM`, `READ_TIME_EXCEEDING`, `WRITE_TIME_EXCEEDING`
        """
        return pulumi.get(self, "trigger")

    @property
    @pulumi.getter(name="sampleCountThresholds")
    def sample_count_thresholds(self) -> Optional['outputs.DiskEdgeAnomalyDetectorsAlertsAlertSampleCountThresholds']:
        """
        no documentation available
        """
        return pulumi.get(self, "sample_count_thresholds")

    @property
    @pulumi.getter(name="sampleCountThresholdsImmediately")
    def sample_count_thresholds_immediately(self) -> Optional['outputs.DiskEdgeAnomalyDetectorsAlertsAlertSampleCountThresholdsImmediately']:
        """
        no documentation available
        """
        return pulumi.get(self, "sample_count_thresholds_immediately")

    @property
    @pulumi.getter(name="thresholdMebibytes")
    def threshold_mebibytes(self) -> Optional[float]:
        """
        no documentation available
        """
        return pulumi.get(self, "threshold_mebibytes")

    @property
    @pulumi.getter(name="thresholdMilliseconds")
    def threshold_milliseconds(self) -> Optional[float]:
        """
        no documentation available
        """
        return pulumi.get(self, "threshold_milliseconds")

    @property
    @pulumi.getter(name="thresholdNumber")
    def threshold_number(self) -> Optional[float]:
        """
        no documentation available
        """
        return pulumi.get(self, "threshold_number")

    @property
    @pulumi.getter(name="thresholdPercent")
    def threshold_percent(self) -> Optional[float]:
        """
        no documentation available
        """
        return pulumi.get(self, "threshold_percent")


@pulumi.output_type
class DiskEdgeAnomalyDetectorsAlertsAlertSampleCountThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskEdgeAnomalyDetectorsAlertsAlertSampleCountThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskEdgeAnomalyDetectorsAlertsAlertSampleCountThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskEdgeAnomalyDetectorsAlertsAlertSampleCountThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        """
        :param int dealerting_evaluation_window: The number of **10-second samples** that form the sliding evaluation window for dealerting.
        :param int dealerting_samples: The number of **10-second samples** within the evaluation window that must be lower than the threshold to close an event
        :param int violating_evaluation_window: The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        :param int violating_samples: The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window for dealerting.
        """
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must be lower than the threshold to close an event
        """
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        """
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class DiskEdgeAnomalyDetectorsAlertsAlertSampleCountThresholdsImmediately(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskEdgeAnomalyDetectorsAlertsAlertSampleCountThresholdsImmediately. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskEdgeAnomalyDetectorsAlertsAlertSampleCountThresholdsImmediately.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskEdgeAnomalyDetectorsAlertsAlertSampleCountThresholdsImmediately.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        """
        :param int dealerting_evaluation_window: The number of **10-second samples** that form the sliding evaluation window for dealerting.
        :param int dealerting_samples: The number of **10-second samples** within the evaluation window that must be lower than the threshold to close an event
        :param int violating_evaluation_window: The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        :param int violating_samples: The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window for dealerting.
        """
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must be lower than the threshold to close an event
        """
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        """
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class DiskEdgeAnomalyDetectorsEventProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventProperties":
            suggest = "event_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskEdgeAnomalyDetectorsEventProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskEdgeAnomalyDetectorsEventProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskEdgeAnomalyDetectorsEventProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_properties: Sequence['outputs.DiskEdgeAnomalyDetectorsEventPropertiesEventProperty']):
        pulumi.set(__self__, "event_properties", event_properties)

    @property
    @pulumi.getter(name="eventProperties")
    def event_properties(self) -> Sequence['outputs.DiskEdgeAnomalyDetectorsEventPropertiesEventProperty']:
        return pulumi.get(self, "event_properties")


@pulumi.output_type
class DiskEdgeAnomalyDetectorsEventPropertiesEventProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataKey":
            suggest = "metadata_key"
        elif key == "metadataValue":
            suggest = "metadata_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskEdgeAnomalyDetectorsEventPropertiesEventProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskEdgeAnomalyDetectorsEventPropertiesEventProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskEdgeAnomalyDetectorsEventPropertiesEventProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_key: str,
                 metadata_value: str):
        """
        :param str metadata_key: Type 'dt.' for key hints.
        :param str metadata_value: no documentation available
        """
        pulumi.set(__self__, "metadata_key", metadata_key)
        pulumi.set(__self__, "metadata_value", metadata_value)

    @property
    @pulumi.getter(name="metadataKey")
    def metadata_key(self) -> str:
        """
        Type 'dt.' for key hints.
        """
        return pulumi.get(self, "metadata_key")

    @property
    @pulumi.getter(name="metadataValue")
    def metadata_value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "metadata_value")


@pulumi.output_type
class DiskEdgeAnomalyDetectorsHostMetadataConditions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostMetadataConditions":
            suggest = "host_metadata_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskEdgeAnomalyDetectorsHostMetadataConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskEdgeAnomalyDetectorsHostMetadataConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskEdgeAnomalyDetectorsHostMetadataConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_metadata_conditions: Sequence['outputs.DiskEdgeAnomalyDetectorsHostMetadataConditionsHostMetadataCondition']):
        pulumi.set(__self__, "host_metadata_conditions", host_metadata_conditions)

    @property
    @pulumi.getter(name="hostMetadataConditions")
    def host_metadata_conditions(self) -> Sequence['outputs.DiskEdgeAnomalyDetectorsHostMetadataConditionsHostMetadataCondition']:
        return pulumi.get(self, "host_metadata_conditions")


@pulumi.output_type
class DiskEdgeAnomalyDetectorsHostMetadataConditionsHostMetadataCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostMetadataCondition":
            suggest = "host_metadata_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskEdgeAnomalyDetectorsHostMetadataConditionsHostMetadataCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskEdgeAnomalyDetectorsHostMetadataConditionsHostMetadataCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskEdgeAnomalyDetectorsHostMetadataConditionsHostMetadataCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_metadata_condition: 'outputs.DiskEdgeAnomalyDetectorsHostMetadataConditionsHostMetadataConditionHostMetadataCondition'):
        """
        :param 'DiskEdgeAnomalyDetectorsHostMetadataConditionsHostMetadataConditionHostMetadataConditionArgs' host_metadata_condition: no documentation available
        """
        pulumi.set(__self__, "host_metadata_condition", host_metadata_condition)

    @property
    @pulumi.getter(name="hostMetadataCondition")
    def host_metadata_condition(self) -> 'outputs.DiskEdgeAnomalyDetectorsHostMetadataConditionsHostMetadataConditionHostMetadataCondition':
        """
        no documentation available
        """
        return pulumi.get(self, "host_metadata_condition")


@pulumi.output_type
class DiskEdgeAnomalyDetectorsHostMetadataConditionsHostMetadataConditionHostMetadataCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataCondition":
            suggest = "metadata_condition"
        elif key == "metadataKey":
            suggest = "metadata_key"
        elif key == "keyMustExist":
            suggest = "key_must_exist"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskEdgeAnomalyDetectorsHostMetadataConditionsHostMetadataConditionHostMetadataCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskEdgeAnomalyDetectorsHostMetadataConditionsHostMetadataConditionHostMetadataCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskEdgeAnomalyDetectorsHostMetadataConditionsHostMetadataConditionHostMetadataCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_condition: str,
                 metadata_key: str,
                 key_must_exist: Optional[bool] = None):
        """
        :param str metadata_condition: This string has to match a required format.
        :param str metadata_key: Key
        :param bool key_must_exist: When enabled, the condition requires a metadata key to exist and match the constraints; when disabled, the key is optional but must still match the constrains if it is present.
        """
        pulumi.set(__self__, "metadata_condition", metadata_condition)
        pulumi.set(__self__, "metadata_key", metadata_key)
        if key_must_exist is not None:
            pulumi.set(__self__, "key_must_exist", key_must_exist)

    @property
    @pulumi.getter(name="metadataCondition")
    def metadata_condition(self) -> str:
        """
        This string has to match a required format.
        """
        return pulumi.get(self, "metadata_condition")

    @property
    @pulumi.getter(name="metadataKey")
    def metadata_key(self) -> str:
        """
        Key
        """
        return pulumi.get(self, "metadata_key")

    @property
    @pulumi.getter(name="keyMustExist")
    def key_must_exist(self) -> Optional[bool]:
        """
        When enabled, the condition requires a metadata key to exist and match the constraints; when disabled, the key is optional but must still match the constrains if it is present.
        """
        return pulumi.get(self, "key_must_exist")


@pulumi.output_type
class DiskOptionsExclusions(dict):
    def __init__(__self__, *,
                 exclusions: Sequence['outputs.DiskOptionsExclusionsExclusion']):
        pulumi.set(__self__, "exclusions", exclusions)

    @property
    @pulumi.getter
    def exclusions(self) -> Sequence['outputs.DiskOptionsExclusionsExclusion']:
        return pulumi.get(self, "exclusions")


@pulumi.output_type
class DiskOptionsExclusionsExclusion(dict):
    def __init__(__self__, *,
                 os: str,
                 filesystem: Optional[str] = None,
                 mountpoint: Optional[str] = None):
        """
        :param str os: Possible Values: `OS_TYPE_AIX`, `OS_TYPE_DARWIN`, `OS_TYPE_HPUX`, `OS_TYPE_LINUX`, `OS_TYPE_SOLARIS`, `OS_TYPE_UNKNOWN`, `OS_TYPE_WINDOWS`, `OS_TYPE_ZOS`
        :param str filesystem: **File system type field:** the type of the file system to be excluded from monitoring. Examples:
               
               * ext4
               * ext3
               * btrfs
               * ext*
               
               ⚠️ Starting from **OneAgent 1.299+** file system types are not case sensitive! 
               
               The wildcard in the last example means to exclude matching file systems such as types ext4 and ext3
        :param str mountpoint: **Disk or mount point path field:** the path to where the disk to be excluded from monitoring is mounted. Examples:
               
               * /mnt/my_disk
               * /staff/emp1
               * C:\\
               * /staff/*
               * /disk*
               
                ⚠️ Mount point paths are case sensitive! 
               
               The wildcard in **/staff/*** means to exclude every child folder of /staff.
               
               The wildcard in **/disk*** means to exclude every mount point starting with /disk, for example /disk1, /disk99,  /diskabc
        """
        pulumi.set(__self__, "os", os)
        if filesystem is not None:
            pulumi.set(__self__, "filesystem", filesystem)
        if mountpoint is not None:
            pulumi.set(__self__, "mountpoint", mountpoint)

    @property
    @pulumi.getter
    def os(self) -> str:
        """
        Possible Values: `OS_TYPE_AIX`, `OS_TYPE_DARWIN`, `OS_TYPE_HPUX`, `OS_TYPE_LINUX`, `OS_TYPE_SOLARIS`, `OS_TYPE_UNKNOWN`, `OS_TYPE_WINDOWS`, `OS_TYPE_ZOS`
        """
        return pulumi.get(self, "os")

    @property
    @pulumi.getter
    def filesystem(self) -> Optional[str]:
        """
        **File system type field:** the type of the file system to be excluded from monitoring. Examples:

        * ext4
        * ext3
        * btrfs
        * ext*

        ⚠️ Starting from **OneAgent 1.299+** file system types are not case sensitive! 

        The wildcard in the last example means to exclude matching file systems such as types ext4 and ext3
        """
        return pulumi.get(self, "filesystem")

    @property
    @pulumi.getter
    def mountpoint(self) -> Optional[str]:
        """
        **Disk or mount point path field:** the path to where the disk to be excluded from monitoring is mounted. Examples:

        * /mnt/my_disk
        * /staff/emp1
        * C:\\
        * /staff/*
        * /disk*

         ⚠️ Mount point paths are case sensitive! 

        The wildcard in **/staff/*** means to exclude every child folder of /staff.

        The wildcard in **/disk*** means to exclude every mount point starting with /disk, for example /disk1, /disk99,  /diskabc
        """
        return pulumi.get(self, "mountpoint")


@pulumi.output_type
class DiskSpecificAnomaliesV2DiskLowInodesDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskSpecificAnomaliesV2DiskLowInodesDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskSpecificAnomaliesV2DiskLowInodesDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskSpecificAnomaliesV2DiskLowInodesDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.DiskSpecificAnomaliesV2DiskLowInodesDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: Detect low inodes number available
        :param 'DiskSpecificAnomaliesV2DiskLowInodesDetectionCustomThresholdsArgs' custom_thresholds: no documentation available
        :param str detection_mode: Detection mode for low inodes number available
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect low inodes number available
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.DiskSpecificAnomaliesV2DiskLowInodesDetectionCustomThresholds']:
        """
        no documentation available
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for low inodes number available
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class DiskSpecificAnomaliesV2DiskLowInodesDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeInodesPercentage":
            suggest = "free_inodes_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskSpecificAnomaliesV2DiskLowInodesDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskSpecificAnomaliesV2DiskLowInodesDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskSpecificAnomaliesV2DiskLowInodesDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_inodes_percentage: int):
        """
        :param int free_inodes_percentage: Alert if the percentage of available inodes is lower than this threshold in 3 out of 5 samples
        """
        pulumi.set(__self__, "free_inodes_percentage", free_inodes_percentage)

    @property
    @pulumi.getter(name="freeInodesPercentage")
    def free_inodes_percentage(self) -> int:
        """
        Alert if the percentage of available inodes is lower than this threshold in 3 out of 5 samples
        """
        return pulumi.get(self, "free_inodes_percentage")


@pulumi.output_type
class DiskSpecificAnomaliesV2DiskLowSpaceDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskSpecificAnomaliesV2DiskLowSpaceDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskSpecificAnomaliesV2DiskLowSpaceDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskSpecificAnomaliesV2DiskLowSpaceDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.DiskSpecificAnomaliesV2DiskLowSpaceDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: Detect low disk space
        :param 'DiskSpecificAnomaliesV2DiskLowSpaceDetectionCustomThresholdsArgs' custom_thresholds: no documentation available
        :param str detection_mode: Detection mode for low disk space
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect low disk space
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.DiskSpecificAnomaliesV2DiskLowSpaceDetectionCustomThresholds']:
        """
        no documentation available
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for low disk space
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class DiskSpecificAnomaliesV2DiskLowSpaceDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeSpacePercentage":
            suggest = "free_space_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskSpecificAnomaliesV2DiskLowSpaceDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskSpecificAnomaliesV2DiskLowSpaceDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskSpecificAnomaliesV2DiskLowSpaceDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_space_percentage: int):
        """
        :param int free_space_percentage: Alert if free disk space is lower than this percentage in 3 out of 5 samples
        """
        pulumi.set(__self__, "free_space_percentage", free_space_percentage)

    @property
    @pulumi.getter(name="freeSpacePercentage")
    def free_space_percentage(self) -> int:
        """
        Alert if free disk space is lower than this percentage in 3 out of 5 samples
        """
        return pulumi.get(self, "free_space_percentage")


@pulumi.output_type
class DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: Detect slow-running disks
        :param 'DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetectionCustomThresholdsArgs' custom_thresholds: no documentation available
        :param str detection_mode: Detection mode for slow running disks
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect slow-running disks
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetectionCustomThresholds']:
        """
        no documentation available
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for slow running disks
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "writeAndReadTime":
            suggest = "write_and_read_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 write_and_read_time: int):
        """
        :param int write_and_read_time: Alert if disk read time or write time is higher than this threshold in 3 out of 5 samples
        """
        pulumi.set(__self__, "write_and_read_time", write_and_read_time)

    @property
    @pulumi.getter(name="writeAndReadTime")
    def write_and_read_time(self) -> int:
        """
        Alert if disk read time or write time is higher than this threshold in 3 out of 5 samples
        """
        return pulumi.get(self, "write_and_read_time")


@pulumi.output_type
class EnvironmentQuotas(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "demUnits":
            suggest = "dem_units"
        elif key == "hostUnits":
            suggest = "host_units"
        elif key == "userSessions":
            suggest = "user_sessions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentQuotas. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentQuotas.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentQuotas.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ddus: Optional['outputs.EnvironmentQuotasDdus'] = None,
                 dem_units: Optional['outputs.EnvironmentQuotasDemUnits'] = None,
                 host_units: Optional[int] = None,
                 logs: Optional['outputs.EnvironmentQuotasLogs'] = None,
                 synthetic: Optional['outputs.EnvironmentQuotasSynthetic'] = None,
                 user_sessions: Optional['outputs.EnvironmentQuotasUserSessions'] = None):
        """
        :param 'EnvironmentQuotasDdusArgs' ddus: Davis Data Units consumption and quota information on environment level. Not set (and not editable) if Davis data units is not enabled
        :param 'EnvironmentQuotasDemUnitsArgs' dem_units: DEM units consumption and quota information on environment level
        :param int host_units: Host units consumption and quota information on environment level
        :param 'EnvironmentQuotasLogsArgs' logs: Log Monitoring consumption and quota information on environment level. Not set (and not editable) if Log monitoring is not enabled. Not set (and not editable) if Log monitoring is migrated to Davis data on license level
        :param 'EnvironmentQuotasSyntheticArgs' synthetic: Synthetic monitors consumption and quota information on environment level. Not set (and not editable) if neither Synthetic nor DEM units is enabled
        :param 'EnvironmentQuotasUserSessionsArgs' user_sessions: User sessions consumption and quota information on environment level
        """
        if ddus is not None:
            pulumi.set(__self__, "ddus", ddus)
        if dem_units is not None:
            pulumi.set(__self__, "dem_units", dem_units)
        if host_units is not None:
            pulumi.set(__self__, "host_units", host_units)
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if synthetic is not None:
            pulumi.set(__self__, "synthetic", synthetic)
        if user_sessions is not None:
            pulumi.set(__self__, "user_sessions", user_sessions)

    @property
    @pulumi.getter
    def ddus(self) -> Optional['outputs.EnvironmentQuotasDdus']:
        """
        Davis Data Units consumption and quota information on environment level. Not set (and not editable) if Davis data units is not enabled
        """
        return pulumi.get(self, "ddus")

    @property
    @pulumi.getter(name="demUnits")
    def dem_units(self) -> Optional['outputs.EnvironmentQuotasDemUnits']:
        """
        DEM units consumption and quota information on environment level
        """
        return pulumi.get(self, "dem_units")

    @property
    @pulumi.getter(name="hostUnits")
    def host_units(self) -> Optional[int]:
        """
        Host units consumption and quota information on environment level
        """
        return pulumi.get(self, "host_units")

    @property
    @pulumi.getter
    def logs(self) -> Optional['outputs.EnvironmentQuotasLogs']:
        """
        Log Monitoring consumption and quota information on environment level. Not set (and not editable) if Log monitoring is not enabled. Not set (and not editable) if Log monitoring is migrated to Davis data on license level
        """
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def synthetic(self) -> Optional['outputs.EnvironmentQuotasSynthetic']:
        """
        Synthetic monitors consumption and quota information on environment level. Not set (and not editable) if neither Synthetic nor DEM units is enabled
        """
        return pulumi.get(self, "synthetic")

    @property
    @pulumi.getter(name="userSessions")
    def user_sessions(self) -> Optional['outputs.EnvironmentQuotasUserSessions']:
        """
        User sessions consumption and quota information on environment level
        """
        return pulumi.get(self, "user_sessions")


@pulumi.output_type
class EnvironmentQuotasDdus(dict):
    def __init__(__self__, *,
                 annual: Optional[int] = None,
                 monthly: Optional[int] = None):
        """
        :param int annual: Annual environment quota. Not set if unlimited
        :param int monthly: Monthly environment quota. Not set if unlimited
        """
        if annual is not None:
            pulumi.set(__self__, "annual", annual)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)

    @property
    @pulumi.getter
    def annual(self) -> Optional[int]:
        """
        Annual environment quota. Not set if unlimited
        """
        return pulumi.get(self, "annual")

    @property
    @pulumi.getter
    def monthly(self) -> Optional[int]:
        """
        Monthly environment quota. Not set if unlimited
        """
        return pulumi.get(self, "monthly")


@pulumi.output_type
class EnvironmentQuotasDemUnits(dict):
    def __init__(__self__, *,
                 annual: Optional[int] = None,
                 monthly: Optional[int] = None):
        """
        :param int annual: Annual environment quota. Not set if unlimited
        :param int monthly: Monthly environment quota. Not set if unlimited
        """
        if annual is not None:
            pulumi.set(__self__, "annual", annual)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)

    @property
    @pulumi.getter
    def annual(self) -> Optional[int]:
        """
        Annual environment quota. Not set if unlimited
        """
        return pulumi.get(self, "annual")

    @property
    @pulumi.getter
    def monthly(self) -> Optional[int]:
        """
        Monthly environment quota. Not set if unlimited
        """
        return pulumi.get(self, "monthly")


@pulumi.output_type
class EnvironmentQuotasLogs(dict):
    def __init__(__self__, *,
                 annual: Optional[int] = None,
                 monthly: Optional[int] = None):
        """
        :param int annual: Annual environment quota. Not set if unlimited
        :param int monthly: Monthly environment quota. Not set if unlimited
        """
        if annual is not None:
            pulumi.set(__self__, "annual", annual)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)

    @property
    @pulumi.getter
    def annual(self) -> Optional[int]:
        """
        Annual environment quota. Not set if unlimited
        """
        return pulumi.get(self, "annual")

    @property
    @pulumi.getter
    def monthly(self) -> Optional[int]:
        """
        Monthly environment quota. Not set if unlimited
        """
        return pulumi.get(self, "monthly")


@pulumi.output_type
class EnvironmentQuotasSynthetic(dict):
    def __init__(__self__, *,
                 annual: Optional[int] = None,
                 monthly: Optional[int] = None):
        """
        :param int annual: Annual environment quota. Not set if unlimited
        :param int monthly: Monthly environment quota. Not set if unlimited
        """
        if annual is not None:
            pulumi.set(__self__, "annual", annual)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)

    @property
    @pulumi.getter
    def annual(self) -> Optional[int]:
        """
        Annual environment quota. Not set if unlimited
        """
        return pulumi.get(self, "annual")

    @property
    @pulumi.getter
    def monthly(self) -> Optional[int]:
        """
        Monthly environment quota. Not set if unlimited
        """
        return pulumi.get(self, "monthly")


@pulumi.output_type
class EnvironmentQuotasUserSessions(dict):
    def __init__(__self__, *,
                 annual: Optional[int] = None,
                 monthly: Optional[int] = None):
        """
        :param int annual: Annual total User sessions environment quota. Not set if unlimited
        :param int monthly: Monthly total User sessions environment quota. Not set if unlimited
        """
        if annual is not None:
            pulumi.set(__self__, "annual", annual)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)

    @property
    @pulumi.getter
    def annual(self) -> Optional[int]:
        """
        Annual total User sessions environment quota. Not set if unlimited
        """
        return pulumi.get(self, "annual")

    @property
    @pulumi.getter
    def monthly(self) -> Optional[int]:
        """
        Monthly total User sessions environment quota. Not set if unlimited
        """
        return pulumi.get(self, "monthly")


@pulumi.output_type
class EnvironmentStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userActions":
            suggest = "user_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transactions: int,
                 limits: Optional['outputs.EnvironmentStorageLimits'] = None,
                 retention: Optional['outputs.EnvironmentStorageRetention'] = None,
                 user_actions: Optional[int] = None):
        """
        :param int transactions: Maximum number of newly monitored entry point PurePaths captured per process/minute on environment level. Can be set to any value from 100 to 100000
        :param int user_actions: Maximum number of user actions generated per minute on environment level. Can be set to any value from 1 to 2147483646 or left unlimited by omitting this property
        """
        pulumi.set(__self__, "transactions", transactions)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if retention is not None:
            pulumi.set(__self__, "retention", retention)
        if user_actions is not None:
            pulumi.set(__self__, "user_actions", user_actions)

    @property
    @pulumi.getter
    def transactions(self) -> int:
        """
        Maximum number of newly monitored entry point PurePaths captured per process/minute on environment level. Can be set to any value from 100 to 100000
        """
        return pulumi.get(self, "transactions")

    @property
    @pulumi.getter
    def limits(self) -> Optional['outputs.EnvironmentStorageLimits']:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def retention(self) -> Optional['outputs.EnvironmentStorageRetention']:
        return pulumi.get(self, "retention")

    @property
    @pulumi.getter(name="userActions")
    def user_actions(self) -> Optional[int]:
        """
        Maximum number of user actions generated per minute on environment level. Can be set to any value from 1 to 2147483646 or left unlimited by omitting this property
        """
        return pulumi.get(self, "user_actions")


@pulumi.output_type
class EnvironmentStorageLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sessionReplay":
            suggest = "session_replay"
        elif key == "symbolFiles":
            suggest = "symbol_files"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentStorageLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentStorageLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentStorageLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logs: Optional[int] = None,
                 session_replay: Optional[int] = None,
                 symbol_files: Optional[int] = None,
                 transactions: Optional[int] = None):
        """
        :param int logs: Log monitoring storage usage and limit information on environment level in bytes. Not editable when Log monitoring is not allowed by license or not configured on cluster level. 0 for unlimited.
        :param int session_replay: Session replay storage usage and limit information on environment level in bytes. 0 for unlimited.
        :param int symbol_files: Session replay storage usage and limit information on environment level in bytes. 0 for unlimited.
        :param int transactions: Transaction storage usage and limit information on environment level in bytes. 0 for unlimited.
        """
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if session_replay is not None:
            pulumi.set(__self__, "session_replay", session_replay)
        if symbol_files is not None:
            pulumi.set(__self__, "symbol_files", symbol_files)
        if transactions is not None:
            pulumi.set(__self__, "transactions", transactions)

    @property
    @pulumi.getter
    def logs(self) -> Optional[int]:
        """
        Log monitoring storage usage and limit information on environment level in bytes. Not editable when Log monitoring is not allowed by license or not configured on cluster level. 0 for unlimited.
        """
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter(name="sessionReplay")
    def session_replay(self) -> Optional[int]:
        """
        Session replay storage usage and limit information on environment level in bytes. 0 for unlimited.
        """
        return pulumi.get(self, "session_replay")

    @property
    @pulumi.getter(name="symbolFiles")
    def symbol_files(self) -> Optional[int]:
        """
        Session replay storage usage and limit information on environment level in bytes. 0 for unlimited.
        """
        return pulumi.get(self, "symbol_files")

    @property
    @pulumi.getter
    def transactions(self) -> Optional[int]:
        """
        Transaction storage usage and limit information on environment level in bytes. 0 for unlimited.
        """
        return pulumi.get(self, "transactions")


@pulumi.output_type
class EnvironmentStorageRetention(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceCodeLevel":
            suggest = "service_code_level"
        elif key == "serviceRequestLevel":
            suggest = "service_request_level"
        elif key == "sessionReplay":
            suggest = "session_replay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentStorageRetention. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentStorageRetention.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentStorageRetention.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rum: int,
                 service_code_level: int,
                 service_request_level: int,
                 session_replay: int,
                 synthetic: int,
                 logs: Optional[int] = None):
        """
        :param int rum: Real user monitoring retention settings on environment level in days. Can be set to any value from 1 to 35 days
        :param int service_code_level: Service code level retention settings on environment level in days. Service code level retention time can't be greater than service request level retention time and both can't exceed one year
        :param int service_request_level: Service request level retention settings on environment level in days. Service code level retention time can't be greater than service request level retention time and both can't exceed one year
        :param int session_replay: Session replay retention settings on environment level in days. Can be set to any value from 1 to 35 days
        :param int synthetic: Synthetic monitoring retention settings on environment level in days. Can be set to any value from 1 to 35 days
        :param int logs: Log monitoring retention settings on environment level in days. Not editable when Log monitoring is not allowed by license or not configured on cluster level. Can be set to any value from 5 to 90 days
        """
        pulumi.set(__self__, "rum", rum)
        pulumi.set(__self__, "service_code_level", service_code_level)
        pulumi.set(__self__, "service_request_level", service_request_level)
        pulumi.set(__self__, "session_replay", session_replay)
        pulumi.set(__self__, "synthetic", synthetic)
        if logs is not None:
            pulumi.set(__self__, "logs", logs)

    @property
    @pulumi.getter
    def rum(self) -> int:
        """
        Real user monitoring retention settings on environment level in days. Can be set to any value from 1 to 35 days
        """
        return pulumi.get(self, "rum")

    @property
    @pulumi.getter(name="serviceCodeLevel")
    def service_code_level(self) -> int:
        """
        Service code level retention settings on environment level in days. Service code level retention time can't be greater than service request level retention time and both can't exceed one year
        """
        return pulumi.get(self, "service_code_level")

    @property
    @pulumi.getter(name="serviceRequestLevel")
    def service_request_level(self) -> int:
        """
        Service request level retention settings on environment level in days. Service code level retention time can't be greater than service request level retention time and both can't exceed one year
        """
        return pulumi.get(self, "service_request_level")

    @property
    @pulumi.getter(name="sessionReplay")
    def session_replay(self) -> int:
        """
        Session replay retention settings on environment level in days. Can be set to any value from 1 to 35 days
        """
        return pulumi.get(self, "session_replay")

    @property
    @pulumi.getter
    def synthetic(self) -> int:
        """
        Synthetic monitoring retention settings on environment level in days. Can be set to any value from 1 to 35 days
        """
        return pulumi.get(self, "synthetic")

    @property
    @pulumi.getter
    def logs(self) -> Optional[int]:
        """
        Log monitoring retention settings on environment level in days. Not editable when Log monitoring is not allowed by license or not configured on cluster level. Can be set to any value from 5 to 90 days
        """
        return pulumi.get(self, "logs")


@pulumi.output_type
class FailureDetectionParametersBrokenLinks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "http404NotFoundFailures":
            suggest = "http404_not_found_failures"
        elif key == "brokenLinkDomains":
            suggest = "broken_link_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersBrokenLinks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersBrokenLinks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersBrokenLinks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http404_not_found_failures: bool,
                 broken_link_domains: Optional[Sequence[str]] = None):
        """
        :param bool http404_not_found_failures: Consider 404 HTTP response codes as failures
        :param Sequence[str] broken_link_domains: If your application relies on other hosts at other domains, add the associated domain names here. Once configured, Dynatrace will consider 404s thrown by hosts at these domains to be service failures related to your application.
        """
        pulumi.set(__self__, "http404_not_found_failures", http404_not_found_failures)
        if broken_link_domains is not None:
            pulumi.set(__self__, "broken_link_domains", broken_link_domains)

    @property
    @pulumi.getter(name="http404NotFoundFailures")
    def http404_not_found_failures(self) -> bool:
        """
        Consider 404 HTTP response codes as failures
        """
        return pulumi.get(self, "http404_not_found_failures")

    @property
    @pulumi.getter(name="brokenLinkDomains")
    def broken_link_domains(self) -> Optional[Sequence[str]]:
        """
        If your application relies on other hosts at other domains, add the associated domain names here. Once configured, Dynatrace will consider 404s thrown by hosts at these domains to be service failures related to your application.
        """
        return pulumi.get(self, "broken_link_domains")


@pulumi.output_type
class FailureDetectionParametersExceptionRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreAllExceptions":
            suggest = "ignore_all_exceptions"
        elif key == "ignoreSpanFailureDetection":
            suggest = "ignore_span_failure_detection"
        elif key == "customErrorRules":
            suggest = "custom_error_rules"
        elif key == "customHandledExceptions":
            suggest = "custom_handled_exceptions"
        elif key == "ignoredExceptions":
            suggest = "ignored_exceptions"
        elif key == "successForcingExceptions":
            suggest = "success_forcing_exceptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ignore_all_exceptions: bool,
                 ignore_span_failure_detection: bool,
                 custom_error_rules: Optional['outputs.FailureDetectionParametersExceptionRulesCustomErrorRules'] = None,
                 custom_handled_exceptions: Optional['outputs.FailureDetectionParametersExceptionRulesCustomHandledExceptions'] = None,
                 ignored_exceptions: Optional['outputs.FailureDetectionParametersExceptionRulesIgnoredExceptions'] = None,
                 success_forcing_exceptions: Optional['outputs.FailureDetectionParametersExceptionRulesSuccessForcingExceptions'] = None):
        """
        :param bool ignore_all_exceptions: Ignore all exceptions
        :param bool ignore_span_failure_detection: Ignore span failure detection
        :param 'FailureDetectionParametersExceptionRulesCustomErrorRulesArgs' custom_error_rules: Some custom error situations are only detectable via a return value or other means. To support such cases, [define a request attribute](https://dt-url.net/ys5k0p4y) that captures the required data. Then define a custom error rule that determines if the request has failed based on the value of the request attribute.
        :param 'FailureDetectionParametersExceptionRulesCustomHandledExceptionsArgs' custom_handled_exceptions: There may be situations where your application code handles exceptions gracefully in a manner that these failures aren't detected by Dynatrace. Use this setting to define specific gracefully-handled exceptions that should be treated as service failures.
        :param 'FailureDetectionParametersExceptionRulesIgnoredExceptionsArgs' ignored_exceptions: Some exceptions that are thrown by legacy or 3rd-party code indicate a specific response, not an error. Use this setting to instruct Dynatrace to treat such exceptions as non-failed requests.. If an exception matching any of the defined patterns occurs in a request, it will not be considered as a failure. Other exceptions occurring at the same request might still mark the request as failed.
        :param 'FailureDetectionParametersExceptionRulesSuccessForcingExceptionsArgs' success_forcing_exceptions: Define exceptions which indicate that a service call should not be considered as failed. E.g. an exception indicating that the client aborted the operation.. If an exception matching any of the defined patterns occurs on the entry node of the service, it will be considered successful. Compared to ignored exceptions, the request will be considered successful even if other exceptions occur in the same request.
        """
        pulumi.set(__self__, "ignore_all_exceptions", ignore_all_exceptions)
        pulumi.set(__self__, "ignore_span_failure_detection", ignore_span_failure_detection)
        if custom_error_rules is not None:
            pulumi.set(__self__, "custom_error_rules", custom_error_rules)
        if custom_handled_exceptions is not None:
            pulumi.set(__self__, "custom_handled_exceptions", custom_handled_exceptions)
        if ignored_exceptions is not None:
            pulumi.set(__self__, "ignored_exceptions", ignored_exceptions)
        if success_forcing_exceptions is not None:
            pulumi.set(__self__, "success_forcing_exceptions", success_forcing_exceptions)

    @property
    @pulumi.getter(name="ignoreAllExceptions")
    def ignore_all_exceptions(self) -> bool:
        """
        Ignore all exceptions
        """
        return pulumi.get(self, "ignore_all_exceptions")

    @property
    @pulumi.getter(name="ignoreSpanFailureDetection")
    def ignore_span_failure_detection(self) -> bool:
        """
        Ignore span failure detection
        """
        return pulumi.get(self, "ignore_span_failure_detection")

    @property
    @pulumi.getter(name="customErrorRules")
    def custom_error_rules(self) -> Optional['outputs.FailureDetectionParametersExceptionRulesCustomErrorRules']:
        """
        Some custom error situations are only detectable via a return value or other means. To support such cases, [define a request attribute](https://dt-url.net/ys5k0p4y) that captures the required data. Then define a custom error rule that determines if the request has failed based on the value of the request attribute.
        """
        return pulumi.get(self, "custom_error_rules")

    @property
    @pulumi.getter(name="customHandledExceptions")
    def custom_handled_exceptions(self) -> Optional['outputs.FailureDetectionParametersExceptionRulesCustomHandledExceptions']:
        """
        There may be situations where your application code handles exceptions gracefully in a manner that these failures aren't detected by Dynatrace. Use this setting to define specific gracefully-handled exceptions that should be treated as service failures.
        """
        return pulumi.get(self, "custom_handled_exceptions")

    @property
    @pulumi.getter(name="ignoredExceptions")
    def ignored_exceptions(self) -> Optional['outputs.FailureDetectionParametersExceptionRulesIgnoredExceptions']:
        """
        Some exceptions that are thrown by legacy or 3rd-party code indicate a specific response, not an error. Use this setting to instruct Dynatrace to treat such exceptions as non-failed requests.. If an exception matching any of the defined patterns occurs in a request, it will not be considered as a failure. Other exceptions occurring at the same request might still mark the request as failed.
        """
        return pulumi.get(self, "ignored_exceptions")

    @property
    @pulumi.getter(name="successForcingExceptions")
    def success_forcing_exceptions(self) -> Optional['outputs.FailureDetectionParametersExceptionRulesSuccessForcingExceptions']:
        """
        Define exceptions which indicate that a service call should not be considered as failed. E.g. an exception indicating that the client aborted the operation.. If an exception matching any of the defined patterns occurs on the entry node of the service, it will be considered successful. Compared to ignored exceptions, the request will be considered successful even if other exceptions occur in the same request.
        """
        return pulumi.get(self, "success_forcing_exceptions")


@pulumi.output_type
class FailureDetectionParametersExceptionRulesCustomErrorRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customErrorRules":
            suggest = "custom_error_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRulesCustomErrorRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRulesCustomErrorRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRulesCustomErrorRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_error_rules: Sequence['outputs.FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRule']):
        pulumi.set(__self__, "custom_error_rules", custom_error_rules)

    @property
    @pulumi.getter(name="customErrorRules")
    def custom_error_rules(self) -> Sequence['outputs.FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRule']:
        return pulumi.get(self, "custom_error_rules")


@pulumi.output_type
class FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: 'outputs.FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRuleCondition',
                 request_attribute: str):
        """
        :param 'FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRuleConditionArgs' condition: Request attribute condition
        :param str request_attribute: Request attribute
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "request_attribute", request_attribute)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRuleCondition':
        """
        Request attribute condition
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> str:
        """
        Request attribute
        """
        return pulumi.get(self, "request_attribute")


@pulumi.output_type
class FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compareOperationType":
            suggest = "compare_operation_type"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "doubleValue":
            suggest = "double_value"
        elif key == "intValue":
            suggest = "int_value"
        elif key == "textValue":
            suggest = "text_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compare_operation_type: str,
                 case_sensitive: Optional[bool] = None,
                 double_value: Optional[float] = None,
                 int_value: Optional[int] = None,
                 text_value: Optional[str] = None):
        """
        :param str compare_operation_type: Apply this comparison
        :param bool case_sensitive: Case sensitive
        :param float double_value: Value
        :param int int_value: Value
        :param str text_value: Value
        """
        pulumi.set(__self__, "compare_operation_type", compare_operation_type)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int_value is not None:
            pulumi.set(__self__, "int_value", int_value)
        if text_value is not None:
            pulumi.set(__self__, "text_value", text_value)

    @property
    @pulumi.getter(name="compareOperationType")
    def compare_operation_type(self) -> str:
        """
        Apply this comparison
        """
        return pulumi.get(self, "compare_operation_type")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        Case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[float]:
        """
        Value
        """
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="intValue")
    def int_value(self) -> Optional[int]:
        """
        Value
        """
        return pulumi.get(self, "int_value")

    @property
    @pulumi.getter(name="textValue")
    def text_value(self) -> Optional[str]:
        """
        Value
        """
        return pulumi.get(self, "text_value")


@pulumi.output_type
class FailureDetectionParametersExceptionRulesCustomHandledExceptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHandledExceptions":
            suggest = "custom_handled_exceptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRulesCustomHandledExceptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRulesCustomHandledExceptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRulesCustomHandledExceptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_handled_exceptions: Sequence['outputs.FailureDetectionParametersExceptionRulesCustomHandledExceptionsCustomHandledException']):
        pulumi.set(__self__, "custom_handled_exceptions", custom_handled_exceptions)

    @property
    @pulumi.getter(name="customHandledExceptions")
    def custom_handled_exceptions(self) -> Sequence['outputs.FailureDetectionParametersExceptionRulesCustomHandledExceptionsCustomHandledException']:
        return pulumi.get(self, "custom_handled_exceptions")


@pulumi.output_type
class FailureDetectionParametersExceptionRulesCustomHandledExceptionsCustomHandledException(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPattern":
            suggest = "class_pattern"
        elif key == "messagePattern":
            suggest = "message_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRulesCustomHandledExceptionsCustomHandledException. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRulesCustomHandledExceptionsCustomHandledException.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRulesCustomHandledExceptionsCustomHandledException.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_pattern: Optional[str] = None,
                 message_pattern: Optional[str] = None):
        """
        :param str class_pattern: The pattern will match if it is contained within the actual class name.
        :param str message_pattern: Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
        """
        if class_pattern is not None:
            pulumi.set(__self__, "class_pattern", class_pattern)
        if message_pattern is not None:
            pulumi.set(__self__, "message_pattern", message_pattern)

    @property
    @pulumi.getter(name="classPattern")
    def class_pattern(self) -> Optional[str]:
        """
        The pattern will match if it is contained within the actual class name.
        """
        return pulumi.get(self, "class_pattern")

    @property
    @pulumi.getter(name="messagePattern")
    def message_pattern(self) -> Optional[str]:
        """
        Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
        """
        return pulumi.get(self, "message_pattern")


@pulumi.output_type
class FailureDetectionParametersExceptionRulesIgnoredExceptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHandledExceptions":
            suggest = "custom_handled_exceptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRulesIgnoredExceptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRulesIgnoredExceptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRulesIgnoredExceptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_handled_exceptions: Sequence['outputs.FailureDetectionParametersExceptionRulesIgnoredExceptionsCustomHandledException']):
        pulumi.set(__self__, "custom_handled_exceptions", custom_handled_exceptions)

    @property
    @pulumi.getter(name="customHandledExceptions")
    def custom_handled_exceptions(self) -> Sequence['outputs.FailureDetectionParametersExceptionRulesIgnoredExceptionsCustomHandledException']:
        return pulumi.get(self, "custom_handled_exceptions")


@pulumi.output_type
class FailureDetectionParametersExceptionRulesIgnoredExceptionsCustomHandledException(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPattern":
            suggest = "class_pattern"
        elif key == "messagePattern":
            suggest = "message_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRulesIgnoredExceptionsCustomHandledException. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRulesIgnoredExceptionsCustomHandledException.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRulesIgnoredExceptionsCustomHandledException.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_pattern: Optional[str] = None,
                 message_pattern: Optional[str] = None):
        """
        :param str class_pattern: The pattern will match if it is contained within the actual class name.
        :param str message_pattern: Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
        """
        if class_pattern is not None:
            pulumi.set(__self__, "class_pattern", class_pattern)
        if message_pattern is not None:
            pulumi.set(__self__, "message_pattern", message_pattern)

    @property
    @pulumi.getter(name="classPattern")
    def class_pattern(self) -> Optional[str]:
        """
        The pattern will match if it is contained within the actual class name.
        """
        return pulumi.get(self, "class_pattern")

    @property
    @pulumi.getter(name="messagePattern")
    def message_pattern(self) -> Optional[str]:
        """
        Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
        """
        return pulumi.get(self, "message_pattern")


@pulumi.output_type
class FailureDetectionParametersExceptionRulesSuccessForcingExceptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHandledExceptions":
            suggest = "custom_handled_exceptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRulesSuccessForcingExceptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRulesSuccessForcingExceptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRulesSuccessForcingExceptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_handled_exceptions: Sequence['outputs.FailureDetectionParametersExceptionRulesSuccessForcingExceptionsCustomHandledException']):
        pulumi.set(__self__, "custom_handled_exceptions", custom_handled_exceptions)

    @property
    @pulumi.getter(name="customHandledExceptions")
    def custom_handled_exceptions(self) -> Sequence['outputs.FailureDetectionParametersExceptionRulesSuccessForcingExceptionsCustomHandledException']:
        return pulumi.get(self, "custom_handled_exceptions")


@pulumi.output_type
class FailureDetectionParametersExceptionRulesSuccessForcingExceptionsCustomHandledException(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPattern":
            suggest = "class_pattern"
        elif key == "messagePattern":
            suggest = "message_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRulesSuccessForcingExceptionsCustomHandledException. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRulesSuccessForcingExceptionsCustomHandledException.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRulesSuccessForcingExceptionsCustomHandledException.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_pattern: Optional[str] = None,
                 message_pattern: Optional[str] = None):
        """
        :param str class_pattern: The pattern will match if it is contained within the actual class name.
        :param str message_pattern: Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
        """
        if class_pattern is not None:
            pulumi.set(__self__, "class_pattern", class_pattern)
        if message_pattern is not None:
            pulumi.set(__self__, "message_pattern", message_pattern)

    @property
    @pulumi.getter(name="classPattern")
    def class_pattern(self) -> Optional[str]:
        """
        The pattern will match if it is contained within the actual class name.
        """
        return pulumi.get(self, "class_pattern")

    @property
    @pulumi.getter(name="messagePattern")
    def message_pattern(self) -> Optional[str]:
        """
        Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
        """
        return pulumi.get(self, "message_pattern")


@pulumi.output_type
class FailureDetectionParametersHttpResponseCodes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientSideErrors":
            suggest = "client_side_errors"
        elif key == "failOnMissingResponseCodeClientSide":
            suggest = "fail_on_missing_response_code_client_side"
        elif key == "failOnMissingResponseCodeServerSide":
            suggest = "fail_on_missing_response_code_server_side"
        elif key == "serverSideErrors":
            suggest = "server_side_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersHttpResponseCodes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersHttpResponseCodes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersHttpResponseCodes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_side_errors: str,
                 fail_on_missing_response_code_client_side: bool,
                 fail_on_missing_response_code_server_side: bool,
                 server_side_errors: str):
        """
        :param str client_side_errors: HTTP response codes which indicate client side errors
        :param bool fail_on_missing_response_code_client_side: Treat missing HTTP response code as client side error
        :param bool fail_on_missing_response_code_server_side: Treat missing HTTP response code as server side errors
        :param str server_side_errors: HTTP response codes which indicate an error on the server side
        """
        pulumi.set(__self__, "client_side_errors", client_side_errors)
        pulumi.set(__self__, "fail_on_missing_response_code_client_side", fail_on_missing_response_code_client_side)
        pulumi.set(__self__, "fail_on_missing_response_code_server_side", fail_on_missing_response_code_server_side)
        pulumi.set(__self__, "server_side_errors", server_side_errors)

    @property
    @pulumi.getter(name="clientSideErrors")
    def client_side_errors(self) -> str:
        """
        HTTP response codes which indicate client side errors
        """
        return pulumi.get(self, "client_side_errors")

    @property
    @pulumi.getter(name="failOnMissingResponseCodeClientSide")
    def fail_on_missing_response_code_client_side(self) -> bool:
        """
        Treat missing HTTP response code as client side error
        """
        return pulumi.get(self, "fail_on_missing_response_code_client_side")

    @property
    @pulumi.getter(name="failOnMissingResponseCodeServerSide")
    def fail_on_missing_response_code_server_side(self) -> bool:
        """
        Treat missing HTTP response code as server side errors
        """
        return pulumi.get(self, "fail_on_missing_response_code_server_side")

    @property
    @pulumi.getter(name="serverSideErrors")
    def server_side_errors(self) -> str:
        """
        HTTP response codes which indicate an error on the server side
        """
        return pulumi.get(self, "server_side_errors")


@pulumi.output_type
class FailureDetectionRulesConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.FailureDetectionRulesConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.FailureDetectionRulesConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class FailureDetectionRulesConditionsCondition(dict):
    def __init__(__self__, *,
                 attribute: str,
                 predicate: 'outputs.FailureDetectionRulesConditionsConditionPredicate'):
        """
        :param str attribute: Possible Values: `PG_NAME`, `PG_TAG`, `SERVICE_MANAGEMENT_ZONE`, `SERVICE_NAME`, `SERVICE_TAG`, `SERVICE_TYPE`
        :param 'FailureDetectionRulesConditionsConditionPredicateArgs' predicate: Condition to check the attribute against
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "predicate", predicate)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        Possible Values: `PG_NAME`, `PG_TAG`, `SERVICE_MANAGEMENT_ZONE`, `SERVICE_NAME`, `SERVICE_TAG`, `SERVICE_TYPE`
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def predicate(self) -> 'outputs.FailureDetectionRulesConditionsConditionPredicate':
        """
        Condition to check the attribute against
        """
        return pulumi.get(self, "predicate")


@pulumi.output_type
class FailureDetectionRulesConditionsConditionPredicate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predicateType":
            suggest = "predicate_type"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "managementZones":
            suggest = "management_zones"
        elif key == "serviceTypes":
            suggest = "service_types"
        elif key == "tagKeys":
            suggest = "tag_keys"
        elif key == "textValues":
            suggest = "text_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionRulesConditionsConditionPredicate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionRulesConditionsConditionPredicate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionRulesConditionsConditionPredicate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 predicate_type: str,
                 case_sensitive: Optional[bool] = None,
                 management_zones: Optional[Sequence[str]] = None,
                 service_types: Optional[Sequence[str]] = None,
                 tag_keys: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None,
                 text_values: Optional[Sequence[str]] = None):
        """
        :param str predicate_type: Predicate type
        :param bool case_sensitive: Case sensitive
        :param Sequence[str] management_zones: Management zones
        :param Sequence[str] service_types: Service types
        :param Sequence[str] tag_keys: Tag keys
        :param Sequence[str] tags: Tags (exact match)
        :param Sequence[str] text_values: Names
        """
        pulumi.set(__self__, "predicate_type", predicate_type)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if management_zones is not None:
            pulumi.set(__self__, "management_zones", management_zones)
        if service_types is not None:
            pulumi.set(__self__, "service_types", service_types)
        if tag_keys is not None:
            pulumi.set(__self__, "tag_keys", tag_keys)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if text_values is not None:
            pulumi.set(__self__, "text_values", text_values)

    @property
    @pulumi.getter(name="predicateType")
    def predicate_type(self) -> str:
        """
        Predicate type
        """
        return pulumi.get(self, "predicate_type")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        Case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="managementZones")
    def management_zones(self) -> Optional[Sequence[str]]:
        """
        Management zones
        """
        return pulumi.get(self, "management_zones")

    @property
    @pulumi.getter(name="serviceTypes")
    def service_types(self) -> Optional[Sequence[str]]:
        """
        Service types
        """
        return pulumi.get(self, "service_types")

    @property
    @pulumi.getter(name="tagKeys")
    def tag_keys(self) -> Optional[Sequence[str]]:
        """
        Tag keys
        """
        return pulumi.get(self, "tag_keys")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        Tags (exact match)
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="textValues")
    def text_values(self) -> Optional[Sequence[str]]:
        """
        Names
        """
        return pulumi.get(self, "text_values")


@pulumi.output_type
class GenericRelationshipsSources(dict):
    def __init__(__self__, *,
                 sources: Sequence['outputs.GenericRelationshipsSourcesSource']):
        pulumi.set(__self__, "sources", sources)

    @property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GenericRelationshipsSourcesSource']:
        return pulumi.get(self, "sources")


@pulumi.output_type
class GenericRelationshipsSourcesSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"
        elif key == "mappingRules":
            suggest = "mapping_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenericRelationshipsSourcesSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenericRelationshipsSourcesSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenericRelationshipsSourcesSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 condition: Optional[str] = None,
                 mapping_rules: Optional['outputs.GenericRelationshipsSourcesSourceMappingRules'] = None):
        """
        :param str source_type: Possible Values: `BusinessEvents`, `Entities`, `Events`, `Logs`, `Metrics`, `Spans`, `Topology`
        :param str condition: Specify a filter that needs to match in order for the extraction to happen.. Two different filters are supported: `$eq(value)` will ensure that the source matches exactly 'value', while `$prefix(value)` will ensure that the source begins with exactly 'value'.
               If your value contains the characters '(', ')' or '~', you need to escape them by adding a '~' in front of them.
        :param 'GenericRelationshipsSourcesSourceMappingRulesArgs' mapping_rules: Specify all properties which should be compared. If all mapping rules match a relationship between entities will be created.
        """
        pulumi.set(__self__, "source_type", source_type)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if mapping_rules is not None:
            pulumi.set(__self__, "mapping_rules", mapping_rules)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Possible Values: `BusinessEvents`, `Entities`, `Events`, `Logs`, `Metrics`, `Spans`, `Topology`
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        Specify a filter that needs to match in order for the extraction to happen.. Two different filters are supported: `$eq(value)` will ensure that the source matches exactly 'value', while `$prefix(value)` will ensure that the source begins with exactly 'value'.
        If your value contains the characters '(', ')' or '~', you need to escape them by adding a '~' in front of them.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="mappingRules")
    def mapping_rules(self) -> Optional['outputs.GenericRelationshipsSourcesSourceMappingRules']:
        """
        Specify all properties which should be compared. If all mapping rules match a relationship between entities will be created.
        """
        return pulumi.get(self, "mapping_rules")


@pulumi.output_type
class GenericRelationshipsSourcesSourceMappingRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mappingRules":
            suggest = "mapping_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenericRelationshipsSourcesSourceMappingRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenericRelationshipsSourcesSourceMappingRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenericRelationshipsSourcesSourceMappingRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mapping_rules: Sequence['outputs.GenericRelationshipsSourcesSourceMappingRulesMappingRule']):
        pulumi.set(__self__, "mapping_rules", mapping_rules)

    @property
    @pulumi.getter(name="mappingRules")
    def mapping_rules(self) -> Sequence['outputs.GenericRelationshipsSourcesSourceMappingRulesMappingRule']:
        return pulumi.get(self, "mapping_rules")


@pulumi.output_type
class GenericRelationshipsSourcesSourceMappingRulesMappingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationProperty":
            suggest = "destination_property"
        elif key == "destinationTransformation":
            suggest = "destination_transformation"
        elif key == "sourceProperty":
            suggest = "source_property"
        elif key == "sourceTransformation":
            suggest = "source_transformation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenericRelationshipsSourcesSourceMappingRulesMappingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenericRelationshipsSourcesSourceMappingRulesMappingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenericRelationshipsSourcesSourceMappingRulesMappingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_property: str,
                 destination_transformation: str,
                 source_property: str,
                 source_transformation: str):
        """
        :param str destination_property: The case-sensitive name of a property of the destination type.
        :param str destination_transformation: Possible Values: `Leavetextas_is`, `Tolowercase`, `Touppercase`
        :param str source_property: The case-sensitive name of a property of the source type.
        :param str source_transformation: Possible Values: `Leavetextas_is`, `Tolowercase`, `Touppercase`
        """
        pulumi.set(__self__, "destination_property", destination_property)
        pulumi.set(__self__, "destination_transformation", destination_transformation)
        pulumi.set(__self__, "source_property", source_property)
        pulumi.set(__self__, "source_transformation", source_transformation)

    @property
    @pulumi.getter(name="destinationProperty")
    def destination_property(self) -> str:
        """
        The case-sensitive name of a property of the destination type.
        """
        return pulumi.get(self, "destination_property")

    @property
    @pulumi.getter(name="destinationTransformation")
    def destination_transformation(self) -> str:
        """
        Possible Values: `Leavetextas_is`, `Tolowercase`, `Touppercase`
        """
        return pulumi.get(self, "destination_transformation")

    @property
    @pulumi.getter(name="sourceProperty")
    def source_property(self) -> str:
        """
        The case-sensitive name of a property of the source type.
        """
        return pulumi.get(self, "source_property")

    @property
    @pulumi.getter(name="sourceTransformation")
    def source_transformation(self) -> str:
        """
        Possible Values: `Leavetextas_is`, `Tolowercase`, `Touppercase`
        """
        return pulumi.get(self, "source_transformation")


@pulumi.output_type
class GenericTypesRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GenericTypesRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GenericTypesRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GenericTypesRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idPattern":
            suggest = "id_pattern"
        elif key == "iconPattern":
            suggest = "icon_pattern"
        elif key == "instanceNamePattern":
            suggest = "instance_name_pattern"
        elif key == "requiredDimensions":
            suggest = "required_dimensions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenericTypesRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenericTypesRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenericTypesRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id_pattern: str,
                 sources: 'outputs.GenericTypesRulesRuleSources',
                 attributes: Optional['outputs.GenericTypesRulesRuleAttributes'] = None,
                 icon_pattern: Optional[str] = None,
                 instance_name_pattern: Optional[str] = None,
                 required_dimensions: Optional['outputs.GenericTypesRulesRuleRequiredDimensions'] = None,
                 role: Optional[str] = None):
        """
        :param str id_pattern: ID patterns are comprised of static text and placeholders referring to dimensions in the ingest data. An ID pattern **must** contain at least one placeholder to ensure that different entities will be created.. Take care that the pattern results in the same ID for the same entity. For example, using timestamp or counter-like dimensions as part of the ID would lead to the creation of new entities for each ingest data and is strongly discouraged!
        :param 'GenericTypesRulesRuleSourcesArgs' sources: Specify all sources which should be evaluated for this rule. A rule is evaluated if any of the specified source filters match.
        :param 'GenericTypesRulesRuleAttributesArgs' attributes: All attribute extraction rules will be applied and found attributes will be added to the extracted type.
        :param str icon_pattern: Define a pattern which is used to set the icon attribute of the entity. The extracted values must reference barista icon ids. You may define placeholders referencing data source dimensions.
        :param str instance_name_pattern: Define a pattern which is used to set the name attribute of the entity. You may define placeholders referencing data source dimensions.
        :param 'GenericTypesRulesRuleRequiredDimensionsArgs' required_dimensions: In addition to the dimensions already referred to in the ID pattern, you may specify additional dimensions which must be present in order to evaluate this rule.
        :param str role: If you want to extract multiple entities of the same type from a single ingest line you need to define multiple rules with different roles.
        """
        pulumi.set(__self__, "id_pattern", id_pattern)
        pulumi.set(__self__, "sources", sources)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if icon_pattern is not None:
            pulumi.set(__self__, "icon_pattern", icon_pattern)
        if instance_name_pattern is not None:
            pulumi.set(__self__, "instance_name_pattern", instance_name_pattern)
        if required_dimensions is not None:
            pulumi.set(__self__, "required_dimensions", required_dimensions)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter(name="idPattern")
    def id_pattern(self) -> str:
        """
        ID patterns are comprised of static text and placeholders referring to dimensions in the ingest data. An ID pattern **must** contain at least one placeholder to ensure that different entities will be created.. Take care that the pattern results in the same ID for the same entity. For example, using timestamp or counter-like dimensions as part of the ID would lead to the creation of new entities for each ingest data and is strongly discouraged!
        """
        return pulumi.get(self, "id_pattern")

    @property
    @pulumi.getter
    def sources(self) -> 'outputs.GenericTypesRulesRuleSources':
        """
        Specify all sources which should be evaluated for this rule. A rule is evaluated if any of the specified source filters match.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def attributes(self) -> Optional['outputs.GenericTypesRulesRuleAttributes']:
        """
        All attribute extraction rules will be applied and found attributes will be added to the extracted type.
        """
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter(name="iconPattern")
    def icon_pattern(self) -> Optional[str]:
        """
        Define a pattern which is used to set the icon attribute of the entity. The extracted values must reference barista icon ids. You may define placeholders referencing data source dimensions.
        """
        return pulumi.get(self, "icon_pattern")

    @property
    @pulumi.getter(name="instanceNamePattern")
    def instance_name_pattern(self) -> Optional[str]:
        """
        Define a pattern which is used to set the name attribute of the entity. You may define placeholders referencing data source dimensions.
        """
        return pulumi.get(self, "instance_name_pattern")

    @property
    @pulumi.getter(name="requiredDimensions")
    def required_dimensions(self) -> Optional['outputs.GenericTypesRulesRuleRequiredDimensions']:
        """
        In addition to the dimensions already referred to in the ID pattern, you may specify additional dimensions which must be present in order to evaluate this rule.
        """
        return pulumi.get(self, "required_dimensions")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        If you want to extract multiple entities of the same type from a single ingest line you need to define multiple rules with different roles.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GenericTypesRulesRuleAttributes(dict):
    def __init__(__self__, *,
                 attributes: Sequence['outputs.GenericTypesRulesRuleAttributesAttribute']):
        pulumi.set(__self__, "attributes", attributes)

    @property
    @pulumi.getter
    def attributes(self) -> Sequence['outputs.GenericTypesRulesRuleAttributesAttribute']:
        return pulumi.get(self, "attributes")


@pulumi.output_type
class GenericTypesRulesRuleAttributesAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenericTypesRulesRuleAttributesAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenericTypesRulesRuleAttributesAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenericTypesRulesRuleAttributesAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 pattern: str,
                 display_name: Optional[str] = None):
        """
        :param str key: The attribute key is the unique name of the attribute.
        :param str pattern: Pattern for specifying the value for the extracted attribute. Can be a static value, placeholders or a combination of both.
        :param str display_name: The human readable attribute name for this extraction rule. Leave blank to use the key as the display name.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "pattern", pattern)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The attribute key is the unique name of the attribute.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def pattern(self) -> str:
        """
        Pattern for specifying the value for the extracted attribute. Can be a static value, placeholders or a combination of both.
        """
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The human readable attribute name for this extraction rule. Leave blank to use the key as the display name.
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class GenericTypesRulesRuleRequiredDimensions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requiredDimensions":
            suggest = "required_dimensions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenericTypesRulesRuleRequiredDimensions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenericTypesRulesRuleRequiredDimensions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenericTypesRulesRuleRequiredDimensions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 required_dimensions: Sequence['outputs.GenericTypesRulesRuleRequiredDimensionsRequiredDimension']):
        pulumi.set(__self__, "required_dimensions", required_dimensions)

    @property
    @pulumi.getter(name="requiredDimensions")
    def required_dimensions(self) -> Sequence['outputs.GenericTypesRulesRuleRequiredDimensionsRequiredDimension']:
        return pulumi.get(self, "required_dimensions")


@pulumi.output_type
class GenericTypesRulesRuleRequiredDimensionsRequiredDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valuePattern":
            suggest = "value_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenericTypesRulesRuleRequiredDimensionsRequiredDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenericTypesRulesRuleRequiredDimensionsRequiredDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenericTypesRulesRuleRequiredDimensionsRequiredDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 value_pattern: Optional[str] = None):
        """
        :param str key: A dimension key which needs to exist in the ingest data to match this filter.
        :param str value_pattern: A dimension value pattern which needs to exist in the ingest data to match this filter.
        """
        pulumi.set(__self__, "key", key)
        if value_pattern is not None:
            pulumi.set(__self__, "value_pattern", value_pattern)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A dimension key which needs to exist in the ingest data to match this filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="valuePattern")
    def value_pattern(self) -> Optional[str]:
        """
        A dimension value pattern which needs to exist in the ingest data to match this filter.
        """
        return pulumi.get(self, "value_pattern")


@pulumi.output_type
class GenericTypesRulesRuleSources(dict):
    def __init__(__self__, *,
                 sources: Sequence['outputs.GenericTypesRulesRuleSourcesSource']):
        pulumi.set(__self__, "sources", sources)

    @property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GenericTypesRulesRuleSourcesSource']:
        return pulumi.get(self, "sources")


@pulumi.output_type
class GenericTypesRulesRuleSourcesSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenericTypesRulesRuleSourcesSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenericTypesRulesRuleSourcesSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenericTypesRulesRuleSourcesSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 condition: Optional[str] = None):
        """
        :param str source_type: Possible Values: `BusinessEvents`, `Entities`, `Events`, `Logs`, `Metrics`, `Spans`, `Topology`
        :param str condition: Specify a filter that needs to match in order for the extraction to happen.. Three different filters are supported: `$eq(value)` will ensure that the source matches exactly 'value', `$prefix(value)` will ensure that the source begins with exactly 'value', '$exists()' will ensure that any source with matching dimension filter exists.
               If your value contains the characters '(', ')' or '~', you need to escape them by adding a '~' in front of them.
        """
        pulumi.set(__self__, "source_type", source_type)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Possible Values: `BusinessEvents`, `Entities`, `Events`, `Logs`, `Metrics`, `Spans`, `Topology`
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        Specify a filter that needs to match in order for the extraction to happen.. Three different filters are supported: `$eq(value)` will ensure that the source matches exactly 'value', `$prefix(value)` will ensure that the source begins with exactly 'value', '$exists()' will ensure that any source with matching dimension filter exists.
        If your value contains the characters '(', ')' or '~', you need to escape them by adding a '~' in front of them.
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class GrailMetricsAllowlistAllowRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRules":
            suggest = "allow_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrailMetricsAllowlistAllowRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrailMetricsAllowlistAllowRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrailMetricsAllowlistAllowRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rules: Sequence['outputs.GrailMetricsAllowlistAllowRulesAllowRule']):
        pulumi.set(__self__, "allow_rules", allow_rules)

    @property
    @pulumi.getter(name="allowRules")
    def allow_rules(self) -> Sequence['outputs.GrailMetricsAllowlistAllowRulesAllowRule']:
        return pulumi.get(self, "allow_rules")


@pulumi.output_type
class GrailMetricsAllowlistAllowRulesAllowRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricKey":
            suggest = "metric_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrailMetricsAllowlistAllowRulesAllowRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrailMetricsAllowlistAllowRulesAllowRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrailMetricsAllowlistAllowRulesAllowRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 metric_key: str,
                 pattern: str):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param str metric_key: Metric key
        :param str pattern: Possible Values: `CONTAINS`, `EQUALS`, `STARTSWITH`
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "metric_key", metric_key)
        pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="metricKey")
    def metric_key(self) -> str:
        """
        Metric key
        """
        return pulumi.get(self, "metric_key")

    @property
    @pulumi.getter
    def pattern(self) -> str:
        """
        Possible Values: `CONTAINS`, `EQUALS`, `STARTSWITH`
        """
        return pulumi.get(self, "pattern")


@pulumi.output_type
class HostAnomaliesConnections(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enabledOnGracefulShutdowns":
            suggest = "enabled_on_graceful_shutdowns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesConnections. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesConnections.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesConnections.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 enabled_on_graceful_shutdowns: bool):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param bool enabled_on_graceful_shutdowns: Alert (`true`) on graceful host shutdowns
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "enabled_on_graceful_shutdowns", enabled_on_graceful_shutdowns)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="enabledOnGracefulShutdowns")
    def enabled_on_graceful_shutdowns(self) -> bool:
        """
        Alert (`true`) on graceful host shutdowns
        """
        return pulumi.get(self, "enabled_on_graceful_shutdowns")


@pulumi.output_type
class HostAnomaliesCpu(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesCpuThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesCpuThresholdsArgs' thresholds: Custom thresholds for high CPU saturation. If not set then the automatic mode is used
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesCpuThresholds']:
        """
        Custom thresholds for high CPU saturation. If not set then the automatic mode is used
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesCpuThresholds(dict):
    def __init__(__self__, *,
                 saturation: int):
        """
        :param int saturation: Alert if CPU usage is higher than *X*% in 3 out of 5 samples
        """
        pulumi.set(__self__, "saturation", saturation)

    @property
    @pulumi.getter
    def saturation(self) -> int:
        """
        Alert if CPU usage is higher than *X*% in 3 out of 5 samples
        """
        return pulumi.get(self, "saturation")


@pulumi.output_type
class HostAnomaliesDisks(dict):
    def __init__(__self__, *,
                 inodes: Optional['outputs.HostAnomaliesDisksInodes'] = None,
                 space: Optional['outputs.HostAnomaliesDisksSpace'] = None,
                 speed: Optional['outputs.HostAnomaliesDisksSpeed'] = None):
        """
        :param 'HostAnomaliesDisksInodesArgs' inodes: Configuration of low disk inodes number detection
        :param 'HostAnomaliesDisksSpaceArgs' space: Configuration of low disk space detection
        :param 'HostAnomaliesDisksSpeedArgs' speed: Configuration of slow running disks detection
        """
        if inodes is not None:
            pulumi.set(__self__, "inodes", inodes)
        if space is not None:
            pulumi.set(__self__, "space", space)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)

    @property
    @pulumi.getter
    def inodes(self) -> Optional['outputs.HostAnomaliesDisksInodes']:
        """
        Configuration of low disk inodes number detection
        """
        return pulumi.get(self, "inodes")

    @property
    @pulumi.getter
    def space(self) -> Optional['outputs.HostAnomaliesDisksSpace']:
        """
        Configuration of low disk space detection
        """
        return pulumi.get(self, "space")

    @property
    @pulumi.getter
    def speed(self) -> Optional['outputs.HostAnomaliesDisksSpeed']:
        """
        Configuration of slow running disks detection
        """
        return pulumi.get(self, "speed")


@pulumi.output_type
class HostAnomaliesDisksInodes(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesDisksInodesThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesDisksInodesThresholdsArgs' thresholds: Custom thresholds for low disk inodes number. If not set, automatic mode is used
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesDisksInodesThresholds']:
        """
        Custom thresholds for low disk inodes number. If not set, automatic mode is used
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesDisksInodesThresholds(dict):
    def __init__(__self__, *,
                 percentage: int):
        """
        :param int percentage: Alert if percentage of available inodes is lower than *X*% in 3 out of 5 samples
        """
        pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter
    def percentage(self) -> int:
        """
        Alert if percentage of available inodes is lower than *X*% in 3 out of 5 samples
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class HostAnomaliesDisksSpace(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesDisksSpaceThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesDisksSpaceThresholdsArgs' thresholds: Custom thresholds for low disk space. If not set, automatic mode is used
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesDisksSpaceThresholds']:
        """
        Custom thresholds for low disk space. If not set, automatic mode is used
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesDisksSpaceThresholds(dict):
    def __init__(__self__, *,
                 percentage: int):
        """
        :param int percentage: Alert if free disk space is lower than *X*% in 3 out of 5 samples
        """
        pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter
    def percentage(self) -> int:
        """
        Alert if free disk space is lower than *X*% in 3 out of 5 samples
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class HostAnomaliesDisksSpeed(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesDisksSpeedThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesDisksSpeedThresholdsArgs' thresholds: Custom thresholds for slow running disks. If not set, the automatic mode is used
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesDisksSpeedThresholds']:
        """
        Custom thresholds for slow running disks. If not set, the automatic mode is used
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesDisksSpeedThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "writeAndReadTime":
            suggest = "write_and_read_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesDisksSpeedThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesDisksSpeedThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesDisksSpeedThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 write_and_read_time: int):
        """
        :param int write_and_read_time: Alert if disk read/write time is higher than *X* milliseconds in 3 out of 5 samples
        """
        pulumi.set(__self__, "write_and_read_time", write_and_read_time)

    @property
    @pulumi.getter(name="writeAndReadTime")
    def write_and_read_time(self) -> int:
        """
        Alert if disk read/write time is higher than *X* milliseconds in 3 out of 5 samples
        """
        return pulumi.get(self, "write_and_read_time")


@pulumi.output_type
class HostAnomaliesGc(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesGcThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesGcThresholdsArgs' thresholds: Custom thresholds for high GC activity. If not set, automatic mode is used.   Meeting **any** of these conditions triggers an alert
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesGcThresholds']:
        """
        Custom thresholds for high GC activity. If not set, automatic mode is used.   Meeting **any** of these conditions triggers an alert
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesGcThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "suspensionPercentage":
            suggest = "suspension_percentage"
        elif key == "timePercentage":
            suggest = "time_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesGcThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesGcThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesGcThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 suspension_percentage: int,
                 time_percentage: int):
        """
        :param int suspension_percentage: GC suspension is higher than *X*% in 3 out of 5 samples
        :param int time_percentage: GC time is higher than *X*% in 3 out of 5 samples
        """
        pulumi.set(__self__, "suspension_percentage", suspension_percentage)
        pulumi.set(__self__, "time_percentage", time_percentage)

    @property
    @pulumi.getter(name="suspensionPercentage")
    def suspension_percentage(self) -> int:
        """
        GC suspension is higher than *X*% in 3 out of 5 samples
        """
        return pulumi.get(self, "suspension_percentage")

    @property
    @pulumi.getter(name="timePercentage")
    def time_percentage(self) -> int:
        """
        GC time is higher than *X*% in 3 out of 5 samples
        """
        return pulumi.get(self, "time_percentage")


@pulumi.output_type
class HostAnomaliesJava(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outOfMemory":
            suggest = "out_of_memory"
        elif key == "outOfThreads":
            suggest = "out_of_threads"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesJava. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesJava.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesJava.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 out_of_memory: Optional['outputs.HostAnomaliesJavaOutOfMemory'] = None,
                 out_of_threads: Optional['outputs.HostAnomaliesJavaOutOfThreads'] = None):
        """
        :param 'HostAnomaliesJavaOutOfMemoryArgs' out_of_memory: Configuration of Java out of memory problems detection
        :param 'HostAnomaliesJavaOutOfThreadsArgs' out_of_threads: Configuration of Java out of threads problems detection
        """
        if out_of_memory is not None:
            pulumi.set(__self__, "out_of_memory", out_of_memory)
        if out_of_threads is not None:
            pulumi.set(__self__, "out_of_threads", out_of_threads)

    @property
    @pulumi.getter(name="outOfMemory")
    def out_of_memory(self) -> Optional['outputs.HostAnomaliesJavaOutOfMemory']:
        """
        Configuration of Java out of memory problems detection
        """
        return pulumi.get(self, "out_of_memory")

    @property
    @pulumi.getter(name="outOfThreads")
    def out_of_threads(self) -> Optional['outputs.HostAnomaliesJavaOutOfThreads']:
        """
        Configuration of Java out of threads problems detection
        """
        return pulumi.get(self, "out_of_threads")


@pulumi.output_type
class HostAnomaliesJavaOutOfMemory(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesJavaOutOfMemoryThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesJavaOutOfMemoryThresholdsArgs' thresholds: Custom thresholds for Java out of memory. If not set, automatic mode is used
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesJavaOutOfMemoryThresholds']:
        """
        Custom thresholds for Java out of memory. If not set, automatic mode is used
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesJavaOutOfMemoryThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exceptionCount":
            suggest = "exception_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesJavaOutOfMemoryThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesJavaOutOfMemoryThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesJavaOutOfMemoryThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exception_count: int):
        """
        :param int exception_count: Alert if the number of Java out of memory exceptions is *X* per minute or higher
        """
        pulumi.set(__self__, "exception_count", exception_count)

    @property
    @pulumi.getter(name="exceptionCount")
    def exception_count(self) -> int:
        """
        Alert if the number of Java out of memory exceptions is *X* per minute or higher
        """
        return pulumi.get(self, "exception_count")


@pulumi.output_type
class HostAnomaliesJavaOutOfThreads(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesJavaOutOfThreadsThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesJavaOutOfThreadsThresholdsArgs' thresholds: Custom thresholds for Java out of threads detection. If not set, automatic mode is used
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesJavaOutOfThreadsThresholds']:
        """
        Custom thresholds for Java out of threads detection. If not set, automatic mode is used
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesJavaOutOfThreadsThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exceptionCount":
            suggest = "exception_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesJavaOutOfThreadsThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesJavaOutOfThreadsThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesJavaOutOfThreadsThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exception_count: int):
        """
        :param int exception_count: Alert if the number of Java out of threads exceptions is *X* per minute or higher
        """
        pulumi.set(__self__, "exception_count", exception_count)

    @property
    @pulumi.getter(name="exceptionCount")
    def exception_count(self) -> int:
        """
        Alert if the number of Java out of threads exceptions is *X* per minute or higher
        """
        return pulumi.get(self, "exception_count")


@pulumi.output_type
class HostAnomaliesMemory(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesMemoryThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesMemoryThresholdsArgs' thresholds: Custom thresholds for high memory usage. If not set then the automatic mode is used. **Both** conditions must be met to trigger an alert
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesMemoryThresholds']:
        """
        Custom thresholds for high memory usage. If not set then the automatic mode is used. **Both** conditions must be met to trigger an alert
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesMemoryThresholds(dict):
    def __init__(__self__, *,
                 linux: 'outputs.HostAnomaliesMemoryThresholdsLinux',
                 windows: 'outputs.HostAnomaliesMemoryThresholdsWindows'):
        """
        :param 'HostAnomaliesMemoryThresholdsLinuxArgs' linux: Custom thresholds for Linux
        :param 'HostAnomaliesMemoryThresholdsWindowsArgs' windows: Custom thresholds for Windows
        """
        pulumi.set(__self__, "linux", linux)
        pulumi.set(__self__, "windows", windows)

    @property
    @pulumi.getter
    def linux(self) -> 'outputs.HostAnomaliesMemoryThresholdsLinux':
        """
        Custom thresholds for Linux
        """
        return pulumi.get(self, "linux")

    @property
    @pulumi.getter
    def windows(self) -> 'outputs.HostAnomaliesMemoryThresholdsWindows':
        """
        Custom thresholds for Windows
        """
        return pulumi.get(self, "windows")


@pulumi.output_type
class HostAnomaliesMemoryThresholdsLinux(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pageFaults":
            suggest = "page_faults"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesMemoryThresholdsLinux. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesMemoryThresholdsLinux.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesMemoryThresholdsLinux.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 page_faults: int,
                 usage: int):
        """
        :param int page_faults: Memory page fault rate is higher than *X* faults per second
        :param int usage: Memory usage is higher than *X*%
        """
        pulumi.set(__self__, "page_faults", page_faults)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter(name="pageFaults")
    def page_faults(self) -> int:
        """
        Memory page fault rate is higher than *X* faults per second
        """
        return pulumi.get(self, "page_faults")

    @property
    @pulumi.getter
    def usage(self) -> int:
        """
        Memory usage is higher than *X*%
        """
        return pulumi.get(self, "usage")


@pulumi.output_type
class HostAnomaliesMemoryThresholdsWindows(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pageFaults":
            suggest = "page_faults"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesMemoryThresholdsWindows. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesMemoryThresholdsWindows.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesMemoryThresholdsWindows.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 page_faults: int,
                 usage: int):
        """
        :param int page_faults: Memory page fault rate is higher than *X* faults per second
        :param int usage: Memory usage is higher than *X*%
        """
        pulumi.set(__self__, "page_faults", page_faults)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter(name="pageFaults")
    def page_faults(self) -> int:
        """
        Memory page fault rate is higher than *X* faults per second
        """
        return pulumi.get(self, "page_faults")

    @property
    @pulumi.getter
    def usage(self) -> int:
        """
        Memory usage is higher than *X*%
        """
        return pulumi.get(self, "usage")


@pulumi.output_type
class HostAnomaliesNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "droppedPackets":
            suggest = "dropped_packets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connectivity: Optional['outputs.HostAnomaliesNetworkConnectivity'] = None,
                 dropped_packets: Optional['outputs.HostAnomaliesNetworkDroppedPackets'] = None,
                 errors: Optional['outputs.HostAnomaliesNetworkErrors'] = None,
                 retransmission: Optional['outputs.HostAnomaliesNetworkRetransmission'] = None,
                 utilization: Optional['outputs.HostAnomaliesNetworkUtilization'] = None):
        """
        :param 'HostAnomaliesNetworkConnectivityArgs' connectivity: Configuration of TCP connectivity problems detection
        :param 'HostAnomaliesNetworkDroppedPacketsArgs' dropped_packets: Configuration of high number of dropped packets detection
        :param 'HostAnomaliesNetworkErrorsArgs' errors: Configuration of high number of network errors detection
        :param 'HostAnomaliesNetworkRetransmissionArgs' retransmission: Configuration of high retransmission rate detection
        :param 'HostAnomaliesNetworkUtilizationArgs' utilization: Configuration of high network utilization detection
        """
        if connectivity is not None:
            pulumi.set(__self__, "connectivity", connectivity)
        if dropped_packets is not None:
            pulumi.set(__self__, "dropped_packets", dropped_packets)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if retransmission is not None:
            pulumi.set(__self__, "retransmission", retransmission)
        if utilization is not None:
            pulumi.set(__self__, "utilization", utilization)

    @property
    @pulumi.getter
    def connectivity(self) -> Optional['outputs.HostAnomaliesNetworkConnectivity']:
        """
        Configuration of TCP connectivity problems detection
        """
        return pulumi.get(self, "connectivity")

    @property
    @pulumi.getter(name="droppedPackets")
    def dropped_packets(self) -> Optional['outputs.HostAnomaliesNetworkDroppedPackets']:
        """
        Configuration of high number of dropped packets detection
        """
        return pulumi.get(self, "dropped_packets")

    @property
    @pulumi.getter
    def errors(self) -> Optional['outputs.HostAnomaliesNetworkErrors']:
        """
        Configuration of high number of network errors detection
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def retransmission(self) -> Optional['outputs.HostAnomaliesNetworkRetransmission']:
        """
        Configuration of high retransmission rate detection
        """
        return pulumi.get(self, "retransmission")

    @property
    @pulumi.getter
    def utilization(self) -> Optional['outputs.HostAnomaliesNetworkUtilization']:
        """
        Configuration of high network utilization detection
        """
        return pulumi.get(self, "utilization")


@pulumi.output_type
class HostAnomaliesNetworkConnectivity(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesNetworkConnectivityThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesNetworkConnectivityThresholdsArgs' thresholds: Custom thresholds for TCP connection problems. If not set, automatic mode is used.   **All** of these conditions must be met to trigger an alert
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesNetworkConnectivityThresholds']:
        """
        Custom thresholds for TCP connection problems. If not set, automatic mode is used.   **All** of these conditions must be met to trigger an alert
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesNetworkConnectivityThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failedConnections":
            suggest = "failed_connections"
        elif key == "newConnectionFailures":
            suggest = "new_connection_failures"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesNetworkConnectivityThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesNetworkConnectivityThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesNetworkConnectivityThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failed_connections: int,
                 new_connection_failures: int):
        """
        :param int failed_connections: Number of failed connections is higher than *X* connections per minute in 3 out of 5 samples
        :param int new_connection_failures: Percentage of new connection failures is higher than *X*% in 3 out of 5 samples
        """
        pulumi.set(__self__, "failed_connections", failed_connections)
        pulumi.set(__self__, "new_connection_failures", new_connection_failures)

    @property
    @pulumi.getter(name="failedConnections")
    def failed_connections(self) -> int:
        """
        Number of failed connections is higher than *X* connections per minute in 3 out of 5 samples
        """
        return pulumi.get(self, "failed_connections")

    @property
    @pulumi.getter(name="newConnectionFailures")
    def new_connection_failures(self) -> int:
        """
        Percentage of new connection failures is higher than *X*% in 3 out of 5 samples
        """
        return pulumi.get(self, "new_connection_failures")


@pulumi.output_type
class HostAnomaliesNetworkDroppedPackets(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesNetworkDroppedPacketsThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesNetworkDroppedPacketsThresholdsArgs' thresholds: Custom thresholds for dropped packets. If not set, automatic mode is used.   **All** of these conditions must be met to trigger an alert
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesNetworkDroppedPacketsThresholds']:
        """
        Custom thresholds for dropped packets. If not set, automatic mode is used.   **All** of these conditions must be met to trigger an alert
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesNetworkDroppedPacketsThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "droppedPackets":
            suggest = "dropped_packets"
        elif key == "totalPacketsRate":
            suggest = "total_packets_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesNetworkDroppedPacketsThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesNetworkDroppedPacketsThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesNetworkDroppedPacketsThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dropped_packets: int,
                 total_packets_rate: int):
        """
        :param int dropped_packets: Receive/transmit dropped packet percentage is higher than *X*% in 3 out of 5 samples
        :param int total_packets_rate: Total receive/transmit packets rate is higher than *X* packets per second in 3 out of 5 samples
        """
        pulumi.set(__self__, "dropped_packets", dropped_packets)
        pulumi.set(__self__, "total_packets_rate", total_packets_rate)

    @property
    @pulumi.getter(name="droppedPackets")
    def dropped_packets(self) -> int:
        """
        Receive/transmit dropped packet percentage is higher than *X*% in 3 out of 5 samples
        """
        return pulumi.get(self, "dropped_packets")

    @property
    @pulumi.getter(name="totalPacketsRate")
    def total_packets_rate(self) -> int:
        """
        Total receive/transmit packets rate is higher than *X* packets per second in 3 out of 5 samples
        """
        return pulumi.get(self, "total_packets_rate")


@pulumi.output_type
class HostAnomaliesNetworkErrors(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesNetworkErrorsThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesNetworkErrorsThresholdsArgs' thresholds: Custom thresholds for network errors. If not set, automatic mode is used.   **All** of these conditions must be met to trigger an alert
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesNetworkErrorsThresholds']:
        """
        Custom thresholds for network errors. If not set, automatic mode is used.   **All** of these conditions must be met to trigger an alert
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesNetworkErrorsThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorsPercentage":
            suggest = "errors_percentage"
        elif key == "totalPacketsRate":
            suggest = "total_packets_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesNetworkErrorsThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesNetworkErrorsThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesNetworkErrorsThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 errors_percentage: int,
                 total_packets_rate: int):
        """
        :param int errors_percentage: Receive/transmit error packet percentage is higher than *X*% in 3 out of 5 samples
        :param int total_packets_rate: Total receive/transmit packets rate is higher than *X* packets per second in 3 out of 5 samples
        """
        pulumi.set(__self__, "errors_percentage", errors_percentage)
        pulumi.set(__self__, "total_packets_rate", total_packets_rate)

    @property
    @pulumi.getter(name="errorsPercentage")
    def errors_percentage(self) -> int:
        """
        Receive/transmit error packet percentage is higher than *X*% in 3 out of 5 samples
        """
        return pulumi.get(self, "errors_percentage")

    @property
    @pulumi.getter(name="totalPacketsRate")
    def total_packets_rate(self) -> int:
        """
        Total receive/transmit packets rate is higher than *X* packets per second in 3 out of 5 samples
        """
        return pulumi.get(self, "total_packets_rate")


@pulumi.output_type
class HostAnomaliesNetworkRetransmission(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesNetworkRetransmissionThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesNetworkRetransmissionThresholdsArgs' thresholds: Custom thresholds for high retransmission rate. If not set, automatic mode is used.   **All** of these conditions must be met to trigger an alert
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesNetworkRetransmissionThresholds']:
        """
        Custom thresholds for high retransmission rate. If not set, automatic mode is used.   **All** of these conditions must be met to trigger an alert
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesNetworkRetransmissionThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retransmissionRate":
            suggest = "retransmission_rate"
        elif key == "retransmittedPackets":
            suggest = "retransmitted_packets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesNetworkRetransmissionThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesNetworkRetransmissionThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesNetworkRetransmissionThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retransmission_rate: int,
                 retransmitted_packets: int):
        """
        :param int retransmission_rate: Retransmission rate is higher than *X*% in 3 out of 5 samples
        :param int retransmitted_packets: Number of retransmitted packets is higher than *X* packets per minute in 3 out of 5 samples
        """
        pulumi.set(__self__, "retransmission_rate", retransmission_rate)
        pulumi.set(__self__, "retransmitted_packets", retransmitted_packets)

    @property
    @pulumi.getter(name="retransmissionRate")
    def retransmission_rate(self) -> int:
        """
        Retransmission rate is higher than *X*% in 3 out of 5 samples
        """
        return pulumi.get(self, "retransmission_rate")

    @property
    @pulumi.getter(name="retransmittedPackets")
    def retransmitted_packets(self) -> int:
        """
        Number of retransmitted packets is higher than *X* packets per minute in 3 out of 5 samples
        """
        return pulumi.get(self, "retransmitted_packets")


@pulumi.output_type
class HostAnomaliesNetworkUtilization(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesNetworkUtilizationThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesNetworkUtilizationThresholdsArgs' thresholds: Custom thresholds for high network utilization. If not set, automatic mode is used
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesNetworkUtilizationThresholds']:
        """
        Custom thresholds for high network utilization. If not set, automatic mode is used
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesNetworkUtilizationThresholds(dict):
    def __init__(__self__, *,
                 utilization: int):
        """
        :param int utilization: Alert if sent/received traffic utilization is higher than *X*% in 3 out of 5 samples
        """
        pulumi.set(__self__, "utilization", utilization)

    @property
    @pulumi.getter
    def utilization(self) -> int:
        """
        Alert if sent/received traffic utilization is higher than *X*% in 3 out of 5 samples
        """
        return pulumi.get(self, "utilization")


@pulumi.output_type
class HostAnomaliesV2Host(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionLostDetection":
            suggest = "connection_lost_detection"
        elif key == "highCpuSaturationDetection":
            suggest = "high_cpu_saturation_detection"
        elif key == "highGcActivityDetection":
            suggest = "high_gc_activity_detection"
        elif key == "highMemoryDetection":
            suggest = "high_memory_detection"
        elif key == "highSystemLoadDetection":
            suggest = "high_system_load_detection"
        elif key == "outOfMemoryDetection":
            suggest = "out_of_memory_detection"
        elif key == "outOfThreadsDetection":
            suggest = "out_of_threads_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2Host. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2Host.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2Host.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_lost_detection: 'outputs.HostAnomaliesV2HostConnectionLostDetection',
                 high_cpu_saturation_detection: 'outputs.HostAnomaliesV2HostHighCpuSaturationDetection',
                 high_gc_activity_detection: 'outputs.HostAnomaliesV2HostHighGcActivityDetection',
                 high_memory_detection: 'outputs.HostAnomaliesV2HostHighMemoryDetection',
                 high_system_load_detection: 'outputs.HostAnomaliesV2HostHighSystemLoadDetection',
                 out_of_memory_detection: 'outputs.HostAnomaliesV2HostOutOfMemoryDetection',
                 out_of_threads_detection: 'outputs.HostAnomaliesV2HostOutOfThreadsDetection'):
        """
        :param 'HostAnomaliesV2HostConnectionLostDetectionArgs' connection_lost_detection: no documentation available
        :param 'HostAnomaliesV2HostHighCpuSaturationDetectionArgs' high_cpu_saturation_detection: no documentation available
        :param 'HostAnomaliesV2HostHighGcActivityDetectionArgs' high_gc_activity_detection: no documentation available
        :param 'HostAnomaliesV2HostHighMemoryDetectionArgs' high_memory_detection: no documentation available
        :param 'HostAnomaliesV2HostHighSystemLoadDetectionArgs' high_system_load_detection: no documentation available
        :param 'HostAnomaliesV2HostOutOfMemoryDetectionArgs' out_of_memory_detection: no documentation available
        :param 'HostAnomaliesV2HostOutOfThreadsDetectionArgs' out_of_threads_detection: no documentation available
        """
        pulumi.set(__self__, "connection_lost_detection", connection_lost_detection)
        pulumi.set(__self__, "high_cpu_saturation_detection", high_cpu_saturation_detection)
        pulumi.set(__self__, "high_gc_activity_detection", high_gc_activity_detection)
        pulumi.set(__self__, "high_memory_detection", high_memory_detection)
        pulumi.set(__self__, "high_system_load_detection", high_system_load_detection)
        pulumi.set(__self__, "out_of_memory_detection", out_of_memory_detection)
        pulumi.set(__self__, "out_of_threads_detection", out_of_threads_detection)

    @property
    @pulumi.getter(name="connectionLostDetection")
    def connection_lost_detection(self) -> 'outputs.HostAnomaliesV2HostConnectionLostDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "connection_lost_detection")

    @property
    @pulumi.getter(name="highCpuSaturationDetection")
    def high_cpu_saturation_detection(self) -> 'outputs.HostAnomaliesV2HostHighCpuSaturationDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "high_cpu_saturation_detection")

    @property
    @pulumi.getter(name="highGcActivityDetection")
    def high_gc_activity_detection(self) -> 'outputs.HostAnomaliesV2HostHighGcActivityDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "high_gc_activity_detection")

    @property
    @pulumi.getter(name="highMemoryDetection")
    def high_memory_detection(self) -> 'outputs.HostAnomaliesV2HostHighMemoryDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "high_memory_detection")

    @property
    @pulumi.getter(name="highSystemLoadDetection")
    def high_system_load_detection(self) -> 'outputs.HostAnomaliesV2HostHighSystemLoadDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "high_system_load_detection")

    @property
    @pulumi.getter(name="outOfMemoryDetection")
    def out_of_memory_detection(self) -> 'outputs.HostAnomaliesV2HostOutOfMemoryDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "out_of_memory_detection")

    @property
    @pulumi.getter(name="outOfThreadsDetection")
    def out_of_threads_detection(self) -> 'outputs.HostAnomaliesV2HostOutOfThreadsDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "out_of_threads_detection")


@pulumi.output_type
class HostAnomaliesV2HostConnectionLostDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onGracefulShutdowns":
            suggest = "on_graceful_shutdowns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostConnectionLostDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostConnectionLostDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostConnectionLostDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 on_graceful_shutdowns: Optional[str] = None):
        """
        :param bool enabled: Detect host or monitoring connection lost problems
        :param str on_graceful_shutdowns: Graceful host shutdowns
        """
        pulumi.set(__self__, "enabled", enabled)
        if on_graceful_shutdowns is not None:
            pulumi.set(__self__, "on_graceful_shutdowns", on_graceful_shutdowns)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect host or monitoring connection lost problems
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="onGracefulShutdowns")
    def on_graceful_shutdowns(self) -> Optional[str]:
        """
        Graceful host shutdowns
        """
        return pulumi.get(self, "on_graceful_shutdowns")


@pulumi.output_type
class HostAnomaliesV2HostHighCpuSaturationDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighCpuSaturationDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighCpuSaturationDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighCpuSaturationDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: Detect CPU saturation on host
        :param 'HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholdsArgs' custom_thresholds: no documentation available
        :param str detection_mode: Detection mode for CPU saturation
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect CPU saturation on host
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholds']:
        """
        no documentation available
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for CPU saturation
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuSaturation":
            suggest = "cpu_saturation"
        elif key == "eventThresholds":
            suggest = "event_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_saturation: int,
                 event_thresholds: 'outputs.HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholdsEventThresholds'):
        """
        :param int cpu_saturation: Alert if the CPU usage is higher than this threshold for the defined amount of samples
        :param 'HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholdsEventThresholdsArgs' event_thresholds: no documentation available
        """
        pulumi.set(__self__, "cpu_saturation", cpu_saturation)
        pulumi.set(__self__, "event_thresholds", event_thresholds)

    @property
    @pulumi.getter(name="cpuSaturation")
    def cpu_saturation(self) -> int:
        """
        Alert if the CPU usage is higher than this threshold for the defined amount of samples
        """
        return pulumi.get(self, "cpu_saturation")

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholdsEventThresholds':
        """
        no documentation available
        """
        return pulumi.get(self, "event_thresholds")


@pulumi.output_type
class HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        """
        :param int dealerting_evaluation_window: The number of **10-second samples** that form the sliding evaluation window for dealerting.
        :param int dealerting_samples: The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        :param int violating_evaluation_window: The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        :param int violating_samples: The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window for dealerting.
        """
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        """
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        """
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2HostHighGcActivityDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighGcActivityDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighGcActivityDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighGcActivityDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2HostHighGcActivityDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: You may also configure high GC activity alerting for .NET processes on [extensions events page](https://www.terraform.io/#settings/anomalydetection/extensionevents).
        :param 'HostAnomaliesV2HostHighGcActivityDetectionCustomThresholdsArgs' custom_thresholds: Alert if the GC time **or** the GC suspension is exceeded
        :param str detection_mode: Detection mode for high GC activity
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        You may also configure high GC activity alerting for .NET processes on [extensions events page](https://www.terraform.io/#settings/anomalydetection/extensionevents).
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2HostHighGcActivityDetectionCustomThresholds']:
        """
        Alert if the GC time **or** the GC suspension is exceeded
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for high GC activity
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2HostHighGcActivityDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventThresholds":
            suggest = "event_thresholds"
        elif key == "gcSuspensionPercentage":
            suggest = "gc_suspension_percentage"
        elif key == "gcTimePercentage":
            suggest = "gc_time_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighGcActivityDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighGcActivityDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighGcActivityDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_thresholds: 'outputs.HostAnomaliesV2HostHighGcActivityDetectionCustomThresholdsEventThresholds',
                 gc_suspension_percentage: int,
                 gc_time_percentage: int):
        """
        :param 'HostAnomaliesV2HostHighGcActivityDetectionCustomThresholdsEventThresholdsArgs' event_thresholds: no documentation available
        :param int gc_suspension_percentage: Alert if the GC suspension is higher than this threshold
        :param int gc_time_percentage: Alert if GC time is higher than this threshold
        """
        pulumi.set(__self__, "event_thresholds", event_thresholds)
        pulumi.set(__self__, "gc_suspension_percentage", gc_suspension_percentage)
        pulumi.set(__self__, "gc_time_percentage", gc_time_percentage)

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2HostHighGcActivityDetectionCustomThresholdsEventThresholds':
        """
        no documentation available
        """
        return pulumi.get(self, "event_thresholds")

    @property
    @pulumi.getter(name="gcSuspensionPercentage")
    def gc_suspension_percentage(self) -> int:
        """
        Alert if the GC suspension is higher than this threshold
        """
        return pulumi.get(self, "gc_suspension_percentage")

    @property
    @pulumi.getter(name="gcTimePercentage")
    def gc_time_percentage(self) -> int:
        """
        Alert if GC time is higher than this threshold
        """
        return pulumi.get(self, "gc_time_percentage")


@pulumi.output_type
class HostAnomaliesV2HostHighGcActivityDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighGcActivityDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighGcActivityDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighGcActivityDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        """
        :param int dealerting_evaluation_window: The number of **10-second samples** that form the sliding evaluation window for dealerting.
        :param int dealerting_samples: The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        :param int violating_evaluation_window: The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        :param int violating_samples: The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window for dealerting.
        """
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        """
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        """
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2HostHighMemoryDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighMemoryDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighMemoryDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighMemoryDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2HostHighMemoryDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: Detect high memory usage on host
        :param 'HostAnomaliesV2HostHighMemoryDetectionCustomThresholdsArgs' custom_thresholds: Alert if **both** the memory usage and the memory page fault rate thresholds are exceeded on Windows or on Unix systems
        :param str detection_mode: Detection mode for high memory usage
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect high memory usage on host
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2HostHighMemoryDetectionCustomThresholds']:
        """
        Alert if **both** the memory usage and the memory page fault rate thresholds are exceeded on Windows or on Unix systems
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for high memory usage
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2HostHighMemoryDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventThresholds":
            suggest = "event_thresholds"
        elif key == "pageFaultsPerSecondNonWindows":
            suggest = "page_faults_per_second_non_windows"
        elif key == "pageFaultsPerSecondWindows":
            suggest = "page_faults_per_second_windows"
        elif key == "usedMemoryPercentageNonWindows":
            suggest = "used_memory_percentage_non_windows"
        elif key == "usedMemoryPercentageWindows":
            suggest = "used_memory_percentage_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighMemoryDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighMemoryDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighMemoryDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_thresholds: 'outputs.HostAnomaliesV2HostHighMemoryDetectionCustomThresholdsEventThresholds',
                 page_faults_per_second_non_windows: int,
                 page_faults_per_second_windows: int,
                 used_memory_percentage_non_windows: int,
                 used_memory_percentage_windows: int):
        """
        :param 'HostAnomaliesV2HostHighMemoryDetectionCustomThresholdsEventThresholdsArgs' event_thresholds: no documentation available
        :param int page_faults_per_second_non_windows: Alert if the memory page fault rate on Unix systems is higher than this threshold for the defined amount of samples
        :param int page_faults_per_second_windows: Alert if the memory page fault rate on Windows is higher than this threshold for the defined amount of samples
        :param int used_memory_percentage_non_windows: Alert if the memory usage on Unix systems is higher than this threshold
        :param int used_memory_percentage_windows: Alert if the memory usage on Windows is higher than this threshold
        """
        pulumi.set(__self__, "event_thresholds", event_thresholds)
        pulumi.set(__self__, "page_faults_per_second_non_windows", page_faults_per_second_non_windows)
        pulumi.set(__self__, "page_faults_per_second_windows", page_faults_per_second_windows)
        pulumi.set(__self__, "used_memory_percentage_non_windows", used_memory_percentage_non_windows)
        pulumi.set(__self__, "used_memory_percentage_windows", used_memory_percentage_windows)

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2HostHighMemoryDetectionCustomThresholdsEventThresholds':
        """
        no documentation available
        """
        return pulumi.get(self, "event_thresholds")

    @property
    @pulumi.getter(name="pageFaultsPerSecondNonWindows")
    def page_faults_per_second_non_windows(self) -> int:
        """
        Alert if the memory page fault rate on Unix systems is higher than this threshold for the defined amount of samples
        """
        return pulumi.get(self, "page_faults_per_second_non_windows")

    @property
    @pulumi.getter(name="pageFaultsPerSecondWindows")
    def page_faults_per_second_windows(self) -> int:
        """
        Alert if the memory page fault rate on Windows is higher than this threshold for the defined amount of samples
        """
        return pulumi.get(self, "page_faults_per_second_windows")

    @property
    @pulumi.getter(name="usedMemoryPercentageNonWindows")
    def used_memory_percentage_non_windows(self) -> int:
        """
        Alert if the memory usage on Unix systems is higher than this threshold
        """
        return pulumi.get(self, "used_memory_percentage_non_windows")

    @property
    @pulumi.getter(name="usedMemoryPercentageWindows")
    def used_memory_percentage_windows(self) -> int:
        """
        Alert if the memory usage on Windows is higher than this threshold
        """
        return pulumi.get(self, "used_memory_percentage_windows")


@pulumi.output_type
class HostAnomaliesV2HostHighMemoryDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighMemoryDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighMemoryDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighMemoryDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        """
        :param int dealerting_evaluation_window: The number of **10-second samples** that form the sliding evaluation window for dealerting.
        :param int dealerting_samples: The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        :param int violating_evaluation_window: The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        :param int violating_samples: The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window for dealerting.
        """
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        """
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        """
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2HostHighSystemLoadDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighSystemLoadDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighSystemLoadDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighSystemLoadDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholdsArgs' custom_thresholds: no documentation available
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholds']:
        """
        no documentation available
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventThresholds":
            suggest = "event_thresholds"
        elif key == "systemLoad":
            suggest = "system_load"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_thresholds: 'outputs.HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholdsEventThresholds',
                 system_load: float):
        """
        :param 'HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholdsEventThresholdsArgs' event_thresholds: no documentation available
        :param float system_load: Alert if the System Load / Logical cpu core is higher than this threshold for the defined amount of samples
        """
        pulumi.set(__self__, "event_thresholds", event_thresholds)
        pulumi.set(__self__, "system_load", system_load)

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholdsEventThresholds':
        """
        no documentation available
        """
        return pulumi.get(self, "event_thresholds")

    @property
    @pulumi.getter(name="systemLoad")
    def system_load(self) -> float:
        """
        Alert if the System Load / Logical cpu core is higher than this threshold for the defined amount of samples
        """
        return pulumi.get(self, "system_load")


@pulumi.output_type
class HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        """
        :param int dealerting_evaluation_window: The number of **10-second samples** that form the sliding evaluation window for dealerting.
        :param int dealerting_samples: The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        :param int violating_evaluation_window: The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        :param int violating_samples: The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window for dealerting.
        """
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        """
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        """
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2HostOutOfMemoryDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostOutOfMemoryDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostOutOfMemoryDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostOutOfMemoryDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: Detect Java out of memory problem
        :param 'HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholdsArgs' custom_thresholds: no documentation available
        :param str detection_mode: Detection mode for Java out of memory problem
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect Java out of memory problem
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholds']:
        """
        no documentation available
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for Java out of memory problem
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventThresholds":
            suggest = "event_thresholds"
        elif key == "outOfMemoryExceptionsNumber":
            suggest = "out_of_memory_exceptions_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_thresholds: 'outputs.HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholdsEventThresholds',
                 out_of_memory_exceptions_number: int):
        """
        :param 'HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholdsEventThresholdsArgs' event_thresholds: no documentation available
        :param int out_of_memory_exceptions_number: Alert if the number of Java out-of-memory exceptions is at least this value
        """
        pulumi.set(__self__, "event_thresholds", event_thresholds)
        pulumi.set(__self__, "out_of_memory_exceptions_number", out_of_memory_exceptions_number)

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholdsEventThresholds':
        """
        no documentation available
        """
        return pulumi.get(self, "event_thresholds")

    @property
    @pulumi.getter(name="outOfMemoryExceptionsNumber")
    def out_of_memory_exceptions_number(self) -> int:
        """
        Alert if the number of Java out-of-memory exceptions is at least this value
        """
        return pulumi.get(self, "out_of_memory_exceptions_number")


@pulumi.output_type
class HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        """
        :param int dealerting_evaluation_window: The number of **10-second samples** that form the sliding evaluation window for dealerting.
        :param int dealerting_samples: The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        :param int violating_evaluation_window: The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        :param int violating_samples: The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window for dealerting.
        """
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        """
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        """
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2HostOutOfThreadsDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostOutOfThreadsDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostOutOfThreadsDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostOutOfThreadsDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: Detect Java out of threads problem
        :param 'HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholdsArgs' custom_thresholds: no documentation available
        :param str detection_mode: Detection mode for Java out of threads problem
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect Java out of threads problem
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholds']:
        """
        no documentation available
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for Java out of threads problem
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventThresholds":
            suggest = "event_thresholds"
        elif key == "outOfThreadsExceptionsNumber":
            suggest = "out_of_threads_exceptions_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_thresholds: 'outputs.HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholdsEventThresholds',
                 out_of_threads_exceptions_number: int):
        """
        :param 'HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholdsEventThresholdsArgs' event_thresholds: no documentation available
        :param int out_of_threads_exceptions_number: Alert if the number of Java out-of-threads exceptions is at least this value
        """
        pulumi.set(__self__, "event_thresholds", event_thresholds)
        pulumi.set(__self__, "out_of_threads_exceptions_number", out_of_threads_exceptions_number)

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholdsEventThresholds':
        """
        no documentation available
        """
        return pulumi.get(self, "event_thresholds")

    @property
    @pulumi.getter(name="outOfThreadsExceptionsNumber")
    def out_of_threads_exceptions_number(self) -> int:
        """
        Alert if the number of Java out-of-threads exceptions is at least this value
        """
        return pulumi.get(self, "out_of_threads_exceptions_number")


@pulumi.output_type
class HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        """
        :param int dealerting_evaluation_window: The number of **10-second samples** that form the sliding evaluation window for dealerting.
        :param int dealerting_samples: The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        :param int violating_evaluation_window: The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        :param int violating_samples: The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window for dealerting.
        """
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        """
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        """
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2Network(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "highNetworkDetection":
            suggest = "high_network_detection"
        elif key == "networkDroppedPacketsDetection":
            suggest = "network_dropped_packets_detection"
        elif key == "networkErrorsDetection":
            suggest = "network_errors_detection"
        elif key == "networkHighRetransmissionDetection":
            suggest = "network_high_retransmission_detection"
        elif key == "networkTcpProblemsDetection":
            suggest = "network_tcp_problems_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2Network. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2Network.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2Network.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 high_network_detection: 'outputs.HostAnomaliesV2NetworkHighNetworkDetection',
                 network_dropped_packets_detection: 'outputs.HostAnomaliesV2NetworkNetworkDroppedPacketsDetection',
                 network_errors_detection: 'outputs.HostAnomaliesV2NetworkNetworkErrorsDetection',
                 network_high_retransmission_detection: 'outputs.HostAnomaliesV2NetworkNetworkHighRetransmissionDetection',
                 network_tcp_problems_detection: 'outputs.HostAnomaliesV2NetworkNetworkTcpProblemsDetection'):
        """
        :param 'HostAnomaliesV2NetworkHighNetworkDetectionArgs' high_network_detection: no documentation available
        :param 'HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionArgs' network_dropped_packets_detection: no documentation available
        :param 'HostAnomaliesV2NetworkNetworkErrorsDetectionArgs' network_errors_detection: no documentation available
        :param 'HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionArgs' network_high_retransmission_detection: no documentation available
        :param 'HostAnomaliesV2NetworkNetworkTcpProblemsDetectionArgs' network_tcp_problems_detection: no documentation available
        """
        pulumi.set(__self__, "high_network_detection", high_network_detection)
        pulumi.set(__self__, "network_dropped_packets_detection", network_dropped_packets_detection)
        pulumi.set(__self__, "network_errors_detection", network_errors_detection)
        pulumi.set(__self__, "network_high_retransmission_detection", network_high_retransmission_detection)
        pulumi.set(__self__, "network_tcp_problems_detection", network_tcp_problems_detection)

    @property
    @pulumi.getter(name="highNetworkDetection")
    def high_network_detection(self) -> 'outputs.HostAnomaliesV2NetworkHighNetworkDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "high_network_detection")

    @property
    @pulumi.getter(name="networkDroppedPacketsDetection")
    def network_dropped_packets_detection(self) -> 'outputs.HostAnomaliesV2NetworkNetworkDroppedPacketsDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "network_dropped_packets_detection")

    @property
    @pulumi.getter(name="networkErrorsDetection")
    def network_errors_detection(self) -> 'outputs.HostAnomaliesV2NetworkNetworkErrorsDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "network_errors_detection")

    @property
    @pulumi.getter(name="networkHighRetransmissionDetection")
    def network_high_retransmission_detection(self) -> 'outputs.HostAnomaliesV2NetworkNetworkHighRetransmissionDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "network_high_retransmission_detection")

    @property
    @pulumi.getter(name="networkTcpProblemsDetection")
    def network_tcp_problems_detection(self) -> 'outputs.HostAnomaliesV2NetworkNetworkTcpProblemsDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "network_tcp_problems_detection")


@pulumi.output_type
class HostAnomaliesV2NetworkHighNetworkDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkHighNetworkDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkHighNetworkDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkHighNetworkDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: Detect high network utilization
        :param 'HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholdsArgs' custom_thresholds: no documentation available
        :param str detection_mode: Detection mode for high network utilization
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect high network utilization
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholds']:
        """
        no documentation available
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for high network utilization
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorsPercentage":
            suggest = "errors_percentage"
        elif key == "eventThresholds":
            suggest = "event_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 errors_percentage: int,
                 event_thresholds: 'outputs.HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholdsEventThresholds'):
        """
        :param int errors_percentage: Alert if sent/received traffic utilization is higher than this threshold for the defined amount of samples
        :param 'HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholdsEventThresholdsArgs' event_thresholds: no documentation available
        """
        pulumi.set(__self__, "errors_percentage", errors_percentage)
        pulumi.set(__self__, "event_thresholds", event_thresholds)

    @property
    @pulumi.getter(name="errorsPercentage")
    def errors_percentage(self) -> int:
        """
        Alert if sent/received traffic utilization is higher than this threshold for the defined amount of samples
        """
        return pulumi.get(self, "errors_percentage")

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholdsEventThresholds':
        """
        no documentation available
        """
        return pulumi.get(self, "event_thresholds")


@pulumi.output_type
class HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        """
        :param int dealerting_evaluation_window: The number of **10-second samples** that form the sliding evaluation window for dealerting.
        :param int dealerting_samples: The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        :param int violating_evaluation_window: The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        :param int violating_samples: The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window for dealerting.
        """
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        """
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        """
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkDroppedPacketsDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkDroppedPacketsDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkDroppedPacketsDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkDroppedPacketsDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: Detect high number of dropped packets
        :param 'HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholdsArgs' custom_thresholds: Alert if the dropped packet percentage is higher than the specified threshold **and** the total packets rate is higher than the defined threshold for the defined amount of samples
        :param str detection_mode: Detection mode for high number of dropped packets
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect high number of dropped packets
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholds']:
        """
        Alert if the dropped packet percentage is higher than the specified threshold **and** the total packets rate is higher than the defined threshold for the defined amount of samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for high number of dropped packets
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "droppedPacketsPercentage":
            suggest = "dropped_packets_percentage"
        elif key == "eventThresholds":
            suggest = "event_thresholds"
        elif key == "totalPacketsRate":
            suggest = "total_packets_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dropped_packets_percentage: int,
                 event_thresholds: 'outputs.HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholdsEventThresholds',
                 total_packets_rate: int):
        """
        :param int dropped_packets_percentage: Receive/transmit dropped packet percentage threshold
        :param 'HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholdsEventThresholdsArgs' event_thresholds: no documentation available
        :param int total_packets_rate: Total packets rate threshold
        """
        pulumi.set(__self__, "dropped_packets_percentage", dropped_packets_percentage)
        pulumi.set(__self__, "event_thresholds", event_thresholds)
        pulumi.set(__self__, "total_packets_rate", total_packets_rate)

    @property
    @pulumi.getter(name="droppedPacketsPercentage")
    def dropped_packets_percentage(self) -> int:
        """
        Receive/transmit dropped packet percentage threshold
        """
        return pulumi.get(self, "dropped_packets_percentage")

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholdsEventThresholds':
        """
        no documentation available
        """
        return pulumi.get(self, "event_thresholds")

    @property
    @pulumi.getter(name="totalPacketsRate")
    def total_packets_rate(self) -> int:
        """
        Total packets rate threshold
        """
        return pulumi.get(self, "total_packets_rate")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        """
        :param int dealerting_evaluation_window: The number of **10-second samples** that form the sliding evaluation window for dealerting.
        :param int dealerting_samples: The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        :param int violating_evaluation_window: The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        :param int violating_samples: The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window for dealerting.
        """
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        """
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        """
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkErrorsDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkErrorsDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkErrorsDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkErrorsDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: Detect high number of network errors
        :param 'HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholdsArgs' custom_thresholds: Alert if the receive/transmit error packet percentage is higher than the specified threshold **and** the total packets rate is higher than the defined threshold for the defined amount of samples
        :param str detection_mode: Detection mode for high number of network errors
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect high number of network errors
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholds']:
        """
        Alert if the receive/transmit error packet percentage is higher than the specified threshold **and** the total packets rate is higher than the defined threshold for the defined amount of samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for high number of network errors
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorsPercentage":
            suggest = "errors_percentage"
        elif key == "eventThresholds":
            suggest = "event_thresholds"
        elif key == "totalPacketsRate":
            suggest = "total_packets_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 errors_percentage: int,
                 event_thresholds: 'outputs.HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholdsEventThresholds',
                 total_packets_rate: int):
        """
        :param int errors_percentage: Receive/transmit error packet percentage threshold
        :param 'HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholdsEventThresholdsArgs' event_thresholds: no documentation available
        :param int total_packets_rate: Total packets rate threshold
        """
        pulumi.set(__self__, "errors_percentage", errors_percentage)
        pulumi.set(__self__, "event_thresholds", event_thresholds)
        pulumi.set(__self__, "total_packets_rate", total_packets_rate)

    @property
    @pulumi.getter(name="errorsPercentage")
    def errors_percentage(self) -> int:
        """
        Receive/transmit error packet percentage threshold
        """
        return pulumi.get(self, "errors_percentage")

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholdsEventThresholds':
        """
        no documentation available
        """
        return pulumi.get(self, "event_thresholds")

    @property
    @pulumi.getter(name="totalPacketsRate")
    def total_packets_rate(self) -> int:
        """
        Total packets rate threshold
        """
        return pulumi.get(self, "total_packets_rate")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        """
        :param int dealerting_evaluation_window: The number of **10-second samples** that form the sliding evaluation window for dealerting.
        :param int dealerting_samples: The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        :param int violating_evaluation_window: The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        :param int violating_samples: The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window for dealerting.
        """
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        """
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        """
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkHighRetransmissionDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkHighRetransmissionDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkHighRetransmissionDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkHighRetransmissionDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: Detect high retransmission rate
        :param 'HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholdsArgs' custom_thresholds: Alert if the retransmission rate is higher than the specified threshold **and** the number of retransmitted packets is higher than the defined threshold for the defined amount of samples
        :param str detection_mode: Detection mode for high retransmission rate
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect high retransmission rate
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholds']:
        """
        Alert if the retransmission rate is higher than the specified threshold **and** the number of retransmitted packets is higher than the defined threshold for the defined amount of samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for high retransmission rate
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventThresholds":
            suggest = "event_thresholds"
        elif key == "retransmissionRatePercentage":
            suggest = "retransmission_rate_percentage"
        elif key == "retransmittedPacketsNumberPerMinute":
            suggest = "retransmitted_packets_number_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_thresholds: 'outputs.HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholdsEventThresholds',
                 retransmission_rate_percentage: int,
                 retransmitted_packets_number_per_minute: int):
        """
        :param 'HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholdsEventThresholdsArgs' event_thresholds: no documentation available
        :param int retransmission_rate_percentage: Retransmission rate threshold
        :param int retransmitted_packets_number_per_minute: Number of retransmitted packets threshold
        """
        pulumi.set(__self__, "event_thresholds", event_thresholds)
        pulumi.set(__self__, "retransmission_rate_percentage", retransmission_rate_percentage)
        pulumi.set(__self__, "retransmitted_packets_number_per_minute", retransmitted_packets_number_per_minute)

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholdsEventThresholds':
        """
        no documentation available
        """
        return pulumi.get(self, "event_thresholds")

    @property
    @pulumi.getter(name="retransmissionRatePercentage")
    def retransmission_rate_percentage(self) -> int:
        """
        Retransmission rate threshold
        """
        return pulumi.get(self, "retransmission_rate_percentage")

    @property
    @pulumi.getter(name="retransmittedPacketsNumberPerMinute")
    def retransmitted_packets_number_per_minute(self) -> int:
        """
        Number of retransmitted packets threshold
        """
        return pulumi.get(self, "retransmitted_packets_number_per_minute")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        """
        :param int dealerting_evaluation_window: The number of **10-second samples** that form the sliding evaluation window for dealerting.
        :param int dealerting_samples: The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        :param int violating_evaluation_window: The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        :param int violating_samples: The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window for dealerting.
        """
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        """
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        """
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkTcpProblemsDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkTcpProblemsDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkTcpProblemsDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkTcpProblemsDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: Detect TCP connectivity problems for process
        :param 'HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholdsArgs' custom_thresholds: Alert if the percentage of new connection failures is higher than the specified threshold **and** the number of failed connections is higher than the defined threshold for the defined amount of samples
        :param str detection_mode: Detection mode for TCP connectivity problems
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect TCP connectivity problems for process
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholds']:
        """
        Alert if the percentage of new connection failures is higher than the specified threshold **and** the number of failed connections is higher than the defined threshold for the defined amount of samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for TCP connectivity problems
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventThresholds":
            suggest = "event_thresholds"
        elif key == "failedConnectionsNumberPerMinute":
            suggest = "failed_connections_number_per_minute"
        elif key == "newConnectionFailuresPercentage":
            suggest = "new_connection_failures_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_thresholds: 'outputs.HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholdsEventThresholds',
                 failed_connections_number_per_minute: int,
                 new_connection_failures_percentage: int):
        """
        :param 'HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholdsEventThresholdsArgs' event_thresholds: no documentation available
        :param int failed_connections_number_per_minute: Number of failed connections threshold
        :param int new_connection_failures_percentage: New connection failure threshold
        """
        pulumi.set(__self__, "event_thresholds", event_thresholds)
        pulumi.set(__self__, "failed_connections_number_per_minute", failed_connections_number_per_minute)
        pulumi.set(__self__, "new_connection_failures_percentage", new_connection_failures_percentage)

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholdsEventThresholds':
        """
        no documentation available
        """
        return pulumi.get(self, "event_thresholds")

    @property
    @pulumi.getter(name="failedConnectionsNumberPerMinute")
    def failed_connections_number_per_minute(self) -> int:
        """
        Number of failed connections threshold
        """
        return pulumi.get(self, "failed_connections_number_per_minute")

    @property
    @pulumi.getter(name="newConnectionFailuresPercentage")
    def new_connection_failures_percentage(self) -> int:
        """
        New connection failure threshold
        """
        return pulumi.get(self, "new_connection_failures_percentage")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        """
        :param int dealerting_evaluation_window: The number of **10-second samples** that form the sliding evaluation window for dealerting.
        :param int dealerting_samples: The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        :param int violating_evaluation_window: The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        :param int violating_samples: The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window for dealerting.
        """
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must be lower the threshold to close an event
        """
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        """
        The number of **10-second samples** that form the sliding evaluation window to detect violating samples.
        """
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        The number of **10-second samples** within the evaluation window that must exceed the threshold to trigger an event
        """
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostNamingCondition(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.HostNamingConditionCondition']] = None):
        """
        :param Sequence['HostNamingConditionConditionArgs'] conditions: A conditions for the metric usage
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.HostNamingConditionCondition']]:
        """
        A conditions for the metric usage
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class HostNamingConditionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationTypeComparisons":
            suggest = "application_type_comparisons"
        elif key == "applicationTypes":
            suggest = "application_types"
        elif key == "azureComputeModeComparisons":
            suggest = "azure_compute_mode_comparisons"
        elif key == "azureComputeModes":
            suggest = "azure_compute_modes"
        elif key == "azureSkuComparisions":
            suggest = "azure_sku_comparisions"
        elif key == "azureSkus":
            suggest = "azure_skus"
        elif key == "baseComparisonBasics":
            suggest = "base_comparison_basics"
        elif key == "baseConditionKeys":
            suggest = "base_condition_keys"
        elif key == "bitnessComparisions":
            suggest = "bitness_comparisions"
        elif key == "cloudTypeComparisons":
            suggest = "cloud_type_comparisons"
        elif key == "cloudTypes":
            suggest = "cloud_types"
        elif key == "customApplicationTypeComparisons":
            suggest = "custom_application_type_comparisons"
        elif key == "customApplicationTypes":
            suggest = "custom_application_types"
        elif key == "customHostMetadataConditionKeys":
            suggest = "custom_host_metadata_condition_keys"
        elif key == "customHostMetadatas":
            suggest = "custom_host_metadatas"
        elif key == "customProcessMetadataConditionKeys":
            suggest = "custom_process_metadata_condition_keys"
        elif key == "customProcessMetadatas":
            suggest = "custom_process_metadatas"
        elif key == "databaseTopologies":
            suggest = "database_topologies"
        elif key == "databaseTopologyComparisons":
            suggest = "database_topology_comparisons"
        elif key == "dcrumDecoderComparisons":
            suggest = "dcrum_decoder_comparisons"
        elif key == "dcrumDecoders":
            suggest = "dcrum_decoders"
        elif key == "entityIdComparisons":
            suggest = "entity_id_comparisons"
        elif key == "hostTeches":
            suggest = "host_teches"
        elif key == "hypervisorTypeComparisions":
            suggest = "hypervisor_type_comparisions"
        elif key == "indexedNameComparisons":
            suggest = "indexed_name_comparisons"
        elif key == "indexedNames":
            suggest = "indexed_names"
        elif key == "indexedStringComparisons":
            suggest = "indexed_string_comparisons"
        elif key == "indexedStrings":
            suggest = "indexed_strings"
        elif key == "indexedTagComparisons":
            suggest = "indexed_tag_comparisons"
        elif key == "indexedTags":
            suggest = "indexed_tags"
        elif key == "integerComparisons":
            suggest = "integer_comparisons"
        elif key == "ipaddressComparisons":
            suggest = "ipaddress_comparisons"
        elif key == "mobilePlatformComparisons":
            suggest = "mobile_platform_comparisons"
        elif key == "mobilePlatforms":
            suggest = "mobile_platforms"
        elif key == "osArches":
            suggest = "os_arches"
        elif key == "osTypes":
            suggest = "os_types"
        elif key == "osarchitectureComparisons":
            suggest = "osarchitecture_comparisons"
        elif key == "ostypeComparisons":
            suggest = "ostype_comparisons"
        elif key == "paasTypeComparisons":
            suggest = "paas_type_comparisons"
        elif key == "paasTypes":
            suggest = "paas_types"
        elif key == "processMetadataConditionKeys":
            suggest = "process_metadata_condition_keys"
        elif key == "processMetadatas":
            suggest = "process_metadatas"
        elif key == "serviceTopologies":
            suggest = "service_topologies"
        elif key == "serviceTopologyComparisons":
            suggest = "service_topology_comparisons"
        elif key == "serviceTypeComparisons":
            suggest = "service_type_comparisons"
        elif key == "serviceTypes":
            suggest = "service_types"
        elif key == "simpleHostTechComparisons":
            suggest = "simple_host_tech_comparisons"
        elif key == "simpleTechComparisons":
            suggest = "simple_tech_comparisons"
        elif key == "stringComparisons":
            suggest = "string_comparisons"
        elif key == "stringConditionKeys":
            suggest = "string_condition_keys"
        elif key == "stringKeys":
            suggest = "string_keys"
        elif key == "syntheticEngineTypeComparisons":
            suggest = "synthetic_engine_type_comparisons"
        elif key == "syntheticEngines":
            suggest = "synthetic_engines"
        elif key == "tagComparisons":
            suggest = "tag_comparisons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_type_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionApplicationTypeComparison']] = None,
                 application_types: Optional[Sequence['outputs.HostNamingConditionConditionApplicationType']] = None,
                 azure_compute_mode_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionAzureComputeModeComparison']] = None,
                 azure_compute_modes: Optional[Sequence['outputs.HostNamingConditionConditionAzureComputeMode']] = None,
                 azure_sku_comparisions: Optional[Sequence['outputs.HostNamingConditionConditionAzureSkuComparision']] = None,
                 azure_skus: Optional[Sequence['outputs.HostNamingConditionConditionAzureSkus']] = None,
                 base_comparison_basics: Optional[Sequence['outputs.HostNamingConditionConditionBaseComparisonBasic']] = None,
                 base_condition_keys: Optional[Sequence['outputs.HostNamingConditionConditionBaseConditionKey']] = None,
                 bitness_comparisions: Optional[Sequence['outputs.HostNamingConditionConditionBitnessComparision']] = None,
                 bitnesses: Optional[Sequence['outputs.HostNamingConditionConditionBitness']] = None,
                 cloud_type_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionCloudTypeComparison']] = None,
                 cloud_types: Optional[Sequence['outputs.HostNamingConditionConditionCloudType']] = None,
                 comparisons: Optional[Sequence['outputs.HostNamingConditionConditionComparison']] = None,
                 custom_application_type_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionCustomApplicationTypeComparison']] = None,
                 custom_application_types: Optional[Sequence['outputs.HostNamingConditionConditionCustomApplicationType']] = None,
                 custom_host_metadata_condition_keys: Optional[Sequence['outputs.HostNamingConditionConditionCustomHostMetadataConditionKey']] = None,
                 custom_host_metadatas: Optional[Sequence['outputs.HostNamingConditionConditionCustomHostMetadata']] = None,
                 custom_process_metadata_condition_keys: Optional[Sequence['outputs.HostNamingConditionConditionCustomProcessMetadataConditionKey']] = None,
                 custom_process_metadatas: Optional[Sequence['outputs.HostNamingConditionConditionCustomProcessMetadata']] = None,
                 database_topologies: Optional[Sequence['outputs.HostNamingConditionConditionDatabaseTopology']] = None,
                 database_topology_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionDatabaseTopologyComparison']] = None,
                 dcrum_decoder_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionDcrumDecoderComparison']] = None,
                 dcrum_decoders: Optional[Sequence['outputs.HostNamingConditionConditionDcrumDecoder']] = None,
                 entities: Optional[Sequence['outputs.HostNamingConditionConditionEntity']] = None,
                 entity_id_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionEntityIdComparison']] = None,
                 host_teches: Optional[Sequence['outputs.HostNamingConditionConditionHostTech']] = None,
                 hypervisor_type_comparisions: Optional[Sequence['outputs.HostNamingConditionConditionHypervisorTypeComparision']] = None,
                 hypervisors: Optional[Sequence['outputs.HostNamingConditionConditionHypervisor']] = None,
                 indexed_name_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionIndexedNameComparison']] = None,
                 indexed_names: Optional[Sequence['outputs.HostNamingConditionConditionIndexedName']] = None,
                 indexed_string_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionIndexedStringComparison']] = None,
                 indexed_strings: Optional[Sequence['outputs.HostNamingConditionConditionIndexedString']] = None,
                 indexed_tag_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionIndexedTagComparison']] = None,
                 indexed_tags: Optional[Sequence['outputs.HostNamingConditionConditionIndexedTag']] = None,
                 integer_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionIntegerComparison']] = None,
                 integers: Optional[Sequence['outputs.HostNamingConditionConditionInteger']] = None,
                 ipaddress_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionIpaddressComparison']] = None,
                 ipaddresses: Optional[Sequence['outputs.HostNamingConditionConditionIpaddress']] = None,
                 keys: Optional[Sequence['outputs.HostNamingConditionConditionKey']] = None,
                 mobile_platform_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionMobilePlatformComparison']] = None,
                 mobile_platforms: Optional[Sequence['outputs.HostNamingConditionConditionMobilePlatform']] = None,
                 os_arches: Optional[Sequence['outputs.HostNamingConditionConditionOsArch']] = None,
                 os_types: Optional[Sequence['outputs.HostNamingConditionConditionOsType']] = None,
                 osarchitecture_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionOsarchitectureComparison']] = None,
                 ostype_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionOstypeComparison']] = None,
                 paas_type_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionPaasTypeComparison']] = None,
                 paas_types: Optional[Sequence['outputs.HostNamingConditionConditionPaasType']] = None,
                 process_metadata_condition_keys: Optional[Sequence['outputs.HostNamingConditionConditionProcessMetadataConditionKey']] = None,
                 process_metadatas: Optional[Sequence['outputs.HostNamingConditionConditionProcessMetadata']] = None,
                 service_topologies: Optional[Sequence['outputs.HostNamingConditionConditionServiceTopology']] = None,
                 service_topology_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionServiceTopologyComparison']] = None,
                 service_type_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionServiceTypeComparison']] = None,
                 service_types: Optional[Sequence['outputs.HostNamingConditionConditionServiceType']] = None,
                 simple_host_tech_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionSimpleHostTechComparison']] = None,
                 simple_tech_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionSimpleTechComparison']] = None,
                 string_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionStringComparison']] = None,
                 string_condition_keys: Optional[Sequence['outputs.HostNamingConditionConditionStringConditionKey']] = None,
                 string_keys: Optional[Sequence['outputs.HostNamingConditionConditionStringKey']] = None,
                 strings: Optional[Sequence['outputs.HostNamingConditionConditionString']] = None,
                 synthetic_engine_type_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionSyntheticEngineTypeComparison']] = None,
                 synthetic_engines: Optional[Sequence['outputs.HostNamingConditionConditionSyntheticEngine']] = None,
                 tag_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionTagComparison']] = None,
                 tags: Optional[Sequence['outputs.HostNamingConditionConditionTag']] = None,
                 teches: Optional[Sequence['outputs.HostNamingConditionConditionTech']] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence['HostNamingConditionConditionApplicationTypeComparisonArgs'] application_type_comparisons: Comparison for `APPLICATION_TYPE` attributes
        :param Sequence['HostNamingConditionConditionApplicationTypeArgs'] application_types: Comparison for `APPLICATION_TYPE` attributes
        :param Sequence['HostNamingConditionConditionAzureComputeModeComparisonArgs'] azure_compute_mode_comparisons: Comparison for `AZURE_COMPUTE_MODE` attributes
        :param Sequence['HostNamingConditionConditionAzureComputeModeArgs'] azure_compute_modes: Comparison for `AZURE_COMPUTE_MODE` attributes
        :param Sequence['HostNamingConditionConditionAzureSkuComparisionArgs'] azure_sku_comparisions: Comparison for `AZURE_SKU` attributes
        :param Sequence['HostNamingConditionConditionAzureSkusArgs'] azure_skus: Comparison for `AZURE_SKU` attributes
        :param Sequence['HostNamingConditionConditionBaseComparisonBasicArgs'] base_comparison_basics: A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        :param Sequence['HostNamingConditionConditionBaseConditionKeyArgs'] base_condition_keys: Fallback for not yet known type
        :param Sequence['HostNamingConditionConditionBitnessComparisionArgs'] bitness_comparisions: Comparison for `BITNESS` attributes
        :param Sequence['HostNamingConditionConditionBitnessArgs'] bitnesses: Comparison for `BITNESS` attributes
        :param Sequence['HostNamingConditionConditionCloudTypeComparisonArgs'] cloud_type_comparisons: Comparison for `CLOUD_TYPE` attributes
        :param Sequence['HostNamingConditionConditionCloudTypeArgs'] cloud_types: Comparison for `CLOUD_TYPE` attributes
        :param Sequence['HostNamingConditionConditionComparisonArgs'] comparisons: A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        :param Sequence['HostNamingConditionConditionCustomApplicationTypeComparisonArgs'] custom_application_type_comparisons: Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        :param Sequence['HostNamingConditionConditionCustomApplicationTypeArgs'] custom_application_types: Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        :param Sequence['HostNamingConditionConditionCustomHostMetadataConditionKeyArgs'] custom_host_metadata_condition_keys: Key for Custom Host Metadata
        :param Sequence['HostNamingConditionConditionCustomHostMetadataArgs'] custom_host_metadatas: Key for Custom Host Metadata
        :param Sequence['HostNamingConditionConditionCustomProcessMetadataConditionKeyArgs'] custom_process_metadata_condition_keys: Key for Custom Process Metadata
        :param Sequence['HostNamingConditionConditionCustomProcessMetadataArgs'] custom_process_metadatas: Key for Custom Process Metadata
        :param Sequence['HostNamingConditionConditionDatabaseTopologyArgs'] database_topologies: Comparison for `DATABASE_TOPOLOGY` attributes
        :param Sequence['HostNamingConditionConditionDatabaseTopologyComparisonArgs'] database_topology_comparisons: Comparison for `DATABASE_TOPOLOGY` attributes
        :param Sequence['HostNamingConditionConditionDcrumDecoderComparisonArgs'] dcrum_decoder_comparisons: Comparison for `DCRUM_DECODER_TYPE` attributes
        :param Sequence['HostNamingConditionConditionDcrumDecoderArgs'] dcrum_decoders: Comparison for `DCRUM_DECODER_TYPE` attributes
        :param Sequence['HostNamingConditionConditionEntityArgs'] entities: Comparison for `ENTITY_ID` attributes
        :param Sequence['HostNamingConditionConditionEntityIdComparisonArgs'] entity_id_comparisons: Comparison for `ENTITY_ID` attributes
        :param Sequence['HostNamingConditionConditionHostTechArgs'] host_teches: Comparison for `SIMPLE_HOST_TECH` attributes
        :param Sequence['HostNamingConditionConditionHypervisorTypeComparisionArgs'] hypervisor_type_comparisions: `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
        :param Sequence['HostNamingConditionConditionHypervisorArgs'] hypervisors: Comparison for `HYPERVISOR_TYPE` attributes
        :param Sequence['HostNamingConditionConditionIndexedNameComparisonArgs'] indexed_name_comparisons: Comparison for `INDEXED_NAME` attributes
        :param Sequence['HostNamingConditionConditionIndexedNameArgs'] indexed_names: Comparison for `INDEXED_NAME` attributes
        :param Sequence['HostNamingConditionConditionIndexedStringComparisonArgs'] indexed_string_comparisons: Comparison for `INDEXED_STRING` attributes
        :param Sequence['HostNamingConditionConditionIndexedStringArgs'] indexed_strings: Comparison for `INDEXED_STRING` attributes
        :param Sequence['HostNamingConditionConditionIndexedTagComparisonArgs'] indexed_tag_comparisons: Comparison for `INDEXED_TAG` attributes
        :param Sequence['HostNamingConditionConditionIndexedTagArgs'] indexed_tags: Comparison for `INDEXED_TAG` attributes
        :param Sequence['HostNamingConditionConditionIntegerComparisonArgs'] integer_comparisons: Comparison for `INTEGER` attributes
        :param Sequence['HostNamingConditionConditionIntegerArgs'] integers: Comparison for `INTEGER` attributes
        :param Sequence['HostNamingConditionConditionIpaddressComparisonArgs'] ipaddress_comparisons: Comparison for `IP_ADDRESS` attributes
        :param Sequence['HostNamingConditionConditionIpaddressArgs'] ipaddresses: Comparison for `IP_ADDRESS` attributes
        :param Sequence['HostNamingConditionConditionKeyArgs'] keys: Fallback for not yet known type
        :param Sequence['HostNamingConditionConditionMobilePlatformComparisonArgs'] mobile_platform_comparisons: Comparison for `MOBILE_PLATFORM` attributes
        :param Sequence['HostNamingConditionConditionMobilePlatformArgs'] mobile_platforms: Comparison for `MOBILE_PLATFORM` attributes
        :param Sequence['HostNamingConditionConditionOsArchArgs'] os_arches: Comparison for `OS_ARCHITECTURE` attributes
        :param Sequence['HostNamingConditionConditionOsTypeArgs'] os_types: Comparison for `OS_TYPE` attributes
        :param Sequence['HostNamingConditionConditionOsarchitectureComparisonArgs'] osarchitecture_comparisons: Comparison for `OS_ARCHITECTURE` attributes
        :param Sequence['HostNamingConditionConditionOstypeComparisonArgs'] ostype_comparisons: Comparison for `OS_TYPE` attributes
        :param Sequence['HostNamingConditionConditionPaasTypeComparisonArgs'] paas_type_comparisons: Comparison for `PAAS_TYPE` attributes
        :param Sequence['HostNamingConditionConditionPaasTypeArgs'] paas_types: Comparison for `PAAS_TYPE` attributes
        :param Sequence['HostNamingConditionConditionProcessMetadataConditionKeyArgs'] process_metadata_condition_keys: The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        :param Sequence['HostNamingConditionConditionProcessMetadataArgs'] process_metadatas: The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        :param Sequence['HostNamingConditionConditionServiceTopologyArgs'] service_topologies: Comparison for `SERVICE_TOPOLOGY` attributes
        :param Sequence['HostNamingConditionConditionServiceTopologyComparisonArgs'] service_topology_comparisons: Comparison for `SERVICE_TOPOLOGY` attributes
        :param Sequence['HostNamingConditionConditionServiceTypeComparisonArgs'] service_type_comparisons: Comparison for `SERVICE_TYPE` attributes
        :param Sequence['HostNamingConditionConditionServiceTypeArgs'] service_types: Comparison for `SERVICE_TYPE` attributes
        :param Sequence['HostNamingConditionConditionSimpleHostTechComparisonArgs'] simple_host_tech_comparisons: Comparison for `SIMPLE_HOST_TECH` attributes
        :param Sequence['HostNamingConditionConditionSimpleTechComparisonArgs'] simple_tech_comparisons: Comparison for `SIMPLE_TECH` attributes
        :param Sequence['HostNamingConditionConditionStringComparisonArgs'] string_comparisons: Comparison for `STRING` attributes
        :param Sequence['HostNamingConditionConditionStringConditionKeyArgs'] string_condition_keys: The key for dynamic attributes of the `STRING` type
        :param Sequence['HostNamingConditionConditionStringKeyArgs'] string_keys: The key for dynamic attributes of the `STRING` type
        :param Sequence['HostNamingConditionConditionStringArgs'] strings: Comparison for `STRING` attributes
        :param Sequence['HostNamingConditionConditionSyntheticEngineTypeComparisonArgs'] synthetic_engine_type_comparisons: Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        :param Sequence['HostNamingConditionConditionSyntheticEngineArgs'] synthetic_engines: Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        :param Sequence['HostNamingConditionConditionTagComparisonArgs'] tag_comparisons: Comparison for `TAG` attributes
        :param Sequence['HostNamingConditionConditionTagArgs'] tags: Comparison for `TAG` attributes
        :param Sequence['HostNamingConditionConditionTechArgs'] teches: Comparison for `SIMPLE_TECH` attributes
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if application_type_comparisons is not None:
            pulumi.set(__self__, "application_type_comparisons", application_type_comparisons)
        if application_types is not None:
            pulumi.set(__self__, "application_types", application_types)
        if azure_compute_mode_comparisons is not None:
            pulumi.set(__self__, "azure_compute_mode_comparisons", azure_compute_mode_comparisons)
        if azure_compute_modes is not None:
            pulumi.set(__self__, "azure_compute_modes", azure_compute_modes)
        if azure_sku_comparisions is not None:
            pulumi.set(__self__, "azure_sku_comparisions", azure_sku_comparisions)
        if azure_skus is not None:
            pulumi.set(__self__, "azure_skus", azure_skus)
        if base_comparison_basics is not None:
            pulumi.set(__self__, "base_comparison_basics", base_comparison_basics)
        if base_condition_keys is not None:
            pulumi.set(__self__, "base_condition_keys", base_condition_keys)
        if bitness_comparisions is not None:
            pulumi.set(__self__, "bitness_comparisions", bitness_comparisions)
        if bitnesses is not None:
            pulumi.set(__self__, "bitnesses", bitnesses)
        if cloud_type_comparisons is not None:
            pulumi.set(__self__, "cloud_type_comparisons", cloud_type_comparisons)
        if cloud_types is not None:
            pulumi.set(__self__, "cloud_types", cloud_types)
        if comparisons is not None:
            pulumi.set(__self__, "comparisons", comparisons)
        if custom_application_type_comparisons is not None:
            pulumi.set(__self__, "custom_application_type_comparisons", custom_application_type_comparisons)
        if custom_application_types is not None:
            pulumi.set(__self__, "custom_application_types", custom_application_types)
        if custom_host_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_host_metadata_condition_keys", custom_host_metadata_condition_keys)
        if custom_host_metadatas is not None:
            pulumi.set(__self__, "custom_host_metadatas", custom_host_metadatas)
        if custom_process_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_process_metadata_condition_keys", custom_process_metadata_condition_keys)
        if custom_process_metadatas is not None:
            pulumi.set(__self__, "custom_process_metadatas", custom_process_metadatas)
        if database_topologies is not None:
            pulumi.set(__self__, "database_topologies", database_topologies)
        if database_topology_comparisons is not None:
            pulumi.set(__self__, "database_topology_comparisons", database_topology_comparisons)
        if dcrum_decoder_comparisons is not None:
            pulumi.set(__self__, "dcrum_decoder_comparisons", dcrum_decoder_comparisons)
        if dcrum_decoders is not None:
            pulumi.set(__self__, "dcrum_decoders", dcrum_decoders)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if entity_id_comparisons is not None:
            pulumi.set(__self__, "entity_id_comparisons", entity_id_comparisons)
        if host_teches is not None:
            pulumi.set(__self__, "host_teches", host_teches)
        if hypervisor_type_comparisions is not None:
            pulumi.set(__self__, "hypervisor_type_comparisions", hypervisor_type_comparisions)
        if hypervisors is not None:
            pulumi.set(__self__, "hypervisors", hypervisors)
        if indexed_name_comparisons is not None:
            pulumi.set(__self__, "indexed_name_comparisons", indexed_name_comparisons)
        if indexed_names is not None:
            pulumi.set(__self__, "indexed_names", indexed_names)
        if indexed_string_comparisons is not None:
            pulumi.set(__self__, "indexed_string_comparisons", indexed_string_comparisons)
        if indexed_strings is not None:
            pulumi.set(__self__, "indexed_strings", indexed_strings)
        if indexed_tag_comparisons is not None:
            pulumi.set(__self__, "indexed_tag_comparisons", indexed_tag_comparisons)
        if indexed_tags is not None:
            pulumi.set(__self__, "indexed_tags", indexed_tags)
        if integer_comparisons is not None:
            pulumi.set(__self__, "integer_comparisons", integer_comparisons)
        if integers is not None:
            pulumi.set(__self__, "integers", integers)
        if ipaddress_comparisons is not None:
            pulumi.set(__self__, "ipaddress_comparisons", ipaddress_comparisons)
        if ipaddresses is not None:
            pulumi.set(__self__, "ipaddresses", ipaddresses)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if mobile_platform_comparisons is not None:
            pulumi.set(__self__, "mobile_platform_comparisons", mobile_platform_comparisons)
        if mobile_platforms is not None:
            pulumi.set(__self__, "mobile_platforms", mobile_platforms)
        if os_arches is not None:
            pulumi.set(__self__, "os_arches", os_arches)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if osarchitecture_comparisons is not None:
            pulumi.set(__self__, "osarchitecture_comparisons", osarchitecture_comparisons)
        if ostype_comparisons is not None:
            pulumi.set(__self__, "ostype_comparisons", ostype_comparisons)
        if paas_type_comparisons is not None:
            pulumi.set(__self__, "paas_type_comparisons", paas_type_comparisons)
        if paas_types is not None:
            pulumi.set(__self__, "paas_types", paas_types)
        if process_metadata_condition_keys is not None:
            pulumi.set(__self__, "process_metadata_condition_keys", process_metadata_condition_keys)
        if process_metadatas is not None:
            pulumi.set(__self__, "process_metadatas", process_metadatas)
        if service_topologies is not None:
            pulumi.set(__self__, "service_topologies", service_topologies)
        if service_topology_comparisons is not None:
            pulumi.set(__self__, "service_topology_comparisons", service_topology_comparisons)
        if service_type_comparisons is not None:
            pulumi.set(__self__, "service_type_comparisons", service_type_comparisons)
        if service_types is not None:
            pulumi.set(__self__, "service_types", service_types)
        if simple_host_tech_comparisons is not None:
            pulumi.set(__self__, "simple_host_tech_comparisons", simple_host_tech_comparisons)
        if simple_tech_comparisons is not None:
            pulumi.set(__self__, "simple_tech_comparisons", simple_tech_comparisons)
        if string_comparisons is not None:
            pulumi.set(__self__, "string_comparisons", string_comparisons)
        if string_condition_keys is not None:
            pulumi.set(__self__, "string_condition_keys", string_condition_keys)
        if string_keys is not None:
            pulumi.set(__self__, "string_keys", string_keys)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)
        if synthetic_engine_type_comparisons is not None:
            pulumi.set(__self__, "synthetic_engine_type_comparisons", synthetic_engine_type_comparisons)
        if synthetic_engines is not None:
            pulumi.set(__self__, "synthetic_engines", synthetic_engines)
        if tag_comparisons is not None:
            pulumi.set(__self__, "tag_comparisons", tag_comparisons)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if teches is not None:
            pulumi.set(__self__, "teches", teches)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="applicationTypeComparisons")
    @_utilities.deprecated("""You should use 'application_type' instead of 'application_type_comparison'. This attribute still exists for backwards compatibility.""")
    def application_type_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionApplicationTypeComparison']]:
        """
        Comparison for `APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "application_type_comparisons")

    @property
    @pulumi.getter(name="applicationTypes")
    def application_types(self) -> Optional[Sequence['outputs.HostNamingConditionConditionApplicationType']]:
        """
        Comparison for `APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "application_types")

    @property
    @pulumi.getter(name="azureComputeModeComparisons")
    def azure_compute_mode_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionAzureComputeModeComparison']]:
        """
        Comparison for `AZURE_COMPUTE_MODE` attributes
        """
        return pulumi.get(self, "azure_compute_mode_comparisons")

    @property
    @pulumi.getter(name="azureComputeModes")
    @_utilities.deprecated("""You should use 'azure_compute_mode' instead of 'azure_compute_mode_comparison'. This attribute still exists for backwards compatibility.""")
    def azure_compute_modes(self) -> Optional[Sequence['outputs.HostNamingConditionConditionAzureComputeMode']]:
        """
        Comparison for `AZURE_COMPUTE_MODE` attributes
        """
        return pulumi.get(self, "azure_compute_modes")

    @property
    @pulumi.getter(name="azureSkuComparisions")
    @_utilities.deprecated("""You should use 'azure_sku' instead of 'azure_sku_comparision'. This attribute still exists for backwards compatibility.""")
    def azure_sku_comparisions(self) -> Optional[Sequence['outputs.HostNamingConditionConditionAzureSkuComparision']]:
        """
        Comparison for `AZURE_SKU` attributes
        """
        return pulumi.get(self, "azure_sku_comparisions")

    @property
    @pulumi.getter(name="azureSkus")
    def azure_skus(self) -> Optional[Sequence['outputs.HostNamingConditionConditionAzureSkus']]:
        """
        Comparison for `AZURE_SKU` attributes
        """
        return pulumi.get(self, "azure_skus")

    @property
    @pulumi.getter(name="baseComparisonBasics")
    @_utilities.deprecated("""You should use 'comparison' instead of 'base_comparison_basic'. This attribute still exists for backwards compatibility.""")
    def base_comparison_basics(self) -> Optional[Sequence['outputs.HostNamingConditionConditionBaseComparisonBasic']]:
        """
        A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        """
        return pulumi.get(self, "base_comparison_basics")

    @property
    @pulumi.getter(name="baseConditionKeys")
    @_utilities.deprecated("""'base_condition_key' is deprecated. You should use 'key'""")
    def base_condition_keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionBaseConditionKey']]:
        """
        Fallback for not yet known type
        """
        return pulumi.get(self, "base_condition_keys")

    @property
    @pulumi.getter(name="bitnessComparisions")
    @_utilities.deprecated("""You should use 'bitness' instead of 'bitness_comparision'. This attribute still exists for backwards compatibility.""")
    def bitness_comparisions(self) -> Optional[Sequence['outputs.HostNamingConditionConditionBitnessComparision']]:
        """
        Comparison for `BITNESS` attributes
        """
        return pulumi.get(self, "bitness_comparisions")

    @property
    @pulumi.getter
    def bitnesses(self) -> Optional[Sequence['outputs.HostNamingConditionConditionBitness']]:
        """
        Comparison for `BITNESS` attributes
        """
        return pulumi.get(self, "bitnesses")

    @property
    @pulumi.getter(name="cloudTypeComparisons")
    @_utilities.deprecated("""You should use 'cloud_type' instead of 'cloud_type_comparison'. This attribute still exists for backwards compatibility.""")
    def cloud_type_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCloudTypeComparison']]:
        """
        Comparison for `CLOUD_TYPE` attributes
        """
        return pulumi.get(self, "cloud_type_comparisons")

    @property
    @pulumi.getter(name="cloudTypes")
    def cloud_types(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCloudType']]:
        """
        Comparison for `CLOUD_TYPE` attributes
        """
        return pulumi.get(self, "cloud_types")

    @property
    @pulumi.getter
    def comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionComparison']]:
        """
        A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        """
        return pulumi.get(self, "comparisons")

    @property
    @pulumi.getter(name="customApplicationTypeComparisons")
    @_utilities.deprecated("""You should use 'custom_application_type' instead of 'custom_application_type_comparison'. This attribute still exists for backwards compatibility.""")
    def custom_application_type_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCustomApplicationTypeComparison']]:
        """
        Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "custom_application_type_comparisons")

    @property
    @pulumi.getter(name="customApplicationTypes")
    def custom_application_types(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCustomApplicationType']]:
        """
        Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "custom_application_types")

    @property
    @pulumi.getter(name="customHostMetadataConditionKeys")
    @_utilities.deprecated("""'custom_host_metadata_condition_key' is deprecated. You should use 'custom_host_metadata'""")
    def custom_host_metadata_condition_keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCustomHostMetadataConditionKey']]:
        """
        Key for Custom Host Metadata
        """
        return pulumi.get(self, "custom_host_metadata_condition_keys")

    @property
    @pulumi.getter(name="customHostMetadatas")
    def custom_host_metadatas(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCustomHostMetadata']]:
        """
        Key for Custom Host Metadata
        """
        return pulumi.get(self, "custom_host_metadatas")

    @property
    @pulumi.getter(name="customProcessMetadataConditionKeys")
    @_utilities.deprecated("""'custom_process_metadata_condition_key' is deprecated. You should use 'custom_process_metadata'""")
    def custom_process_metadata_condition_keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCustomProcessMetadataConditionKey']]:
        """
        Key for Custom Process Metadata
        """
        return pulumi.get(self, "custom_process_metadata_condition_keys")

    @property
    @pulumi.getter(name="customProcessMetadatas")
    def custom_process_metadatas(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCustomProcessMetadata']]:
        """
        Key for Custom Process Metadata
        """
        return pulumi.get(self, "custom_process_metadatas")

    @property
    @pulumi.getter(name="databaseTopologies")
    def database_topologies(self) -> Optional[Sequence['outputs.HostNamingConditionConditionDatabaseTopology']]:
        """
        Comparison for `DATABASE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "database_topologies")

    @property
    @pulumi.getter(name="databaseTopologyComparisons")
    @_utilities.deprecated("""You should use 'database_topology' instead of 'database_topology_comparison'. This attribute still exists for backwards compatibility.""")
    def database_topology_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionDatabaseTopologyComparison']]:
        """
        Comparison for `DATABASE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "database_topology_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoderComparisons")
    @_utilities.deprecated("""You should use 'dcrum_decoder' instead of 'dcrum_decoder_comparison'. This attribute still exists for backwards compatibility.""")
    def dcrum_decoder_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionDcrumDecoderComparison']]:
        """
        Comparison for `DCRUM_DECODER_TYPE` attributes
        """
        return pulumi.get(self, "dcrum_decoder_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoders")
    def dcrum_decoders(self) -> Optional[Sequence['outputs.HostNamingConditionConditionDcrumDecoder']]:
        """
        Comparison for `DCRUM_DECODER_TYPE` attributes
        """
        return pulumi.get(self, "dcrum_decoders")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.HostNamingConditionConditionEntity']]:
        """
        Comparison for `ENTITY_ID` attributes
        """
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="entityIdComparisons")
    @_utilities.deprecated("""You should use 'entity' instead of 'entity_id_comparison'. This attribute still exists for backwards compatibility.""")
    def entity_id_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionEntityIdComparison']]:
        """
        Comparison for `ENTITY_ID` attributes
        """
        return pulumi.get(self, "entity_id_comparisons")

    @property
    @pulumi.getter(name="hostTeches")
    def host_teches(self) -> Optional[Sequence['outputs.HostNamingConditionConditionHostTech']]:
        """
        Comparison for `SIMPLE_HOST_TECH` attributes
        """
        return pulumi.get(self, "host_teches")

    @property
    @pulumi.getter(name="hypervisorTypeComparisions")
    @_utilities.deprecated("""`hypervisor_type_comparision` is deprecated. Use `hypervisor` instead""")
    def hypervisor_type_comparisions(self) -> Optional[Sequence['outputs.HostNamingConditionConditionHypervisorTypeComparision']]:
        """
        `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
        """
        return pulumi.get(self, "hypervisor_type_comparisions")

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[Sequence['outputs.HostNamingConditionConditionHypervisor']]:
        """
        Comparison for `HYPERVISOR_TYPE` attributes
        """
        return pulumi.get(self, "hypervisors")

    @property
    @pulumi.getter(name="indexedNameComparisons")
    @_utilities.deprecated("""You should use 'indexed_name' instead of 'indexed_name_comparison'. This attribute still exists for backwards compatibility.""")
    def indexed_name_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIndexedNameComparison']]:
        """
        Comparison for `INDEXED_NAME` attributes
        """
        return pulumi.get(self, "indexed_name_comparisons")

    @property
    @pulumi.getter(name="indexedNames")
    def indexed_names(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIndexedName']]:
        """
        Comparison for `INDEXED_NAME` attributes
        """
        return pulumi.get(self, "indexed_names")

    @property
    @pulumi.getter(name="indexedStringComparisons")
    @_utilities.deprecated("""You should use 'indexed_string' instead of 'indexed_string_comparison'. This attribute still exists for backwards compatibility.""")
    def indexed_string_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIndexedStringComparison']]:
        """
        Comparison for `INDEXED_STRING` attributes
        """
        return pulumi.get(self, "indexed_string_comparisons")

    @property
    @pulumi.getter(name="indexedStrings")
    def indexed_strings(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIndexedString']]:
        """
        Comparison for `INDEXED_STRING` attributes
        """
        return pulumi.get(self, "indexed_strings")

    @property
    @pulumi.getter(name="indexedTagComparisons")
    @_utilities.deprecated("""You should use 'indexed_tag' instead of 'indexed_tag_comparison'. This attribute still exists for backwards compatibility.""")
    def indexed_tag_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIndexedTagComparison']]:
        """
        Comparison for `INDEXED_TAG` attributes
        """
        return pulumi.get(self, "indexed_tag_comparisons")

    @property
    @pulumi.getter(name="indexedTags")
    def indexed_tags(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIndexedTag']]:
        """
        Comparison for `INDEXED_TAG` attributes
        """
        return pulumi.get(self, "indexed_tags")

    @property
    @pulumi.getter(name="integerComparisons")
    @_utilities.deprecated("""You should use 'integer' instead of 'integer_comparison'. This attribute still exists for backwards compatibility.""")
    def integer_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIntegerComparison']]:
        """
        Comparison for `INTEGER` attributes
        """
        return pulumi.get(self, "integer_comparisons")

    @property
    @pulumi.getter
    def integers(self) -> Optional[Sequence['outputs.HostNamingConditionConditionInteger']]:
        """
        Comparison for `INTEGER` attributes
        """
        return pulumi.get(self, "integers")

    @property
    @pulumi.getter(name="ipaddressComparisons")
    @_utilities.deprecated("""You should use 'ipaddress' instead of 'ipaddress_comparison'. This attribute still exists for backwards compatibility.""")
    def ipaddress_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIpaddressComparison']]:
        """
        Comparison for `IP_ADDRESS` attributes
        """
        return pulumi.get(self, "ipaddress_comparisons")

    @property
    @pulumi.getter
    def ipaddresses(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIpaddress']]:
        """
        Comparison for `IP_ADDRESS` attributes
        """
        return pulumi.get(self, "ipaddresses")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionKey']]:
        """
        Fallback for not yet known type
        """
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter(name="mobilePlatformComparisons")
    @_utilities.deprecated("""You should use 'mobile_platform' instead of 'mobile_platform_comparison'. This attribute still exists for backwards compatibility.""")
    def mobile_platform_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionMobilePlatformComparison']]:
        """
        Comparison for `MOBILE_PLATFORM` attributes
        """
        return pulumi.get(self, "mobile_platform_comparisons")

    @property
    @pulumi.getter(name="mobilePlatforms")
    def mobile_platforms(self) -> Optional[Sequence['outputs.HostNamingConditionConditionMobilePlatform']]:
        """
        Comparison for `MOBILE_PLATFORM` attributes
        """
        return pulumi.get(self, "mobile_platforms")

    @property
    @pulumi.getter(name="osArches")
    def os_arches(self) -> Optional[Sequence['outputs.HostNamingConditionConditionOsArch']]:
        """
        Comparison for `OS_ARCHITECTURE` attributes
        """
        return pulumi.get(self, "os_arches")

    @property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[Sequence['outputs.HostNamingConditionConditionOsType']]:
        """
        Comparison for `OS_TYPE` attributes
        """
        return pulumi.get(self, "os_types")

    @property
    @pulumi.getter(name="osarchitectureComparisons")
    @_utilities.deprecated("""You should use 'os_arch' instead of 'osarchitecture_comparison'. This attribute still exists for backwards compatibility.""")
    def osarchitecture_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionOsarchitectureComparison']]:
        """
        Comparison for `OS_ARCHITECTURE` attributes
        """
        return pulumi.get(self, "osarchitecture_comparisons")

    @property
    @pulumi.getter(name="ostypeComparisons")
    @_utilities.deprecated("""You should use 'os_type' instead of 'ostype_comparison'. This attribute still exists for backwards compatibility.""")
    def ostype_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionOstypeComparison']]:
        """
        Comparison for `OS_TYPE` attributes
        """
        return pulumi.get(self, "ostype_comparisons")

    @property
    @pulumi.getter(name="paasTypeComparisons")
    @_utilities.deprecated("""You should use 'paas_type' instead of 'paas_type_comparison'. This attribute still exists for backwards compatibility.""")
    def paas_type_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionPaasTypeComparison']]:
        """
        Comparison for `PAAS_TYPE` attributes
        """
        return pulumi.get(self, "paas_type_comparisons")

    @property
    @pulumi.getter(name="paasTypes")
    def paas_types(self) -> Optional[Sequence['outputs.HostNamingConditionConditionPaasType']]:
        """
        Comparison for `PAAS_TYPE` attributes
        """
        return pulumi.get(self, "paas_types")

    @property
    @pulumi.getter(name="processMetadataConditionKeys")
    @_utilities.deprecated("""'process_metadata_condition_key' is deprecated. You should use 'process_metadata'""")
    def process_metadata_condition_keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionProcessMetadataConditionKey']]:
        """
        The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        """
        return pulumi.get(self, "process_metadata_condition_keys")

    @property
    @pulumi.getter(name="processMetadatas")
    def process_metadatas(self) -> Optional[Sequence['outputs.HostNamingConditionConditionProcessMetadata']]:
        """
        The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        """
        return pulumi.get(self, "process_metadatas")

    @property
    @pulumi.getter(name="serviceTopologies")
    def service_topologies(self) -> Optional[Sequence['outputs.HostNamingConditionConditionServiceTopology']]:
        """
        Comparison for `SERVICE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "service_topologies")

    @property
    @pulumi.getter(name="serviceTopologyComparisons")
    @_utilities.deprecated("""You should use 'service_topology' instead of 'service_topology_comparison'. This attribute still exists for backwards compatibility.""")
    def service_topology_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionServiceTopologyComparison']]:
        """
        Comparison for `SERVICE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "service_topology_comparisons")

    @property
    @pulumi.getter(name="serviceTypeComparisons")
    @_utilities.deprecated("""You should use 'service_type' instead of 'service_type_comparison'. This attribute still exists for backwards compatibility.""")
    def service_type_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionServiceTypeComparison']]:
        """
        Comparison for `SERVICE_TYPE` attributes
        """
        return pulumi.get(self, "service_type_comparisons")

    @property
    @pulumi.getter(name="serviceTypes")
    def service_types(self) -> Optional[Sequence['outputs.HostNamingConditionConditionServiceType']]:
        """
        Comparison for `SERVICE_TYPE` attributes
        """
        return pulumi.get(self, "service_types")

    @property
    @pulumi.getter(name="simpleHostTechComparisons")
    @_utilities.deprecated("""You should use 'host_tech' instead of 'simple_host_tech_comparison'. This attribute still exists for backwards compatibility.""")
    def simple_host_tech_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionSimpleHostTechComparison']]:
        """
        Comparison for `SIMPLE_HOST_TECH` attributes
        """
        return pulumi.get(self, "simple_host_tech_comparisons")

    @property
    @pulumi.getter(name="simpleTechComparisons")
    @_utilities.deprecated("""You should use 'tech' instead of 'simple_tech_comparison'. This attribute still exists for backwards compatibility.""")
    def simple_tech_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionSimpleTechComparison']]:
        """
        Comparison for `SIMPLE_TECH` attributes
        """
        return pulumi.get(self, "simple_tech_comparisons")

    @property
    @pulumi.getter(name="stringComparisons")
    @_utilities.deprecated("""You should use 'string' instead of 'string_comparison'. This attribute still exists for backwards compatibility.""")
    def string_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionStringComparison']]:
        """
        Comparison for `STRING` attributes
        """
        return pulumi.get(self, "string_comparisons")

    @property
    @pulumi.getter(name="stringConditionKeys")
    @_utilities.deprecated("""'string_condition_key' is deprecated. You should use 'string_key'""")
    def string_condition_keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionStringConditionKey']]:
        """
        The key for dynamic attributes of the `STRING` type
        """
        return pulumi.get(self, "string_condition_keys")

    @property
    @pulumi.getter(name="stringKeys")
    def string_keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionStringKey']]:
        """
        The key for dynamic attributes of the `STRING` type
        """
        return pulumi.get(self, "string_keys")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence['outputs.HostNamingConditionConditionString']]:
        """
        Comparison for `STRING` attributes
        """
        return pulumi.get(self, "strings")

    @property
    @pulumi.getter(name="syntheticEngineTypeComparisons")
    @_utilities.deprecated("""You should use 'synthetic_engine' instead of 'synthetic_engine_type_comparison'. This attribute still exists for backwards compatibility.""")
    def synthetic_engine_type_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionSyntheticEngineTypeComparison']]:
        """
        Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        """
        return pulumi.get(self, "synthetic_engine_type_comparisons")

    @property
    @pulumi.getter(name="syntheticEngines")
    def synthetic_engines(self) -> Optional[Sequence['outputs.HostNamingConditionConditionSyntheticEngine']]:
        """
        Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        """
        return pulumi.get(self, "synthetic_engines")

    @property
    @pulumi.getter(name="tagComparisons")
    @_utilities.deprecated("""You should use 'tag' instead of 'tag_comparison'. This attribute still exists for backwards compatibility.""")
    def tag_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionTagComparison']]:
        """
        Comparison for `TAG` attributes
        """
        return pulumi.get(self, "tag_comparisons")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.HostNamingConditionConditionTag']]:
        """
        Comparison for `TAG` attributes
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def teches(self) -> Optional[Sequence['outputs.HostNamingConditionConditionTech']]:
        """
        Comparison for `SIMPLE_TECH` attributes
        """
        return pulumi.get(self, "teches")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be APPLICATION_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be APPLICATION_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionAzureComputeMode(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are DEDICATED or SHARED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are DEDICATED or SHARED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionAzureComputeModeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are DEDICATED or SHARED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are DEDICATED or SHARED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionAzureSkuComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be AZURE_SKU
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be AZURE_SKU
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionAzureSkus(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionBaseComparisonBasic(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str type: The type of comparison
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of comparison
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionBaseConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str type: Defines the actual set of fields depending on the value
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defines the actual set of fields depending on the value
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionBitness(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are 32 and 64.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are 32 and 64.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionBitnessComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be BITNESS
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are 32 and 64.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be BITNESS
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are 32 and 64.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionCloudType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionCloudTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be CLOUD_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be CLOUD_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionComparison(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str type: The type of comparison
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of comparison
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionCustomApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be CUSTOM_APPLICATION_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be CUSTOM_APPLICATION_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionCustomHostMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionCustomHostMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionCustomHostMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionCustomHostMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.HostNamingConditionConditionCustomHostMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'HostNamingConditionConditionCustomHostMetadataDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.HostNamingConditionConditionCustomHostMetadataDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomHostMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionCustomHostMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.HostNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'HostNamingConditionConditionCustomHostMetadataConditionKeyDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str type: if specified, needs to be HOST_CUSTOM_METADATA_KEY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.HostNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be HOST_CUSTOM_METADATA_KEY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomHostMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionCustomProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionCustomProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionCustomProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.HostNamingConditionConditionCustomProcessMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'HostNamingConditionConditionCustomProcessMetadataDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.HostNamingConditionConditionCustomProcessMetadataDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionCustomProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.HostNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'HostNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str type: if specified, needs to be PROCESS_CUSTOM_METADATA_KEY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.HostNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be PROCESS_CUSTOM_METADATA_KEY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomProcessMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionDatabaseTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionDatabaseTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be DATABASE_TOPOLOGY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be DATABASE_TOPOLOGY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionDcrumDecoder(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionDcrumDecoderComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be DCRUM_DECODER_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be DCRUM_DECODER_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionEntity(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionEntityIdComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be ENTITY_ID
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be ENTITY_ID
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionHostTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionHostTechValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'HostNamingConditionConditionHostTechValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionHostTechValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionHostTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionHostTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionHostTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionHostTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class HostNamingConditionConditionHypervisor(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionHypervisorTypeComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be HYPERVISOR_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be HYPERVISOR_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedName(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedNameComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be INDEXED_NAME
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INDEXED_NAME
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedString(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedStringComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be INDEXED_STRING
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INDEXED_STRING
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionIndexedTagValue'] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param 'HostNamingConditionConditionIndexedTagValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionIndexedTagValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionIndexedTagComparisonValue'] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be INDEXED_TAG
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param 'HostNamingConditionConditionIndexedTagComparisonValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INDEXED_TAG
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionIndexedTagComparisonValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionInteger(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param int value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIntegerComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be INTEGER
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param int value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INTEGER
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIpaddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionIpaddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionIpaddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionIpaddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIpaddressComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionIpaddressComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionIpaddressComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionIpaddressComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be IP_ADDRESS
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be IP_ADDRESS
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str type: Defines the actual set of fields depending on the value
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defines the actual set of fields depending on the value
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionMobilePlatform(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionMobilePlatformComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be MOBILE_PLATFORM
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be MOBILE_PLATFORM
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionOsArch(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionOsType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionOsarchitectureComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be OS_ARCHITECTURE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be OS_ARCHITECTURE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionOstypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be OS_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be OS_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionPaasType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionPaasTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be PAAS_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be PAAS_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        :param str type: if specified, needs to be PROCESS_PREDEFINED_METADATA_KEY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be PROCESS_PREDEFINED_METADATA_KEY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionServiceTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionServiceTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SERVICE_TOPOLOGY
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SERVICE_TOPOLOGY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionServiceType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionServiceTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SERVICE_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SERVICE_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionSimpleHostTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionSimpleHostTechComparisonValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SIMPLE_HOST_TECH
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'HostNamingConditionConditionSimpleHostTechComparisonValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SIMPLE_HOST_TECH
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionSimpleHostTechComparisonValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionSimpleHostTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionSimpleHostTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class HostNamingConditionConditionSimpleTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionSimpleTechComparisonValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SIMPLE_TECH
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'HostNamingConditionConditionSimpleTechComparisonValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SIMPLE_TECH
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionSimpleTechComparisonValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionSimpleTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionSimpleTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionSimpleTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionSimpleTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class HostNamingConditionConditionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionStringComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionStringComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionStringComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionStringComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be STRING
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be STRING
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionStringConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionStringConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionStringConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionStringConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
                  - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
                  - `AMAZON_ECR_IMAGE_REGION`
                  - `AMAZON_LAMBDA_FUNCTION_NAME`
                  - `AMAZON_REGION`
                  - `APACHE_CONFIG_PATH`
                  - `APACHE_SPARK_MASTER_IP_ADDRESS`
                  - `ASP_DOT_NET_CORE_APPLICATION_PATH`
                  - `AWS_ECS_CLUSTER`
                  - `AWS_ECS_CONTAINERNAME`
                  - `AWS_ECS_FAMILY`
                  - `AWS_ECS_REVISION`
                  - `CASSANDRA_CLUSTER_NAME`
                  - `CATALINA_BASE`
                  - `CATALINA_HOME`
                  - `CLOUD_FOUNDRY_APP_ID`
                  - `CLOUD_FOUNDRY_APP_NAME`
                  - `CLOUD_FOUNDRY_INSTANCE_INDEX`
                  - `CLOUD_FOUNDRY_SPACE_ID`
                  - `CLOUD_FOUNDRY_SPACE_NAME`
                  - `COLDFUSION_JVM_CONFIG_FILE`
                  - `COLDFUSION_SERVICE_NAME`
                  - `COMMAND_LINE_ARGS`
                  - `DOTNET_COMMAND`
                  - `DOTNET_COMMAND_PATH`
                  - `DYNATRACE_CLUSTER_ID`
                  - `DYNATRACE_NODE_ID`
                  - `ELASTICSEARCH_CLUSTER_NAME`
                  - `ELASTICSEARCH_NODE_NAME`
                  - `EQUINOX_CONFIG_PATH`
                  - `EXE_NAME`
                  - `EXE_PATH`
                  - `GLASS_FISH_DOMAIN_NAME`
                  - `GLASS_FISH_INSTANCE_NAME`
                  - `GOOGLE_APP_ENGINE_INSTANCE`
                  - `GOOGLE_APP_ENGINE_SERVICE`
                  - `GOOGLE_CLOUD_PROJECT`
                  - `HYBRIS_BIN_DIRECTORY`
                  - `HYBRIS_CONFIG_DIRECTORY`
                  - `HYBRIS_DATA_DIRECTORY`
                  - `IBM_CICS_REGION`
                  - `IBM_CTG_NAME`
                  - `IBM_IMS_CONNECT_REGION`
                  - `IBM_IMS_CONTROL_REGION`
                  - `IBM_IMS_MESSAGE_PROCESSING_REGION`
                  - `IBM_IMS_SOAP_GW_NAME`
                  - `IBM_INTEGRATION_NODE_NAME`
                  - `IBM_INTEGRATION_SERVER_NAME`
                  - `IIS_APP_POOL`
                  - `IIS_ROLE_NAME`
                  - `JAVA_JAR_FILE`
                  - `JAVA_JAR_PATH`
                  - `JAVA_MAIN_CLASS`
                  - `JAVA_MAIN_MODULE`
                  - `JBOSS_HOME`
                  - `JBOSS_MODE`
                  - `JBOSS_SERVER_NAME`
                  - `KUBERNETES_BASE_POD_NAME`
                  - `KUBERNETES_CONTAINER_NAME`
                  - `KUBERNETES_FULL_POD_NAME`
                  - `KUBERNETES_NAMESPACE`
                  - `KUBERNETES_POD_UID`
                  - `MSSQL_INSTANCE_NAME`
                  - `NODE_JS_APP_BASE_DIRECTORY`
                  - `NODE_JS_APP_NAME`
                  - `NODE_JS_SCRIPT_NAME`
                  - `ORACLE_SID`
                  - `PG_ID_CALC_INPUT_KEY_LINKAGE`
                  - `PHP_SCRIPT_PATH`
                  - `PHP_WORKING_DIRECTORY`
                  - `RUBY_APP_ROOT_PATH`
                  - `RUBY_SCRIPT_PATH`
                  - `RULE_RESULT`
                  - `SOFTWAREAG_INSTALL_ROOT`
                  - `SOFTWAREAG_PRODUCTPROPNAME`
                  - `SPRINGBOOT_APP_NAME`
                  - `SPRINGBOOT_PROFILE_NAME`
                  - `SPRINGBOOT_STARTUP_CLASS`
                  - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
                  - `TIBCO_BUSINESSWORKS_CE_VERSION`
                  - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
                  - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
                  - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
                  - `TIBCO_BUSINESS_WORKS_HOME`
                  - `VARNISH_INSTANCE_NAME`
                  - `WEB_LOGIC_CLUSTER_NAME`
                  - `WEB_LOGIC_DOMAIN_NAME`
                  - `WEB_LOGIC_HOME`
                  - `WEB_LOGIC_NAME`
                  - `WEB_SPHERE_CELL_NAME`
                  - `WEB_SPHERE_CLUSTER_NAME`
                  - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        :param str type: if specified, needs to be `STRING`
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
           - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
           - `AMAZON_ECR_IMAGE_REGION`
           - `AMAZON_LAMBDA_FUNCTION_NAME`
           - `AMAZON_REGION`
           - `APACHE_CONFIG_PATH`
           - `APACHE_SPARK_MASTER_IP_ADDRESS`
           - `ASP_DOT_NET_CORE_APPLICATION_PATH`
           - `AWS_ECS_CLUSTER`
           - `AWS_ECS_CONTAINERNAME`
           - `AWS_ECS_FAMILY`
           - `AWS_ECS_REVISION`
           - `CASSANDRA_CLUSTER_NAME`
           - `CATALINA_BASE`
           - `CATALINA_HOME`
           - `CLOUD_FOUNDRY_APP_ID`
           - `CLOUD_FOUNDRY_APP_NAME`
           - `CLOUD_FOUNDRY_INSTANCE_INDEX`
           - `CLOUD_FOUNDRY_SPACE_ID`
           - `CLOUD_FOUNDRY_SPACE_NAME`
           - `COLDFUSION_JVM_CONFIG_FILE`
           - `COLDFUSION_SERVICE_NAME`
           - `COMMAND_LINE_ARGS`
           - `DOTNET_COMMAND`
           - `DOTNET_COMMAND_PATH`
           - `DYNATRACE_CLUSTER_ID`
           - `DYNATRACE_NODE_ID`
           - `ELASTICSEARCH_CLUSTER_NAME`
           - `ELASTICSEARCH_NODE_NAME`
           - `EQUINOX_CONFIG_PATH`
           - `EXE_NAME`
           - `EXE_PATH`
           - `GLASS_FISH_DOMAIN_NAME`
           - `GLASS_FISH_INSTANCE_NAME`
           - `GOOGLE_APP_ENGINE_INSTANCE`
           - `GOOGLE_APP_ENGINE_SERVICE`
           - `GOOGLE_CLOUD_PROJECT`
           - `HYBRIS_BIN_DIRECTORY`
           - `HYBRIS_CONFIG_DIRECTORY`
           - `HYBRIS_DATA_DIRECTORY`
           - `IBM_CICS_REGION`
           - `IBM_CTG_NAME`
           - `IBM_IMS_CONNECT_REGION`
           - `IBM_IMS_CONTROL_REGION`
           - `IBM_IMS_MESSAGE_PROCESSING_REGION`
           - `IBM_IMS_SOAP_GW_NAME`
           - `IBM_INTEGRATION_NODE_NAME`
           - `IBM_INTEGRATION_SERVER_NAME`
           - `IIS_APP_POOL`
           - `IIS_ROLE_NAME`
           - `JAVA_JAR_FILE`
           - `JAVA_JAR_PATH`
           - `JAVA_MAIN_CLASS`
           - `JAVA_MAIN_MODULE`
           - `JBOSS_HOME`
           - `JBOSS_MODE`
           - `JBOSS_SERVER_NAME`
           - `KUBERNETES_BASE_POD_NAME`
           - `KUBERNETES_CONTAINER_NAME`
           - `KUBERNETES_FULL_POD_NAME`
           - `KUBERNETES_NAMESPACE`
           - `KUBERNETES_POD_UID`
           - `MSSQL_INSTANCE_NAME`
           - `NODE_JS_APP_BASE_DIRECTORY`
           - `NODE_JS_APP_NAME`
           - `NODE_JS_SCRIPT_NAME`
           - `ORACLE_SID`
           - `PG_ID_CALC_INPUT_KEY_LINKAGE`
           - `PHP_SCRIPT_PATH`
           - `PHP_WORKING_DIRECTORY`
           - `RUBY_APP_ROOT_PATH`
           - `RUBY_SCRIPT_PATH`
           - `RULE_RESULT`
           - `SOFTWAREAG_INSTALL_ROOT`
           - `SOFTWAREAG_PRODUCTPROPNAME`
           - `SPRINGBOOT_APP_NAME`
           - `SPRINGBOOT_PROFILE_NAME`
           - `SPRINGBOOT_STARTUP_CLASS`
           - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
           - `TIBCO_BUSINESSWORKS_CE_VERSION`
           - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
           - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
           - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
           - `TIBCO_BUSINESS_WORKS_HOME`
           - `VARNISH_INSTANCE_NAME`
           - `WEB_LOGIC_CLUSTER_NAME`
           - `WEB_LOGIC_DOMAIN_NAME`
           - `WEB_LOGIC_HOME`
           - `WEB_LOGIC_NAME`
           - `WEB_SPHERE_CELL_NAME`
           - `WEB_SPHERE_CLUSTER_NAME`
           - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be `STRING`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionStringKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionStringKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionStringKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionStringKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
                  - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
                  - `AMAZON_ECR_IMAGE_REGION`
                  - `AMAZON_LAMBDA_FUNCTION_NAME`
                  - `AMAZON_REGION`
                  - `APACHE_CONFIG_PATH`
                  - `APACHE_SPARK_MASTER_IP_ADDRESS`
                  - `ASP_DOT_NET_CORE_APPLICATION_PATH`
                  - `AWS_ECS_CLUSTER`
                  - `AWS_ECS_CONTAINERNAME`
                  - `AWS_ECS_FAMILY`
                  - `AWS_ECS_REVISION`
                  - `CASSANDRA_CLUSTER_NAME`
                  - `CATALINA_BASE`
                  - `CATALINA_HOME`
                  - `CLOUD_FOUNDRY_APP_ID`
                  - `CLOUD_FOUNDRY_APP_NAME`
                  - `CLOUD_FOUNDRY_INSTANCE_INDEX`
                  - `CLOUD_FOUNDRY_SPACE_ID`
                  - `CLOUD_FOUNDRY_SPACE_NAME`
                  - `COLDFUSION_JVM_CONFIG_FILE`
                  - `COLDFUSION_SERVICE_NAME`
                  - `COMMAND_LINE_ARGS`
                  - `DOTNET_COMMAND`
                  - `DOTNET_COMMAND_PATH`
                  - `DYNATRACE_CLUSTER_ID`
                  - `DYNATRACE_NODE_ID`
                  - `ELASTICSEARCH_CLUSTER_NAME`
                  - `ELASTICSEARCH_NODE_NAME`
                  - `EQUINOX_CONFIG_PATH`
                  - `EXE_NAME`
                  - `EXE_PATH`
                  - `GLASS_FISH_DOMAIN_NAME`
                  - `GLASS_FISH_INSTANCE_NAME`
                  - `GOOGLE_APP_ENGINE_INSTANCE`
                  - `GOOGLE_APP_ENGINE_SERVICE`
                  - `GOOGLE_CLOUD_PROJECT`
                  - `HYBRIS_BIN_DIRECTORY`
                  - `HYBRIS_CONFIG_DIRECTORY`
                  - `HYBRIS_DATA_DIRECTORY`
                  - `IBM_CICS_REGION`
                  - `IBM_CTG_NAME`
                  - `IBM_IMS_CONNECT_REGION`
                  - `IBM_IMS_CONTROL_REGION`
                  - `IBM_IMS_MESSAGE_PROCESSING_REGION`
                  - `IBM_IMS_SOAP_GW_NAME`
                  - `IBM_INTEGRATION_NODE_NAME`
                  - `IBM_INTEGRATION_SERVER_NAME`
                  - `IIS_APP_POOL`
                  - `IIS_ROLE_NAME`
                  - `JAVA_JAR_FILE`
                  - `JAVA_JAR_PATH`
                  - `JAVA_MAIN_CLASS`
                  - `JAVA_MAIN_MODULE`
                  - `JBOSS_HOME`
                  - `JBOSS_MODE`
                  - `JBOSS_SERVER_NAME`
                  - `KUBERNETES_BASE_POD_NAME`
                  - `KUBERNETES_CONTAINER_NAME`
                  - `KUBERNETES_FULL_POD_NAME`
                  - `KUBERNETES_NAMESPACE`
                  - `KUBERNETES_POD_UID`
                  - `MSSQL_INSTANCE_NAME`
                  - `NODE_JS_APP_BASE_DIRECTORY`
                  - `NODE_JS_APP_NAME`
                  - `NODE_JS_SCRIPT_NAME`
                  - `ORACLE_SID`
                  - `PG_ID_CALC_INPUT_KEY_LINKAGE`
                  - `PHP_SCRIPT_PATH`
                  - `PHP_WORKING_DIRECTORY`
                  - `RUBY_APP_ROOT_PATH`
                  - `RUBY_SCRIPT_PATH`
                  - `RULE_RESULT`
                  - `SOFTWAREAG_INSTALL_ROOT`
                  - `SOFTWAREAG_PRODUCTPROPNAME`
                  - `SPRINGBOOT_APP_NAME`
                  - `SPRINGBOOT_PROFILE_NAME`
                  - `SPRINGBOOT_STARTUP_CLASS`
                  - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
                  - `TIBCO_BUSINESSWORKS_CE_VERSION`
                  - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
                  - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
                  - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
                  - `TIBCO_BUSINESS_WORKS_HOME`
                  - `VARNISH_INSTANCE_NAME`
                  - `WEB_LOGIC_CLUSTER_NAME`
                  - `WEB_LOGIC_DOMAIN_NAME`
                  - `WEB_LOGIC_HOME`
                  - `WEB_LOGIC_NAME`
                  - `WEB_SPHERE_CELL_NAME`
                  - `WEB_SPHERE_CLUSTER_NAME`
                  - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
           - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
           - `AMAZON_ECR_IMAGE_REGION`
           - `AMAZON_LAMBDA_FUNCTION_NAME`
           - `AMAZON_REGION`
           - `APACHE_CONFIG_PATH`
           - `APACHE_SPARK_MASTER_IP_ADDRESS`
           - `ASP_DOT_NET_CORE_APPLICATION_PATH`
           - `AWS_ECS_CLUSTER`
           - `AWS_ECS_CONTAINERNAME`
           - `AWS_ECS_FAMILY`
           - `AWS_ECS_REVISION`
           - `CASSANDRA_CLUSTER_NAME`
           - `CATALINA_BASE`
           - `CATALINA_HOME`
           - `CLOUD_FOUNDRY_APP_ID`
           - `CLOUD_FOUNDRY_APP_NAME`
           - `CLOUD_FOUNDRY_INSTANCE_INDEX`
           - `CLOUD_FOUNDRY_SPACE_ID`
           - `CLOUD_FOUNDRY_SPACE_NAME`
           - `COLDFUSION_JVM_CONFIG_FILE`
           - `COLDFUSION_SERVICE_NAME`
           - `COMMAND_LINE_ARGS`
           - `DOTNET_COMMAND`
           - `DOTNET_COMMAND_PATH`
           - `DYNATRACE_CLUSTER_ID`
           - `DYNATRACE_NODE_ID`
           - `ELASTICSEARCH_CLUSTER_NAME`
           - `ELASTICSEARCH_NODE_NAME`
           - `EQUINOX_CONFIG_PATH`
           - `EXE_NAME`
           - `EXE_PATH`
           - `GLASS_FISH_DOMAIN_NAME`
           - `GLASS_FISH_INSTANCE_NAME`
           - `GOOGLE_APP_ENGINE_INSTANCE`
           - `GOOGLE_APP_ENGINE_SERVICE`
           - `GOOGLE_CLOUD_PROJECT`
           - `HYBRIS_BIN_DIRECTORY`
           - `HYBRIS_CONFIG_DIRECTORY`
           - `HYBRIS_DATA_DIRECTORY`
           - `IBM_CICS_REGION`
           - `IBM_CTG_NAME`
           - `IBM_IMS_CONNECT_REGION`
           - `IBM_IMS_CONTROL_REGION`
           - `IBM_IMS_MESSAGE_PROCESSING_REGION`
           - `IBM_IMS_SOAP_GW_NAME`
           - `IBM_INTEGRATION_NODE_NAME`
           - `IBM_INTEGRATION_SERVER_NAME`
           - `IIS_APP_POOL`
           - `IIS_ROLE_NAME`
           - `JAVA_JAR_FILE`
           - `JAVA_JAR_PATH`
           - `JAVA_MAIN_CLASS`
           - `JAVA_MAIN_MODULE`
           - `JBOSS_HOME`
           - `JBOSS_MODE`
           - `JBOSS_SERVER_NAME`
           - `KUBERNETES_BASE_POD_NAME`
           - `KUBERNETES_CONTAINER_NAME`
           - `KUBERNETES_FULL_POD_NAME`
           - `KUBERNETES_NAMESPACE`
           - `KUBERNETES_POD_UID`
           - `MSSQL_INSTANCE_NAME`
           - `NODE_JS_APP_BASE_DIRECTORY`
           - `NODE_JS_APP_NAME`
           - `NODE_JS_SCRIPT_NAME`
           - `ORACLE_SID`
           - `PG_ID_CALC_INPUT_KEY_LINKAGE`
           - `PHP_SCRIPT_PATH`
           - `PHP_WORKING_DIRECTORY`
           - `RUBY_APP_ROOT_PATH`
           - `RUBY_SCRIPT_PATH`
           - `RULE_RESULT`
           - `SOFTWAREAG_INSTALL_ROOT`
           - `SOFTWAREAG_PRODUCTPROPNAME`
           - `SPRINGBOOT_APP_NAME`
           - `SPRINGBOOT_PROFILE_NAME`
           - `SPRINGBOOT_STARTUP_CLASS`
           - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
           - `TIBCO_BUSINESSWORKS_CE_VERSION`
           - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
           - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
           - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
           - `TIBCO_BUSINESS_WORKS_HOME`
           - `VARNISH_INSTANCE_NAME`
           - `WEB_LOGIC_CLUSTER_NAME`
           - `WEB_LOGIC_DOMAIN_NAME`
           - `WEB_LOGIC_HOME`
           - `WEB_LOGIC_NAME`
           - `WEB_SPHERE_CELL_NAME`
           - `WEB_SPHERE_CLUSTER_NAME`
           - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionSyntheticEngine(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionSyntheticEngineTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SYNTHETIC_ENGINE_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SYNTHETIC_ENGINE_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionTagValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'HostNamingConditionConditionTagValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionTagValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionTagComparisonValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be TAG
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'HostNamingConditionConditionTagComparisonValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be TAG
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionTagComparisonValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionTechValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'HostNamingConditionConditionTechValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionTechValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class HttpMonitorAnomalyDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadingTimeThresholds":
            suggest = "loading_time_thresholds"
        elif key == "outageHandlings":
            suggest = "outage_handlings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorAnomalyDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorAnomalyDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorAnomalyDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 loading_time_thresholds: Optional[Sequence['outputs.HttpMonitorAnomalyDetectionLoadingTimeThreshold']] = None,
                 outage_handlings: Optional[Sequence['outputs.HttpMonitorAnomalyDetectionOutageHandling']] = None):
        """
        :param Sequence['HttpMonitorAnomalyDetectionLoadingTimeThresholdArgs'] loading_time_thresholds: Thresholds for loading times
        :param Sequence['HttpMonitorAnomalyDetectionOutageHandlingArgs'] outage_handlings: Outage handling configuration
        """
        if loading_time_thresholds is not None:
            pulumi.set(__self__, "loading_time_thresholds", loading_time_thresholds)
        if outage_handlings is not None:
            pulumi.set(__self__, "outage_handlings", outage_handlings)

    @property
    @pulumi.getter(name="loadingTimeThresholds")
    def loading_time_thresholds(self) -> Optional[Sequence['outputs.HttpMonitorAnomalyDetectionLoadingTimeThreshold']]:
        """
        Thresholds for loading times
        """
        return pulumi.get(self, "loading_time_thresholds")

    @property
    @pulumi.getter(name="outageHandlings")
    def outage_handlings(self) -> Optional[Sequence['outputs.HttpMonitorAnomalyDetectionOutageHandling']]:
        """
        Outage handling configuration
        """
        return pulumi.get(self, "outage_handlings")


@pulumi.output_type
class HttpMonitorAnomalyDetectionLoadingTimeThreshold(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 thresholds: Optional[Sequence['outputs.HttpMonitorAnomalyDetectionLoadingTimeThresholdThreshold']] = None):
        """
        :param bool enabled: Performance threshold is enabled (`true`) or disabled (`false`)
        :param Sequence['HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdArgs'] thresholds: The list of performance threshold rules
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Performance threshold is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional[Sequence['outputs.HttpMonitorAnomalyDetectionLoadingTimeThresholdThreshold']]:
        """
        The list of performance threshold rules
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HttpMonitorAnomalyDetectionLoadingTimeThresholdThreshold(dict):
    def __init__(__self__, *,
                 thresholds: Sequence['outputs.HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold']):
        """
        :param Sequence['HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThresholdArgs'] thresholds: The list of performance threshold rules
        """
        pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold']:
        """
        The list of performance threshold rules
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueMs":
            suggest = "value_ms"
        elif key == "eventIndex":
            suggest = "event_index"
        elif key == "requestIndex":
            suggest = "request_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value_ms: int,
                 event_index: Optional[int] = None,
                 request_index: Optional[int] = None,
                 type: Optional[str] = None):
        """
        :param int value_ms: Notify if monitor takes longer than *X* milliseconds to load
        :param int event_index: Specify the event to which an ACTION threshold applies
        :param int request_index: Specify the request to which an ACTION threshold applies
        :param str type: The type of the threshold: `TOTAL` (total loading time) or `ACTION` (action loading time)
        """
        pulumi.set(__self__, "value_ms", value_ms)
        if event_index is not None:
            pulumi.set(__self__, "event_index", event_index)
        if request_index is not None:
            pulumi.set(__self__, "request_index", request_index)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="valueMs")
    def value_ms(self) -> int:
        """
        Notify if monitor takes longer than *X* milliseconds to load
        """
        return pulumi.get(self, "value_ms")

    @property
    @pulumi.getter(name="eventIndex")
    def event_index(self) -> Optional[int]:
        """
        Specify the event to which an ACTION threshold applies
        """
        return pulumi.get(self, "event_index")

    @property
    @pulumi.getter(name="requestIndex")
    def request_index(self) -> Optional[int]:
        """
        Specify the request to which an ACTION threshold applies
        """
        return pulumi.get(self, "request_index")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the threshold: `TOTAL` (total loading time) or `ACTION` (action loading time)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class HttpMonitorAnomalyDetectionOutageHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "globalOutage":
            suggest = "global_outage"
        elif key == "globalOutagePolicies":
            suggest = "global_outage_policies"
        elif key == "localOutage":
            suggest = "local_outage"
        elif key == "localOutagePolicies":
            suggest = "local_outage_policies"
        elif key == "retryOnError":
            suggest = "retry_on_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorAnomalyDetectionOutageHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorAnomalyDetectionOutageHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorAnomalyDetectionOutageHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 global_outage: Optional[bool] = None,
                 global_outage_policies: Optional[Sequence['outputs.HttpMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy']] = None,
                 local_outage: Optional[bool] = None,
                 local_outage_policies: Optional[Sequence['outputs.HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy']] = None,
                 retry_on_error: Optional[bool] = None):
        """
        :param bool global_outage: (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) When enabled (`true`), generate a problem and send an alert when the monitor is unavailable at all configured locations
        :param Sequence['HttpMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicyArgs'] global_outage_policies: (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) Global outage handling configuration.
        :param bool local_outage: (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) When enabled (`true`), generate a problem and send an alert when the monitor is unavailable for one or more consecutive runs at any location
        :param Sequence['HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicyArgs'] local_outage_policies: (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) Local outage handling configuration. 
               
                Alert if **affectedLocations** of locations are unable to access the web application **consecutiveRuns** times consecutively
        :param bool retry_on_error: (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) Schedule retry if browser monitor execution results in a fail. For HTTP monitors this property is ignored
        """
        if global_outage is not None:
            pulumi.set(__self__, "global_outage", global_outage)
        if global_outage_policies is not None:
            pulumi.set(__self__, "global_outage_policies", global_outage_policies)
        if local_outage is not None:
            pulumi.set(__self__, "local_outage", local_outage)
        if local_outage_policies is not None:
            pulumi.set(__self__, "local_outage_policies", local_outage_policies)
        if retry_on_error is not None:
            pulumi.set(__self__, "retry_on_error", retry_on_error)

    @property
    @pulumi.getter(name="globalOutage")
    def global_outage(self) -> Optional[bool]:
        """
        (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) When enabled (`true`), generate a problem and send an alert when the monitor is unavailable at all configured locations
        """
        return pulumi.get(self, "global_outage")

    @property
    @pulumi.getter(name="globalOutagePolicies")
    def global_outage_policies(self) -> Optional[Sequence['outputs.HttpMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy']]:
        """
        (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) Global outage handling configuration.
        """
        return pulumi.get(self, "global_outage_policies")

    @property
    @pulumi.getter(name="localOutage")
    def local_outage(self) -> Optional[bool]:
        """
        (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) When enabled (`true`), generate a problem and send an alert when the monitor is unavailable for one or more consecutive runs at any location
        """
        return pulumi.get(self, "local_outage")

    @property
    @pulumi.getter(name="localOutagePolicies")
    def local_outage_policies(self) -> Optional[Sequence['outputs.HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy']]:
        """
        (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) Local outage handling configuration. 

         Alert if **affectedLocations** of locations are unable to access the web application **consecutiveRuns** times consecutively
        """
        return pulumi.get(self, "local_outage_policies")

    @property
    @pulumi.getter(name="retryOnError")
    def retry_on_error(self) -> Optional[bool]:
        """
        (Field has overlap with `BrowserMonitorOutage` and `HttpMonitorOutage`) Schedule retry if browser monitor execution results in a fail. For HTTP monitors this property is ignored
        """
        return pulumi.get(self, "retry_on_error")


@pulumi.output_type
class HttpMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consecutiveRuns":
            suggest = "consecutive_runs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consecutive_runs: int):
        """
        :param int consecutive_runs: The number of consecutive fails to trigger an alert
        """
        pulumi.set(__self__, "consecutive_runs", consecutive_runs)

    @property
    @pulumi.getter(name="consecutiveRuns")
    def consecutive_runs(self) -> int:
        """
        The number of consecutive fails to trigger an alert
        """
        return pulumi.get(self, "consecutive_runs")


@pulumi.output_type
class HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "affectedLocations":
            suggest = "affected_locations"
        elif key == "consecutiveRuns":
            suggest = "consecutive_runs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affected_locations: int,
                 consecutive_runs: int):
        """
        :param int affected_locations: The number of affected locations to trigger an alert
        :param int consecutive_runs: The number of consecutive fails to trigger an alert
        """
        pulumi.set(__self__, "affected_locations", affected_locations)
        pulumi.set(__self__, "consecutive_runs", consecutive_runs)

    @property
    @pulumi.getter(name="affectedLocations")
    def affected_locations(self) -> int:
        """
        The number of affected locations to trigger an alert
        """
        return pulumi.get(self, "affected_locations")

    @property
    @pulumi.getter(name="consecutiveRuns")
    def consecutive_runs(self) -> int:
        """
        The number of consecutive fails to trigger an alert
        """
        return pulumi.get(self, "consecutive_runs")


@pulumi.output_type
class HttpMonitorCookiesCookies(dict):
    def __init__(__self__, *,
                 cookies: Sequence['outputs.HttpMonitorCookiesCookiesCookie']):
        pulumi.set(__self__, "cookies", cookies)

    @property
    @pulumi.getter
    def cookies(self) -> Sequence['outputs.HttpMonitorCookiesCookiesCookie']:
        return pulumi.get(self, "cookies")


@pulumi.output_type
class HttpMonitorCookiesCookiesCookie(dict):
    def __init__(__self__, *,
                 domain: str,
                 name: str,
                 value: str,
                 path: Optional[str] = None):
        """
        :param str domain: Enclose placeholder values in brackets, for example {email}
        :param str name: Enclose placeholder values in brackets, for example {email}
        :param str value: Enclose placeholder values in brackets, for example {email}
        :param str path: Enclose placeholder values in brackets, for example {email}
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        Enclose placeholder values in brackets, for example {email}
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Enclose placeholder values in brackets, for example {email}
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Enclose placeholder values in brackets, for example {email}
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Enclose placeholder values in brackets, for example {email}
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class HttpMonitorPerformanceThresholds(dict):
    def __init__(__self__, *,
                 thresholds: Sequence['outputs.HttpMonitorPerformanceThresholdsThreshold']):
        pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.HttpMonitorPerformanceThresholdsThreshold']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HttpMonitorPerformanceThresholdsThreshold(dict):
    def __init__(__self__, *,
                 event: str,
                 threshold: float):
        """
        :param str event: Request
        :param float threshold: Threshold (in seconds)
        """
        pulumi.set(__self__, "event", event)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def event(self) -> str:
        """
        Request
        """
        return pulumi.get(self, "event")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Threshold (in seconds)
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class HttpMonitorScript(dict):
    def __init__(__self__, *,
                 requests: Sequence['outputs.HttpMonitorScriptRequest']):
        """
        :param Sequence['HttpMonitorScriptRequestArgs'] requests: A HTTP request to be performed by the monitor.
        """
        pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def requests(self) -> Sequence['outputs.HttpMonitorScriptRequest']:
        """
        A HTTP request to be performed by the monitor.
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class HttpMonitorScriptRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postProcessing":
            suggest = "post_processing"
        elif key == "preProcessing":
            suggest = "pre_processing"
        elif key == "requestTimeout":
            suggest = "request_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorScriptRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorScriptRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorScriptRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 url: str,
                 authentication: Optional['outputs.HttpMonitorScriptRequestAuthentication'] = None,
                 body: Optional[str] = None,
                 configuration: Optional['outputs.HttpMonitorScriptRequestConfiguration'] = None,
                 description: Optional[str] = None,
                 post_processing: Optional[str] = None,
                 pre_processing: Optional[str] = None,
                 request_timeout: Optional[int] = None,
                 validation: Optional['outputs.HttpMonitorScriptRequestValidation'] = None):
        """
        :param str method: The HTTP method of the request.
        :param str url: The URL to check.
        :param 'HttpMonitorScriptRequestAuthenticationArgs' authentication: Authentication options for this request
        :param str body: The body of the HTTP request.
        :param 'HttpMonitorScriptRequestConfigurationArgs' configuration: The setup of the monitor
        :param str description: A short description of the event to appear in the web UI.
        :param str post_processing: Javascript code to execute after sending the request.
        :param str pre_processing: Javascript code to execute before sending the request.
        :param int request_timeout: Adapt request timeout option - the maximum time this request is allowed to consume. Keep in mind the maximum timeout of the complete monitor is 60 seconds
        :param 'HttpMonitorScriptRequestValidationArgs' validation: Validation helps you verify that your HTTP monitor loads the expected content
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "url", url)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if post_processing is not None:
            pulumi.set(__self__, "post_processing", post_processing)
        if pre_processing is not None:
            pulumi.set(__self__, "pre_processing", pre_processing)
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The HTTP method of the request.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL to check.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.HttpMonitorScriptRequestAuthentication']:
        """
        Authentication options for this request
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        The body of the HTTP request.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.HttpMonitorScriptRequestConfiguration']:
        """
        The setup of the monitor
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A short description of the event to appear in the web UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="postProcessing")
    def post_processing(self) -> Optional[str]:
        """
        Javascript code to execute after sending the request.
        """
        return pulumi.get(self, "post_processing")

    @property
    @pulumi.getter(name="preProcessing")
    def pre_processing(self) -> Optional[str]:
        """
        Javascript code to execute before sending the request.
        """
        return pulumi.get(self, "pre_processing")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[int]:
        """
        Adapt request timeout option - the maximum time this request is allowed to consume. Keep in mind the maximum timeout of the complete monitor is 60 seconds
        """
        return pulumi.get(self, "request_timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.HttpMonitorScriptRequestValidation']:
        """
        Validation helps you verify that your HTTP monitor loads the expected content
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class HttpMonitorScriptRequestAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kdcIp":
            suggest = "kdc_ip"
        elif key == "realmName":
            suggest = "realm_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorScriptRequestAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorScriptRequestAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorScriptRequestAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: str,
                 type: str,
                 kdc_ip: Optional[str] = None,
                 realm_name: Optional[str] = None):
        """
        :param str credentials: The ID of the credentials within the Dynatrace Credentials Vault.
        :param str type: The type of authentication. Possible values are `BASIC_AUTHENTICATION`, `NTLM` and `KERBEROS`.
        :param str kdc_ip: The KDC IP. Valid and required only if the type of authentication is `KERBEROS`.
        :param str realm_name: The Realm Name. Valid and required only if the type of authentication is `KERBEROS`.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "type", type)
        if kdc_ip is not None:
            pulumi.set(__self__, "kdc_ip", kdc_ip)
        if realm_name is not None:
            pulumi.set(__self__, "realm_name", realm_name)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        """
        The ID of the credentials within the Dynatrace Credentials Vault.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of authentication. Possible values are `BASIC_AUTHENTICATION`, `NTLM` and `KERBEROS`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="kdcIp")
    def kdc_ip(self) -> Optional[str]:
        """
        The KDC IP. Valid and required only if the type of authentication is `KERBEROS`.
        """
        return pulumi.get(self, "kdc_ip")

    @property
    @pulumi.getter(name="realmName")
    def realm_name(self) -> Optional[str]:
        """
        The Realm Name. Valid and required only if the type of authentication is `KERBEROS`.
        """
        return pulumi.get(self, "realm_name")


@pulumi.output_type
class HttpMonitorScriptRequestConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptAnyCertificate":
            suggest = "accept_any_certificate"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "followRedirects":
            suggest = "follow_redirects"
        elif key == "sensitiveData":
            suggest = "sensitive_data"
        elif key == "userAgent":
            suggest = "user_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorScriptRequestConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorScriptRequestConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorScriptRequestConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept_any_certificate: Optional[bool] = None,
                 client_certificate: Optional[str] = None,
                 follow_redirects: Optional[bool] = None,
                 headers: Optional['outputs.HttpMonitorScriptRequestConfigurationHeaders'] = None,
                 sensitive_data: Optional[bool] = None,
                 user_agent: Optional[str] = None):
        """
        :param bool accept_any_certificate: If set to `false`, then the monitor fails with invalid SSL certificates.
        :param str client_certificate: The client certificate, if applicable - eg. CREDENTIALS_VAULT-XXXXXXXXXXXXXXXX
        :param bool follow_redirects: If set to `false`, redirects are reported as successful requests with response code 3xx.
               
               If not set, the `false` option is used.
        :param 'HttpMonitorScriptRequestConfigurationHeadersArgs' headers: The setup of the monitor
        :param bool sensitive_data: Option not to store and display request and response bodies and header values in execution details, `true` or `false`. If not set, `false`.
        :param str user_agent: The User agent of the request
        """
        if accept_any_certificate is not None:
            pulumi.set(__self__, "accept_any_certificate", accept_any_certificate)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if sensitive_data is not None:
            pulumi.set(__self__, "sensitive_data", sensitive_data)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)

    @property
    @pulumi.getter(name="acceptAnyCertificate")
    def accept_any_certificate(self) -> Optional[bool]:
        """
        If set to `false`, then the monitor fails with invalid SSL certificates.
        """
        return pulumi.get(self, "accept_any_certificate")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        The client certificate, if applicable - eg. CREDENTIALS_VAULT-XXXXXXXXXXXXXXXX
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[bool]:
        """
        If set to `false`, redirects are reported as successful requests with response code 3xx.

        If not set, the `false` option is used.
        """
        return pulumi.get(self, "follow_redirects")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.HttpMonitorScriptRequestConfigurationHeaders']:
        """
        The setup of the monitor
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="sensitiveData")
    def sensitive_data(self) -> Optional[bool]:
        """
        Option not to store and display request and response bodies and header values in execution details, `true` or `false`. If not set, `false`.
        """
        return pulumi.get(self, "sensitive_data")

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[str]:
        """
        The User agent of the request
        """
        return pulumi.get(self, "user_agent")


@pulumi.output_type
class HttpMonitorScriptRequestConfigurationHeaders(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.HttpMonitorScriptRequestConfigurationHeadersHeader']):
        """
        :param Sequence['HttpMonitorScriptRequestConfigurationHeadersHeaderArgs'] headers: contains an HTTP header of the request
        """
        pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.HttpMonitorScriptRequestConfigurationHeadersHeader']:
        """
        contains an HTTP header of the request
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class HttpMonitorScriptRequestConfigurationHeadersHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The key of the header
        :param str value: The value of the header
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The key of the header
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the header
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HttpMonitorScriptRequestValidation(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.HttpMonitorScriptRequestValidationRule']):
        """
        :param Sequence['HttpMonitorScriptRequestValidationRuleArgs'] rules: A list of validation rules
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.HttpMonitorScriptRequestValidationRule']:
        """
        A list of validation rules
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class HttpMonitorScriptRequestValidationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passIfFound":
            suggest = "pass_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorScriptRequestValidationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorScriptRequestValidationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorScriptRequestValidationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 value: str,
                 pass_if_found: Optional[bool] = None):
        """
        :param str type: The type of the rule. Possible values are `patternConstraint`, `regexConstraint`, `httpStatusesList` and `certificateExpiryDateConstraint`
        :param str value: The content to look for
        :param bool pass_if_found: The validation condition. `true` means validation succeeds if the specified content/element is found. `false` means validation fails if the specified content/element is found. Always specify `false` for `certificateExpiryDateConstraint` to fail the monitor if SSL certificate expiry is within the specified number of days
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if pass_if_found is not None:
            pulumi.set(__self__, "pass_if_found", pass_if_found)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the rule. Possible values are `patternConstraint`, `regexConstraint`, `httpStatusesList` and `certificateExpiryDateConstraint`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The content to look for
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="passIfFound")
    def pass_if_found(self) -> Optional[bool]:
        """
        The validation condition. `true` means validation succeeds if the specified content/element is found. `false` means validation fails if the specified content/element is found. Always specify `false` for `certificateExpiryDateConstraint` to fail the monitor if SSL certificate expiry is within the specified number of days
        """
        return pulumi.get(self, "pass_if_found")


@pulumi.output_type
class HttpMonitorScriptScript(dict):
    def __init__(__self__, *,
                 requests: Sequence['outputs.HttpMonitorScriptScriptRequest']):
        """
        :param Sequence['HttpMonitorScriptScriptRequestArgs'] requests: A HTTP request to be performed by the monitor.
        """
        pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def requests(self) -> Sequence['outputs.HttpMonitorScriptScriptRequest']:
        """
        A HTTP request to be performed by the monitor.
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class HttpMonitorScriptScriptRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postProcessing":
            suggest = "post_processing"
        elif key == "preProcessing":
            suggest = "pre_processing"
        elif key == "requestTimeout":
            suggest = "request_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorScriptScriptRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorScriptScriptRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorScriptScriptRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 url: str,
                 authentication: Optional['outputs.HttpMonitorScriptScriptRequestAuthentication'] = None,
                 body: Optional[str] = None,
                 configuration: Optional['outputs.HttpMonitorScriptScriptRequestConfiguration'] = None,
                 description: Optional[str] = None,
                 post_processing: Optional[str] = None,
                 pre_processing: Optional[str] = None,
                 request_timeout: Optional[int] = None,
                 validation: Optional['outputs.HttpMonitorScriptScriptRequestValidation'] = None):
        """
        :param str method: The HTTP method of the request.
        :param str url: The URL to check.
        :param 'HttpMonitorScriptScriptRequestAuthenticationArgs' authentication: Authentication options for this request
        :param str body: The body of the HTTP request.
        :param 'HttpMonitorScriptScriptRequestConfigurationArgs' configuration: The setup of the monitor
        :param str description: A short description of the event to appear in the web UI.
        :param str post_processing: Javascript code to execute after sending the request.
        :param str pre_processing: Javascript code to execute before sending the request.
        :param int request_timeout: Adapt request timeout option - the maximum time this request is allowed to consume. Keep in mind the maximum timeout of the complete monitor is 60 seconds
        :param 'HttpMonitorScriptScriptRequestValidationArgs' validation: Validation helps you verify that your HTTP monitor loads the expected content
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "url", url)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if post_processing is not None:
            pulumi.set(__self__, "post_processing", post_processing)
        if pre_processing is not None:
            pulumi.set(__self__, "pre_processing", pre_processing)
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The HTTP method of the request.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL to check.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.HttpMonitorScriptScriptRequestAuthentication']:
        """
        Authentication options for this request
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        The body of the HTTP request.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.HttpMonitorScriptScriptRequestConfiguration']:
        """
        The setup of the monitor
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A short description of the event to appear in the web UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="postProcessing")
    def post_processing(self) -> Optional[str]:
        """
        Javascript code to execute after sending the request.
        """
        return pulumi.get(self, "post_processing")

    @property
    @pulumi.getter(name="preProcessing")
    def pre_processing(self) -> Optional[str]:
        """
        Javascript code to execute before sending the request.
        """
        return pulumi.get(self, "pre_processing")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[int]:
        """
        Adapt request timeout option - the maximum time this request is allowed to consume. Keep in mind the maximum timeout of the complete monitor is 60 seconds
        """
        return pulumi.get(self, "request_timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.HttpMonitorScriptScriptRequestValidation']:
        """
        Validation helps you verify that your HTTP monitor loads the expected content
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class HttpMonitorScriptScriptRequestAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kdcIp":
            suggest = "kdc_ip"
        elif key == "realmName":
            suggest = "realm_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorScriptScriptRequestAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorScriptScriptRequestAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorScriptScriptRequestAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: str,
                 type: str,
                 kdc_ip: Optional[str] = None,
                 realm_name: Optional[str] = None):
        """
        :param str credentials: The ID of the credentials within the Dynatrace Credentials Vault.
        :param str type: The type of authentication. Possible values are `BASIC_AUTHENTICATION`, `NTLM` and `KERBEROS`.
        :param str kdc_ip: The KDC IP. Valid and required only if the type of authentication is `KERBEROS`.
        :param str realm_name: The Realm Name. Valid and required only if the type of authentication is `KERBEROS`.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "type", type)
        if kdc_ip is not None:
            pulumi.set(__self__, "kdc_ip", kdc_ip)
        if realm_name is not None:
            pulumi.set(__self__, "realm_name", realm_name)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        """
        The ID of the credentials within the Dynatrace Credentials Vault.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of authentication. Possible values are `BASIC_AUTHENTICATION`, `NTLM` and `KERBEROS`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="kdcIp")
    def kdc_ip(self) -> Optional[str]:
        """
        The KDC IP. Valid and required only if the type of authentication is `KERBEROS`.
        """
        return pulumi.get(self, "kdc_ip")

    @property
    @pulumi.getter(name="realmName")
    def realm_name(self) -> Optional[str]:
        """
        The Realm Name. Valid and required only if the type of authentication is `KERBEROS`.
        """
        return pulumi.get(self, "realm_name")


@pulumi.output_type
class HttpMonitorScriptScriptRequestConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptAnyCertificate":
            suggest = "accept_any_certificate"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "followRedirects":
            suggest = "follow_redirects"
        elif key == "sensitiveData":
            suggest = "sensitive_data"
        elif key == "userAgent":
            suggest = "user_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorScriptScriptRequestConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorScriptScriptRequestConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorScriptScriptRequestConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept_any_certificate: Optional[bool] = None,
                 client_certificate: Optional[str] = None,
                 follow_redirects: Optional[bool] = None,
                 headers: Optional['outputs.HttpMonitorScriptScriptRequestConfigurationHeaders'] = None,
                 sensitive_data: Optional[bool] = None,
                 user_agent: Optional[str] = None):
        """
        :param bool accept_any_certificate: If set to `false`, then the monitor fails with invalid SSL certificates.
        :param str client_certificate: The client certificate, if applicable - eg. CREDENTIALS_VAULT-XXXXXXXXXXXXXXXX
        :param bool follow_redirects: If set to `false`, redirects are reported as successful requests with response code 3xx.
               
               If not set, the `false` option is used.
        :param 'HttpMonitorScriptScriptRequestConfigurationHeadersArgs' headers: The setup of the monitor
        :param bool sensitive_data: Option not to store and display request and response bodies and header values in execution details, `true` or `false`. If not set, `false`.
        :param str user_agent: The User agent of the request
        """
        if accept_any_certificate is not None:
            pulumi.set(__self__, "accept_any_certificate", accept_any_certificate)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if sensitive_data is not None:
            pulumi.set(__self__, "sensitive_data", sensitive_data)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)

    @property
    @pulumi.getter(name="acceptAnyCertificate")
    def accept_any_certificate(self) -> Optional[bool]:
        """
        If set to `false`, then the monitor fails with invalid SSL certificates.
        """
        return pulumi.get(self, "accept_any_certificate")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        The client certificate, if applicable - eg. CREDENTIALS_VAULT-XXXXXXXXXXXXXXXX
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[bool]:
        """
        If set to `false`, redirects are reported as successful requests with response code 3xx.

        If not set, the `false` option is used.
        """
        return pulumi.get(self, "follow_redirects")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.HttpMonitorScriptScriptRequestConfigurationHeaders']:
        """
        The setup of the monitor
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="sensitiveData")
    def sensitive_data(self) -> Optional[bool]:
        """
        Option not to store and display request and response bodies and header values in execution details, `true` or `false`. If not set, `false`.
        """
        return pulumi.get(self, "sensitive_data")

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[str]:
        """
        The User agent of the request
        """
        return pulumi.get(self, "user_agent")


@pulumi.output_type
class HttpMonitorScriptScriptRequestConfigurationHeaders(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.HttpMonitorScriptScriptRequestConfigurationHeadersHeader']):
        """
        :param Sequence['HttpMonitorScriptScriptRequestConfigurationHeadersHeaderArgs'] headers: contains an HTTP header of the request
        """
        pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.HttpMonitorScriptScriptRequestConfigurationHeadersHeader']:
        """
        contains an HTTP header of the request
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class HttpMonitorScriptScriptRequestConfigurationHeadersHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The key of the header
        :param str value: The value of the header
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The key of the header
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the header
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HttpMonitorScriptScriptRequestValidation(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.HttpMonitorScriptScriptRequestValidationRule']):
        """
        :param Sequence['HttpMonitorScriptScriptRequestValidationRuleArgs'] rules: A list of validation rules
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.HttpMonitorScriptScriptRequestValidationRule']:
        """
        A list of validation rules
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class HttpMonitorScriptScriptRequestValidationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passIfFound":
            suggest = "pass_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorScriptScriptRequestValidationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorScriptScriptRequestValidationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorScriptScriptRequestValidationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 value: str,
                 pass_if_found: Optional[bool] = None):
        """
        :param str type: The type of the rule. Possible values are `patternConstraint`, `regexConstraint`, `httpStatusesList` and `certificateExpiryDateConstraint`
        :param str value: The content to look for
        :param bool pass_if_found: The validation condition. `true` means validation succeeds if the specified content/element is found. `false` means validation fails if the specified content/element is found. Always specify `false` for `certificateExpiryDateConstraint` to fail the monitor if SSL certificate expiry is within the specified number of days
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if pass_if_found is not None:
            pulumi.set(__self__, "pass_if_found", pass_if_found)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the rule. Possible values are `patternConstraint`, `regexConstraint`, `httpStatusesList` and `certificateExpiryDateConstraint`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The content to look for
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="passIfFound")
    def pass_if_found(self) -> Optional[bool]:
        """
        The validation condition. `true` means validation succeeds if the specified content/element is found. `false` means validation fails if the specified content/element is found. Always specify `false` for `certificateExpiryDateConstraint` to fail the monitor if SSL certificate expiry is within the specified number of days
        """
        return pulumi.get(self, "pass_if_found")


@pulumi.output_type
class HttpMonitorTag(dict):
    def __init__(__self__, *,
                 tags: Optional[Sequence['outputs.HttpMonitorTagTag']] = None):
        """
        :param Sequence['HttpMonitorTagTagArgs'] tags: Tag with source of a Dynatrace entity.
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.HttpMonitorTagTag']]:
        """
        Tag with source of a Dynatrace entity.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class HttpMonitorTagTag(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 source: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag. Supported values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_CLOUD` and `KUBERNETES`.
        :param str key: The key of the tag.
               
               Custom tags have the tag value here.
        :param str source: The source of the tag. Supported values are `USER`, `RULE_BASED` and `AUTO`.
        :param str value: The value of the tag.
               
               Not applicable to custom tags.
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag. Supported values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_CLOUD` and `KUBERNETES`.
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag.

        Custom tags have the tag value here.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        The source of the tag. Supported values are `USER`, `RULE_BASED` and `AUTO`.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag.

        Not applicable to custom tags.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HubSubscriptionsTokenSubscriptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenSubscriptions":
            suggest = "token_subscriptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HubSubscriptionsTokenSubscriptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HubSubscriptionsTokenSubscriptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HubSubscriptionsTokenSubscriptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token_subscriptions: Sequence['outputs.HubSubscriptionsTokenSubscriptionsTokenSubscription']):
        pulumi.set(__self__, "token_subscriptions", token_subscriptions)

    @property
    @pulumi.getter(name="tokenSubscriptions")
    def token_subscriptions(self) -> Sequence['outputs.HubSubscriptionsTokenSubscriptionsTokenSubscription']:
        return pulumi.get(self, "token_subscriptions")


@pulumi.output_type
class HubSubscriptionsTokenSubscriptionsTokenSubscription(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 name: str,
                 token: str,
                 description: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param str name: Name of subscription
        :param str token: Subscription token
        :param str description: no documentation available
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of subscription
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        Subscription token
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class IamGroupPermissions(dict):
    def __init__(__self__, *,
                 permissions: Sequence['outputs.IamGroupPermissionsPermission']):
        """
        :param Sequence['IamGroupPermissionsPermissionArgs'] permissions: A Permission
        """
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence['outputs.IamGroupPermissionsPermission']:
        """
        A Permission
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class IamGroupPermissionsPermission(dict):
    def __init__(__self__, *,
                 name: str,
                 scope: str,
                 type: str):
        """
        :param str name: Possible values: `account-company-info`, `account-user-management`, `account-viewer`, `account-saml-flexible-federation`, `tenant-viewer`, `tenant-manage-settings`, `tenant-agent-install`, `tenant-logviewer`, `tenant-view-sensitive-request-data`, `tenant-configure-request-capture-data`, `tenant-replay-sessions-with-masking`, `tenant-replay-sessions-without-masking`, `tenant-manage-security-problems`, `tenant-view-security-problems`, `tenant-manage-support-tickets`
        :param str scope: If `type` is `account` this attribute should hold the UUID of the account. If `type` is 'tenant`this attribute should hold the ID of the environment (`https://\\n\\n.live.dynatrace.com`). If`type`is`management-zone`this attribute should hold a value like`\\n\\n:\\n\\n. You need to use the attribute `legacy_id` when referring to a resource `ManagementZoneV2` or a data source `ManagementZone`.
        :param str type: The type of this permission. Possible values are `account`, `tenant`, `management-zone`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Possible values: `account-company-info`, `account-user-management`, `account-viewer`, `account-saml-flexible-federation`, `tenant-viewer`, `tenant-manage-settings`, `tenant-agent-install`, `tenant-logviewer`, `tenant-view-sensitive-request-data`, `tenant-configure-request-capture-data`, `tenant-replay-sessions-with-masking`, `tenant-replay-sessions-without-masking`, `tenant-manage-security-problems`, `tenant-view-security-problems`, `tenant-manage-support-tickets`
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        If `type` is `account` this attribute should hold the UUID of the account. If `type` is 'tenant`this attribute should hold the ID of the environment (`https://\\n\\n.live.dynatrace.com`). If`type`is`management-zone`this attribute should hold a value like`\\n\\n:\\n\\n. You need to use the attribute `legacy_id` when referring to a resource `ManagementZoneV2` or a data source `ManagementZone`.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of this permission. Possible values are `account`, `tenant`, `management-zone`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class IamPolicyBindingsV2Policy(dict):
    def __init__(__self__, *,
                 id: str,
                 metadata: Optional[Mapping[str, str]] = None,
                 parameters: Optional[Mapping[str, str]] = None):
        """
        :param str id: Either the attribute `id` or the attribute `uuid` of a `IamPolicy`. Initially just the `id` attribute was supported (which is a concatenation of several configuration settings) - and is still supported for backwards compatibility
        """
        pulumi.set(__self__, "id", id)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Either the attribute `id` or the attribute `uuid` of a `IamPolicy`. Initially just the `id` attribute was supported (which is a concatenation of several configuration settings) - and is still supported for backwards compatibility
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class ImsBridgesQueueManager(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueManagers":
            suggest = "queue_managers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImsBridgesQueueManager. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImsBridgesQueueManager.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImsBridgesQueueManager.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue_managers: Optional[Sequence['outputs.ImsBridgesQueueManagerQueueManager']] = None):
        """
        :param Sequence['ImsBridgesQueueManagerQueueManagerArgs'] queue_managers: Queue manager definition for IMS bridge
        """
        if queue_managers is not None:
            pulumi.set(__self__, "queue_managers", queue_managers)

    @property
    @pulumi.getter(name="queueManagers")
    def queue_managers(self) -> Optional[Sequence['outputs.ImsBridgesQueueManagerQueueManager']]:
        """
        Queue manager definition for IMS bridge
        """
        return pulumi.get(self, "queue_managers")


@pulumi.output_type
class ImsBridgesQueueManagerQueueManager(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueManagerQueues":
            suggest = "queue_manager_queues"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImsBridgesQueueManagerQueueManager. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImsBridgesQueueManagerQueueManager.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImsBridgesQueueManagerQueueManager.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 queue_manager_queues: Optional[Sequence[str]] = None):
        """
        :param str name: The name of the queue manager
        :param Sequence[str] queue_manager_queues: Queue(s) that belong to the queue manager
        """
        pulumi.set(__self__, "name", name)
        if queue_manager_queues is not None:
            pulumi.set(__self__, "queue_manager_queues", queue_manager_queues)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the queue manager
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="queueManagerQueues")
    def queue_manager_queues(self) -> Optional[Sequence[str]]:
        """
        Queue(s) that belong to the queue manager
        """
        return pulumi.get(self, "queue_manager_queues")


@pulumi.output_type
class K8sClusterAnomaliesCpuRequestsSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sClusterAnomaliesCpuRequestsSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sClusterAnomaliesCpuRequestsSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sClusterAnomaliesCpuRequestsSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sClusterAnomaliesCpuRequestsSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sClusterAnomaliesCpuRequestsSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sClusterAnomaliesCpuRequestsSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sClusterAnomaliesCpuRequestsSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: of cluster CPU capacity for at least
        :param int threshold: amount of requested CPU is above
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        of cluster CPU capacity for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        amount of requested CPU is above
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sClusterAnomaliesMemoryRequestsSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sClusterAnomaliesMemoryRequestsSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sClusterAnomaliesMemoryRequestsSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sClusterAnomaliesMemoryRequestsSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sClusterAnomaliesMemoryRequestsSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sClusterAnomaliesMemoryRequestsSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sClusterAnomaliesMemoryRequestsSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sClusterAnomaliesMemoryRequestsSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: of cluster memory capacity for at least
        :param int threshold: amount of requested memory is above
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        of cluster memory capacity for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        amount of requested memory is above
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sClusterAnomaliesMonitoringIssues(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sClusterAnomaliesMonitoringIssuesConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sClusterAnomaliesMonitoringIssuesConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sClusterAnomaliesMonitoringIssuesConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sClusterAnomaliesMonitoringIssuesConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sClusterAnomaliesMonitoringIssuesConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sClusterAnomaliesMonitoringIssuesConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sClusterAnomaliesMonitoringIssuesConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: monitoring is not available for at least
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        monitoring is not available for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")


@pulumi.output_type
class K8sClusterAnomaliesPodsSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sClusterAnomaliesPodsSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sClusterAnomaliesPodsSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sClusterAnomaliesPodsSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sClusterAnomaliesPodsSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sClusterAnomaliesPodsSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sClusterAnomaliesPodsSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sClusterAnomaliesPodsSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: of schedulable pod capacity for at least
        :param int threshold: number of running pods is higher than
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        of schedulable pod capacity for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        number of running pods is higher than
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sClusterAnomaliesReadinessIssues(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sClusterAnomaliesReadinessIssuesConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sClusterAnomaliesReadinessIssuesConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sClusterAnomaliesReadinessIssuesConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sClusterAnomaliesReadinessIssuesConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sClusterAnomaliesReadinessIssuesConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sClusterAnomaliesReadinessIssuesConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sClusterAnomaliesReadinessIssuesConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: cluster is not ready for at least
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        cluster is not ready for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")


@pulumi.output_type
class K8sCredentialsEventsFieldSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldSelector":
            suggest = "field_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCredentialsEventsFieldSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCredentialsEventsFieldSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCredentialsEventsFieldSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 field_selector: str,
                 label: str,
                 unknowns: Optional[str] = None):
        """
        :param bool active: Whether subscription to this events field selector is enabled (value set to `true`). If disabled (value set to `false`), Dynatrace will stop fetching events from the Kubernetes API for this events field selector
        :param str field_selector: The field selector string (url decoding is applied) when storing it.
        :param str label: A label of the events field selector.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "field_selector", field_selector)
        pulumi.set(__self__, "label", label)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        Whether subscription to this events field selector is enabled (value set to `true`). If disabled (value set to `false`), Dynatrace will stop fetching events from the Kubernetes API for this events field selector
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="fieldSelector")
    def field_selector(self) -> str:
        """
        The field selector string (url decoding is applied) when storing it.
        """
        return pulumi.get(self, "field_selector")

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        A label of the events field selector.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class K8sMonitoringEventPatterns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventPatterns":
            suggest = "event_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sMonitoringEventPatterns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sMonitoringEventPatterns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sMonitoringEventPatterns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_patterns: Sequence['outputs.K8sMonitoringEventPatternsEventPattern']):
        pulumi.set(__self__, "event_patterns", event_patterns)

    @property
    @pulumi.getter(name="eventPatterns")
    def event_patterns(self) -> Sequence['outputs.K8sMonitoringEventPatternsEventPattern']:
        return pulumi.get(self, "event_patterns")


@pulumi.output_type
class K8sMonitoringEventPatternsEventPattern(dict):
    def __init__(__self__, *,
                 active: bool,
                 label: str,
                 pattern: str):
        """
        :param bool active: Activate
        :param str label: Field selector name
        :param str pattern: The set of allowed characters for this field has been extended with ActiveGate version 1.259. For more details, see the [documentation](https://dt-url.net/7h23wuk#set-up-event-field-selectors).
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        Activate
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        Field selector name
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def pattern(self) -> str:
        """
        The set of allowed characters for this field has been extended with ActiveGate version 1.259. For more details, see the [documentation](https://dt-url.net/7h23wuk#set-up-event-field-selectors).
        """
        return pulumi.get(self, "pattern")


@pulumi.output_type
class K8sNamespaceAnomaliesCpuLimitsQuotaSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNamespaceAnomaliesCpuLimitsQuotaSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNamespaceAnomaliesCpuLimitsQuotaSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNamespaceAnomaliesCpuLimitsQuotaSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNamespaceAnomaliesCpuLimitsQuotaSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNamespaceAnomaliesCpuLimitsQuotaSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNamespaceAnomaliesCpuLimitsQuotaSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNamespaceAnomaliesCpuLimitsQuotaSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: of quota for at least
        :param int threshold: amount of utilized namespace CPU is above
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        of quota for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        amount of utilized namespace CPU is above
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sNamespaceAnomaliesCpuRequestsQuotaSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNamespaceAnomaliesCpuRequestsQuotaSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNamespaceAnomaliesCpuRequestsQuotaSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNamespaceAnomaliesCpuRequestsQuotaSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNamespaceAnomaliesCpuRequestsQuotaSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNamespaceAnomaliesCpuRequestsQuotaSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNamespaceAnomaliesCpuRequestsQuotaSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNamespaceAnomaliesCpuRequestsQuotaSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: of quota for at least
        :param int threshold: amount of requested namespace CPU is above
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        of quota for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        amount of requested namespace CPU is above
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sNamespaceAnomaliesMemoryLimitsQuotaSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNamespaceAnomaliesMemoryLimitsQuotaSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNamespaceAnomaliesMemoryLimitsQuotaSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNamespaceAnomaliesMemoryLimitsQuotaSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNamespaceAnomaliesMemoryLimitsQuotaSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNamespaceAnomaliesMemoryLimitsQuotaSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNamespaceAnomaliesMemoryLimitsQuotaSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNamespaceAnomaliesMemoryLimitsQuotaSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: of quota for at least
        :param int threshold: amount of utilized namespace memory is above
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        of quota for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        amount of utilized namespace memory is above
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sNamespaceAnomaliesMemoryRequestsQuotaSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNamespaceAnomaliesMemoryRequestsQuotaSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNamespaceAnomaliesMemoryRequestsQuotaSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNamespaceAnomaliesMemoryRequestsQuotaSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNamespaceAnomaliesMemoryRequestsQuotaSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNamespaceAnomaliesMemoryRequestsQuotaSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNamespaceAnomaliesMemoryRequestsQuotaSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNamespaceAnomaliesMemoryRequestsQuotaSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: of quota for at least
        :param int threshold: amount of requested namespace memory is above
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        of quota for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        amount of requested namespace memory is above
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sNamespaceAnomaliesPodsQuotaSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNamespaceAnomaliesPodsQuotaSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNamespaceAnomaliesPodsQuotaSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNamespaceAnomaliesPodsQuotaSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNamespaceAnomaliesPodsQuotaSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNamespaceAnomaliesPodsQuotaSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNamespaceAnomaliesPodsQuotaSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNamespaceAnomaliesPodsQuotaSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: of quota for at least
        :param int threshold: number of utilized namespace pods is above
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        of quota for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        number of utilized namespace pods is above
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sNodeAnomaliesCpuRequestsSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNodeAnomaliesCpuRequestsSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNodeAnomaliesCpuRequestsSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNodeAnomaliesCpuRequestsSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNodeAnomaliesCpuRequestsSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNodeAnomaliesCpuRequestsSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNodeAnomaliesCpuRequestsSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNodeAnomaliesCpuRequestsSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: of node CPU capacity for at least
        :param int threshold: amount of requested CPU is higher than
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        of node CPU capacity for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        amount of requested CPU is higher than
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sNodeAnomaliesMemoryRequestsSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNodeAnomaliesMemoryRequestsSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNodeAnomaliesMemoryRequestsSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNodeAnomaliesMemoryRequestsSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNodeAnomaliesMemoryRequestsSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNodeAnomaliesMemoryRequestsSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNodeAnomaliesMemoryRequestsSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNodeAnomaliesMemoryRequestsSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: of node memory capacity for at least
        :param int threshold: amount of requested memory is higher than
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        of node memory capacity for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        amount of requested memory is higher than
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sNodeAnomaliesNodeProblematicCondition(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNodeAnomaliesNodeProblematicConditionConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNodeAnomaliesNodeProblematicConditionConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNodeAnomaliesNodeProblematicConditionConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNodeAnomaliesNodeProblematicConditionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNodeAnomaliesNodeProblematicConditionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNodeAnomaliesNodeProblematicConditionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNodeAnomaliesNodeProblematicConditionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: node has problematic conditions for at least
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        node has problematic conditions for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")


@pulumi.output_type
class K8sNodeAnomaliesPodsSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNodeAnomaliesPodsSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNodeAnomaliesPodsSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNodeAnomaliesPodsSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNodeAnomaliesPodsSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNodeAnomaliesPodsSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNodeAnomaliesPodsSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNodeAnomaliesPodsSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: of node capacity for at least
        :param int threshold: number of pods running on node is higher than
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        of node capacity for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        number of pods running on node is higher than
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sNodeAnomaliesReadinessIssues(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNodeAnomaliesReadinessIssuesConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNodeAnomaliesReadinessIssuesConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNodeAnomaliesReadinessIssuesConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNodeAnomaliesReadinessIssuesConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNodeAnomaliesReadinessIssuesConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNodeAnomaliesReadinessIssuesConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNodeAnomaliesReadinessIssuesConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: node is not ready for at least
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        node is not ready for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")


@pulumi.output_type
class K8sPvcAnomaliesLowDiskSpaceCritical(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sPvcAnomaliesLowDiskSpaceCriticalConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sPvcAnomaliesLowDiskSpaceCriticalConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sPvcAnomaliesLowDiskSpaceCriticalConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sPvcAnomaliesLowDiskSpaceCriticalConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sPvcAnomaliesLowDiskSpaceCriticalConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sPvcAnomaliesLowDiskSpaceCriticalConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sPvcAnomaliesLowDiskSpaceCriticalConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: for at least
        :param int threshold: the available disk space is below
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        the available disk space is below
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sPvcAnomaliesLowDiskSpaceCriticalPercentage(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sPvcAnomaliesLowDiskSpaceCriticalPercentageConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sPvcAnomaliesLowDiskSpaceCriticalPercentageConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sPvcAnomaliesLowDiskSpaceCriticalPercentageConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sPvcAnomaliesLowDiskSpaceCriticalPercentageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sPvcAnomaliesLowDiskSpaceCriticalPercentageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sPvcAnomaliesLowDiskSpaceCriticalPercentageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sPvcAnomaliesLowDiskSpaceCriticalPercentageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: for at least
        :param int threshold: the available disk space is below
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        the available disk space is below
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sWorkloadAnomaliesContainerRestarts(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sWorkloadAnomaliesContainerRestartsConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sWorkloadAnomaliesContainerRestartsConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sWorkloadAnomaliesContainerRestartsConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sWorkloadAnomaliesContainerRestartsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sWorkloadAnomaliesContainerRestartsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sWorkloadAnomaliesContainerRestartsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sWorkloadAnomaliesContainerRestartsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: per minute, for any
        :param int threshold: there is at least
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        per minute, for any
        """
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        there is at least
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sWorkloadAnomaliesDeploymentStuck(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sWorkloadAnomaliesDeploymentStuckConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sWorkloadAnomaliesDeploymentStuckConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sWorkloadAnomaliesDeploymentStuckConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sWorkloadAnomaliesDeploymentStuckConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sWorkloadAnomaliesDeploymentStuckConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sWorkloadAnomaliesDeploymentStuckConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sWorkloadAnomaliesDeploymentStuckConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: workload stops progressing for at least
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        workload stops progressing for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")


@pulumi.output_type
class K8sWorkloadAnomaliesHighCpuThrottling(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sWorkloadAnomaliesHighCpuThrottlingConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sWorkloadAnomaliesHighCpuThrottlingConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sWorkloadAnomaliesHighCpuThrottlingConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sWorkloadAnomaliesHighCpuThrottlingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sWorkloadAnomaliesHighCpuThrottlingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sWorkloadAnomaliesHighCpuThrottlingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sWorkloadAnomaliesHighCpuThrottlingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: of CPU usage for at least
        :param int threshold: amount of CPU throttling is above
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        of CPU usage for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        amount of CPU throttling is above
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sWorkloadAnomaliesHighCpuUsage(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sWorkloadAnomaliesHighCpuUsageConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sWorkloadAnomaliesHighCpuUsageConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sWorkloadAnomaliesHighCpuUsageConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sWorkloadAnomaliesHighCpuUsageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sWorkloadAnomaliesHighCpuUsageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sWorkloadAnomaliesHighCpuUsageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sWorkloadAnomaliesHighCpuUsageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: of defined CPU limits for at least
        :param int threshold: amount of utilized workload CPU is above
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        of defined CPU limits for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        amount of utilized workload CPU is above
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sWorkloadAnomaliesHighMemoryUsage(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sWorkloadAnomaliesHighMemoryUsageConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sWorkloadAnomaliesHighMemoryUsageConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sWorkloadAnomaliesHighMemoryUsageConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sWorkloadAnomaliesHighMemoryUsageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sWorkloadAnomaliesHighMemoryUsageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sWorkloadAnomaliesHighMemoryUsageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sWorkloadAnomaliesHighMemoryUsageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: of defined memory limits for at least
        :param int threshold: amount of utilized workload memory is above
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        of defined memory limits for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        amount of utilized workload memory is above
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sWorkloadAnomaliesJobFailureEvents(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class K8sWorkloadAnomaliesNotAllPodsReady(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sWorkloadAnomaliesNotAllPodsReadyConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sWorkloadAnomaliesNotAllPodsReadyConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sWorkloadAnomaliesNotAllPodsReadyConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sWorkloadAnomaliesNotAllPodsReadyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sWorkloadAnomaliesNotAllPodsReadyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sWorkloadAnomaliesNotAllPodsReadyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sWorkloadAnomaliesNotAllPodsReadyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: some workload pods are not ready for at least
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        some workload pods are not ready for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")


@pulumi.output_type
class K8sWorkloadAnomaliesOomKills(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class K8sWorkloadAnomaliesPendingPods(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sWorkloadAnomaliesPendingPodsConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sWorkloadAnomaliesPendingPodsConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sWorkloadAnomaliesPendingPodsConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sWorkloadAnomaliesPendingPodsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sWorkloadAnomaliesPendingPodsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sWorkloadAnomaliesPendingPodsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sWorkloadAnomaliesPendingPodsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: stuck in pending state for at least
        :param int threshold: there is at least
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        stuck in pending state for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        there is at least
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sWorkloadAnomaliesPodBackoffEvents(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class K8sWorkloadAnomaliesPodEvictionEvents(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class K8sWorkloadAnomaliesPodPreemptionEvents(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class K8sWorkloadAnomaliesPodStuckInTerminating(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sWorkloadAnomaliesPodStuckInTerminatingConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sWorkloadAnomaliesPodStuckInTerminatingConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sWorkloadAnomaliesPodStuckInTerminatingConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sWorkloadAnomaliesPodStuckInTerminatingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sWorkloadAnomaliesPodStuckInTerminatingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sWorkloadAnomaliesPodStuckInTerminatingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sWorkloadAnomaliesPodStuckInTerminatingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: pod termination stops progressing for at least
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        pod termination stops progressing for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")


@pulumi.output_type
class K8sWorkloadAnomaliesWorkloadWithoutReadyPods(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sWorkloadAnomaliesWorkloadWithoutReadyPodsConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sWorkloadAnomaliesWorkloadWithoutReadyPodsConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sWorkloadAnomaliesWorkloadWithoutReadyPodsConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sWorkloadAnomaliesWorkloadWithoutReadyPodsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sWorkloadAnomaliesWorkloadWithoutReadyPodsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sWorkloadAnomaliesWorkloadWithoutReadyPodsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sWorkloadAnomaliesWorkloadWithoutReadyPodsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int):
        """
        :param int observation_period_in_minutes: within the last
        :param int sample_period_in_minutes: workload has no ready pods for at least
        """
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        """
        within the last
        """
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        """
        workload has no ready pods for at least
        """
        return pulumi.get(self, "sample_period_in_minutes")


@pulumi.output_type
class KubernetesAppKubernetesAppOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableKubernetesApp":
            suggest = "enable_kubernetes_app"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesAppKubernetesAppOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesAppKubernetesAppOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesAppKubernetesAppOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_kubernetes_app: bool):
        """
        :param bool enable_kubernetes_app: New Kubernetes experience
        """
        pulumi.set(__self__, "enable_kubernetes_app", enable_kubernetes_app)

    @property
    @pulumi.getter(name="enableKubernetesApp")
    def enable_kubernetes_app(self) -> bool:
        """
        New Kubernetes experience
        """
        return pulumi.get(self, "enable_kubernetes_app")


@pulumi.output_type
class KubernetesEnrichmentRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.KubernetesEnrichmentRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.KubernetesEnrichmentRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class KubernetesEnrichmentRulesRule(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 source: str,
                 target: str,
                 type: str):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param str source: The source must follow the syntax of Kubernetes annotation/label keys as defined in the [Kubernetes documentation](https://dt-url.net/2c02sbn).
        :param str target: Possible Values: `Dt_cost_costcenter`, `Dt_cost_product`, `Dt_security_context`
        :param str type: Possible Values: `ANNOTATION`, `LABEL`
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source must follow the syntax of Kubernetes annotation/label keys as defined in the [Kubernetes documentation](https://dt-url.net/2c02sbn).
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Possible Values: `Dt_cost_costcenter`, `Dt_cost_product`, `Dt_security_context`
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `ANNOTATION`, `LABEL`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class KubernetesEventPatterns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventPatterns":
            suggest = "event_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesEventPatterns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesEventPatterns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesEventPatterns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_patterns: Sequence['outputs.KubernetesEventPatternsEventPattern']):
        pulumi.set(__self__, "event_patterns", event_patterns)

    @property
    @pulumi.getter(name="eventPatterns")
    def event_patterns(self) -> Sequence['outputs.KubernetesEventPatternsEventPattern']:
        return pulumi.get(self, "event_patterns")


@pulumi.output_type
class KubernetesEventPatternsEventPattern(dict):
    def __init__(__self__, *,
                 active: bool,
                 label: str,
                 pattern: str):
        """
        :param bool active: Activate
        :param str label: Field selector name
        :param str pattern: The set of allowed characters for this field has been extended with ActiveGate version 1.259. For more details, see the [documentation](https://dt-url.net/7h23wuk#set-up-event-field-selectors).
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        Activate
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        Field selector name
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def pattern(self) -> str:
        """
        The set of allowed characters for this field has been extended with ActiveGate version 1.259. For more details, see the [documentation](https://dt-url.net/7h23wuk#set-up-event-field-selectors).
        """
        return pulumi.get(self, "pattern")


@pulumi.output_type
class LimitOutboundConnectionsAllowedOutboundConnections(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostLists":
            suggest = "host_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LimitOutboundConnectionsAllowedOutboundConnections. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LimitOutboundConnectionsAllowedOutboundConnections.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LimitOutboundConnectionsAllowedOutboundConnections.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enforced: bool,
                 host_lists: Optional[Sequence[str]] = None):
        """
        :param bool enforced: If enabled, the Dynatrace JavaScript runtime will only be able to connect to the specified hosts.
        :param Sequence[str] host_lists: The Dynatrace JavaScript runtime will only be to connect to these hosts.
        """
        pulumi.set(__self__, "enforced", enforced)
        if host_lists is not None:
            pulumi.set(__self__, "host_lists", host_lists)

    @property
    @pulumi.getter
    def enforced(self) -> bool:
        """
        If enabled, the Dynatrace JavaScript runtime will only be able to connect to the specified hosts.
        """
        return pulumi.get(self, "enforced")

    @property
    @pulumi.getter(name="hostLists")
    def host_lists(self) -> Optional[Sequence[str]]:
        """
        The Dynatrace JavaScript runtime will only be to connect to these hosts.
        """
        return pulumi.get(self, "host_lists")


@pulumi.output_type
class LogCustomSourceContext(dict):
    def __init__(__self__, *,
                 contexts: Sequence['outputs.LogCustomSourceContextContext']):
        pulumi.set(__self__, "contexts", contexts)

    @property
    @pulumi.getter
    def contexts(self) -> Sequence['outputs.LogCustomSourceContextContext']:
        return pulumi.get(self, "contexts")


@pulumi.output_type
class LogCustomSourceContextContext(dict):
    def __init__(__self__, *,
                 attribute: str,
                 values: Sequence[str]):
        """
        :param str attribute: Possible Values: `Dt_entity_process_group`
        :param Sequence[str] values: no documentation available
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        Possible Values: `Dt_entity_process_group`
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class LogCustomSourceCustomLogSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptBinary":
            suggest = "accept_binary"
        elif key == "valuesAndEnrichment":
            suggest = "values_and_enrichment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogCustomSourceCustomLogSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogCustomSourceCustomLogSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogCustomSourceCustomLogSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 accept_binary: Optional[bool] = None,
                 values: Optional[Sequence[str]] = None,
                 values_and_enrichment: Optional['outputs.LogCustomSourceCustomLogSourceValuesAndEnrichment'] = None):
        """
        :param str type: Possible Values: `LOG_PATH_PATTERN`, `WINDOWS_EVENT_LOG`
        :param bool accept_binary: Accept binary content
        :param Sequence[str] values: (Required attribute for cluster v1.291 and under) It might be either an absolute path to log(s) with optional wildcards or Windows Event Log name.
        :param 'LogCustomSourceCustomLogSourceValuesAndEnrichmentArgs' values_and_enrichment: (Required attribute for cluster v1.292+) It might be either an absolute path to log(s) with optional wildcards or Windows Event Log name.
        """
        pulumi.set(__self__, "type", type)
        if accept_binary is not None:
            pulumi.set(__self__, "accept_binary", accept_binary)
        if values is not None:
            pulumi.set(__self__, "values", values)
        if values_and_enrichment is not None:
            pulumi.set(__self__, "values_and_enrichment", values_and_enrichment)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `LOG_PATH_PATTERN`, `WINDOWS_EVENT_LOG`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="acceptBinary")
    def accept_binary(self) -> Optional[bool]:
        """
        Accept binary content
        """
        return pulumi.get(self, "accept_binary")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        (Required attribute for cluster v1.291 and under) It might be either an absolute path to log(s) with optional wildcards or Windows Event Log name.
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter(name="valuesAndEnrichment")
    def values_and_enrichment(self) -> Optional['outputs.LogCustomSourceCustomLogSourceValuesAndEnrichment']:
        """
        (Required attribute for cluster v1.292+) It might be either an absolute path to log(s) with optional wildcards or Windows Event Log name.
        """
        return pulumi.get(self, "values_and_enrichment")


@pulumi.output_type
class LogCustomSourceCustomLogSourceValuesAndEnrichment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLogSourceWithEnrichments":
            suggest = "custom_log_source_with_enrichments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogCustomSourceCustomLogSourceValuesAndEnrichment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogCustomSourceCustomLogSourceValuesAndEnrichment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogCustomSourceCustomLogSourceValuesAndEnrichment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_log_source_with_enrichments: Sequence['outputs.LogCustomSourceCustomLogSourceValuesAndEnrichmentCustomLogSourceWithEnrichment']):
        pulumi.set(__self__, "custom_log_source_with_enrichments", custom_log_source_with_enrichments)

    @property
    @pulumi.getter(name="customLogSourceWithEnrichments")
    def custom_log_source_with_enrichments(self) -> Sequence['outputs.LogCustomSourceCustomLogSourceValuesAndEnrichmentCustomLogSourceWithEnrichment']:
        return pulumi.get(self, "custom_log_source_with_enrichments")


@pulumi.output_type
class LogCustomSourceCustomLogSourceValuesAndEnrichmentCustomLogSourceWithEnrichment(dict):
    def __init__(__self__, *,
                 path: str,
                 enrichment: Optional['outputs.LogCustomSourceCustomLogSourceValuesAndEnrichmentCustomLogSourceWithEnrichmentEnrichment'] = None):
        """
        :param str path: Values
        :param 'LogCustomSourceCustomLogSourceValuesAndEnrichmentCustomLogSourceWithEnrichmentEnrichmentArgs' enrichment: Optional field that allows to define attributes that will enrich logs. ${N} can be used in attribute value to expand the value matched by wildcards where N denotes the number of the wildcard the expand
        """
        pulumi.set(__self__, "path", path)
        if enrichment is not None:
            pulumi.set(__self__, "enrichment", enrichment)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Values
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def enrichment(self) -> Optional['outputs.LogCustomSourceCustomLogSourceValuesAndEnrichmentCustomLogSourceWithEnrichmentEnrichment']:
        """
        Optional field that allows to define attributes that will enrich logs. ${N} can be used in attribute value to expand the value matched by wildcards where N denotes the number of the wildcard the expand
        """
        return pulumi.get(self, "enrichment")


@pulumi.output_type
class LogCustomSourceCustomLogSourceValuesAndEnrichmentCustomLogSourceWithEnrichmentEnrichment(dict):
    def __init__(__self__, *,
                 enrichments: Sequence['outputs.LogCustomSourceCustomLogSourceValuesAndEnrichmentCustomLogSourceWithEnrichmentEnrichmentEnrichment']):
        pulumi.set(__self__, "enrichments", enrichments)

    @property
    @pulumi.getter
    def enrichments(self) -> Sequence['outputs.LogCustomSourceCustomLogSourceValuesAndEnrichmentCustomLogSourceWithEnrichmentEnrichmentEnrichment']:
        return pulumi.get(self, "enrichments")


@pulumi.output_type
class LogCustomSourceCustomLogSourceValuesAndEnrichmentCustomLogSourceWithEnrichmentEnrichmentEnrichment(dict):
    def __init__(__self__, *,
                 type: str,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str type: Possible Values: `Attribute`
        :param str key: no documentation available
        :param str value: no documentation available
        """
        pulumi.set(__self__, "type", type)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `Attribute`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LogEventsEventTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"
        elif key == "davisMerge":
            suggest = "davis_merge"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogEventsEventTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogEventsEventTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogEventsEventTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 event_type: str,
                 title: str,
                 davis_merge: Optional[bool] = None,
                 metadata: Optional['outputs.LogEventsEventTemplateMetadata'] = None):
        """
        :param str description: The description of the event to trigger.
        :param str event_type: Possible Values: `AVAILABILITY`, `CUSTOM_ALERT`, `CUSTOM_ANNOTATION`, `CUSTOM_CONFIGURATION`, `CUSTOM_DEPLOYMENT`, `ERROR`, `INFO`, `MARKED_FOR_TERMINATION`, `RESOURCE`, `SLOWDOWN`
        :param str title: The title of the event to trigger.
        :param bool davis_merge: Davis® AI will try to merge this event into existing problems, otherwise a new problem will always be created.
        :param 'LogEventsEventTemplateMetadataArgs' metadata: Set of additional key-value properties to be attached to the triggered event.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "title", title)
        if davis_merge is not None:
            pulumi.set(__self__, "davis_merge", davis_merge)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the event to trigger.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> str:
        """
        Possible Values: `AVAILABILITY`, `CUSTOM_ALERT`, `CUSTOM_ANNOTATION`, `CUSTOM_CONFIGURATION`, `CUSTOM_DEPLOYMENT`, `ERROR`, `INFO`, `MARKED_FOR_TERMINATION`, `RESOURCE`, `SLOWDOWN`
        """
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The title of the event to trigger.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="davisMerge")
    def davis_merge(self) -> Optional[bool]:
        """
        Davis® AI will try to merge this event into existing problems, otherwise a new problem will always be created.
        """
        return pulumi.get(self, "davis_merge")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.LogEventsEventTemplateMetadata']:
        """
        Set of additional key-value properties to be attached to the triggered event.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class LogEventsEventTemplateMetadata(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.LogEventsEventTemplateMetadataItem']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.LogEventsEventTemplateMetadataItem']:
        return pulumi.get(self, "items")


@pulumi.output_type
class LogEventsEventTemplateMetadataItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataKey":
            suggest = "metadata_key"
        elif key == "metadataValue":
            suggest = "metadata_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogEventsEventTemplateMetadataItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogEventsEventTemplateMetadataItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogEventsEventTemplateMetadataItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_key: str,
                 metadata_value: str):
        """
        :param str metadata_key: Type 'dt.' for key hints.
        :param str metadata_value: no documentation available
        """
        pulumi.set(__self__, "metadata_key", metadata_key)
        pulumi.set(__self__, "metadata_value", metadata_value)

    @property
    @pulumi.getter(name="metadataKey")
    def metadata_key(self) -> str:
        """
        Type 'dt.' for key hints.
        """
        return pulumi.get(self, "metadata_key")

    @property
    @pulumi.getter(name="metadataValue")
    def metadata_value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "metadata_value")


@pulumi.output_type
class LogProcessingProcessorDefinition(dict):
    def __init__(__self__, *,
                 rule: str):
        """
        :param str rule: Processor definition
        """
        pulumi.set(__self__, "rule", rule)

    @property
    @pulumi.getter
    def rule(self) -> str:
        """
        Processor definition
        """
        return pulumi.get(self, "rule")


@pulumi.output_type
class LogProcessingRuleTesting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sampleLog":
            suggest = "sample_log"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogProcessingRuleTesting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogProcessingRuleTesting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogProcessingRuleTesting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sample_log: str):
        """
        :param str sample_log: Sample log in JSON format.
        """
        pulumi.set(__self__, "sample_log", sample_log)

    @property
    @pulumi.getter(name="sampleLog")
    def sample_log(self) -> str:
        """
        Sample log in JSON format.
        """
        return pulumi.get(self, "sample_log")


@pulumi.output_type
class LogSecurityContextSecurityContextRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleName":
            suggest = "rule_name"
        elif key == "valueSource":
            suggest = "value_source"
        elif key == "valueSourceField":
            suggest = "value_source_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSecurityContextSecurityContextRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSecurityContextSecurityContextRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSecurityContextSecurityContextRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 rule_name: str,
                 value_source: str,
                 value: Optional[str] = None,
                 value_source_field: Optional[str] = None):
        """
        :param str query: Matcher
        :param str rule_name: Rule name
        :param str value_source: Possible Values: `FIELD`, `LITERAL`
        :param str value: Literal value to be set
        :param str value_source_field: Name of field used to copy value
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "rule_name", rule_name)
        pulumi.set(__self__, "value_source", value_source)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_source_field is not None:
            pulumi.set(__self__, "value_source_field", value_source_field)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Matcher
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> str:
        """
        Rule name
        """
        return pulumi.get(self, "rule_name")

    @property
    @pulumi.getter(name="valueSource")
    def value_source(self) -> str:
        """
        Possible Values: `FIELD`, `LITERAL`
        """
        return pulumi.get(self, "value_source")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Literal value to be set
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueSourceField")
    def value_source_field(self) -> Optional[str]:
        """
        Name of field used to copy value
        """
        return pulumi.get(self, "value_source_field")


@pulumi.output_type
class LogSensitiveDataMaskingMasking(dict):
    def __init__(__self__, *,
                 expression: str,
                 type: str,
                 replacement: Optional[str] = None):
        """
        :param str expression: Maximum one capture group is allowed. If none was given, the whole expression will be treated as a capture group.
        :param str type: Possible Values: `SHA1`, `STRING`
        :param str replacement: The string to replace the masked expression with. Irrelevant if `type` is `SHA1`.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "type", type)
        if replacement is not None:
            pulumi.set(__self__, "replacement", replacement)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Maximum one capture group is allowed. If none was given, the whole expression will be treated as a capture group.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `SHA1`, `STRING`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def replacement(self) -> Optional[str]:
        """
        The string to replace the masked expression with. Irrelevant if `type` is `SHA1`.
        """
        return pulumi.get(self, "replacement")


@pulumi.output_type
class LogSensitiveDataMaskingMatchers(dict):
    def __init__(__self__, *,
                 matchers: Sequence['outputs.LogSensitiveDataMaskingMatchersMatcher']):
        pulumi.set(__self__, "matchers", matchers)

    @property
    @pulumi.getter
    def matchers(self) -> Sequence['outputs.LogSensitiveDataMaskingMatchersMatcher']:
        return pulumi.get(self, "matchers")


@pulumi.output_type
class LogSensitiveDataMaskingMatchersMatcher(dict):
    def __init__(__self__, *,
                 attribute: str,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str attribute: Possible Values: `container.name`, `dt.entity.container_group`, `dt.entity.process_group`, `k8s.container.name`, `k8s.deployment.name`, `k8s.namespace.name`, `log.source`, `process.technology` and `host.tag`
        :param str operator: Possible Values: `MATCHES`
        :param Sequence[str] values: no documentation available
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        Possible Values: `container.name`, `dt.entity.container_group`, `dt.entity.process_group`, `k8s.container.name`, `k8s.deployment.name`, `k8s.namespace.name`, `log.source`, `process.technology` and `host.tag`
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Possible Values: `MATCHES`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class LogStorageMatchers(dict):
    def __init__(__self__, *,
                 matchers: Sequence['outputs.LogStorageMatchersMatcher']):
        pulumi.set(__self__, "matchers", matchers)

    @property
    @pulumi.getter
    def matchers(self) -> Sequence['outputs.LogStorageMatchersMatcher']:
        return pulumi.get(self, "matchers")


@pulumi.output_type
class LogStorageMatchersMatcher(dict):
    def __init__(__self__, *,
                 attribute: str,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str attribute: Possible Values: `Container_name`, `Dt_entity_container_group`, `Dt_entity_process_group`, `Host_tag`, `K8s_container_name`, `K8s_deployment_name`, `K8s_namespace_name`, `Log_content`, `Log_source`, `Loglevel`, `Process_technology`, `Winlog_eventid`, `Winlog_opcode`, `Winlog_provider`, `Winlog_task`
        :param str operator: Possible Values: `MATCHES`
        :param Sequence[str] values: no documentation available
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        Possible Values: `Container_name`, `Dt_entity_container_group`, `Dt_entity_process_group`, `Host_tag`, `K8s_container_name`, `K8s_deployment_name`, `K8s_namespace_name`, `Log_content`, `Log_source`, `Loglevel`, `Process_technology`, `Winlog_eventid`, `Winlog_opcode`, `Winlog_provider`, `Winlog_task`
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Possible Values: `MATCHES`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class LogTimestampEntryBoundary(dict):
    def __init__(__self__, *,
                 pattern: Optional[str] = None):
        """
        :param str pattern: no documentation available
        """
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "pattern")


@pulumi.output_type
class LogTimestampMatchers(dict):
    def __init__(__self__, *,
                 matchers: Sequence['outputs.LogTimestampMatchersMatcher']):
        pulumi.set(__self__, "matchers", matchers)

    @property
    @pulumi.getter
    def matchers(self) -> Sequence['outputs.LogTimestampMatchersMatcher']:
        return pulumi.get(self, "matchers")


@pulumi.output_type
class LogTimestampMatchersMatcher(dict):
    def __init__(__self__, *,
                 attribute: str,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str attribute: Possible Values: `Container_name`, `Dt_entity_container_group`, `Dt_entity_process_group`, `K8s_container_name`, `K8s_deployment_name`, `K8s_namespace_name`, `Log_source`, `Process_technology`
        :param str operator: Possible Values: `MATCHES`
        :param Sequence[str] values: no documentation available
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        Possible Values: `Container_name`, `Dt_entity_container_group`, `Dt_entity_process_group`, `K8s_container_name`, `K8s_deployment_name`, `K8s_namespace_name`, `Log_source`, `Process_technology`
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Possible Values: `MATCHES`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class MaintenanceFilters(dict):
    def __init__(__self__, *,
                 filters: Sequence['outputs.MaintenanceFiltersFilter']):
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.MaintenanceFiltersFilter']:
        return pulumi.get(self, "filters")


@pulumi.output_type
class MaintenanceFiltersFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityId":
            suggest = "entity_id"
        elif key == "entityTags":
            suggest = "entity_tags"
        elif key == "entityType":
            suggest = "entity_type"
        elif key == "managementZones":
            suggest = "management_zones"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceFiltersFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceFiltersFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceFiltersFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_id: Optional[str] = None,
                 entity_tags: Optional[Sequence[str]] = None,
                 entity_type: Optional[str] = None,
                 management_zones: Optional[Sequence[str]] = None):
        """
        :param str entity_id: A specific entity that should match this maintenance window.. **Note**: If an entity type filter value is set, it must be equal to the type of the selected entity. Otherwise this maintenance window will not match.
        :param Sequence[str] entity_tags: Entities which contain all of the configured tags will match this maintenance window.
        :param str entity_type: Type of entities this maintenance window should match.. If no entity type is selected all entities regardless of the type will match.
        :param Sequence[str] management_zones: Entities which are part of all the configured management zones will match this maintenance window.
        """
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_tags is not None:
            pulumi.set(__self__, "entity_tags", entity_tags)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if management_zones is not None:
            pulumi.set(__self__, "management_zones", management_zones)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[str]:
        """
        A specific entity that should match this maintenance window.. **Note**: If an entity type filter value is set, it must be equal to the type of the selected entity. Otherwise this maintenance window will not match.
        """
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter(name="entityTags")
    def entity_tags(self) -> Optional[Sequence[str]]:
        """
        Entities which contain all of the configured tags will match this maintenance window.
        """
        return pulumi.get(self, "entity_tags")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[str]:
        """
        Type of entities this maintenance window should match.. If no entity type is selected all entities regardless of the type will match.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="managementZones")
    def management_zones(self) -> Optional[Sequence[str]]:
        """
        Entities which are part of all the configured management zones will match this maintenance window.
        """
        return pulumi.get(self, "management_zones")


@pulumi.output_type
class MaintenanceGeneralProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableSynthetic":
            suggest = "disable_synthetic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceGeneralProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceGeneralProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceGeneralProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_synthetic: bool,
                 name: str,
                 suppression: str,
                 type: str,
                 description: Optional[str] = None):
        """
        :param bool disable_synthetic: Disables the execution of the synthetic monitors that are within [the scope of this maintenance window](https://dt-url.net/0e0341m).
        :param str name: The name of the maintenance window, displayed in the UI
        :param str suppression: The type of suppression of alerting and problem detection during the maintenance. Possible Values: `DETECT_PROBLEMS_AND_ALERT`, `DETECT_PROBLEMS_DONT_ALERT`, `DONT_DETECT_PROBLEMS`
        :param str type: The type of the maintenance, possible values: `PLANNED` or `UNPLANNED`
        :param str description: A short description of the maintenance purpose.
        """
        pulumi.set(__self__, "disable_synthetic", disable_synthetic)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "suppression", suppression)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="disableSynthetic")
    def disable_synthetic(self) -> bool:
        """
        Disables the execution of the synthetic monitors that are within [the scope of this maintenance window](https://dt-url.net/0e0341m).
        """
        return pulumi.get(self, "disable_synthetic")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the maintenance window, displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def suppression(self) -> str:
        """
        The type of suppression of alerting and problem detection during the maintenance. Possible Values: `DETECT_PROBLEMS_AND_ALERT`, `DETECT_PROBLEMS_DONT_ALERT`, `DONT_DETECT_PROBLEMS`
        """
        return pulumi.get(self, "suppression")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the maintenance, possible values: `PLANNED` or `UNPLANNED`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A short description of the maintenance purpose.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class MaintenanceSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dailyRecurrence":
            suggest = "daily_recurrence"
        elif key == "monthlyRecurrence":
            suggest = "monthly_recurrence"
        elif key == "onceRecurrence":
            suggest = "once_recurrence"
        elif key == "weeklyRecurrence":
            suggest = "weekly_recurrence"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 daily_recurrence: Optional['outputs.MaintenanceScheduleDailyRecurrence'] = None,
                 monthly_recurrence: Optional['outputs.MaintenanceScheduleMonthlyRecurrence'] = None,
                 once_recurrence: Optional['outputs.MaintenanceScheduleOnceRecurrence'] = None,
                 weekly_recurrence: Optional['outputs.MaintenanceScheduleWeeklyRecurrence'] = None):
        """
        :param str type: The type maintenance window, possible values: `DAILY`, `MONTHLY`, `ONCE`, `WEEKLY`
        :param 'MaintenanceScheduleDailyRecurrenceArgs' daily_recurrence: The configuration for maintenance windows occuring daily
        :param 'MaintenanceScheduleMonthlyRecurrenceArgs' monthly_recurrence: The configuration for maintenance windows occuring monthly
        :param 'MaintenanceScheduleOnceRecurrenceArgs' once_recurrence: The configuration for maintenance windows occuring once
        :param 'MaintenanceScheduleWeeklyRecurrenceArgs' weekly_recurrence: The configuration for maintenance windows occuring weekly
        """
        pulumi.set(__self__, "type", type)
        if daily_recurrence is not None:
            pulumi.set(__self__, "daily_recurrence", daily_recurrence)
        if monthly_recurrence is not None:
            pulumi.set(__self__, "monthly_recurrence", monthly_recurrence)
        if once_recurrence is not None:
            pulumi.set(__self__, "once_recurrence", once_recurrence)
        if weekly_recurrence is not None:
            pulumi.set(__self__, "weekly_recurrence", weekly_recurrence)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type maintenance window, possible values: `DAILY`, `MONTHLY`, `ONCE`, `WEEKLY`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="dailyRecurrence")
    def daily_recurrence(self) -> Optional['outputs.MaintenanceScheduleDailyRecurrence']:
        """
        The configuration for maintenance windows occuring daily
        """
        return pulumi.get(self, "daily_recurrence")

    @property
    @pulumi.getter(name="monthlyRecurrence")
    def monthly_recurrence(self) -> Optional['outputs.MaintenanceScheduleMonthlyRecurrence']:
        """
        The configuration for maintenance windows occuring monthly
        """
        return pulumi.get(self, "monthly_recurrence")

    @property
    @pulumi.getter(name="onceRecurrence")
    def once_recurrence(self) -> Optional['outputs.MaintenanceScheduleOnceRecurrence']:
        """
        The configuration for maintenance windows occuring once
        """
        return pulumi.get(self, "once_recurrence")

    @property
    @pulumi.getter(name="weeklyRecurrence")
    def weekly_recurrence(self) -> Optional['outputs.MaintenanceScheduleWeeklyRecurrence']:
        """
        The configuration for maintenance windows occuring weekly
        """
        return pulumi.get(self, "weekly_recurrence")


@pulumi.output_type
class MaintenanceScheduleDailyRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurrenceRange":
            suggest = "recurrence_range"
        elif key == "timeWindow":
            suggest = "time_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleDailyRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleDailyRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleDailyRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recurrence_range: 'outputs.MaintenanceScheduleDailyRecurrenceRecurrenceRange',
                 time_window: 'outputs.MaintenanceScheduleDailyRecurrenceTimeWindow'):
        """
        :param 'MaintenanceScheduleDailyRecurrenceRecurrenceRangeArgs' recurrence_range: The recurrence date range of the maintenance window
        :param 'MaintenanceScheduleDailyRecurrenceTimeWindowArgs' time_window: The time window of the maintenance window
        """
        pulumi.set(__self__, "recurrence_range", recurrence_range)
        pulumi.set(__self__, "time_window", time_window)

    @property
    @pulumi.getter(name="recurrenceRange")
    def recurrence_range(self) -> 'outputs.MaintenanceScheduleDailyRecurrenceRecurrenceRange':
        """
        The recurrence date range of the maintenance window
        """
        return pulumi.get(self, "recurrence_range")

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> 'outputs.MaintenanceScheduleDailyRecurrenceTimeWindow':
        """
        The time window of the maintenance window
        """
        return pulumi.get(self, "time_window")


@pulumi.output_type
class MaintenanceScheduleDailyRecurrenceRecurrenceRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleDailyRecurrenceRecurrenceRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleDailyRecurrenceRecurrenceRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleDailyRecurrenceRecurrenceRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: str,
                 start_date: str):
        """
        :param str end_date: The end date of the recurrence range in YYYY-MM-DD format
        :param str start_date: The start date of the recurrence range in YYYY-MM-DD format
        """
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        """
        The end date of the recurrence range in YYYY-MM-DD format
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The start date of the recurrence range in YYYY-MM-DD format
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class MaintenanceScheduleDailyRecurrenceTimeWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleDailyRecurrenceTimeWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleDailyRecurrenceTimeWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleDailyRecurrenceTimeWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 start_time: str,
                 time_zone: str):
        """
        :param str end_time: The end time of the maintenance window validity period in hh:mm:ss format
        :param str start_time: The start time of the maintenance window validity period in hh:mm:ss format
        :param str time_zone: The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        """
        The end time of the maintenance window validity period in hh:mm:ss format
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        The start time of the maintenance window validity period in hh:mm:ss format
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class MaintenanceScheduleMonthlyRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfMonth":
            suggest = "day_of_month"
        elif key == "recurrenceRange":
            suggest = "recurrence_range"
        elif key == "timeWindow":
            suggest = "time_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleMonthlyRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleMonthlyRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleMonthlyRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_month: int,
                 recurrence_range: 'outputs.MaintenanceScheduleMonthlyRecurrenceRecurrenceRange',
                 time_window: 'outputs.MaintenanceScheduleMonthlyRecurrenceTimeWindow'):
        """
        :param int day_of_month: The day of the month for monthly maintenance. If the selected day does not fall within the month, the maintenance window will be active on the last day of the month.
        :param 'MaintenanceScheduleMonthlyRecurrenceRecurrenceRangeArgs' recurrence_range: The recurrence date range of the maintenance window
        :param 'MaintenanceScheduleMonthlyRecurrenceTimeWindowArgs' time_window: The time window of the maintenance window
        """
        pulumi.set(__self__, "day_of_month", day_of_month)
        pulumi.set(__self__, "recurrence_range", recurrence_range)
        pulumi.set(__self__, "time_window", time_window)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> int:
        """
        The day of the month for monthly maintenance. If the selected day does not fall within the month, the maintenance window will be active on the last day of the month.
        """
        return pulumi.get(self, "day_of_month")

    @property
    @pulumi.getter(name="recurrenceRange")
    def recurrence_range(self) -> 'outputs.MaintenanceScheduleMonthlyRecurrenceRecurrenceRange':
        """
        The recurrence date range of the maintenance window
        """
        return pulumi.get(self, "recurrence_range")

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> 'outputs.MaintenanceScheduleMonthlyRecurrenceTimeWindow':
        """
        The time window of the maintenance window
        """
        return pulumi.get(self, "time_window")


@pulumi.output_type
class MaintenanceScheduleMonthlyRecurrenceRecurrenceRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleMonthlyRecurrenceRecurrenceRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleMonthlyRecurrenceRecurrenceRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleMonthlyRecurrenceRecurrenceRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: str,
                 start_date: str):
        """
        :param str end_date: The end date of the recurrence range in YYYY-MM-DD format
        :param str start_date: The start date of the recurrence range in YYYY-MM-DD format
        """
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        """
        The end date of the recurrence range in YYYY-MM-DD format
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The start date of the recurrence range in YYYY-MM-DD format
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class MaintenanceScheduleMonthlyRecurrenceTimeWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleMonthlyRecurrenceTimeWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleMonthlyRecurrenceTimeWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleMonthlyRecurrenceTimeWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 start_time: str,
                 time_zone: str):
        """
        :param str end_time: The end time of the maintenance window validity period in hh:mm:ss format
        :param str start_time: The start time of the maintenance window validity period in hh:mm:ss format
        :param str time_zone: The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        """
        The end time of the maintenance window validity period in hh:mm:ss format
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        The start time of the maintenance window validity period in hh:mm:ss format
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class MaintenanceScheduleOnceRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleOnceRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleOnceRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleOnceRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 start_time: str,
                 time_zone: str):
        """
        :param str end_time: The end time of the maintenance window validity period in YYYY-MM-DDThh:mm:ss format (for example, `2022-01-01T08:00:00`)
        :param str start_time: The start time of the maintenance window validity period in YYYY-MM-DDThh:mm:ss format (for example, `2022-01-01T08:00:00`)
        :param str time_zone: The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        """
        The end time of the maintenance window validity period in YYYY-MM-DDThh:mm:ss format (for example, `2022-01-01T08:00:00`)
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        The start time of the maintenance window validity period in YYYY-MM-DDThh:mm:ss format (for example, `2022-01-01T08:00:00`)
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class MaintenanceScheduleWeeklyRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "recurrenceRange":
            suggest = "recurrence_range"
        elif key == "timeWindow":
            suggest = "time_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleWeeklyRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleWeeklyRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleWeeklyRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: str,
                 recurrence_range: 'outputs.MaintenanceScheduleWeeklyRecurrenceRecurrenceRange',
                 time_window: 'outputs.MaintenanceScheduleWeeklyRecurrenceTimeWindow'):
        """
        :param str day_of_week: The day of the week for weekly maintenance, possible values: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
        :param 'MaintenanceScheduleWeeklyRecurrenceRecurrenceRangeArgs' recurrence_range: The recurrence date range of the maintenance window
        :param 'MaintenanceScheduleWeeklyRecurrenceTimeWindowArgs' time_window: The time window of the maintenance window
        """
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "recurrence_range", recurrence_range)
        pulumi.set(__self__, "time_window", time_window)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> str:
        """
        The day of the week for weekly maintenance, possible values: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
        """
        return pulumi.get(self, "day_of_week")

    @property
    @pulumi.getter(name="recurrenceRange")
    def recurrence_range(self) -> 'outputs.MaintenanceScheduleWeeklyRecurrenceRecurrenceRange':
        """
        The recurrence date range of the maintenance window
        """
        return pulumi.get(self, "recurrence_range")

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> 'outputs.MaintenanceScheduleWeeklyRecurrenceTimeWindow':
        """
        The time window of the maintenance window
        """
        return pulumi.get(self, "time_window")


@pulumi.output_type
class MaintenanceScheduleWeeklyRecurrenceRecurrenceRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleWeeklyRecurrenceRecurrenceRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleWeeklyRecurrenceRecurrenceRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleWeeklyRecurrenceRecurrenceRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: str,
                 start_date: str):
        """
        :param str end_date: The end date of the recurrence range in YYYY-MM-DD format
        :param str start_date: The start date of the recurrence range in YYYY-MM-DD format
        """
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        """
        The end date of the recurrence range in YYYY-MM-DD format
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The start date of the recurrence range in YYYY-MM-DD format
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class MaintenanceScheduleWeeklyRecurrenceTimeWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleWeeklyRecurrenceTimeWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleWeeklyRecurrenceTimeWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleWeeklyRecurrenceTimeWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 start_time: str,
                 time_zone: str):
        """
        :param str end_time: The end time of the maintenance window validity period in hh:mm:ss format
        :param str start_time: The start time of the maintenance window validity period in hh:mm:ss format
        :param str time_zone: The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        """
        The end time of the maintenance window validity period in hh:mm:ss format
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        The start time of the maintenance window validity period in hh:mm:ss format
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class MaintenanceWindowSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurrenceType":
            suggest = "recurrence_type"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end: str,
                 recurrence_type: str,
                 start: str,
                 zone_id: str,
                 recurrence: Optional['outputs.MaintenanceWindowScheduleRecurrence'] = None,
                 unknowns: Optional[str] = None):
        """
        :param str end: The end date and time of the maintenance window validity period in yyyy-mm-dd HH:mm format
        :param str recurrence_type: The type of the schedule recurrence. Possible values are `DAILY`, `MONTHLY`, `ONCE` and `WEEKLY`
        :param str start: The start date and time of the maintenance window validity period in yyyy-mm-dd HH:mm format
        :param str zone_id: The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
        :param 'MaintenanceWindowScheduleRecurrenceArgs' recurrence: The recurrence of the maintenance window
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "recurrence_type", recurrence_type)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "zone_id", zone_id)
        if recurrence is not None:
            pulumi.set(__self__, "recurrence", recurrence)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def end(self) -> str:
        """
        The end date and time of the maintenance window validity period in yyyy-mm-dd HH:mm format
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> str:
        """
        The type of the schedule recurrence. Possible values are `DAILY`, `MONTHLY`, `ONCE` and `WEEKLY`
        """
        return pulumi.get(self, "recurrence_type")

    @property
    @pulumi.getter
    def start(self) -> str:
        """
        The start date and time of the maintenance window validity period in yyyy-mm-dd HH:mm format
        """
        return pulumi.get(self, "start")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
        """
        return pulumi.get(self, "zone_id")

    @property
    @pulumi.getter
    def recurrence(self) -> Optional['outputs.MaintenanceWindowScheduleRecurrence']:
        """
        The recurrence of the maintenance window
        """
        return pulumi.get(self, "recurrence")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class MaintenanceWindowScheduleRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationMinutes":
            suggest = "duration_minutes"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "dayOfMonth":
            suggest = "day_of_month"
        elif key == "dayOfWeek":
            suggest = "day_of_week"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowScheduleRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowScheduleRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowScheduleRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_minutes: int,
                 start_time: str,
                 day_of_month: Optional[int] = None,
                 day_of_week: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param int duration_minutes: The duration of the maintenance window in minutes
        :param str start_time: The start time of the maintenance window in HH:mm format
        :param int day_of_month: The day of the month for monthly maintenance.  The value of `31` is treated as the last day of the month for months that don't have a 31st day. The value of `30` is also treated as the last day of the month for February
        :param str day_of_week: The day of the week for weekly maintenance.  The format is the full name of the day in upper case, for example `THURSDAY`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "duration_minutes", duration_minutes)
        pulumi.set(__self__, "start_time", start_time)
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="durationMinutes")
    def duration_minutes(self) -> int:
        """
        The duration of the maintenance window in minutes
        """
        return pulumi.get(self, "duration_minutes")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        The start time of the maintenance window in HH:mm format
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[int]:
        """
        The day of the month for monthly maintenance.  The value of `31` is treated as the last day of the month for months that don't have a 31st day. The value of `30` is also treated as the last day of the month for February
        """
        return pulumi.get(self, "day_of_month")

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[str]:
        """
        The day of the week for weekly maintenance.  The format is the full name of the day in upper case, for example `THURSDAY`
        """
        return pulumi.get(self, "day_of_week")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class MaintenanceWindowScope(dict):
    def __init__(__self__, *,
                 entities: Optional[Sequence[str]] = None,
                 matches: Optional[Sequence['outputs.MaintenanceWindowScopeMatch']] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence[str] entities: A list of Dynatrace entities (for example, hosts or services) to be included in the scope.  Allowed values are Dynatrace entity IDs
        :param Sequence['MaintenanceWindowScopeMatchArgs'] matches: A list of matching rules for dynamic scope formation.  If several rules are set, the OR logic applies
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence[str]]:
        """
        A list of Dynatrace entities (for example, hosts or services) to be included in the scope.  Allowed values are Dynatrace entity IDs
        """
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.MaintenanceWindowScopeMatch']]:
        """
        A list of matching rules for dynamic scope formation.  If several rules are set, the OR logic applies
        """
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class MaintenanceWindowScopeMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mzId":
            suggest = "mz_id"
        elif key == "tagCombination":
            suggest = "tag_combination"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowScopeMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowScopeMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowScopeMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mz_id: Optional[str] = None,
                 tag_combination: Optional[str] = None,
                 tags: Optional[Sequence['outputs.MaintenanceWindowScopeMatchTag']] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str mz_id: The ID of a management zone to which the matched entities must belong
        :param str tag_combination: The logic that applies when several tags are specified: AND/OR.  If not set, the OR logic is used
        :param Sequence['MaintenanceWindowScopeMatchTagArgs'] tags: The tag you want to use for matching.  You can use custom tags from the UI, AWS tags, Cloud Foundry tags, OpenShift/Kubernetes, and tags based on environment variables
        :param str type: The type of the Dynatrace entities (for example, hosts or services) you want to pick up by matching
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if mz_id is not None:
            pulumi.set(__self__, "mz_id", mz_id)
        if tag_combination is not None:
            pulumi.set(__self__, "tag_combination", tag_combination)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="mzId")
    def mz_id(self) -> Optional[str]:
        """
        The ID of a management zone to which the matched entities must belong
        """
        return pulumi.get(self, "mz_id")

    @property
    @pulumi.getter(name="tagCombination")
    def tag_combination(self) -> Optional[str]:
        """
        The logic that applies when several tags are specified: AND/OR.  If not set, the OR logic is used
        """
        return pulumi.get(self, "tag_combination")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.MaintenanceWindowScopeMatchTag']]:
        """
        The tag you want to use for matching.  You can use custom tags from the UI, AWS tags, Cloud Foundry tags, OpenShift/Kubernetes, and tags based on environment variables
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the Dynatrace entities (for example, hosts or services) you want to pick up by matching
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class MaintenanceWindowScopeMatchTag(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneDimensionalRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appliesTo":
            suggest = "applies_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneDimensionalRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneDimensionalRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneDimensionalRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applies_to: str,
                 conditions: Optional[Sequence['outputs.ManagementZoneDimensionalRuleCondition']] = None,
                 enabled: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str applies_to: The target of the rule. Possible values are
                  - `ANY`
                  - `LOG`
                  - `METRIC`
        :param Sequence['ManagementZoneDimensionalRuleConditionArgs'] conditions: A list of conditions for the management zone. The management zone applies only if **all** conditions are fulfilled
        :param bool enabled: The rule is enabled (`true`) or disabled (`false`)
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "applies_to", applies_to)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="appliesTo")
    def applies_to(self) -> str:
        """
        The target of the rule. Possible values are
           - `ANY`
           - `LOG`
           - `METRIC`
        """
        return pulumi.get(self, "applies_to")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ManagementZoneDimensionalRuleCondition']]:
        """
        A list of conditions for the management zone. The management zone applies only if **all** conditions are fulfilled
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        The rule is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneDimensionalRuleCondition(dict):
    def __init__(__self__, *,
                 key: str,
                 match: str,
                 type: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The reference value for comparison. For conditions of the `DIMENSION` type, specify the key here
        :param str match: How to compare. Possible values are 
                  - `BEGINS_WITH`
                  - `EQUALS`
        :param str type: The type of the condition. Possible values are 
                  - `DIMENSION`
                  - `LOG_FILE_NAME`
                  - `METRIC_KEY`
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value of the dimension. Only applicable when type is set to `DIMENSION`
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The reference value for comparison. For conditions of the `DIMENSION` type, specify the key here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def match(self) -> str:
        """
        How to compare. Possible values are 
           - `BEGINS_WITH`
           - `EQUALS`
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the condition. Possible values are 
           - `DIMENSION`
           - `LOG_FILE_NAME`
           - `METRIC_KEY`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the dimension. Only applicable when type is set to `DIMENSION`
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneEntitySelectorBasedRule(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 selector: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool enabled: The rule is enabled (`true`) or disabled (`false`)
        :param str selector: The entity selector string, by which the entities are selected
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        The rule is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        """
        The entity selector string, by which the entities are selected
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propagationTypes":
            suggest = "propagation_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.ManagementZoneRuleCondition']] = None,
                 enabled: Optional[bool] = None,
                 propagation_types: Optional[Sequence[str]] = None,
                 unknowns: Optional[str] = None):
        """
        :param str type: The type of Dynatrace entities the management zone can be applied to
        :param Sequence['ManagementZoneRuleConditionArgs'] conditions: A list of matching rules for the management zone. The management zone applies only if **all** conditions are fulfilled
        :param bool enabled: The rule is enabled (`true`) or disabled (`false`)
        :param Sequence[str] propagation_types: How to apply the management zone to underlying entities:
                  - `SERVICE_TO_HOST_LIKE`: Apply to underlying hosts of matching services
                  - `SERVICE_TO_PROCESS_GROUP_LIKE`: Apply to underlying process groups of matching services
                  - `PROCESS_GROUP_TO_HOST`: Apply to underlying hosts of matching process groups
                  - `PROCESS_GROUP_TO_SERVICE`: Apply to all services provided by matching process groups
                  - `HOST_TO_PROCESS_GROUP_INSTANCE`: Apply to processes running on matching hosts
                  - `CUSTOM_DEVICE_GROUP_TO_CUSTOM_DEVICE`: Apply to custom devices in matching custom device groups
                  - `AZURE_TO_PG`: Apply to process groups connected to matching Azure entities
                  - `AZURE_TO_SERVICE`: Apply to services provided by matching Azure entities
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if propagation_types is not None:
            pulumi.set(__self__, "propagation_types", propagation_types)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of Dynatrace entities the management zone can be applied to
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ManagementZoneRuleCondition']]:
        """
        A list of matching rules for the management zone. The management zone applies only if **all** conditions are fulfilled
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        The rule is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propagationTypes")
    def propagation_types(self) -> Optional[Sequence[str]]:
        """
        How to apply the management zone to underlying entities:
           - `SERVICE_TO_HOST_LIKE`: Apply to underlying hosts of matching services
           - `SERVICE_TO_PROCESS_GROUP_LIKE`: Apply to underlying process groups of matching services
           - `PROCESS_GROUP_TO_HOST`: Apply to underlying hosts of matching process groups
           - `PROCESS_GROUP_TO_SERVICE`: Apply to all services provided by matching process groups
           - `HOST_TO_PROCESS_GROUP_INSTANCE`: Apply to processes running on matching hosts
           - `CUSTOM_DEVICE_GROUP_TO_CUSTOM_DEVICE`: Apply to custom devices in matching custom device groups
           - `AZURE_TO_PG`: Apply to process groups connected to matching Azure entities
           - `AZURE_TO_SERVICE`: Apply to services provided by matching Azure entities
        """
        return pulumi.get(self, "propagation_types")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationTypeComparisons":
            suggest = "application_type_comparisons"
        elif key == "applicationTypes":
            suggest = "application_types"
        elif key == "azureComputeModeComparisons":
            suggest = "azure_compute_mode_comparisons"
        elif key == "azureComputeModes":
            suggest = "azure_compute_modes"
        elif key == "azureSkuComparisions":
            suggest = "azure_sku_comparisions"
        elif key == "azureSkus":
            suggest = "azure_skus"
        elif key == "baseComparisonBasics":
            suggest = "base_comparison_basics"
        elif key == "baseConditionKeys":
            suggest = "base_condition_keys"
        elif key == "bitnessComparisions":
            suggest = "bitness_comparisions"
        elif key == "cloudTypeComparisons":
            suggest = "cloud_type_comparisons"
        elif key == "cloudTypes":
            suggest = "cloud_types"
        elif key == "customApplicationTypeComparisons":
            suggest = "custom_application_type_comparisons"
        elif key == "customApplicationTypes":
            suggest = "custom_application_types"
        elif key == "customHostMetadataConditionKeys":
            suggest = "custom_host_metadata_condition_keys"
        elif key == "customHostMetadatas":
            suggest = "custom_host_metadatas"
        elif key == "customProcessMetadataConditionKeys":
            suggest = "custom_process_metadata_condition_keys"
        elif key == "customProcessMetadatas":
            suggest = "custom_process_metadatas"
        elif key == "databaseTopologies":
            suggest = "database_topologies"
        elif key == "databaseTopologyComparisons":
            suggest = "database_topology_comparisons"
        elif key == "dcrumDecoderComparisons":
            suggest = "dcrum_decoder_comparisons"
        elif key == "dcrumDecoders":
            suggest = "dcrum_decoders"
        elif key == "entityIdComparisons":
            suggest = "entity_id_comparisons"
        elif key == "hostTeches":
            suggest = "host_teches"
        elif key == "hypervisorTypeComparisions":
            suggest = "hypervisor_type_comparisions"
        elif key == "indexedNameComparisons":
            suggest = "indexed_name_comparisons"
        elif key == "indexedNames":
            suggest = "indexed_names"
        elif key == "indexedStringComparisons":
            suggest = "indexed_string_comparisons"
        elif key == "indexedStrings":
            suggest = "indexed_strings"
        elif key == "indexedTagComparisons":
            suggest = "indexed_tag_comparisons"
        elif key == "indexedTags":
            suggest = "indexed_tags"
        elif key == "integerComparisons":
            suggest = "integer_comparisons"
        elif key == "ipaddressComparisons":
            suggest = "ipaddress_comparisons"
        elif key == "mobilePlatformComparisons":
            suggest = "mobile_platform_comparisons"
        elif key == "mobilePlatforms":
            suggest = "mobile_platforms"
        elif key == "osArches":
            suggest = "os_arches"
        elif key == "osTypes":
            suggest = "os_types"
        elif key == "osarchitectureComparisons":
            suggest = "osarchitecture_comparisons"
        elif key == "ostypeComparisons":
            suggest = "ostype_comparisons"
        elif key == "paasTypeComparisons":
            suggest = "paas_type_comparisons"
        elif key == "paasTypes":
            suggest = "paas_types"
        elif key == "processMetadataConditionKeys":
            suggest = "process_metadata_condition_keys"
        elif key == "processMetadatas":
            suggest = "process_metadatas"
        elif key == "serviceTopologies":
            suggest = "service_topologies"
        elif key == "serviceTopologyComparisons":
            suggest = "service_topology_comparisons"
        elif key == "serviceTypeComparisons":
            suggest = "service_type_comparisons"
        elif key == "serviceTypes":
            suggest = "service_types"
        elif key == "simpleHostTechComparisons":
            suggest = "simple_host_tech_comparisons"
        elif key == "simpleTechComparisons":
            suggest = "simple_tech_comparisons"
        elif key == "stringComparisons":
            suggest = "string_comparisons"
        elif key == "stringConditionKeys":
            suggest = "string_condition_keys"
        elif key == "stringKeys":
            suggest = "string_keys"
        elif key == "syntheticEngineTypeComparisons":
            suggest = "synthetic_engine_type_comparisons"
        elif key == "syntheticEngines":
            suggest = "synthetic_engines"
        elif key == "tagComparisons":
            suggest = "tag_comparisons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_type_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionApplicationTypeComparison']] = None,
                 application_types: Optional[Sequence['outputs.ManagementZoneRuleConditionApplicationType']] = None,
                 azure_compute_mode_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionAzureComputeModeComparison']] = None,
                 azure_compute_modes: Optional[Sequence['outputs.ManagementZoneRuleConditionAzureComputeMode']] = None,
                 azure_sku_comparisions: Optional[Sequence['outputs.ManagementZoneRuleConditionAzureSkuComparision']] = None,
                 azure_skus: Optional[Sequence['outputs.ManagementZoneRuleConditionAzureSkus']] = None,
                 base_comparison_basics: Optional[Sequence['outputs.ManagementZoneRuleConditionBaseComparisonBasic']] = None,
                 base_condition_keys: Optional[Sequence['outputs.ManagementZoneRuleConditionBaseConditionKey']] = None,
                 bitness_comparisions: Optional[Sequence['outputs.ManagementZoneRuleConditionBitnessComparision']] = None,
                 bitnesses: Optional[Sequence['outputs.ManagementZoneRuleConditionBitness']] = None,
                 cloud_type_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionCloudTypeComparison']] = None,
                 cloud_types: Optional[Sequence['outputs.ManagementZoneRuleConditionCloudType']] = None,
                 comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionComparison']] = None,
                 custom_application_type_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionCustomApplicationTypeComparison']] = None,
                 custom_application_types: Optional[Sequence['outputs.ManagementZoneRuleConditionCustomApplicationType']] = None,
                 custom_host_metadata_condition_keys: Optional[Sequence['outputs.ManagementZoneRuleConditionCustomHostMetadataConditionKey']] = None,
                 custom_host_metadatas: Optional[Sequence['outputs.ManagementZoneRuleConditionCustomHostMetadata']] = None,
                 custom_process_metadata_condition_keys: Optional[Sequence['outputs.ManagementZoneRuleConditionCustomProcessMetadataConditionKey']] = None,
                 custom_process_metadatas: Optional[Sequence['outputs.ManagementZoneRuleConditionCustomProcessMetadata']] = None,
                 database_topologies: Optional[Sequence['outputs.ManagementZoneRuleConditionDatabaseTopology']] = None,
                 database_topology_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionDatabaseTopologyComparison']] = None,
                 dcrum_decoder_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionDcrumDecoderComparison']] = None,
                 dcrum_decoders: Optional[Sequence['outputs.ManagementZoneRuleConditionDcrumDecoder']] = None,
                 entities: Optional[Sequence['outputs.ManagementZoneRuleConditionEntity']] = None,
                 entity_id_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionEntityIdComparison']] = None,
                 host_teches: Optional[Sequence['outputs.ManagementZoneRuleConditionHostTech']] = None,
                 hypervisor_type_comparisions: Optional[Sequence['outputs.ManagementZoneRuleConditionHypervisorTypeComparision']] = None,
                 hypervisors: Optional[Sequence['outputs.ManagementZoneRuleConditionHypervisor']] = None,
                 indexed_name_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedNameComparison']] = None,
                 indexed_names: Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedName']] = None,
                 indexed_string_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedStringComparison']] = None,
                 indexed_strings: Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedString']] = None,
                 indexed_tag_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedTagComparison']] = None,
                 indexed_tags: Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedTag']] = None,
                 integer_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionIntegerComparison']] = None,
                 integers: Optional[Sequence['outputs.ManagementZoneRuleConditionInteger']] = None,
                 ipaddress_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionIpaddressComparison']] = None,
                 ipaddresses: Optional[Sequence['outputs.ManagementZoneRuleConditionIpaddress']] = None,
                 keys: Optional[Sequence['outputs.ManagementZoneRuleConditionKey']] = None,
                 mobile_platform_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionMobilePlatformComparison']] = None,
                 mobile_platforms: Optional[Sequence['outputs.ManagementZoneRuleConditionMobilePlatform']] = None,
                 os_arches: Optional[Sequence['outputs.ManagementZoneRuleConditionOsArch']] = None,
                 os_types: Optional[Sequence['outputs.ManagementZoneRuleConditionOsType']] = None,
                 osarchitecture_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionOsarchitectureComparison']] = None,
                 ostype_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionOstypeComparison']] = None,
                 paas_type_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionPaasTypeComparison']] = None,
                 paas_types: Optional[Sequence['outputs.ManagementZoneRuleConditionPaasType']] = None,
                 process_metadata_condition_keys: Optional[Sequence['outputs.ManagementZoneRuleConditionProcessMetadataConditionKey']] = None,
                 process_metadatas: Optional[Sequence['outputs.ManagementZoneRuleConditionProcessMetadata']] = None,
                 service_topologies: Optional[Sequence['outputs.ManagementZoneRuleConditionServiceTopology']] = None,
                 service_topology_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionServiceTopologyComparison']] = None,
                 service_type_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionServiceTypeComparison']] = None,
                 service_types: Optional[Sequence['outputs.ManagementZoneRuleConditionServiceType']] = None,
                 simple_host_tech_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionSimpleHostTechComparison']] = None,
                 simple_tech_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionSimpleTechComparison']] = None,
                 string_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionStringComparison']] = None,
                 string_condition_keys: Optional[Sequence['outputs.ManagementZoneRuleConditionStringConditionKey']] = None,
                 string_keys: Optional[Sequence['outputs.ManagementZoneRuleConditionStringKey']] = None,
                 strings: Optional[Sequence['outputs.ManagementZoneRuleConditionString']] = None,
                 synthetic_engine_type_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionSyntheticEngineTypeComparison']] = None,
                 synthetic_engines: Optional[Sequence['outputs.ManagementZoneRuleConditionSyntheticEngine']] = None,
                 tag_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionTagComparison']] = None,
                 tags: Optional[Sequence['outputs.ManagementZoneRuleConditionTag']] = None,
                 teches: Optional[Sequence['outputs.ManagementZoneRuleConditionTech']] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence['ManagementZoneRuleConditionApplicationTypeComparisonArgs'] application_type_comparisons: Comparison for `APPLICATION_TYPE` attributes
        :param Sequence['ManagementZoneRuleConditionApplicationTypeArgs'] application_types: Comparison for `APPLICATION_TYPE` attributes
        :param Sequence['ManagementZoneRuleConditionAzureComputeModeComparisonArgs'] azure_compute_mode_comparisons: Comparison for `AZURE_COMPUTE_MODE` attributes
        :param Sequence['ManagementZoneRuleConditionAzureComputeModeArgs'] azure_compute_modes: Comparison for `AZURE_COMPUTE_MODE` attributes
        :param Sequence['ManagementZoneRuleConditionAzureSkuComparisionArgs'] azure_sku_comparisions: Comparison for `AZURE_SKU` attributes
        :param Sequence['ManagementZoneRuleConditionAzureSkusArgs'] azure_skus: Comparison for `AZURE_SKU` attributes
        :param Sequence['ManagementZoneRuleConditionBaseComparisonBasicArgs'] base_comparison_basics: A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        :param Sequence['ManagementZoneRuleConditionBaseConditionKeyArgs'] base_condition_keys: Fallback for not yet known type
        :param Sequence['ManagementZoneRuleConditionBitnessComparisionArgs'] bitness_comparisions: Comparison for `BITNESS` attributes
        :param Sequence['ManagementZoneRuleConditionBitnessArgs'] bitnesses: Comparison for `BITNESS` attributes
        :param Sequence['ManagementZoneRuleConditionCloudTypeComparisonArgs'] cloud_type_comparisons: Comparison for `CLOUD_TYPE` attributes
        :param Sequence['ManagementZoneRuleConditionCloudTypeArgs'] cloud_types: Comparison for `CLOUD_TYPE` attributes
        :param Sequence['ManagementZoneRuleConditionComparisonArgs'] comparisons: A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        :param Sequence['ManagementZoneRuleConditionCustomApplicationTypeComparisonArgs'] custom_application_type_comparisons: Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        :param Sequence['ManagementZoneRuleConditionCustomApplicationTypeArgs'] custom_application_types: Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        :param Sequence['ManagementZoneRuleConditionCustomHostMetadataConditionKeyArgs'] custom_host_metadata_condition_keys: Key for Custom Host Metadata
        :param Sequence['ManagementZoneRuleConditionCustomHostMetadataArgs'] custom_host_metadatas: Key for Custom Host Metadata
        :param Sequence['ManagementZoneRuleConditionCustomProcessMetadataConditionKeyArgs'] custom_process_metadata_condition_keys: Key for Custom Process Metadata
        :param Sequence['ManagementZoneRuleConditionCustomProcessMetadataArgs'] custom_process_metadatas: Key for Custom Process Metadata
        :param Sequence['ManagementZoneRuleConditionDatabaseTopologyArgs'] database_topologies: Comparison for `DATABASE_TOPOLOGY` attributes
        :param Sequence['ManagementZoneRuleConditionDatabaseTopologyComparisonArgs'] database_topology_comparisons: Comparison for `DATABASE_TOPOLOGY` attributes
        :param Sequence['ManagementZoneRuleConditionDcrumDecoderComparisonArgs'] dcrum_decoder_comparisons: Comparison for `DCRUM_DECODER_TYPE` attributes
        :param Sequence['ManagementZoneRuleConditionDcrumDecoderArgs'] dcrum_decoders: Comparison for `DCRUM_DECODER_TYPE` attributes
        :param Sequence['ManagementZoneRuleConditionEntityArgs'] entities: Comparison for `ENTITY_ID` attributes
        :param Sequence['ManagementZoneRuleConditionEntityIdComparisonArgs'] entity_id_comparisons: Comparison for `ENTITY_ID` attributes
        :param Sequence['ManagementZoneRuleConditionHostTechArgs'] host_teches: Comparison for `SIMPLE_HOST_TECH` attributes
        :param Sequence['ManagementZoneRuleConditionHypervisorTypeComparisionArgs'] hypervisor_type_comparisions: `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
        :param Sequence['ManagementZoneRuleConditionHypervisorArgs'] hypervisors: Comparison for `HYPERVISOR_TYPE` attributes
        :param Sequence['ManagementZoneRuleConditionIndexedNameComparisonArgs'] indexed_name_comparisons: Comparison for `INDEXED_NAME` attributes
        :param Sequence['ManagementZoneRuleConditionIndexedNameArgs'] indexed_names: Comparison for `INDEXED_NAME` attributes
        :param Sequence['ManagementZoneRuleConditionIndexedStringComparisonArgs'] indexed_string_comparisons: Comparison for `INDEXED_STRING` attributes
        :param Sequence['ManagementZoneRuleConditionIndexedStringArgs'] indexed_strings: Comparison for `INDEXED_STRING` attributes
        :param Sequence['ManagementZoneRuleConditionIndexedTagComparisonArgs'] indexed_tag_comparisons: Comparison for `INDEXED_TAG` attributes
        :param Sequence['ManagementZoneRuleConditionIndexedTagArgs'] indexed_tags: Comparison for `INDEXED_TAG` attributes
        :param Sequence['ManagementZoneRuleConditionIntegerComparisonArgs'] integer_comparisons: Comparison for `INTEGER` attributes
        :param Sequence['ManagementZoneRuleConditionIntegerArgs'] integers: Comparison for `INTEGER` attributes
        :param Sequence['ManagementZoneRuleConditionIpaddressComparisonArgs'] ipaddress_comparisons: Comparison for `IP_ADDRESS` attributes
        :param Sequence['ManagementZoneRuleConditionIpaddressArgs'] ipaddresses: Comparison for `IP_ADDRESS` attributes
        :param Sequence['ManagementZoneRuleConditionKeyArgs'] keys: Fallback for not yet known type
        :param Sequence['ManagementZoneRuleConditionMobilePlatformComparisonArgs'] mobile_platform_comparisons: Comparison for `MOBILE_PLATFORM` attributes
        :param Sequence['ManagementZoneRuleConditionMobilePlatformArgs'] mobile_platforms: Comparison for `MOBILE_PLATFORM` attributes
        :param Sequence['ManagementZoneRuleConditionOsArchArgs'] os_arches: Comparison for `OS_ARCHITECTURE` attributes
        :param Sequence['ManagementZoneRuleConditionOsTypeArgs'] os_types: Comparison for `OS_TYPE` attributes
        :param Sequence['ManagementZoneRuleConditionOsarchitectureComparisonArgs'] osarchitecture_comparisons: Comparison for `OS_ARCHITECTURE` attributes
        :param Sequence['ManagementZoneRuleConditionOstypeComparisonArgs'] ostype_comparisons: Comparison for `OS_TYPE` attributes
        :param Sequence['ManagementZoneRuleConditionPaasTypeComparisonArgs'] paas_type_comparisons: Comparison for `PAAS_TYPE` attributes
        :param Sequence['ManagementZoneRuleConditionPaasTypeArgs'] paas_types: Comparison for `PAAS_TYPE` attributes
        :param Sequence['ManagementZoneRuleConditionProcessMetadataConditionKeyArgs'] process_metadata_condition_keys: The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        :param Sequence['ManagementZoneRuleConditionProcessMetadataArgs'] process_metadatas: The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        :param Sequence['ManagementZoneRuleConditionServiceTopologyArgs'] service_topologies: Comparison for `SERVICE_TOPOLOGY` attributes
        :param Sequence['ManagementZoneRuleConditionServiceTopologyComparisonArgs'] service_topology_comparisons: Comparison for `SERVICE_TOPOLOGY` attributes
        :param Sequence['ManagementZoneRuleConditionServiceTypeComparisonArgs'] service_type_comparisons: Comparison for `SERVICE_TYPE` attributes
        :param Sequence['ManagementZoneRuleConditionServiceTypeArgs'] service_types: Comparison for `SERVICE_TYPE` attributes
        :param Sequence['ManagementZoneRuleConditionSimpleHostTechComparisonArgs'] simple_host_tech_comparisons: Comparison for `SIMPLE_HOST_TECH` attributes
        :param Sequence['ManagementZoneRuleConditionSimpleTechComparisonArgs'] simple_tech_comparisons: Comparison for `SIMPLE_TECH` attributes
        :param Sequence['ManagementZoneRuleConditionStringComparisonArgs'] string_comparisons: Comparison for `STRING` attributes
        :param Sequence['ManagementZoneRuleConditionStringConditionKeyArgs'] string_condition_keys: The key for dynamic attributes of the `STRING` type
        :param Sequence['ManagementZoneRuleConditionStringKeyArgs'] string_keys: The key for dynamic attributes of the `STRING` type
        :param Sequence['ManagementZoneRuleConditionStringArgs'] strings: Comparison for `STRING` attributes
        :param Sequence['ManagementZoneRuleConditionSyntheticEngineTypeComparisonArgs'] synthetic_engine_type_comparisons: Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        :param Sequence['ManagementZoneRuleConditionSyntheticEngineArgs'] synthetic_engines: Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        :param Sequence['ManagementZoneRuleConditionTagComparisonArgs'] tag_comparisons: Comparison for `TAG` attributes
        :param Sequence['ManagementZoneRuleConditionTagArgs'] tags: Comparison for `TAG` attributes
        :param Sequence['ManagementZoneRuleConditionTechArgs'] teches: Comparison for `SIMPLE_TECH` attributes
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if application_type_comparisons is not None:
            pulumi.set(__self__, "application_type_comparisons", application_type_comparisons)
        if application_types is not None:
            pulumi.set(__self__, "application_types", application_types)
        if azure_compute_mode_comparisons is not None:
            pulumi.set(__self__, "azure_compute_mode_comparisons", azure_compute_mode_comparisons)
        if azure_compute_modes is not None:
            pulumi.set(__self__, "azure_compute_modes", azure_compute_modes)
        if azure_sku_comparisions is not None:
            pulumi.set(__self__, "azure_sku_comparisions", azure_sku_comparisions)
        if azure_skus is not None:
            pulumi.set(__self__, "azure_skus", azure_skus)
        if base_comparison_basics is not None:
            pulumi.set(__self__, "base_comparison_basics", base_comparison_basics)
        if base_condition_keys is not None:
            pulumi.set(__self__, "base_condition_keys", base_condition_keys)
        if bitness_comparisions is not None:
            pulumi.set(__self__, "bitness_comparisions", bitness_comparisions)
        if bitnesses is not None:
            pulumi.set(__self__, "bitnesses", bitnesses)
        if cloud_type_comparisons is not None:
            pulumi.set(__self__, "cloud_type_comparisons", cloud_type_comparisons)
        if cloud_types is not None:
            pulumi.set(__self__, "cloud_types", cloud_types)
        if comparisons is not None:
            pulumi.set(__self__, "comparisons", comparisons)
        if custom_application_type_comparisons is not None:
            pulumi.set(__self__, "custom_application_type_comparisons", custom_application_type_comparisons)
        if custom_application_types is not None:
            pulumi.set(__self__, "custom_application_types", custom_application_types)
        if custom_host_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_host_metadata_condition_keys", custom_host_metadata_condition_keys)
        if custom_host_metadatas is not None:
            pulumi.set(__self__, "custom_host_metadatas", custom_host_metadatas)
        if custom_process_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_process_metadata_condition_keys", custom_process_metadata_condition_keys)
        if custom_process_metadatas is not None:
            pulumi.set(__self__, "custom_process_metadatas", custom_process_metadatas)
        if database_topologies is not None:
            pulumi.set(__self__, "database_topologies", database_topologies)
        if database_topology_comparisons is not None:
            pulumi.set(__self__, "database_topology_comparisons", database_topology_comparisons)
        if dcrum_decoder_comparisons is not None:
            pulumi.set(__self__, "dcrum_decoder_comparisons", dcrum_decoder_comparisons)
        if dcrum_decoders is not None:
            pulumi.set(__self__, "dcrum_decoders", dcrum_decoders)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if entity_id_comparisons is not None:
            pulumi.set(__self__, "entity_id_comparisons", entity_id_comparisons)
        if host_teches is not None:
            pulumi.set(__self__, "host_teches", host_teches)
        if hypervisor_type_comparisions is not None:
            pulumi.set(__self__, "hypervisor_type_comparisions", hypervisor_type_comparisions)
        if hypervisors is not None:
            pulumi.set(__self__, "hypervisors", hypervisors)
        if indexed_name_comparisons is not None:
            pulumi.set(__self__, "indexed_name_comparisons", indexed_name_comparisons)
        if indexed_names is not None:
            pulumi.set(__self__, "indexed_names", indexed_names)
        if indexed_string_comparisons is not None:
            pulumi.set(__self__, "indexed_string_comparisons", indexed_string_comparisons)
        if indexed_strings is not None:
            pulumi.set(__self__, "indexed_strings", indexed_strings)
        if indexed_tag_comparisons is not None:
            pulumi.set(__self__, "indexed_tag_comparisons", indexed_tag_comparisons)
        if indexed_tags is not None:
            pulumi.set(__self__, "indexed_tags", indexed_tags)
        if integer_comparisons is not None:
            pulumi.set(__self__, "integer_comparisons", integer_comparisons)
        if integers is not None:
            pulumi.set(__self__, "integers", integers)
        if ipaddress_comparisons is not None:
            pulumi.set(__self__, "ipaddress_comparisons", ipaddress_comparisons)
        if ipaddresses is not None:
            pulumi.set(__self__, "ipaddresses", ipaddresses)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if mobile_platform_comparisons is not None:
            pulumi.set(__self__, "mobile_platform_comparisons", mobile_platform_comparisons)
        if mobile_platforms is not None:
            pulumi.set(__self__, "mobile_platforms", mobile_platforms)
        if os_arches is not None:
            pulumi.set(__self__, "os_arches", os_arches)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if osarchitecture_comparisons is not None:
            pulumi.set(__self__, "osarchitecture_comparisons", osarchitecture_comparisons)
        if ostype_comparisons is not None:
            pulumi.set(__self__, "ostype_comparisons", ostype_comparisons)
        if paas_type_comparisons is not None:
            pulumi.set(__self__, "paas_type_comparisons", paas_type_comparisons)
        if paas_types is not None:
            pulumi.set(__self__, "paas_types", paas_types)
        if process_metadata_condition_keys is not None:
            pulumi.set(__self__, "process_metadata_condition_keys", process_metadata_condition_keys)
        if process_metadatas is not None:
            pulumi.set(__self__, "process_metadatas", process_metadatas)
        if service_topologies is not None:
            pulumi.set(__self__, "service_topologies", service_topologies)
        if service_topology_comparisons is not None:
            pulumi.set(__self__, "service_topology_comparisons", service_topology_comparisons)
        if service_type_comparisons is not None:
            pulumi.set(__self__, "service_type_comparisons", service_type_comparisons)
        if service_types is not None:
            pulumi.set(__self__, "service_types", service_types)
        if simple_host_tech_comparisons is not None:
            pulumi.set(__self__, "simple_host_tech_comparisons", simple_host_tech_comparisons)
        if simple_tech_comparisons is not None:
            pulumi.set(__self__, "simple_tech_comparisons", simple_tech_comparisons)
        if string_comparisons is not None:
            pulumi.set(__self__, "string_comparisons", string_comparisons)
        if string_condition_keys is not None:
            pulumi.set(__self__, "string_condition_keys", string_condition_keys)
        if string_keys is not None:
            pulumi.set(__self__, "string_keys", string_keys)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)
        if synthetic_engine_type_comparisons is not None:
            pulumi.set(__self__, "synthetic_engine_type_comparisons", synthetic_engine_type_comparisons)
        if synthetic_engines is not None:
            pulumi.set(__self__, "synthetic_engines", synthetic_engines)
        if tag_comparisons is not None:
            pulumi.set(__self__, "tag_comparisons", tag_comparisons)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if teches is not None:
            pulumi.set(__self__, "teches", teches)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="applicationTypeComparisons")
    @_utilities.deprecated("""You should use 'application_type' instead of 'application_type_comparison'. This attribute still exists for backwards compatibility.""")
    def application_type_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionApplicationTypeComparison']]:
        """
        Comparison for `APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "application_type_comparisons")

    @property
    @pulumi.getter(name="applicationTypes")
    def application_types(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionApplicationType']]:
        """
        Comparison for `APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "application_types")

    @property
    @pulumi.getter(name="azureComputeModeComparisons")
    def azure_compute_mode_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionAzureComputeModeComparison']]:
        """
        Comparison for `AZURE_COMPUTE_MODE` attributes
        """
        return pulumi.get(self, "azure_compute_mode_comparisons")

    @property
    @pulumi.getter(name="azureComputeModes")
    @_utilities.deprecated("""You should use 'azure_compute_mode' instead of 'azure_compute_mode_comparison'. This attribute still exists for backwards compatibility.""")
    def azure_compute_modes(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionAzureComputeMode']]:
        """
        Comparison for `AZURE_COMPUTE_MODE` attributes
        """
        return pulumi.get(self, "azure_compute_modes")

    @property
    @pulumi.getter(name="azureSkuComparisions")
    @_utilities.deprecated("""You should use 'azure_sku' instead of 'azure_sku_comparision'. This attribute still exists for backwards compatibility.""")
    def azure_sku_comparisions(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionAzureSkuComparision']]:
        """
        Comparison for `AZURE_SKU` attributes
        """
        return pulumi.get(self, "azure_sku_comparisions")

    @property
    @pulumi.getter(name="azureSkus")
    def azure_skus(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionAzureSkus']]:
        """
        Comparison for `AZURE_SKU` attributes
        """
        return pulumi.get(self, "azure_skus")

    @property
    @pulumi.getter(name="baseComparisonBasics")
    @_utilities.deprecated("""You should use 'comparison' instead of 'base_comparison_basic'. This attribute still exists for backwards compatibility.""")
    def base_comparison_basics(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionBaseComparisonBasic']]:
        """
        A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        """
        return pulumi.get(self, "base_comparison_basics")

    @property
    @pulumi.getter(name="baseConditionKeys")
    @_utilities.deprecated("""'base_condition_key' is deprecated. You should use 'key'""")
    def base_condition_keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionBaseConditionKey']]:
        """
        Fallback for not yet known type
        """
        return pulumi.get(self, "base_condition_keys")

    @property
    @pulumi.getter(name="bitnessComparisions")
    @_utilities.deprecated("""You should use 'bitness' instead of 'bitness_comparision'. This attribute still exists for backwards compatibility.""")
    def bitness_comparisions(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionBitnessComparision']]:
        """
        Comparison for `BITNESS` attributes
        """
        return pulumi.get(self, "bitness_comparisions")

    @property
    @pulumi.getter
    def bitnesses(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionBitness']]:
        """
        Comparison for `BITNESS` attributes
        """
        return pulumi.get(self, "bitnesses")

    @property
    @pulumi.getter(name="cloudTypeComparisons")
    @_utilities.deprecated("""You should use 'cloud_type' instead of 'cloud_type_comparison'. This attribute still exists for backwards compatibility.""")
    def cloud_type_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCloudTypeComparison']]:
        """
        Comparison for `CLOUD_TYPE` attributes
        """
        return pulumi.get(self, "cloud_type_comparisons")

    @property
    @pulumi.getter(name="cloudTypes")
    def cloud_types(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCloudType']]:
        """
        Comparison for `CLOUD_TYPE` attributes
        """
        return pulumi.get(self, "cloud_types")

    @property
    @pulumi.getter
    def comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionComparison']]:
        """
        A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        """
        return pulumi.get(self, "comparisons")

    @property
    @pulumi.getter(name="customApplicationTypeComparisons")
    @_utilities.deprecated("""You should use 'custom_application_type' instead of 'custom_application_type_comparison'. This attribute still exists for backwards compatibility.""")
    def custom_application_type_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCustomApplicationTypeComparison']]:
        """
        Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "custom_application_type_comparisons")

    @property
    @pulumi.getter(name="customApplicationTypes")
    def custom_application_types(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCustomApplicationType']]:
        """
        Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "custom_application_types")

    @property
    @pulumi.getter(name="customHostMetadataConditionKeys")
    @_utilities.deprecated("""'custom_host_metadata_condition_key' is deprecated. You should use 'custom_host_metadata'""")
    def custom_host_metadata_condition_keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCustomHostMetadataConditionKey']]:
        """
        Key for Custom Host Metadata
        """
        return pulumi.get(self, "custom_host_metadata_condition_keys")

    @property
    @pulumi.getter(name="customHostMetadatas")
    def custom_host_metadatas(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCustomHostMetadata']]:
        """
        Key for Custom Host Metadata
        """
        return pulumi.get(self, "custom_host_metadatas")

    @property
    @pulumi.getter(name="customProcessMetadataConditionKeys")
    @_utilities.deprecated("""'custom_process_metadata_condition_key' is deprecated. You should use 'custom_process_metadata'""")
    def custom_process_metadata_condition_keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCustomProcessMetadataConditionKey']]:
        """
        Key for Custom Process Metadata
        """
        return pulumi.get(self, "custom_process_metadata_condition_keys")

    @property
    @pulumi.getter(name="customProcessMetadatas")
    def custom_process_metadatas(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCustomProcessMetadata']]:
        """
        Key for Custom Process Metadata
        """
        return pulumi.get(self, "custom_process_metadatas")

    @property
    @pulumi.getter(name="databaseTopologies")
    def database_topologies(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionDatabaseTopology']]:
        """
        Comparison for `DATABASE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "database_topologies")

    @property
    @pulumi.getter(name="databaseTopologyComparisons")
    @_utilities.deprecated("""You should use 'database_topology' instead of 'database_topology_comparison'. This attribute still exists for backwards compatibility.""")
    def database_topology_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionDatabaseTopologyComparison']]:
        """
        Comparison for `DATABASE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "database_topology_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoderComparisons")
    @_utilities.deprecated("""You should use 'dcrum_decoder' instead of 'dcrum_decoder_comparison'. This attribute still exists for backwards compatibility.""")
    def dcrum_decoder_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionDcrumDecoderComparison']]:
        """
        Comparison for `DCRUM_DECODER_TYPE` attributes
        """
        return pulumi.get(self, "dcrum_decoder_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoders")
    def dcrum_decoders(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionDcrumDecoder']]:
        """
        Comparison for `DCRUM_DECODER_TYPE` attributes
        """
        return pulumi.get(self, "dcrum_decoders")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionEntity']]:
        """
        Comparison for `ENTITY_ID` attributes
        """
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="entityIdComparisons")
    @_utilities.deprecated("""You should use 'entity' instead of 'entity_id_comparison'. This attribute still exists for backwards compatibility.""")
    def entity_id_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionEntityIdComparison']]:
        """
        Comparison for `ENTITY_ID` attributes
        """
        return pulumi.get(self, "entity_id_comparisons")

    @property
    @pulumi.getter(name="hostTeches")
    def host_teches(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionHostTech']]:
        """
        Comparison for `SIMPLE_HOST_TECH` attributes
        """
        return pulumi.get(self, "host_teches")

    @property
    @pulumi.getter(name="hypervisorTypeComparisions")
    @_utilities.deprecated("""`hypervisor_type_comparision` is deprecated. Use `hypervisor` instead""")
    def hypervisor_type_comparisions(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionHypervisorTypeComparision']]:
        """
        `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
        """
        return pulumi.get(self, "hypervisor_type_comparisions")

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionHypervisor']]:
        """
        Comparison for `HYPERVISOR_TYPE` attributes
        """
        return pulumi.get(self, "hypervisors")

    @property
    @pulumi.getter(name="indexedNameComparisons")
    @_utilities.deprecated("""You should use 'indexed_name' instead of 'indexed_name_comparison'. This attribute still exists for backwards compatibility.""")
    def indexed_name_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedNameComparison']]:
        """
        Comparison for `INDEXED_NAME` attributes
        """
        return pulumi.get(self, "indexed_name_comparisons")

    @property
    @pulumi.getter(name="indexedNames")
    def indexed_names(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedName']]:
        """
        Comparison for `INDEXED_NAME` attributes
        """
        return pulumi.get(self, "indexed_names")

    @property
    @pulumi.getter(name="indexedStringComparisons")
    @_utilities.deprecated("""You should use 'indexed_string' instead of 'indexed_string_comparison'. This attribute still exists for backwards compatibility.""")
    def indexed_string_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedStringComparison']]:
        """
        Comparison for `INDEXED_STRING` attributes
        """
        return pulumi.get(self, "indexed_string_comparisons")

    @property
    @pulumi.getter(name="indexedStrings")
    def indexed_strings(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedString']]:
        """
        Comparison for `INDEXED_STRING` attributes
        """
        return pulumi.get(self, "indexed_strings")

    @property
    @pulumi.getter(name="indexedTagComparisons")
    @_utilities.deprecated("""You should use 'indexed_tag' instead of 'indexed_tag_comparison'. This attribute still exists for backwards compatibility.""")
    def indexed_tag_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedTagComparison']]:
        """
        Comparison for `INDEXED_TAG` attributes
        """
        return pulumi.get(self, "indexed_tag_comparisons")

    @property
    @pulumi.getter(name="indexedTags")
    def indexed_tags(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedTag']]:
        """
        Comparison for `INDEXED_TAG` attributes
        """
        return pulumi.get(self, "indexed_tags")

    @property
    @pulumi.getter(name="integerComparisons")
    @_utilities.deprecated("""You should use 'integer' instead of 'integer_comparison'. This attribute still exists for backwards compatibility.""")
    def integer_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIntegerComparison']]:
        """
        Comparison for `INTEGER` attributes
        """
        return pulumi.get(self, "integer_comparisons")

    @property
    @pulumi.getter
    def integers(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionInteger']]:
        """
        Comparison for `INTEGER` attributes
        """
        return pulumi.get(self, "integers")

    @property
    @pulumi.getter(name="ipaddressComparisons")
    @_utilities.deprecated("""You should use 'ipaddress' instead of 'ipaddress_comparison'. This attribute still exists for backwards compatibility.""")
    def ipaddress_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIpaddressComparison']]:
        """
        Comparison for `IP_ADDRESS` attributes
        """
        return pulumi.get(self, "ipaddress_comparisons")

    @property
    @pulumi.getter
    def ipaddresses(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIpaddress']]:
        """
        Comparison for `IP_ADDRESS` attributes
        """
        return pulumi.get(self, "ipaddresses")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionKey']]:
        """
        Fallback for not yet known type
        """
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter(name="mobilePlatformComparisons")
    @_utilities.deprecated("""You should use 'mobile_platform' instead of 'mobile_platform_comparison'. This attribute still exists for backwards compatibility.""")
    def mobile_platform_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionMobilePlatformComparison']]:
        """
        Comparison for `MOBILE_PLATFORM` attributes
        """
        return pulumi.get(self, "mobile_platform_comparisons")

    @property
    @pulumi.getter(name="mobilePlatforms")
    def mobile_platforms(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionMobilePlatform']]:
        """
        Comparison for `MOBILE_PLATFORM` attributes
        """
        return pulumi.get(self, "mobile_platforms")

    @property
    @pulumi.getter(name="osArches")
    def os_arches(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionOsArch']]:
        """
        Comparison for `OS_ARCHITECTURE` attributes
        """
        return pulumi.get(self, "os_arches")

    @property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionOsType']]:
        """
        Comparison for `OS_TYPE` attributes
        """
        return pulumi.get(self, "os_types")

    @property
    @pulumi.getter(name="osarchitectureComparisons")
    @_utilities.deprecated("""You should use 'os_arch' instead of 'osarchitecture_comparison'. This attribute still exists for backwards compatibility.""")
    def osarchitecture_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionOsarchitectureComparison']]:
        """
        Comparison for `OS_ARCHITECTURE` attributes
        """
        return pulumi.get(self, "osarchitecture_comparisons")

    @property
    @pulumi.getter(name="ostypeComparisons")
    @_utilities.deprecated("""You should use 'os_type' instead of 'ostype_comparison'. This attribute still exists for backwards compatibility.""")
    def ostype_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionOstypeComparison']]:
        """
        Comparison for `OS_TYPE` attributes
        """
        return pulumi.get(self, "ostype_comparisons")

    @property
    @pulumi.getter(name="paasTypeComparisons")
    @_utilities.deprecated("""You should use 'paas_type' instead of 'paas_type_comparison'. This attribute still exists for backwards compatibility.""")
    def paas_type_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionPaasTypeComparison']]:
        """
        Comparison for `PAAS_TYPE` attributes
        """
        return pulumi.get(self, "paas_type_comparisons")

    @property
    @pulumi.getter(name="paasTypes")
    def paas_types(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionPaasType']]:
        """
        Comparison for `PAAS_TYPE` attributes
        """
        return pulumi.get(self, "paas_types")

    @property
    @pulumi.getter(name="processMetadataConditionKeys")
    @_utilities.deprecated("""'process_metadata_condition_key' is deprecated. You should use 'process_metadata'""")
    def process_metadata_condition_keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionProcessMetadataConditionKey']]:
        """
        The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        """
        return pulumi.get(self, "process_metadata_condition_keys")

    @property
    @pulumi.getter(name="processMetadatas")
    def process_metadatas(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionProcessMetadata']]:
        """
        The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        """
        return pulumi.get(self, "process_metadatas")

    @property
    @pulumi.getter(name="serviceTopologies")
    def service_topologies(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionServiceTopology']]:
        """
        Comparison for `SERVICE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "service_topologies")

    @property
    @pulumi.getter(name="serviceTopologyComparisons")
    @_utilities.deprecated("""You should use 'service_topology' instead of 'service_topology_comparison'. This attribute still exists for backwards compatibility.""")
    def service_topology_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionServiceTopologyComparison']]:
        """
        Comparison for `SERVICE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "service_topology_comparisons")

    @property
    @pulumi.getter(name="serviceTypeComparisons")
    @_utilities.deprecated("""You should use 'service_type' instead of 'service_type_comparison'. This attribute still exists for backwards compatibility.""")
    def service_type_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionServiceTypeComparison']]:
        """
        Comparison for `SERVICE_TYPE` attributes
        """
        return pulumi.get(self, "service_type_comparisons")

    @property
    @pulumi.getter(name="serviceTypes")
    def service_types(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionServiceType']]:
        """
        Comparison for `SERVICE_TYPE` attributes
        """
        return pulumi.get(self, "service_types")

    @property
    @pulumi.getter(name="simpleHostTechComparisons")
    @_utilities.deprecated("""You should use 'host_tech' instead of 'simple_host_tech_comparison'. This attribute still exists for backwards compatibility.""")
    def simple_host_tech_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionSimpleHostTechComparison']]:
        """
        Comparison for `SIMPLE_HOST_TECH` attributes
        """
        return pulumi.get(self, "simple_host_tech_comparisons")

    @property
    @pulumi.getter(name="simpleTechComparisons")
    @_utilities.deprecated("""You should use 'tech' instead of 'simple_tech_comparison'. This attribute still exists for backwards compatibility.""")
    def simple_tech_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionSimpleTechComparison']]:
        """
        Comparison for `SIMPLE_TECH` attributes
        """
        return pulumi.get(self, "simple_tech_comparisons")

    @property
    @pulumi.getter(name="stringComparisons")
    @_utilities.deprecated("""You should use 'string' instead of 'string_comparison'. This attribute still exists for backwards compatibility.""")
    def string_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionStringComparison']]:
        """
        Comparison for `STRING` attributes
        """
        return pulumi.get(self, "string_comparisons")

    @property
    @pulumi.getter(name="stringConditionKeys")
    @_utilities.deprecated("""'string_condition_key' is deprecated. You should use 'string_key'""")
    def string_condition_keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionStringConditionKey']]:
        """
        The key for dynamic attributes of the `STRING` type
        """
        return pulumi.get(self, "string_condition_keys")

    @property
    @pulumi.getter(name="stringKeys")
    def string_keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionStringKey']]:
        """
        The key for dynamic attributes of the `STRING` type
        """
        return pulumi.get(self, "string_keys")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionString']]:
        """
        Comparison for `STRING` attributes
        """
        return pulumi.get(self, "strings")

    @property
    @pulumi.getter(name="syntheticEngineTypeComparisons")
    @_utilities.deprecated("""You should use 'synthetic_engine' instead of 'synthetic_engine_type_comparison'. This attribute still exists for backwards compatibility.""")
    def synthetic_engine_type_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionSyntheticEngineTypeComparison']]:
        """
        Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        """
        return pulumi.get(self, "synthetic_engine_type_comparisons")

    @property
    @pulumi.getter(name="syntheticEngines")
    def synthetic_engines(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionSyntheticEngine']]:
        """
        Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        """
        return pulumi.get(self, "synthetic_engines")

    @property
    @pulumi.getter(name="tagComparisons")
    @_utilities.deprecated("""You should use 'tag' instead of 'tag_comparison'. This attribute still exists for backwards compatibility.""")
    def tag_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionTagComparison']]:
        """
        Comparison for `TAG` attributes
        """
        return pulumi.get(self, "tag_comparisons")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionTag']]:
        """
        Comparison for `TAG` attributes
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def teches(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionTech']]:
        """
        Comparison for `SIMPLE_TECH` attributes
        """
        return pulumi.get(self, "teches")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be APPLICATION_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be APPLICATION_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionAzureComputeMode(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are DEDICATED or SHARED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are DEDICATED or SHARED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionAzureComputeModeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are DEDICATED or SHARED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are DEDICATED or SHARED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionAzureSkuComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be AZURE_SKU
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be AZURE_SKU
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionAzureSkus(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionBaseComparisonBasic(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str type: The type of comparison
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of comparison
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionBaseConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str type: Defines the actual set of fields depending on the value
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defines the actual set of fields depending on the value
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionBitness(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are 32 and 64.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are 32 and 64.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionBitnessComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be BITNESS
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are 32 and 64.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be BITNESS
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are 32 and 64.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionCloudType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionCloudTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be CLOUD_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be CLOUD_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionComparison(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str type: The type of comparison
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of comparison
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionCustomApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be CUSTOM_APPLICATION_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be CUSTOM_APPLICATION_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionCustomHostMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionCustomHostMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionCustomHostMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionCustomHostMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ManagementZoneRuleConditionCustomHostMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'ManagementZoneRuleConditionCustomHostMetadataDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ManagementZoneRuleConditionCustomHostMetadataDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomHostMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionCustomHostMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ManagementZoneRuleConditionCustomHostMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'ManagementZoneRuleConditionCustomHostMetadataConditionKeyDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str type: if specified, needs to be HOST_CUSTOM_METADATA_KEY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ManagementZoneRuleConditionCustomHostMetadataConditionKeyDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be HOST_CUSTOM_METADATA_KEY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomHostMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomHostMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionCustomProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionCustomProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionCustomProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ManagementZoneRuleConditionCustomProcessMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'ManagementZoneRuleConditionCustomProcessMetadataDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ManagementZoneRuleConditionCustomProcessMetadataDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionCustomProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ManagementZoneRuleConditionCustomProcessMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'ManagementZoneRuleConditionCustomProcessMetadataConditionKeyDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str type: if specified, needs to be PROCESS_CUSTOM_METADATA_KEY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ManagementZoneRuleConditionCustomProcessMetadataConditionKeyDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be PROCESS_CUSTOM_METADATA_KEY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomProcessMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomProcessMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionDatabaseTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionDatabaseTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be DATABASE_TOPOLOGY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be DATABASE_TOPOLOGY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionDcrumDecoder(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionDcrumDecoderComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be DCRUM_DECODER_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be DCRUM_DECODER_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionEntity(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionEntityIdComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be ENTITY_ID
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be ENTITY_ID
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionHostTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionHostTechValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'ManagementZoneRuleConditionHostTechValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionHostTechValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionHostTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionHostTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionHostTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionHostTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ManagementZoneRuleConditionHypervisor(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionHypervisorTypeComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be HYPERVISOR_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be HYPERVISOR_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedName(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedNameComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be INDEXED_NAME
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INDEXED_NAME
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedString(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedStringComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be INDEXED_STRING
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INDEXED_STRING
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionIndexedTagValue'] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param 'ManagementZoneRuleConditionIndexedTagValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionIndexedTagValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionIndexedTagComparisonValue'] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be INDEXED_TAG
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param 'ManagementZoneRuleConditionIndexedTagComparisonValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INDEXED_TAG
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionIndexedTagComparisonValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionInteger(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param int value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIntegerComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be INTEGER
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param int value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INTEGER
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIpaddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionIpaddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionIpaddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionIpaddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIpaddressComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionIpaddressComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionIpaddressComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionIpaddressComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be IP_ADDRESS
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be IP_ADDRESS
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str type: Defines the actual set of fields depending on the value
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defines the actual set of fields depending on the value
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionMobilePlatform(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionMobilePlatformComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be MOBILE_PLATFORM
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be MOBILE_PLATFORM
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionOsArch(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionOsType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionOsarchitectureComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be OS_ARCHITECTURE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be OS_ARCHITECTURE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionOstypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be OS_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be OS_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionPaasType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionPaasTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be PAAS_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be PAAS_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        :param str type: if specified, needs to be PROCESS_PREDEFINED_METADATA_KEY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be PROCESS_PREDEFINED_METADATA_KEY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionServiceTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionServiceTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SERVICE_TOPOLOGY
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SERVICE_TOPOLOGY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionServiceType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionServiceTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SERVICE_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SERVICE_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionSimpleHostTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionSimpleHostTechComparisonValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SIMPLE_HOST_TECH
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'ManagementZoneRuleConditionSimpleHostTechComparisonValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SIMPLE_HOST_TECH
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionSimpleHostTechComparisonValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionSimpleHostTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionSimpleHostTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ManagementZoneRuleConditionSimpleTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionSimpleTechComparisonValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SIMPLE_TECH
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'ManagementZoneRuleConditionSimpleTechComparisonValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SIMPLE_TECH
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionSimpleTechComparisonValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionSimpleTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionSimpleTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionSimpleTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionSimpleTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ManagementZoneRuleConditionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionStringComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionStringComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionStringComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionStringComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be STRING
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be STRING
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionStringConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionStringConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionStringConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionStringConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
                  - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
                  - `AMAZON_ECR_IMAGE_REGION`
                  - `AMAZON_LAMBDA_FUNCTION_NAME`
                  - `AMAZON_REGION`
                  - `APACHE_CONFIG_PATH`
                  - `APACHE_SPARK_MASTER_IP_ADDRESS`
                  - `ASP_DOT_NET_CORE_APPLICATION_PATH`
                  - `AWS_ECS_CLUSTER`
                  - `AWS_ECS_CONTAINERNAME`
                  - `AWS_ECS_FAMILY`
                  - `AWS_ECS_REVISION`
                  - `CASSANDRA_CLUSTER_NAME`
                  - `CATALINA_BASE`
                  - `CATALINA_HOME`
                  - `CLOUD_FOUNDRY_APP_ID`
                  - `CLOUD_FOUNDRY_APP_NAME`
                  - `CLOUD_FOUNDRY_INSTANCE_INDEX`
                  - `CLOUD_FOUNDRY_SPACE_ID`
                  - `CLOUD_FOUNDRY_SPACE_NAME`
                  - `COLDFUSION_JVM_CONFIG_FILE`
                  - `COLDFUSION_SERVICE_NAME`
                  - `COMMAND_LINE_ARGS`
                  - `DOTNET_COMMAND`
                  - `DOTNET_COMMAND_PATH`
                  - `DYNATRACE_CLUSTER_ID`
                  - `DYNATRACE_NODE_ID`
                  - `ELASTICSEARCH_CLUSTER_NAME`
                  - `ELASTICSEARCH_NODE_NAME`
                  - `EQUINOX_CONFIG_PATH`
                  - `EXE_NAME`
                  - `EXE_PATH`
                  - `GLASS_FISH_DOMAIN_NAME`
                  - `GLASS_FISH_INSTANCE_NAME`
                  - `GOOGLE_APP_ENGINE_INSTANCE`
                  - `GOOGLE_APP_ENGINE_SERVICE`
                  - `GOOGLE_CLOUD_PROJECT`
                  - `HYBRIS_BIN_DIRECTORY`
                  - `HYBRIS_CONFIG_DIRECTORY`
                  - `HYBRIS_DATA_DIRECTORY`
                  - `IBM_CICS_REGION`
                  - `IBM_CTG_NAME`
                  - `IBM_IMS_CONNECT_REGION`
                  - `IBM_IMS_CONTROL_REGION`
                  - `IBM_IMS_MESSAGE_PROCESSING_REGION`
                  - `IBM_IMS_SOAP_GW_NAME`
                  - `IBM_INTEGRATION_NODE_NAME`
                  - `IBM_INTEGRATION_SERVER_NAME`
                  - `IIS_APP_POOL`
                  - `IIS_ROLE_NAME`
                  - `JAVA_JAR_FILE`
                  - `JAVA_JAR_PATH`
                  - `JAVA_MAIN_CLASS`
                  - `JAVA_MAIN_MODULE`
                  - `JBOSS_HOME`
                  - `JBOSS_MODE`
                  - `JBOSS_SERVER_NAME`
                  - `KUBERNETES_BASE_POD_NAME`
                  - `KUBERNETES_CONTAINER_NAME`
                  - `KUBERNETES_FULL_POD_NAME`
                  - `KUBERNETES_NAMESPACE`
                  - `KUBERNETES_POD_UID`
                  - `MSSQL_INSTANCE_NAME`
                  - `NODE_JS_APP_BASE_DIRECTORY`
                  - `NODE_JS_APP_NAME`
                  - `NODE_JS_SCRIPT_NAME`
                  - `ORACLE_SID`
                  - `PG_ID_CALC_INPUT_KEY_LINKAGE`
                  - `PHP_SCRIPT_PATH`
                  - `PHP_WORKING_DIRECTORY`
                  - `RUBY_APP_ROOT_PATH`
                  - `RUBY_SCRIPT_PATH`
                  - `RULE_RESULT`
                  - `SOFTWAREAG_INSTALL_ROOT`
                  - `SOFTWAREAG_PRODUCTPROPNAME`
                  - `SPRINGBOOT_APP_NAME`
                  - `SPRINGBOOT_PROFILE_NAME`
                  - `SPRINGBOOT_STARTUP_CLASS`
                  - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
                  - `TIBCO_BUSINESSWORKS_CE_VERSION`
                  - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
                  - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
                  - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
                  - `TIBCO_BUSINESS_WORKS_HOME`
                  - `VARNISH_INSTANCE_NAME`
                  - `WEB_LOGIC_CLUSTER_NAME`
                  - `WEB_LOGIC_DOMAIN_NAME`
                  - `WEB_LOGIC_HOME`
                  - `WEB_LOGIC_NAME`
                  - `WEB_SPHERE_CELL_NAME`
                  - `WEB_SPHERE_CLUSTER_NAME`
                  - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        :param str type: if specified, needs to be `STRING`
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
           - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
           - `AMAZON_ECR_IMAGE_REGION`
           - `AMAZON_LAMBDA_FUNCTION_NAME`
           - `AMAZON_REGION`
           - `APACHE_CONFIG_PATH`
           - `APACHE_SPARK_MASTER_IP_ADDRESS`
           - `ASP_DOT_NET_CORE_APPLICATION_PATH`
           - `AWS_ECS_CLUSTER`
           - `AWS_ECS_CONTAINERNAME`
           - `AWS_ECS_FAMILY`
           - `AWS_ECS_REVISION`
           - `CASSANDRA_CLUSTER_NAME`
           - `CATALINA_BASE`
           - `CATALINA_HOME`
           - `CLOUD_FOUNDRY_APP_ID`
           - `CLOUD_FOUNDRY_APP_NAME`
           - `CLOUD_FOUNDRY_INSTANCE_INDEX`
           - `CLOUD_FOUNDRY_SPACE_ID`
           - `CLOUD_FOUNDRY_SPACE_NAME`
           - `COLDFUSION_JVM_CONFIG_FILE`
           - `COLDFUSION_SERVICE_NAME`
           - `COMMAND_LINE_ARGS`
           - `DOTNET_COMMAND`
           - `DOTNET_COMMAND_PATH`
           - `DYNATRACE_CLUSTER_ID`
           - `DYNATRACE_NODE_ID`
           - `ELASTICSEARCH_CLUSTER_NAME`
           - `ELASTICSEARCH_NODE_NAME`
           - `EQUINOX_CONFIG_PATH`
           - `EXE_NAME`
           - `EXE_PATH`
           - `GLASS_FISH_DOMAIN_NAME`
           - `GLASS_FISH_INSTANCE_NAME`
           - `GOOGLE_APP_ENGINE_INSTANCE`
           - `GOOGLE_APP_ENGINE_SERVICE`
           - `GOOGLE_CLOUD_PROJECT`
           - `HYBRIS_BIN_DIRECTORY`
           - `HYBRIS_CONFIG_DIRECTORY`
           - `HYBRIS_DATA_DIRECTORY`
           - `IBM_CICS_REGION`
           - `IBM_CTG_NAME`
           - `IBM_IMS_CONNECT_REGION`
           - `IBM_IMS_CONTROL_REGION`
           - `IBM_IMS_MESSAGE_PROCESSING_REGION`
           - `IBM_IMS_SOAP_GW_NAME`
           - `IBM_INTEGRATION_NODE_NAME`
           - `IBM_INTEGRATION_SERVER_NAME`
           - `IIS_APP_POOL`
           - `IIS_ROLE_NAME`
           - `JAVA_JAR_FILE`
           - `JAVA_JAR_PATH`
           - `JAVA_MAIN_CLASS`
           - `JAVA_MAIN_MODULE`
           - `JBOSS_HOME`
           - `JBOSS_MODE`
           - `JBOSS_SERVER_NAME`
           - `KUBERNETES_BASE_POD_NAME`
           - `KUBERNETES_CONTAINER_NAME`
           - `KUBERNETES_FULL_POD_NAME`
           - `KUBERNETES_NAMESPACE`
           - `KUBERNETES_POD_UID`
           - `MSSQL_INSTANCE_NAME`
           - `NODE_JS_APP_BASE_DIRECTORY`
           - `NODE_JS_APP_NAME`
           - `NODE_JS_SCRIPT_NAME`
           - `ORACLE_SID`
           - `PG_ID_CALC_INPUT_KEY_LINKAGE`
           - `PHP_SCRIPT_PATH`
           - `PHP_WORKING_DIRECTORY`
           - `RUBY_APP_ROOT_PATH`
           - `RUBY_SCRIPT_PATH`
           - `RULE_RESULT`
           - `SOFTWAREAG_INSTALL_ROOT`
           - `SOFTWAREAG_PRODUCTPROPNAME`
           - `SPRINGBOOT_APP_NAME`
           - `SPRINGBOOT_PROFILE_NAME`
           - `SPRINGBOOT_STARTUP_CLASS`
           - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
           - `TIBCO_BUSINESSWORKS_CE_VERSION`
           - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
           - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
           - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
           - `TIBCO_BUSINESS_WORKS_HOME`
           - `VARNISH_INSTANCE_NAME`
           - `WEB_LOGIC_CLUSTER_NAME`
           - `WEB_LOGIC_DOMAIN_NAME`
           - `WEB_LOGIC_HOME`
           - `WEB_LOGIC_NAME`
           - `WEB_SPHERE_CELL_NAME`
           - `WEB_SPHERE_CLUSTER_NAME`
           - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be `STRING`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionStringKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionStringKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionStringKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionStringKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
                  - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
                  - `AMAZON_ECR_IMAGE_REGION`
                  - `AMAZON_LAMBDA_FUNCTION_NAME`
                  - `AMAZON_REGION`
                  - `APACHE_CONFIG_PATH`
                  - `APACHE_SPARK_MASTER_IP_ADDRESS`
                  - `ASP_DOT_NET_CORE_APPLICATION_PATH`
                  - `AWS_ECS_CLUSTER`
                  - `AWS_ECS_CONTAINERNAME`
                  - `AWS_ECS_FAMILY`
                  - `AWS_ECS_REVISION`
                  - `CASSANDRA_CLUSTER_NAME`
                  - `CATALINA_BASE`
                  - `CATALINA_HOME`
                  - `CLOUD_FOUNDRY_APP_ID`
                  - `CLOUD_FOUNDRY_APP_NAME`
                  - `CLOUD_FOUNDRY_INSTANCE_INDEX`
                  - `CLOUD_FOUNDRY_SPACE_ID`
                  - `CLOUD_FOUNDRY_SPACE_NAME`
                  - `COLDFUSION_JVM_CONFIG_FILE`
                  - `COLDFUSION_SERVICE_NAME`
                  - `COMMAND_LINE_ARGS`
                  - `DOTNET_COMMAND`
                  - `DOTNET_COMMAND_PATH`
                  - `DYNATRACE_CLUSTER_ID`
                  - `DYNATRACE_NODE_ID`
                  - `ELASTICSEARCH_CLUSTER_NAME`
                  - `ELASTICSEARCH_NODE_NAME`
                  - `EQUINOX_CONFIG_PATH`
                  - `EXE_NAME`
                  - `EXE_PATH`
                  - `GLASS_FISH_DOMAIN_NAME`
                  - `GLASS_FISH_INSTANCE_NAME`
                  - `GOOGLE_APP_ENGINE_INSTANCE`
                  - `GOOGLE_APP_ENGINE_SERVICE`
                  - `GOOGLE_CLOUD_PROJECT`
                  - `HYBRIS_BIN_DIRECTORY`
                  - `HYBRIS_CONFIG_DIRECTORY`
                  - `HYBRIS_DATA_DIRECTORY`
                  - `IBM_CICS_REGION`
                  - `IBM_CTG_NAME`
                  - `IBM_IMS_CONNECT_REGION`
                  - `IBM_IMS_CONTROL_REGION`
                  - `IBM_IMS_MESSAGE_PROCESSING_REGION`
                  - `IBM_IMS_SOAP_GW_NAME`
                  - `IBM_INTEGRATION_NODE_NAME`
                  - `IBM_INTEGRATION_SERVER_NAME`
                  - `IIS_APP_POOL`
                  - `IIS_ROLE_NAME`
                  - `JAVA_JAR_FILE`
                  - `JAVA_JAR_PATH`
                  - `JAVA_MAIN_CLASS`
                  - `JAVA_MAIN_MODULE`
                  - `JBOSS_HOME`
                  - `JBOSS_MODE`
                  - `JBOSS_SERVER_NAME`
                  - `KUBERNETES_BASE_POD_NAME`
                  - `KUBERNETES_CONTAINER_NAME`
                  - `KUBERNETES_FULL_POD_NAME`
                  - `KUBERNETES_NAMESPACE`
                  - `KUBERNETES_POD_UID`
                  - `MSSQL_INSTANCE_NAME`
                  - `NODE_JS_APP_BASE_DIRECTORY`
                  - `NODE_JS_APP_NAME`
                  - `NODE_JS_SCRIPT_NAME`
                  - `ORACLE_SID`
                  - `PG_ID_CALC_INPUT_KEY_LINKAGE`
                  - `PHP_SCRIPT_PATH`
                  - `PHP_WORKING_DIRECTORY`
                  - `RUBY_APP_ROOT_PATH`
                  - `RUBY_SCRIPT_PATH`
                  - `RULE_RESULT`
                  - `SOFTWAREAG_INSTALL_ROOT`
                  - `SOFTWAREAG_PRODUCTPROPNAME`
                  - `SPRINGBOOT_APP_NAME`
                  - `SPRINGBOOT_PROFILE_NAME`
                  - `SPRINGBOOT_STARTUP_CLASS`
                  - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
                  - `TIBCO_BUSINESSWORKS_CE_VERSION`
                  - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
                  - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
                  - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
                  - `TIBCO_BUSINESS_WORKS_HOME`
                  - `VARNISH_INSTANCE_NAME`
                  - `WEB_LOGIC_CLUSTER_NAME`
                  - `WEB_LOGIC_DOMAIN_NAME`
                  - `WEB_LOGIC_HOME`
                  - `WEB_LOGIC_NAME`
                  - `WEB_SPHERE_CELL_NAME`
                  - `WEB_SPHERE_CLUSTER_NAME`
                  - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
           - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
           - `AMAZON_ECR_IMAGE_REGION`
           - `AMAZON_LAMBDA_FUNCTION_NAME`
           - `AMAZON_REGION`
           - `APACHE_CONFIG_PATH`
           - `APACHE_SPARK_MASTER_IP_ADDRESS`
           - `ASP_DOT_NET_CORE_APPLICATION_PATH`
           - `AWS_ECS_CLUSTER`
           - `AWS_ECS_CONTAINERNAME`
           - `AWS_ECS_FAMILY`
           - `AWS_ECS_REVISION`
           - `CASSANDRA_CLUSTER_NAME`
           - `CATALINA_BASE`
           - `CATALINA_HOME`
           - `CLOUD_FOUNDRY_APP_ID`
           - `CLOUD_FOUNDRY_APP_NAME`
           - `CLOUD_FOUNDRY_INSTANCE_INDEX`
           - `CLOUD_FOUNDRY_SPACE_ID`
           - `CLOUD_FOUNDRY_SPACE_NAME`
           - `COLDFUSION_JVM_CONFIG_FILE`
           - `COLDFUSION_SERVICE_NAME`
           - `COMMAND_LINE_ARGS`
           - `DOTNET_COMMAND`
           - `DOTNET_COMMAND_PATH`
           - `DYNATRACE_CLUSTER_ID`
           - `DYNATRACE_NODE_ID`
           - `ELASTICSEARCH_CLUSTER_NAME`
           - `ELASTICSEARCH_NODE_NAME`
           - `EQUINOX_CONFIG_PATH`
           - `EXE_NAME`
           - `EXE_PATH`
           - `GLASS_FISH_DOMAIN_NAME`
           - `GLASS_FISH_INSTANCE_NAME`
           - `GOOGLE_APP_ENGINE_INSTANCE`
           - `GOOGLE_APP_ENGINE_SERVICE`
           - `GOOGLE_CLOUD_PROJECT`
           - `HYBRIS_BIN_DIRECTORY`
           - `HYBRIS_CONFIG_DIRECTORY`
           - `HYBRIS_DATA_DIRECTORY`
           - `IBM_CICS_REGION`
           - `IBM_CTG_NAME`
           - `IBM_IMS_CONNECT_REGION`
           - `IBM_IMS_CONTROL_REGION`
           - `IBM_IMS_MESSAGE_PROCESSING_REGION`
           - `IBM_IMS_SOAP_GW_NAME`
           - `IBM_INTEGRATION_NODE_NAME`
           - `IBM_INTEGRATION_SERVER_NAME`
           - `IIS_APP_POOL`
           - `IIS_ROLE_NAME`
           - `JAVA_JAR_FILE`
           - `JAVA_JAR_PATH`
           - `JAVA_MAIN_CLASS`
           - `JAVA_MAIN_MODULE`
           - `JBOSS_HOME`
           - `JBOSS_MODE`
           - `JBOSS_SERVER_NAME`
           - `KUBERNETES_BASE_POD_NAME`
           - `KUBERNETES_CONTAINER_NAME`
           - `KUBERNETES_FULL_POD_NAME`
           - `KUBERNETES_NAMESPACE`
           - `KUBERNETES_POD_UID`
           - `MSSQL_INSTANCE_NAME`
           - `NODE_JS_APP_BASE_DIRECTORY`
           - `NODE_JS_APP_NAME`
           - `NODE_JS_SCRIPT_NAME`
           - `ORACLE_SID`
           - `PG_ID_CALC_INPUT_KEY_LINKAGE`
           - `PHP_SCRIPT_PATH`
           - `PHP_WORKING_DIRECTORY`
           - `RUBY_APP_ROOT_PATH`
           - `RUBY_SCRIPT_PATH`
           - `RULE_RESULT`
           - `SOFTWAREAG_INSTALL_ROOT`
           - `SOFTWAREAG_PRODUCTPROPNAME`
           - `SPRINGBOOT_APP_NAME`
           - `SPRINGBOOT_PROFILE_NAME`
           - `SPRINGBOOT_STARTUP_CLASS`
           - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
           - `TIBCO_BUSINESSWORKS_CE_VERSION`
           - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
           - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
           - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
           - `TIBCO_BUSINESS_WORKS_HOME`
           - `VARNISH_INSTANCE_NAME`
           - `WEB_LOGIC_CLUSTER_NAME`
           - `WEB_LOGIC_DOMAIN_NAME`
           - `WEB_LOGIC_HOME`
           - `WEB_LOGIC_NAME`
           - `WEB_SPHERE_CELL_NAME`
           - `WEB_SPHERE_CLUSTER_NAME`
           - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionSyntheticEngine(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionSyntheticEngineTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SYNTHETIC_ENGINE_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SYNTHETIC_ENGINE_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionTagValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'ManagementZoneRuleConditionTagValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionTagValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionTagComparisonValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be TAG
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'ManagementZoneRuleConditionTagComparisonValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be TAG
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionTagComparisonValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionTechValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'ManagementZoneRuleConditionTechValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionTechValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ManagementZoneV2Rules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.ManagementZoneV2RulesRule']):
        """
        :param Sequence['ManagementZoneV2RulesRuleArgs'] rules: A management zone rule
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.ManagementZoneV2RulesRule']:
        """
        A management zone rule
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ManagementZoneV2RulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeRule":
            suggest = "attribute_rule"
        elif key == "dimensionRule":
            suggest = "dimension_rule"
        elif key == "entitySelector":
            suggest = "entity_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneV2RulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneV2RulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneV2RulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 type: str,
                 attribute_rule: Optional['outputs.ManagementZoneV2RulesRuleAttributeRule'] = None,
                 dimension_rule: Optional['outputs.ManagementZoneV2RulesRuleDimensionRule'] = None,
                 entity_selector: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param str type: Possible Values: `DIMENSION`, `ME`, `SELECTOR`
        :param 'ManagementZoneV2RulesRuleAttributeRuleArgs' attribute_rule: no documentation available
        :param 'ManagementZoneV2RulesRuleDimensionRuleArgs' dimension_rule: no documentation available
        :param str entity_selector: The documentation of the entity selector can be found [here](https://dt-url.net/apientityselector).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "type", type)
        if attribute_rule is not None:
            pulumi.set(__self__, "attribute_rule", attribute_rule)
        if dimension_rule is not None:
            pulumi.set(__self__, "dimension_rule", dimension_rule)
        if entity_selector is not None:
            pulumi.set(__self__, "entity_selector", entity_selector)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `DIMENSION`, `ME`, `SELECTOR`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="attributeRule")
    def attribute_rule(self) -> Optional['outputs.ManagementZoneV2RulesRuleAttributeRule']:
        """
        no documentation available
        """
        return pulumi.get(self, "attribute_rule")

    @property
    @pulumi.getter(name="dimensionRule")
    def dimension_rule(self) -> Optional['outputs.ManagementZoneV2RulesRuleDimensionRule']:
        """
        no documentation available
        """
        return pulumi.get(self, "dimension_rule")

    @property
    @pulumi.getter(name="entitySelector")
    def entity_selector(self) -> Optional[str]:
        """
        The documentation of the entity selector can be found [here](https://dt-url.net/apientityselector).
        """
        return pulumi.get(self, "entity_selector")


@pulumi.output_type
class ManagementZoneV2RulesRuleAttributeRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeConditions":
            suggest = "attribute_conditions"
        elif key == "entityType":
            suggest = "entity_type"
        elif key == "azureToPgpropagation":
            suggest = "azure_to_pgpropagation"
        elif key == "azureToServicePropagation":
            suggest = "azure_to_service_propagation"
        elif key == "customDeviceGroupToCustomDevicePropagation":
            suggest = "custom_device_group_to_custom_device_propagation"
        elif key == "hostToPgpropagation":
            suggest = "host_to_pgpropagation"
        elif key == "pgToHostPropagation":
            suggest = "pg_to_host_propagation"
        elif key == "pgToServicePropagation":
            suggest = "pg_to_service_propagation"
        elif key == "serviceToHostPropagation":
            suggest = "service_to_host_propagation"
        elif key == "serviceToPgpropagation":
            suggest = "service_to_pgpropagation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneV2RulesRuleAttributeRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneV2RulesRuleAttributeRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneV2RulesRuleAttributeRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_conditions: 'outputs.ManagementZoneV2RulesRuleAttributeRuleAttributeConditions',
                 entity_type: str,
                 azure_to_pgpropagation: Optional[bool] = None,
                 azure_to_service_propagation: Optional[bool] = None,
                 custom_device_group_to_custom_device_propagation: Optional[bool] = None,
                 host_to_pgpropagation: Optional[bool] = None,
                 pg_to_host_propagation: Optional[bool] = None,
                 pg_to_service_propagation: Optional[bool] = None,
                 service_to_host_propagation: Optional[bool] = None,
                 service_to_pgpropagation: Optional[bool] = None):
        """
        :param 'ManagementZoneV2RulesRuleAttributeRuleAttributeConditionsArgs' attribute_conditions: no documentation available
        :param str entity_type: Possible Values: `APPMON_SERVER`, `APPMON_SYSTEM_PROFILE`, `AWS_ACCOUNT`, `AWS_APPLICATION_LOAD_BALANCER`, `AWS_AUTO_SCALING_GROUP`, `AWS_CLASSIC_LOAD_BALANCER`, `AWS_NETWORK_LOAD_BALANCER`, `AWS_RELATIONAL_DATABASE_SERVICE`, `AZURE`, `BROWSER_MONITOR`, `CLOUD_APPLICATION`, `CLOUD_APPLICATION_NAMESPACE`, `CLOUD_FOUNDRY_FOUNDATION`, `CUSTOM_APPLICATION`, `CUSTOM_DEVICE`, `CUSTOM_DEVICE_GROUP`, `DATA_CENTER_SERVICE`, `ENTERPRISE_APPLICATION`, `ESXI_HOST`, `EXTERNAL_MONITOR`, `HOST`, `HOST_GROUP`, `HTTP_MONITOR`, `KUBERNETES_CLUSTER`, `KUBERNETES_SERVICE`, `MOBILE_APPLICATION`, `OPENSTACK_ACCOUNT`, `PROCESS_GROUP`, `QUEUE`, `SERVICE`, `WEB_APPLICATION`
        :param bool azure_to_pgpropagation: Apply to process groups connected to matching Azure entities
        :param bool azure_to_service_propagation: Apply to services provided by matching Azure entities
        :param bool custom_device_group_to_custom_device_propagation: Apply to custom devices in a custom device group
        :param bool host_to_pgpropagation: Apply to processes running on matching hosts. `entity_type` must be set to `HOST`
        :param bool pg_to_host_propagation: Apply to underlying hosts of matching process groups. `entity_type` must be set to `PROCESS_GROUP`
        :param bool pg_to_service_propagation: Apply to all services provided by the process groups. `entity_type` must be set to `PROCESS_GROUP`
        :param bool service_to_host_propagation: Apply to underlying hosts of matching services. `entity_type` must be set to `SERVICE`
        :param bool service_to_pgpropagation: Apply to underlying process groups of matching services. `entity_type` must be set to `SERVICE`
        """
        pulumi.set(__self__, "attribute_conditions", attribute_conditions)
        pulumi.set(__self__, "entity_type", entity_type)
        if azure_to_pgpropagation is not None:
            pulumi.set(__self__, "azure_to_pgpropagation", azure_to_pgpropagation)
        if azure_to_service_propagation is not None:
            pulumi.set(__self__, "azure_to_service_propagation", azure_to_service_propagation)
        if custom_device_group_to_custom_device_propagation is not None:
            pulumi.set(__self__, "custom_device_group_to_custom_device_propagation", custom_device_group_to_custom_device_propagation)
        if host_to_pgpropagation is not None:
            pulumi.set(__self__, "host_to_pgpropagation", host_to_pgpropagation)
        if pg_to_host_propagation is not None:
            pulumi.set(__self__, "pg_to_host_propagation", pg_to_host_propagation)
        if pg_to_service_propagation is not None:
            pulumi.set(__self__, "pg_to_service_propagation", pg_to_service_propagation)
        if service_to_host_propagation is not None:
            pulumi.set(__self__, "service_to_host_propagation", service_to_host_propagation)
        if service_to_pgpropagation is not None:
            pulumi.set(__self__, "service_to_pgpropagation", service_to_pgpropagation)

    @property
    @pulumi.getter(name="attributeConditions")
    def attribute_conditions(self) -> 'outputs.ManagementZoneV2RulesRuleAttributeRuleAttributeConditions':
        """
        no documentation available
        """
        return pulumi.get(self, "attribute_conditions")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Possible Values: `APPMON_SERVER`, `APPMON_SYSTEM_PROFILE`, `AWS_ACCOUNT`, `AWS_APPLICATION_LOAD_BALANCER`, `AWS_AUTO_SCALING_GROUP`, `AWS_CLASSIC_LOAD_BALANCER`, `AWS_NETWORK_LOAD_BALANCER`, `AWS_RELATIONAL_DATABASE_SERVICE`, `AZURE`, `BROWSER_MONITOR`, `CLOUD_APPLICATION`, `CLOUD_APPLICATION_NAMESPACE`, `CLOUD_FOUNDRY_FOUNDATION`, `CUSTOM_APPLICATION`, `CUSTOM_DEVICE`, `CUSTOM_DEVICE_GROUP`, `DATA_CENTER_SERVICE`, `ENTERPRISE_APPLICATION`, `ESXI_HOST`, `EXTERNAL_MONITOR`, `HOST`, `HOST_GROUP`, `HTTP_MONITOR`, `KUBERNETES_CLUSTER`, `KUBERNETES_SERVICE`, `MOBILE_APPLICATION`, `OPENSTACK_ACCOUNT`, `PROCESS_GROUP`, `QUEUE`, `SERVICE`, `WEB_APPLICATION`
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="azureToPgpropagation")
    def azure_to_pgpropagation(self) -> Optional[bool]:
        """
        Apply to process groups connected to matching Azure entities
        """
        return pulumi.get(self, "azure_to_pgpropagation")

    @property
    @pulumi.getter(name="azureToServicePropagation")
    def azure_to_service_propagation(self) -> Optional[bool]:
        """
        Apply to services provided by matching Azure entities
        """
        return pulumi.get(self, "azure_to_service_propagation")

    @property
    @pulumi.getter(name="customDeviceGroupToCustomDevicePropagation")
    def custom_device_group_to_custom_device_propagation(self) -> Optional[bool]:
        """
        Apply to custom devices in a custom device group
        """
        return pulumi.get(self, "custom_device_group_to_custom_device_propagation")

    @property
    @pulumi.getter(name="hostToPgpropagation")
    def host_to_pgpropagation(self) -> Optional[bool]:
        """
        Apply to processes running on matching hosts. `entity_type` must be set to `HOST`
        """
        return pulumi.get(self, "host_to_pgpropagation")

    @property
    @pulumi.getter(name="pgToHostPropagation")
    def pg_to_host_propagation(self) -> Optional[bool]:
        """
        Apply to underlying hosts of matching process groups. `entity_type` must be set to `PROCESS_GROUP`
        """
        return pulumi.get(self, "pg_to_host_propagation")

    @property
    @pulumi.getter(name="pgToServicePropagation")
    def pg_to_service_propagation(self) -> Optional[bool]:
        """
        Apply to all services provided by the process groups. `entity_type` must be set to `PROCESS_GROUP`
        """
        return pulumi.get(self, "pg_to_service_propagation")

    @property
    @pulumi.getter(name="serviceToHostPropagation")
    def service_to_host_propagation(self) -> Optional[bool]:
        """
        Apply to underlying hosts of matching services. `entity_type` must be set to `SERVICE`
        """
        return pulumi.get(self, "service_to_host_propagation")

    @property
    @pulumi.getter(name="serviceToPgpropagation")
    def service_to_pgpropagation(self) -> Optional[bool]:
        """
        Apply to underlying process groups of matching services. `entity_type` must be set to `SERVICE`
        """
        return pulumi.get(self, "service_to_pgpropagation")


@pulumi.output_type
class ManagementZoneV2RulesRuleAttributeRuleAttributeConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.ManagementZoneV2RulesRuleAttributeRuleAttributeConditionsCondition']):
        """
        :param Sequence['ManagementZoneV2RulesRuleAttributeRuleAttributeConditionsConditionArgs'] conditions: Attribute conditions
        """
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.ManagementZoneV2RulesRuleAttributeRuleAttributeConditionsCondition']:
        """
        Attribute conditions
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ManagementZoneV2RulesRuleAttributeRuleAttributeConditionsCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "dynamicKey":
            suggest = "dynamic_key"
        elif key == "dynamicKeySource":
            suggest = "dynamic_key_source"
        elif key == "entityId":
            suggest = "entity_id"
        elif key == "enumValue":
            suggest = "enum_value"
        elif key == "integerValue":
            suggest = "integer_value"
        elif key == "stringValue":
            suggest = "string_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneV2RulesRuleAttributeRuleAttributeConditionsCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneV2RulesRuleAttributeRuleAttributeConditionsCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneV2RulesRuleAttributeRuleAttributeConditionsCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 dynamic_key: Optional[str] = None,
                 dynamic_key_source: Optional[str] = None,
                 entity_id: Optional[str] = None,
                 enum_value: Optional[str] = None,
                 integer_value: Optional[int] = None,
                 string_value: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        :param str key: Possible Values: `APPMON_SERVER_NAME`, `APPMON_SYSTEM_PROFILE_NAME`, `AWS_ACCOUNT_ID`, `AWS_ACCOUNT_NAME`, `AWS_APPLICATION_LOAD_BALANCER_NAME`, `AWS_APPLICATION_LOAD_BALANCER_TAGS`, `AWS_AUTO_SCALING_GROUP_NAME`, `AWS_AUTO_SCALING_GROUP_TAGS`, `AWS_AVAILABILITY_ZONE_NAME`, `AWS_CLASSIC_LOAD_BALANCER_FRONTEND_PORTS`, `AWS_CLASSIC_LOAD_BALANCER_NAME`, `AWS_CLASSIC_LOAD_BALANCER_TAGS`, `AWS_NETWORK_LOAD_BALANCER_NAME`, `AWS_NETWORK_LOAD_BALANCER_TAGS`, `AWS_RELATIONAL_DATABASE_SERVICE_DB_NAME`, `AWS_RELATIONAL_DATABASE_SERVICE_ENDPOINT`, `AWS_RELATIONAL_DATABASE_SERVICE_ENGINE`, `AWS_RELATIONAL_DATABASE_SERVICE_INSTANCE_CLASS`, `AWS_RELATIONAL_DATABASE_SERVICE_NAME`, `AWS_RELATIONAL_DATABASE_SERVICE_PORT`, `AWS_RELATIONAL_DATABASE_SERVICE_TAGS`, `AZURE_ENTITY_NAME`, `AZURE_ENTITY_TAGS`, `AZURE_MGMT_GROUP_NAME`, `AZURE_MGMT_GROUP_UUID`, `AZURE_REGION_NAME`, `AZURE_SCALE_SET_NAME`, `AZURE_SUBSCRIPTION_NAME`, `AZURE_SUBSCRIPTION_UUID`, `AZURE_TENANT_NAME`, `AZURE_TENANT_UUID`, `AZURE_VM_NAME`, `BROWSER_MONITOR_NAME`, `BROWSER_MONITOR_TAGS`, `CLOUD_APPLICATION_LABELS`, `CLOUD_APPLICATION_NAME`, `CLOUD_APPLICATION_NAMESPACE_LABELS`, `CLOUD_APPLICATION_NAMESPACE_NAME`, `CLOUD_FOUNDRY_FOUNDATION_NAME`, `CLOUD_FOUNDRY_ORG_NAME`, `CUSTOM_APPLICATION_NAME`, `CUSTOM_APPLICATION_PLATFORM`, `CUSTOM_APPLICATION_TAGS`, `CUSTOM_APPLICATION_TYPE`, `CUSTOM_DEVICE_DNS_ADDRESS`, `CUSTOM_DEVICE_GROUP_NAME`, `CUSTOM_DEVICE_GROUP_TAGS`, `CUSTOM_DEVICE_IP_ADDRESS`, `CUSTOM_DEVICE_METADATA`, `CUSTOM_DEVICE_NAME`, `CUSTOM_DEVICE_PORT`, `CUSTOM_DEVICE_TAGS`, `CUSTOM_DEVICE_TECHNOLOGY`, `DATA_CENTER_SERVICE_DECODER_TYPE`, `DATA_CENTER_SERVICE_IP_ADDRESS`, `DATA_CENTER_SERVICE_METADATA`, `DATA_CENTER_SERVICE_NAME`, `DATA_CENTER_SERVICE_PORT`, `DATA_CENTER_SERVICE_TAGS`, `DOCKER_CONTAINER_NAME`, `DOCKER_FULL_IMAGE_NAME`, `DOCKER_IMAGE_VERSION`, `EC2_INSTANCE_AMI_ID`, `EC2_INSTANCE_AWS_INSTANCE_TYPE`, `EC2_INSTANCE_AWS_SECURITY_GROUP`, `EC2_INSTANCE_BEANSTALK_ENV_NAME`, `EC2_INSTANCE_ID`, `EC2_INSTANCE_NAME`, `EC2_INSTANCE_PRIVATE_HOST_NAME`, `EC2_INSTANCE_PUBLIC_HOST_NAME`, `EC2_INSTANCE_TAGS`, `ENTERPRISE_APPLICATION_DECODER_TYPE`, `ENTERPRISE_APPLICATION_IP_ADDRESS`, `ENTERPRISE_APPLICATION_METADATA`, `ENTERPRISE_APPLICATION_NAME`, `ENTERPRISE_APPLICATION_PORT`, `ENTERPRISE_APPLICATION_TAGS`, `ESXI_HOST_CLUSTER_NAME`, `ESXI_HOST_HARDWARE_MODEL`, `ESXI_HOST_HARDWARE_VENDOR`, `ESXI_HOST_NAME`, `ESXI_HOST_PRODUCT_NAME`, `ESXI_HOST_PRODUCT_VERSION`, `ESXI_HOST_TAGS`, `EXTERNAL_MONITOR_ENGINE_DESCRIPTION`, `EXTERNAL_MONITOR_ENGINE_NAME`, `EXTERNAL_MONITOR_ENGINE_TYPE`, `EXTERNAL_MONITOR_NAME`, `EXTERNAL_MONITOR_TAGS`, `GEOLOCATION_SITE_NAME`, `GOOGLE_CLOUD_PLATFORM_ZONE_NAME`, `GOOGLE_COMPUTE_INSTANCE_ID`, `GOOGLE_COMPUTE_INSTANCE_MACHINE_TYPE`, `GOOGLE_COMPUTE_INSTANCE_NAME`, `GOOGLE_COMPUTE_INSTANCE_PROJECT`, `GOOGLE_COMPUTE_INSTANCE_PROJECT_ID`, `GOOGLE_COMPUTE_INSTANCE_PUBLIC_IP_ADDRESSES`, `HOST_AIX_LOGICAL_CPU_COUNT`, `HOST_AIX_SIMULTANEOUS_THREADS`, `HOST_AIX_VIRTUAL_CPU_COUNT`, `HOST_ARCHITECTURE`, `HOST_AWS_NAME_TAG`, `HOST_AZURE_COMPUTE_MODE`, `HOST_AZURE_SKU`, `HOST_AZURE_WEB_APPLICATION_HOST_NAMES`, `HOST_AZURE_WEB_APPLICATION_SITE_NAMES`, `HOST_BITNESS`, `HOST_BOSH_AVAILABILITY_ZONE`, `HOST_BOSH_DEPLOYMENT_ID`, `HOST_BOSH_INSTANCE_ID`, `HOST_BOSH_INSTANCE_NAME`, `HOST_BOSH_NAME`, `HOST_BOSH_STEMCELL_VERSION`, `HOST_CLOUD_TYPE`, `HOST_CPU_CORES`, `HOST_CUSTOM_METADATA`, `HOST_DETECTED_NAME`, `HOST_GROUP_ID`, `HOST_GROUP_NAME`, `HOST_HYPERVISOR_TYPE`, `HOST_IP_ADDRESS`, `HOST_KUBERNETES_LABELS`, `HOST_LOGICAL_CPU_CORES`, `HOST_NAME`, `HOST_ONEAGENT_CUSTOM_HOST_NAME`, `HOST_OS_TYPE`, `HOST_OS_VERSION`, `HOST_PAAS_MEMORY_LIMIT`, `HOST_PAAS_TYPE`, `HOST_TAGS`, `HOST_TECHNOLOGY`, `HTTP_MONITOR_NAME`, `HTTP_MONITOR_TAGS`, `KUBERNETES_CLUSTER_NAME`, `KUBERNETES_NODE_NAME`, `KUBERNETES_SERVICE_NAME`, `MOBILE_APPLICATION_NAME`, `MOBILE_APPLICATION_PLATFORM`, `MOBILE_APPLICATION_TAGS`, `NAME_OF_COMPUTE_NODE`, `OPENSTACK_ACCOUNT_NAME`, `OPENSTACK_ACCOUNT_PROJECT_NAME`, `OPENSTACK_AVAILABILITY_ZONE_NAME`, `OPENSTACK_PROJECT_NAME`, `OPENSTACK_REGION_NAME`, `OPENSTACK_VM_INSTANCE_TYPE`, `OPENSTACK_VM_NAME`, `OPENSTACK_VM_SECURITY_GROUP`, `PROCESS_GROUP_AZURE_HOST_NAME`, `PROCESS_GROUP_AZURE_SITE_NAME`, `PROCESS_GROUP_CUSTOM_METADATA`, `PROCESS_GROUP_DETECTED_NAME`, `PROCESS_GROUP_ID`, `PROCESS_GROUP_LISTEN_PORT`, `PROCESS_GROUP_NAME`, `PROCESS_GROUP_PREDEFINED_METADATA`, `PROCESS_GROUP_TAGS`, `PROCESS_GROUP_TECHNOLOGY`, `PROCESS_GROUP_TECHNOLOGY_EDITION`, `PROCESS_GROUP_TECHNOLOGY_VERSION`, `QUEUE_NAME`, `QUEUE_TECHNOLOGY`, `QUEUE_VENDOR`, `SERVICE_AKKA_ACTOR_SYSTEM`, `SERVICE_CTG_SERVICE_NAME`, `SERVICE_DATABASE_HOST_NAME`, `SERVICE_DATABASE_NAME`, `SERVICE_DATABASE_TOPOLOGY`, `SERVICE_DATABASE_VENDOR`, `SERVICE_DETECTED_NAME`, `SERVICE_ESB_APPLICATION_NAME`, `SERVICE_IBM_CTG_GATEWAY_URL`, `SERVICE_MESSAGING_LISTENER_CLASS_NAME`, `SERVICE_NAME`, `SERVICE_PORT`, `SERVICE_PUBLIC_DOMAIN_NAME`, `SERVICE_REMOTE_ENDPOINT`, `SERVICE_REMOTE_SERVICE_NAME`, `SERVICE_TAGS`, `SERVICE_TECHNOLOGY`, `SERVICE_TECHNOLOGY_EDITION`, `SERVICE_TECHNOLOGY_VERSION`, `SERVICE_TOPOLOGY`, `SERVICE_TYPE`, `SERVICE_WEB_APPLICATION_ID`, `SERVICE_WEB_CONTEXT_ROOT`, `SERVICE_WEB_SERVER_ENDPOINT`, `SERVICE_WEB_SERVER_NAME`, `SERVICE_WEB_SERVICE_NAME`, `SERVICE_WEB_SERVICE_NAMESPACE`, `VMWARE_DATACENTER_NAME`, `VMWARE_VM_NAME`, `WEB_APPLICATION_NAME`, `WEB_APPLICATION_NAME_PATTERN`, `WEB_APPLICATION_TAGS`, `WEB_APPLICATION_TYPE`
        :param str operator: Possible Values: `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EXISTS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `IS_IP_IN_RANGE`, `LOWER_THAN`, `LOWER_THAN_OR_EQUAL`, `NOT_BEGINS_WITH`, `NOT_CONTAINS`, `NOT_ENDS_WITH`, `NOT_EQUALS`, `NOT_EXISTS`, `NOT_GREATER_THAN`, `NOT_GREATER_THAN_OR_EQUAL`, `NOT_IS_IP_IN_RANGE`, `NOT_LOWER_THAN`, `NOT_LOWER_THAN_OR_EQUAL`, `NOT_REGEX_MATCHES`, `NOT_TAG_KEY_EQUALS`, `REGEX_MATCHES`, `TAG_KEY_EQUALS`
        :param bool case_sensitive: Case sensitive
        :param str dynamic_key: Dynamic key
        :param str dynamic_key_source: Key source
        :param str entity_id: Value
        :param str enum_value: Value
        :param int integer_value: Value
        :param str string_value: Value
        :param str tag: Format: `[CONTEXT]tagKey:tagValue`
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if dynamic_key is not None:
            pulumi.set(__self__, "dynamic_key", dynamic_key)
        if dynamic_key_source is not None:
            pulumi.set(__self__, "dynamic_key_source", dynamic_key_source)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if enum_value is not None:
            pulumi.set(__self__, "enum_value", enum_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Possible Values: `APPMON_SERVER_NAME`, `APPMON_SYSTEM_PROFILE_NAME`, `AWS_ACCOUNT_ID`, `AWS_ACCOUNT_NAME`, `AWS_APPLICATION_LOAD_BALANCER_NAME`, `AWS_APPLICATION_LOAD_BALANCER_TAGS`, `AWS_AUTO_SCALING_GROUP_NAME`, `AWS_AUTO_SCALING_GROUP_TAGS`, `AWS_AVAILABILITY_ZONE_NAME`, `AWS_CLASSIC_LOAD_BALANCER_FRONTEND_PORTS`, `AWS_CLASSIC_LOAD_BALANCER_NAME`, `AWS_CLASSIC_LOAD_BALANCER_TAGS`, `AWS_NETWORK_LOAD_BALANCER_NAME`, `AWS_NETWORK_LOAD_BALANCER_TAGS`, `AWS_RELATIONAL_DATABASE_SERVICE_DB_NAME`, `AWS_RELATIONAL_DATABASE_SERVICE_ENDPOINT`, `AWS_RELATIONAL_DATABASE_SERVICE_ENGINE`, `AWS_RELATIONAL_DATABASE_SERVICE_INSTANCE_CLASS`, `AWS_RELATIONAL_DATABASE_SERVICE_NAME`, `AWS_RELATIONAL_DATABASE_SERVICE_PORT`, `AWS_RELATIONAL_DATABASE_SERVICE_TAGS`, `AZURE_ENTITY_NAME`, `AZURE_ENTITY_TAGS`, `AZURE_MGMT_GROUP_NAME`, `AZURE_MGMT_GROUP_UUID`, `AZURE_REGION_NAME`, `AZURE_SCALE_SET_NAME`, `AZURE_SUBSCRIPTION_NAME`, `AZURE_SUBSCRIPTION_UUID`, `AZURE_TENANT_NAME`, `AZURE_TENANT_UUID`, `AZURE_VM_NAME`, `BROWSER_MONITOR_NAME`, `BROWSER_MONITOR_TAGS`, `CLOUD_APPLICATION_LABELS`, `CLOUD_APPLICATION_NAME`, `CLOUD_APPLICATION_NAMESPACE_LABELS`, `CLOUD_APPLICATION_NAMESPACE_NAME`, `CLOUD_FOUNDRY_FOUNDATION_NAME`, `CLOUD_FOUNDRY_ORG_NAME`, `CUSTOM_APPLICATION_NAME`, `CUSTOM_APPLICATION_PLATFORM`, `CUSTOM_APPLICATION_TAGS`, `CUSTOM_APPLICATION_TYPE`, `CUSTOM_DEVICE_DNS_ADDRESS`, `CUSTOM_DEVICE_GROUP_NAME`, `CUSTOM_DEVICE_GROUP_TAGS`, `CUSTOM_DEVICE_IP_ADDRESS`, `CUSTOM_DEVICE_METADATA`, `CUSTOM_DEVICE_NAME`, `CUSTOM_DEVICE_PORT`, `CUSTOM_DEVICE_TAGS`, `CUSTOM_DEVICE_TECHNOLOGY`, `DATA_CENTER_SERVICE_DECODER_TYPE`, `DATA_CENTER_SERVICE_IP_ADDRESS`, `DATA_CENTER_SERVICE_METADATA`, `DATA_CENTER_SERVICE_NAME`, `DATA_CENTER_SERVICE_PORT`, `DATA_CENTER_SERVICE_TAGS`, `DOCKER_CONTAINER_NAME`, `DOCKER_FULL_IMAGE_NAME`, `DOCKER_IMAGE_VERSION`, `EC2_INSTANCE_AMI_ID`, `EC2_INSTANCE_AWS_INSTANCE_TYPE`, `EC2_INSTANCE_AWS_SECURITY_GROUP`, `EC2_INSTANCE_BEANSTALK_ENV_NAME`, `EC2_INSTANCE_ID`, `EC2_INSTANCE_NAME`, `EC2_INSTANCE_PRIVATE_HOST_NAME`, `EC2_INSTANCE_PUBLIC_HOST_NAME`, `EC2_INSTANCE_TAGS`, `ENTERPRISE_APPLICATION_DECODER_TYPE`, `ENTERPRISE_APPLICATION_IP_ADDRESS`, `ENTERPRISE_APPLICATION_METADATA`, `ENTERPRISE_APPLICATION_NAME`, `ENTERPRISE_APPLICATION_PORT`, `ENTERPRISE_APPLICATION_TAGS`, `ESXI_HOST_CLUSTER_NAME`, `ESXI_HOST_HARDWARE_MODEL`, `ESXI_HOST_HARDWARE_VENDOR`, `ESXI_HOST_NAME`, `ESXI_HOST_PRODUCT_NAME`, `ESXI_HOST_PRODUCT_VERSION`, `ESXI_HOST_TAGS`, `EXTERNAL_MONITOR_ENGINE_DESCRIPTION`, `EXTERNAL_MONITOR_ENGINE_NAME`, `EXTERNAL_MONITOR_ENGINE_TYPE`, `EXTERNAL_MONITOR_NAME`, `EXTERNAL_MONITOR_TAGS`, `GEOLOCATION_SITE_NAME`, `GOOGLE_CLOUD_PLATFORM_ZONE_NAME`, `GOOGLE_COMPUTE_INSTANCE_ID`, `GOOGLE_COMPUTE_INSTANCE_MACHINE_TYPE`, `GOOGLE_COMPUTE_INSTANCE_NAME`, `GOOGLE_COMPUTE_INSTANCE_PROJECT`, `GOOGLE_COMPUTE_INSTANCE_PROJECT_ID`, `GOOGLE_COMPUTE_INSTANCE_PUBLIC_IP_ADDRESSES`, `HOST_AIX_LOGICAL_CPU_COUNT`, `HOST_AIX_SIMULTANEOUS_THREADS`, `HOST_AIX_VIRTUAL_CPU_COUNT`, `HOST_ARCHITECTURE`, `HOST_AWS_NAME_TAG`, `HOST_AZURE_COMPUTE_MODE`, `HOST_AZURE_SKU`, `HOST_AZURE_WEB_APPLICATION_HOST_NAMES`, `HOST_AZURE_WEB_APPLICATION_SITE_NAMES`, `HOST_BITNESS`, `HOST_BOSH_AVAILABILITY_ZONE`, `HOST_BOSH_DEPLOYMENT_ID`, `HOST_BOSH_INSTANCE_ID`, `HOST_BOSH_INSTANCE_NAME`, `HOST_BOSH_NAME`, `HOST_BOSH_STEMCELL_VERSION`, `HOST_CLOUD_TYPE`, `HOST_CPU_CORES`, `HOST_CUSTOM_METADATA`, `HOST_DETECTED_NAME`, `HOST_GROUP_ID`, `HOST_GROUP_NAME`, `HOST_HYPERVISOR_TYPE`, `HOST_IP_ADDRESS`, `HOST_KUBERNETES_LABELS`, `HOST_LOGICAL_CPU_CORES`, `HOST_NAME`, `HOST_ONEAGENT_CUSTOM_HOST_NAME`, `HOST_OS_TYPE`, `HOST_OS_VERSION`, `HOST_PAAS_MEMORY_LIMIT`, `HOST_PAAS_TYPE`, `HOST_TAGS`, `HOST_TECHNOLOGY`, `HTTP_MONITOR_NAME`, `HTTP_MONITOR_TAGS`, `KUBERNETES_CLUSTER_NAME`, `KUBERNETES_NODE_NAME`, `KUBERNETES_SERVICE_NAME`, `MOBILE_APPLICATION_NAME`, `MOBILE_APPLICATION_PLATFORM`, `MOBILE_APPLICATION_TAGS`, `NAME_OF_COMPUTE_NODE`, `OPENSTACK_ACCOUNT_NAME`, `OPENSTACK_ACCOUNT_PROJECT_NAME`, `OPENSTACK_AVAILABILITY_ZONE_NAME`, `OPENSTACK_PROJECT_NAME`, `OPENSTACK_REGION_NAME`, `OPENSTACK_VM_INSTANCE_TYPE`, `OPENSTACK_VM_NAME`, `OPENSTACK_VM_SECURITY_GROUP`, `PROCESS_GROUP_AZURE_HOST_NAME`, `PROCESS_GROUP_AZURE_SITE_NAME`, `PROCESS_GROUP_CUSTOM_METADATA`, `PROCESS_GROUP_DETECTED_NAME`, `PROCESS_GROUP_ID`, `PROCESS_GROUP_LISTEN_PORT`, `PROCESS_GROUP_NAME`, `PROCESS_GROUP_PREDEFINED_METADATA`, `PROCESS_GROUP_TAGS`, `PROCESS_GROUP_TECHNOLOGY`, `PROCESS_GROUP_TECHNOLOGY_EDITION`, `PROCESS_GROUP_TECHNOLOGY_VERSION`, `QUEUE_NAME`, `QUEUE_TECHNOLOGY`, `QUEUE_VENDOR`, `SERVICE_AKKA_ACTOR_SYSTEM`, `SERVICE_CTG_SERVICE_NAME`, `SERVICE_DATABASE_HOST_NAME`, `SERVICE_DATABASE_NAME`, `SERVICE_DATABASE_TOPOLOGY`, `SERVICE_DATABASE_VENDOR`, `SERVICE_DETECTED_NAME`, `SERVICE_ESB_APPLICATION_NAME`, `SERVICE_IBM_CTG_GATEWAY_URL`, `SERVICE_MESSAGING_LISTENER_CLASS_NAME`, `SERVICE_NAME`, `SERVICE_PORT`, `SERVICE_PUBLIC_DOMAIN_NAME`, `SERVICE_REMOTE_ENDPOINT`, `SERVICE_REMOTE_SERVICE_NAME`, `SERVICE_TAGS`, `SERVICE_TECHNOLOGY`, `SERVICE_TECHNOLOGY_EDITION`, `SERVICE_TECHNOLOGY_VERSION`, `SERVICE_TOPOLOGY`, `SERVICE_TYPE`, `SERVICE_WEB_APPLICATION_ID`, `SERVICE_WEB_CONTEXT_ROOT`, `SERVICE_WEB_SERVER_ENDPOINT`, `SERVICE_WEB_SERVER_NAME`, `SERVICE_WEB_SERVICE_NAME`, `SERVICE_WEB_SERVICE_NAMESPACE`, `VMWARE_DATACENTER_NAME`, `VMWARE_VM_NAME`, `WEB_APPLICATION_NAME`, `WEB_APPLICATION_NAME_PATTERN`, `WEB_APPLICATION_TAGS`, `WEB_APPLICATION_TYPE`
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Possible Values: `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EXISTS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `IS_IP_IN_RANGE`, `LOWER_THAN`, `LOWER_THAN_OR_EQUAL`, `NOT_BEGINS_WITH`, `NOT_CONTAINS`, `NOT_ENDS_WITH`, `NOT_EQUALS`, `NOT_EXISTS`, `NOT_GREATER_THAN`, `NOT_GREATER_THAN_OR_EQUAL`, `NOT_IS_IP_IN_RANGE`, `NOT_LOWER_THAN`, `NOT_LOWER_THAN_OR_EQUAL`, `NOT_REGEX_MATCHES`, `NOT_TAG_KEY_EQUALS`, `REGEX_MATCHES`, `TAG_KEY_EQUALS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        Case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> Optional[str]:
        """
        Dynamic key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter(name="dynamicKeySource")
    def dynamic_key_source(self) -> Optional[str]:
        """
        Key source
        """
        return pulumi.get(self, "dynamic_key_source")

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[str]:
        """
        Value
        """
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter(name="enumValue")
    def enum_value(self) -> Optional[str]:
        """
        Value
        """
        return pulumi.get(self, "enum_value")

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[int]:
        """
        Value
        """
        return pulumi.get(self, "integer_value")

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[str]:
        """
        Value
        """
        return pulumi.get(self, "string_value")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Format: `[CONTEXT]tagKey:tagValue`
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class ManagementZoneV2RulesRuleDimensionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appliesTo":
            suggest = "applies_to"
        elif key == "dimensionConditions":
            suggest = "dimension_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneV2RulesRuleDimensionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneV2RulesRuleDimensionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneV2RulesRuleDimensionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applies_to: str,
                 dimension_conditions: Optional['outputs.ManagementZoneV2RulesRuleDimensionRuleDimensionConditions'] = None):
        """
        :param str applies_to: Possible Values: `ANY`, `LOG`, `METRIC`
        :param 'ManagementZoneV2RulesRuleDimensionRuleDimensionConditionsArgs' dimension_conditions: Conditions
        """
        pulumi.set(__self__, "applies_to", applies_to)
        if dimension_conditions is not None:
            pulumi.set(__self__, "dimension_conditions", dimension_conditions)

    @property
    @pulumi.getter(name="appliesTo")
    def applies_to(self) -> str:
        """
        Possible Values: `ANY`, `LOG`, `METRIC`
        """
        return pulumi.get(self, "applies_to")

    @property
    @pulumi.getter(name="dimensionConditions")
    def dimension_conditions(self) -> Optional['outputs.ManagementZoneV2RulesRuleDimensionRuleDimensionConditions']:
        """
        Conditions
        """
        return pulumi.get(self, "dimension_conditions")


@pulumi.output_type
class ManagementZoneV2RulesRuleDimensionRuleDimensionConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.ManagementZoneV2RulesRuleDimensionRuleDimensionConditionsCondition']):
        """
        :param Sequence['ManagementZoneV2RulesRuleDimensionRuleDimensionConditionsConditionArgs'] conditions: Dimension conditions
        """
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.ManagementZoneV2RulesRuleDimensionRuleDimensionConditionsCondition']:
        """
        Dimension conditions
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ManagementZoneV2RulesRuleDimensionRuleDimensionConditionsCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionType":
            suggest = "condition_type"
        elif key == "ruleMatcher":
            suggest = "rule_matcher"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneV2RulesRuleDimensionRuleDimensionConditionsCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneV2RulesRuleDimensionRuleDimensionConditionsCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneV2RulesRuleDimensionRuleDimensionConditionsCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_type: str,
                 rule_matcher: str,
                 value: str,
                 key: Optional[str] = None):
        """
        :param str condition_type: Possible Values: `DIMENSION`, `LOG_FILE_NAME`, `METRIC_KEY`
        :param str rule_matcher: Possible Values: `BEGINS_WITH`, `EQUALS`
        :param str value: no documentation available
        :param str key: no documentation available
        """
        pulumi.set(__self__, "condition_type", condition_type)
        pulumi.set(__self__, "rule_matcher", rule_matcher)
        pulumi.set(__self__, "value", value)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> str:
        """
        Possible Values: `DIMENSION`, `LOG_FILE_NAME`, `METRIC_KEY`
        """
        return pulumi.get(self, "condition_type")

    @property
    @pulumi.getter(name="ruleMatcher")
    def rule_matcher(self) -> str:
        """
        Possible Values: `BEGINS_WITH`, `EQUALS`
        """
        return pulumi.get(self, "rule_matcher")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class MetricEventsEventTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"
        elif key == "davisMerge":
            suggest = "davis_merge"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricEventsEventTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricEventsEventTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricEventsEventTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 event_type: str,
                 title: str,
                 davis_merge: Optional[bool] = None,
                 metadatas: Optional[Sequence['outputs.MetricEventsEventTemplateMetadata']] = None):
        """
        :param str description: The description of the event to trigger.
        :param str event_type: Possible Values: `AVAILABILITY`, `CUSTOM_ALERT`, `CUSTOM_ANNOTATION`, `CUSTOM_CONFIGURATION`, `CUSTOM_DEPLOYMENT`, `ERROR`, `INFO`, `MARKED_FOR_TERMINATION`, `RESOURCE`, `SLOWDOWN`
        :param str title: The title of the event to trigger.
        :param bool davis_merge: Davis® AI will try to merge this event into existing problems, otherwise a new problem will always be created.
        :param Sequence['MetricEventsEventTemplateMetadataArgs'] metadatas: Set of additional key-value properties to be attached to the triggered event.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "title", title)
        if davis_merge is not None:
            pulumi.set(__self__, "davis_merge", davis_merge)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the event to trigger.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> str:
        """
        Possible Values: `AVAILABILITY`, `CUSTOM_ALERT`, `CUSTOM_ANNOTATION`, `CUSTOM_CONFIGURATION`, `CUSTOM_DEPLOYMENT`, `ERROR`, `INFO`, `MARKED_FOR_TERMINATION`, `RESOURCE`, `SLOWDOWN`
        """
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The title of the event to trigger.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="davisMerge")
    def davis_merge(self) -> Optional[bool]:
        """
        Davis® AI will try to merge this event into existing problems, otherwise a new problem will always be created.
        """
        return pulumi.get(self, "davis_merge")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.MetricEventsEventTemplateMetadata']]:
        """
        Set of additional key-value properties to be attached to the triggered event.
        """
        return pulumi.get(self, "metadatas")


@pulumi.output_type
class MetricEventsEventTemplateMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataKey":
            suggest = "metadata_key"
        elif key == "metadataValue":
            suggest = "metadata_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricEventsEventTemplateMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricEventsEventTemplateMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricEventsEventTemplateMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_key: str,
                 metadata_value: str):
        """
        :param str metadata_key: Type 'dt.' for key hints.
        :param str metadata_value: no documentation available
        """
        pulumi.set(__self__, "metadata_key", metadata_key)
        pulumi.set(__self__, "metadata_value", metadata_value)

    @property
    @pulumi.getter(name="metadataKey")
    def metadata_key(self) -> str:
        """
        Type 'dt.' for key hints.
        """
        return pulumi.get(self, "metadata_key")

    @property
    @pulumi.getter(name="metadataValue")
    def metadata_value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "metadata_value")


@pulumi.output_type
class MetricEventsModelProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertCondition":
            suggest = "alert_condition"
        elif key == "alertOnNoData":
            suggest = "alert_on_no_data"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingSamples":
            suggest = "violating_samples"
        elif key == "signalFluctuation":
            suggest = "signal_fluctuation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricEventsModelProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricEventsModelProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricEventsModelProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_condition: str,
                 alert_on_no_data: bool,
                 dealerting_samples: int,
                 samples: int,
                 type: str,
                 violating_samples: int,
                 signal_fluctuation: Optional[float] = None,
                 threshold: Optional[float] = None,
                 tolerance: Optional[float] = None):
        """
        :param str alert_condition: Possible Values: `ABOVE`, `BELOW`, `OUTSIDE`
        :param bool alert_on_no_data: The ability to set an alert on missing data in a metric. When enabled, missing data samples will contribute as violating samples defined in advanced model properties. We recommend to not alert on missing data for sparse timeseries as this leads to alert spam.
        :param int dealerting_samples: The number of one-minute samples within the evaluation window that must go back to normal to close the event.
        :param int samples: The number of one-minute samples that form the sliding evaluation window.
        :param str type: Possible Values: `AUTO_ADAPTIVE_THRESHOLD`, `SEASONAL_BASELINE`, `STATIC_THRESHOLD`
        :param int violating_samples: The number of one-minute samples within the evaluation window that must violate to trigger an event.
        :param float signal_fluctuation: Controls how many times the signal fluctuation is added to the baseline to produce the actual threshold for alerting
        :param float threshold: Raise an event if this value is violated
        :param float tolerance: Controls the width of the confidence band and larger values lead to a less sensitive model
        """
        pulumi.set(__self__, "alert_condition", alert_condition)
        pulumi.set(__self__, "alert_on_no_data", alert_on_no_data)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "samples", samples)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "violating_samples", violating_samples)
        if signal_fluctuation is not None:
            pulumi.set(__self__, "signal_fluctuation", signal_fluctuation)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if tolerance is not None:
            pulumi.set(__self__, "tolerance", tolerance)

    @property
    @pulumi.getter(name="alertCondition")
    def alert_condition(self) -> str:
        """
        Possible Values: `ABOVE`, `BELOW`, `OUTSIDE`
        """
        return pulumi.get(self, "alert_condition")

    @property
    @pulumi.getter(name="alertOnNoData")
    def alert_on_no_data(self) -> bool:
        """
        The ability to set an alert on missing data in a metric. When enabled, missing data samples will contribute as violating samples defined in advanced model properties. We recommend to not alert on missing data for sparse timeseries as this leads to alert spam.
        """
        return pulumi.get(self, "alert_on_no_data")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        """
        The number of one-minute samples within the evaluation window that must go back to normal to close the event.
        """
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter
    def samples(self) -> int:
        """
        The number of one-minute samples that form the sliding evaluation window.
        """
        return pulumi.get(self, "samples")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `AUTO_ADAPTIVE_THRESHOLD`, `SEASONAL_BASELINE`, `STATIC_THRESHOLD`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        The number of one-minute samples within the evaluation window that must violate to trigger an event.
        """
        return pulumi.get(self, "violating_samples")

    @property
    @pulumi.getter(name="signalFluctuation")
    def signal_fluctuation(self) -> Optional[float]:
        """
        Controls how many times the signal fluctuation is added to the baseline to produce the actual threshold for alerting
        """
        return pulumi.get(self, "signal_fluctuation")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        """
        Raise an event if this value is violated
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def tolerance(self) -> Optional[float]:
        """
        Controls the width of the confidence band and larger values lead to a less sensitive model
        """
        return pulumi.get(self, "tolerance")


@pulumi.output_type
class MetricEventsQueryDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dimensionFilter":
            suggest = "dimension_filter"
        elif key == "entityFilter":
            suggest = "entity_filter"
        elif key == "managementZone":
            suggest = "management_zone"
        elif key == "metricKey":
            suggest = "metric_key"
        elif key == "metricSelector":
            suggest = "metric_selector"
        elif key == "queryOffset":
            suggest = "query_offset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricEventsQueryDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricEventsQueryDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricEventsQueryDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 aggregation: Optional[str] = None,
                 dimension_filter: Optional['outputs.MetricEventsQueryDefinitionDimensionFilter'] = None,
                 entity_filter: Optional['outputs.MetricEventsQueryDefinitionEntityFilter'] = None,
                 management_zone: Optional[str] = None,
                 metric_key: Optional[str] = None,
                 metric_selector: Optional[str] = None,
                 query_offset: Optional[int] = None):
        """
        :param str type: Possible Values: `METRIC_KEY`, `METRIC_SELECTOR`
        :param str aggregation: Possible Values: `AVG`, `COUNT`, `MAX`, `MEDIAN`, `MIN`, `PERCENTILE90`, `SUM`, `VALUE`
        :param 'MetricEventsQueryDefinitionDimensionFilterArgs' dimension_filter: Dimension filter
        :param 'MetricEventsQueryDefinitionEntityFilterArgs' entity_filter: Use rule-based filters to define the scope this event monitors.
        :param str management_zone: The `legacy_id` of a Management Zone (as provided by the resource `ManagementZoneV2` or the data source `ManagementZone`)
        :param str metric_key: Metric key
        :param str metric_selector: To learn more, visit [Metric Selector](https://dt-url.net/metselad)
        :param int query_offset: Minute offset of sliding evaluation window for metrics with latency
        """
        pulumi.set(__self__, "type", type)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if dimension_filter is not None:
            pulumi.set(__self__, "dimension_filter", dimension_filter)
        if entity_filter is not None:
            pulumi.set(__self__, "entity_filter", entity_filter)
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if metric_key is not None:
            pulumi.set(__self__, "metric_key", metric_key)
        if metric_selector is not None:
            pulumi.set(__self__, "metric_selector", metric_selector)
        if query_offset is not None:
            pulumi.set(__self__, "query_offset", query_offset)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `METRIC_KEY`, `METRIC_SELECTOR`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        Possible Values: `AVG`, `COUNT`, `MAX`, `MEDIAN`, `MIN`, `PERCENTILE90`, `SUM`, `VALUE`
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="dimensionFilter")
    def dimension_filter(self) -> Optional['outputs.MetricEventsQueryDefinitionDimensionFilter']:
        """
        Dimension filter
        """
        return pulumi.get(self, "dimension_filter")

    @property
    @pulumi.getter(name="entityFilter")
    def entity_filter(self) -> Optional['outputs.MetricEventsQueryDefinitionEntityFilter']:
        """
        Use rule-based filters to define the scope this event monitors.
        """
        return pulumi.get(self, "entity_filter")

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        """
        The `legacy_id` of a Management Zone (as provided by the resource `ManagementZoneV2` or the data source `ManagementZone`)
        """
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="metricKey")
    def metric_key(self) -> Optional[str]:
        """
        Metric key
        """
        return pulumi.get(self, "metric_key")

    @property
    @pulumi.getter(name="metricSelector")
    def metric_selector(self) -> Optional[str]:
        """
        To learn more, visit [Metric Selector](https://dt-url.net/metselad)
        """
        return pulumi.get(self, "metric_selector")

    @property
    @pulumi.getter(name="queryOffset")
    def query_offset(self) -> Optional[int]:
        """
        Minute offset of sliding evaluation window for metrics with latency
        """
        return pulumi.get(self, "query_offset")


@pulumi.output_type
class MetricEventsQueryDefinitionDimensionFilter(dict):
    def __init__(__self__, *,
                 filters: Sequence['outputs.MetricEventsQueryDefinitionDimensionFilterFilter']):
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.MetricEventsQueryDefinitionDimensionFilterFilter']:
        return pulumi.get(self, "filters")


@pulumi.output_type
class MetricEventsQueryDefinitionDimensionFilterFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dimensionKey":
            suggest = "dimension_key"
        elif key == "dimensionValue":
            suggest = "dimension_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricEventsQueryDefinitionDimensionFilterFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricEventsQueryDefinitionDimensionFilterFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricEventsQueryDefinitionDimensionFilterFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension_key: str,
                 dimension_value: str,
                 operator: Optional[str] = None):
        """
        :param str dimension_key: Dimension key
        :param str dimension_value: Dimension value
        :param str operator: Possible Values: `CONTAINS_CASE_SENSITIVE`, `DOES_NOT_CONTAIN_CASE_SENSITIVE`, `DOES_NOT_EQUAL`, `DOES_NOT_START_WITH`, `EQUALS`, `STARTS_WITH`
        """
        pulumi.set(__self__, "dimension_key", dimension_key)
        pulumi.set(__self__, "dimension_value", dimension_value)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="dimensionKey")
    def dimension_key(self) -> str:
        """
        Dimension key
        """
        return pulumi.get(self, "dimension_key")

    @property
    @pulumi.getter(name="dimensionValue")
    def dimension_value(self) -> str:
        """
        Dimension value
        """
        return pulumi.get(self, "dimension_value")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Possible Values: `CONTAINS_CASE_SENSITIVE`, `DOES_NOT_CONTAIN_CASE_SENSITIVE`, `DOES_NOT_EQUAL`, `DOES_NOT_START_WITH`, `EQUALS`, `STARTS_WITH`
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class MetricEventsQueryDefinitionEntityFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dimensionKey":
            suggest = "dimension_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricEventsQueryDefinitionEntityFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricEventsQueryDefinitionEntityFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricEventsQueryDefinitionEntityFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional['outputs.MetricEventsQueryDefinitionEntityFilterConditions'] = None,
                 dimension_key: Optional[str] = None):
        """
        :param 'MetricEventsQueryDefinitionEntityFilterConditionsArgs' conditions: no documentation available
        :param str dimension_key: Dimension key of entity type to filter
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if dimension_key is not None:
            pulumi.set(__self__, "dimension_key", dimension_key)

    @property
    @pulumi.getter
    def conditions(self) -> Optional['outputs.MetricEventsQueryDefinitionEntityFilterConditions']:
        """
        no documentation available
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="dimensionKey")
    def dimension_key(self) -> Optional[str]:
        """
        Dimension key of entity type to filter
        """
        return pulumi.get(self, "dimension_key")


@pulumi.output_type
class MetricEventsQueryDefinitionEntityFilterConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.MetricEventsQueryDefinitionEntityFilterConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.MetricEventsQueryDefinitionEntityFilterConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class MetricEventsQueryDefinitionEntityFilterConditionsCondition(dict):
    def __init__(__self__, *,
                 operator: str,
                 type: str,
                 value: str):
        """
        :param str operator: Possible Values: `CONTAINS_CASE_INSENSITIVE`, `CONTAINS_CASE_SENSITIVE`, `DOES_NOT_CONTAIN_CASE_INSENSITIVE`, `DOES_NOT_CONTAIN_CASE_SENSITIVE`, `DOES_NOT_EQUAL`, `DOES_NOT_START_WITH`, `EQUALS`, `STARTS_WITH`
        :param str type: Possible Values: `CUSTOM_DEVICE_GROUP_NAME`, `ENTITY_ID`, `HOST_GROUP_NAME`, `HOST_NAME`, `MANAGEMENT_ZONE`, `NAME`, `PROCESS_GROUP_ID`, `PROCESS_GROUP_NAME`, `TAG`
        :param str value: no documentation available
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Possible Values: `CONTAINS_CASE_INSENSITIVE`, `CONTAINS_CASE_SENSITIVE`, `DOES_NOT_CONTAIN_CASE_INSENSITIVE`, `DOES_NOT_CONTAIN_CASE_SENSITIVE`, `DOES_NOT_EQUAL`, `DOES_NOT_START_WITH`, `EQUALS`, `STARTS_WITH`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `CUSTOM_DEVICE_GROUP_NAME`, `ENTITY_ID`, `HOST_GROUP_NAME`, `HOST_NAME`, `MANAGEMENT_ZONE`, `NAME`, `PROCESS_GROUP_ID`, `PROCESS_GROUP_NAME`, `TAG`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class MetricMetadataDimensions(dict):
    def __init__(__self__, *,
                 dimensions: Sequence['outputs.MetricMetadataDimensionsDimension']):
        pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.MetricMetadataDimensionsDimension']:
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class MetricMetadataDimensionsDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricMetadataDimensionsDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricMetadataDimensionsDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricMetadataDimensionsDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 display_name: Optional[str] = None):
        """
        :param str key: Dimension key
        :param str display_name: Display name
        """
        pulumi.set(__self__, "key", key)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Dimension key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class MetricMetadataMetricProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueType":
            suggest = "value_type"
        elif key == "impactRelevant":
            suggest = "impact_relevant"
        elif key == "maxValue":
            suggest = "max_value"
        elif key == "minValue":
            suggest = "min_value"
        elif key == "rootCauseRelevant":
            suggest = "root_cause_relevant"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricMetadataMetricProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricMetadataMetricProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricMetadataMetricProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value_type: str,
                 impact_relevant: Optional[bool] = None,
                 latency: Optional[int] = None,
                 max_value: Optional[float] = None,
                 min_value: Optional[float] = None,
                 root_cause_relevant: Optional[bool] = None):
        """
        :param str value_type: Possible Values: `Error`, `Score`, `Unknown`
        :param bool impact_relevant: Whether (true or false) the metric is relevant to a problem's impact.
        :param int latency: The latency of the metric, in minutes. 
               
                The latency is the expected reporting delay (for example, caused by constraints of cloud vendors or other third-party data sources) between the observation of a metric data point and its availability in Dynatrace. 
               
               The allowed value range is from 1 to 60 minutes.
        :param float max_value: The maximum allowed value of the metric.
        :param float min_value: The minimum allowed value of the metric.
        :param bool root_cause_relevant: Whether (true or false) the metric is related to a root cause of a problem.
               
               A root-cause relevant metric represents a strong indicator for a faulty component.
        """
        pulumi.set(__self__, "value_type", value_type)
        if impact_relevant is not None:
            pulumi.set(__self__, "impact_relevant", impact_relevant)
        if latency is not None:
            pulumi.set(__self__, "latency", latency)
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if root_cause_relevant is not None:
            pulumi.set(__self__, "root_cause_relevant", root_cause_relevant)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> str:
        """
        Possible Values: `Error`, `Score`, `Unknown`
        """
        return pulumi.get(self, "value_type")

    @property
    @pulumi.getter(name="impactRelevant")
    def impact_relevant(self) -> Optional[bool]:
        """
        Whether (true or false) the metric is relevant to a problem's impact.
        """
        return pulumi.get(self, "impact_relevant")

    @property
    @pulumi.getter
    def latency(self) -> Optional[int]:
        """
        The latency of the metric, in minutes. 

         The latency is the expected reporting delay (for example, caused by constraints of cloud vendors or other third-party data sources) between the observation of a metric data point and its availability in Dynatrace. 

        The allowed value range is from 1 to 60 minutes.
        """
        return pulumi.get(self, "latency")

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[float]:
        """
        The maximum allowed value of the metric.
        """
        return pulumi.get(self, "max_value")

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[float]:
        """
        The minimum allowed value of the metric.
        """
        return pulumi.get(self, "min_value")

    @property
    @pulumi.getter(name="rootCauseRelevant")
    def root_cause_relevant(self) -> Optional[bool]:
        """
        Whether (true or false) the metric is related to a root cause of a problem.

        A root-cause relevant metric represents a strong indicator for a faulty component.
        """
        return pulumi.get(self, "root_cause_relevant")


@pulumi.output_type
class MobileAppAnomaliesErrorRateIncrease(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectionMode":
            suggest = "detection_mode"
        elif key == "errorRateIncreaseAuto":
            suggest = "error_rate_increase_auto"
        elif key == "errorRateIncreaseFixed":
            suggest = "error_rate_increase_fixed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesErrorRateIncrease. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesErrorRateIncrease.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesErrorRateIncrease.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 detection_mode: Optional[str] = None,
                 error_rate_increase_auto: Optional['outputs.MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto'] = None,
                 error_rate_increase_fixed: Optional['outputs.MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param str detection_mode: Possible Values: `Auto`, `Fixed`
        :param 'MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseAutoArgs' error_rate_increase_auto: Alert if the percentage of user actions affected by reported errors exceeds **both** the absolute threshold and the relative threshold
        :param 'MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixedArgs' error_rate_increase_fixed: Alert if the custom reported error rate threshold is exceeded during any 5-minute period
        """
        pulumi.set(__self__, "enabled", enabled)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if error_rate_increase_auto is not None:
            pulumi.set(__self__, "error_rate_increase_auto", error_rate_increase_auto)
        if error_rate_increase_fixed is not None:
            pulumi.set(__self__, "error_rate_increase_fixed", error_rate_increase_fixed)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Fixed`
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter(name="errorRateIncreaseAuto")
    def error_rate_increase_auto(self) -> Optional['outputs.MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto']:
        """
        Alert if the percentage of user actions affected by reported errors exceeds **both** the absolute threshold and the relative threshold
        """
        return pulumi.get(self, "error_rate_increase_auto")

    @property
    @pulumi.getter(name="errorRateIncreaseFixed")
    def error_rate_increase_fixed(self) -> Optional['outputs.MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed']:
        """
        Alert if the custom reported error rate threshold is exceeded during any 5-minute period
        """
        return pulumi.get(self, "error_rate_increase_fixed")


@pulumi.output_type
class MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdAbsolute":
            suggest = "threshold_absolute"
        elif key == "thresholdRelative":
            suggest = "threshold_relative"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 threshold_absolute: float,
                 threshold_relative: float):
        """
        :param float threshold_absolute: Absolute threshold
        :param float threshold_relative: Relative threshold
        """
        pulumi.set(__self__, "threshold_absolute", threshold_absolute)
        pulumi.set(__self__, "threshold_relative", threshold_relative)

    @property
    @pulumi.getter(name="thresholdAbsolute")
    def threshold_absolute(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "threshold_absolute")

    @property
    @pulumi.getter(name="thresholdRelative")
    def threshold_relative(self) -> float:
        """
        Relative threshold
        """
        return pulumi.get(self, "threshold_relative")


@pulumi.output_type
class MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdAbsolute":
            suggest = "threshold_absolute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sensitivity: str,
                 threshold_absolute: float):
        """
        :param str sensitivity: Possible Values: `Low`, `Medium`, `High`
        :param float threshold_absolute: Absolute threshold
        """
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold_absolute", threshold_absolute)

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        """
        Possible Values: `Low`, `Medium`, `High`
        """
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter(name="thresholdAbsolute")
    def threshold_absolute(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "threshold_absolute")


@pulumi.output_type
class MobileAppAnomaliesSlowUserActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectionMode":
            suggest = "detection_mode"
        elif key == "slowUserActionsAuto":
            suggest = "slow_user_actions_auto"
        elif key == "slowUserActionsFixed":
            suggest = "slow_user_actions_fixed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesSlowUserActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesSlowUserActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesSlowUserActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 detection_mode: Optional[str] = None,
                 slow_user_actions_auto: Optional['outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAuto'] = None,
                 slow_user_actions_fixed: Optional['outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixed'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param str detection_mode: Possible Values: `Auto`, `Fixed`
        :param 'MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoArgs' slow_user_actions_auto: no documentation available
        :param 'MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedArgs' slow_user_actions_fixed: no documentation available
        """
        pulumi.set(__self__, "enabled", enabled)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if slow_user_actions_auto is not None:
            pulumi.set(__self__, "slow_user_actions_auto", slow_user_actions_auto)
        if slow_user_actions_fixed is not None:
            pulumi.set(__self__, "slow_user_actions_fixed", slow_user_actions_fixed)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Fixed`
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter(name="slowUserActionsAuto")
    def slow_user_actions_auto(self) -> Optional['outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAuto']:
        """
        no documentation available
        """
        return pulumi.get(self, "slow_user_actions_auto")

    @property
    @pulumi.getter(name="slowUserActionsFixed")
    def slow_user_actions_fixed(self) -> Optional['outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixed']:
        """
        no documentation available
        """
        return pulumi.get(self, "slow_user_actions_fixed")


@pulumi.output_type
class MobileAppAnomaliesSlowUserActionsSlowUserActionsAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationAvoidOveralerting":
            suggest = "duration_avoid_overalerting"
        elif key == "durationThresholdAll":
            suggest = "duration_threshold_all"
        elif key == "durationThresholdSlowest":
            suggest = "duration_threshold_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesSlowUserActionsSlowUserActionsAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_avoid_overalerting: 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting',
                 duration_threshold_all: 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll',
                 duration_threshold_slowest: 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest'):
        """
        :param 'MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralertingArgs' duration_avoid_overalerting: To avoid over-alerting do not alert for low traffic applications with less than
        :param 'MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAllArgs' duration_threshold_all: Alert if the action duration of all user actions degrades beyond **both** the absolute and relative threshold:
        :param 'MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowestArgs' duration_threshold_slowest: Alert if the action duration of the slowest 10% of user actions degrades beyond **both** the absolute and relative threshold:
        """
        pulumi.set(__self__, "duration_avoid_overalerting", duration_avoid_overalerting)
        pulumi.set(__self__, "duration_threshold_all", duration_threshold_all)
        pulumi.set(__self__, "duration_threshold_slowest", duration_threshold_slowest)

    @property
    @pulumi.getter(name="durationAvoidOveralerting")
    def duration_avoid_overalerting(self) -> 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting':
        """
        To avoid over-alerting do not alert for low traffic applications with less than
        """
        return pulumi.get(self, "duration_avoid_overalerting")

    @property
    @pulumi.getter(name="durationThresholdAll")
    def duration_threshold_all(self) -> 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll':
        """
        Alert if the action duration of all user actions degrades beyond **both** the absolute and relative threshold:
        """
        return pulumi.get(self, "duration_threshold_all")

    @property
    @pulumi.getter(name="durationThresholdSlowest")
    def duration_threshold_slowest(self) -> 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest':
        """
        Alert if the action duration of the slowest 10% of user actions degrades beyond **both** the absolute and relative threshold:
        """
        return pulumi.get(self, "duration_threshold_slowest")


@pulumi.output_type
class MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minActionRate":
            suggest = "min_action_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_action_rate: int):
        """
        :param int min_action_rate: no documentation available
        """
        pulumi.set(__self__, "min_action_rate", min_action_rate)

    @property
    @pulumi.getter(name="minActionRate")
    def min_action_rate(self) -> int:
        """
        no documentation available
        """
        return pulumi.get(self, "min_action_rate")


@pulumi.output_type
class MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationThreshold":
            suggest = "duration_threshold"
        elif key == "slowdownPercentage":
            suggest = "slowdown_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_threshold: float,
                 slowdown_percentage: float):
        """
        :param float duration_threshold: Absolute threshold
        :param float slowdown_percentage: Relative threshold
        """
        pulumi.set(__self__, "duration_threshold", duration_threshold)
        pulumi.set(__self__, "slowdown_percentage", slowdown_percentage)

    @property
    @pulumi.getter(name="durationThreshold")
    def duration_threshold(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "duration_threshold")

    @property
    @pulumi.getter(name="slowdownPercentage")
    def slowdown_percentage(self) -> float:
        """
        Relative threshold
        """
        return pulumi.get(self, "slowdown_percentage")


@pulumi.output_type
class MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationThreshold":
            suggest = "duration_threshold"
        elif key == "slowdownPercentage":
            suggest = "slowdown_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_threshold: float,
                 slowdown_percentage: float):
        """
        :param float duration_threshold: Absolute threshold
        :param float slowdown_percentage: Relative threshold
        """
        pulumi.set(__self__, "duration_threshold", duration_threshold)
        pulumi.set(__self__, "slowdown_percentage", slowdown_percentage)

    @property
    @pulumi.getter(name="durationThreshold")
    def duration_threshold(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "duration_threshold")

    @property
    @pulumi.getter(name="slowdownPercentage")
    def slowdown_percentage(self) -> float:
        """
        Relative threshold
        """
        return pulumi.get(self, "slowdown_percentage")


@pulumi.output_type
class MobileAppAnomaliesSlowUserActionsSlowUserActionsFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationAvoidOveralerting":
            suggest = "duration_avoid_overalerting"
        elif key == "durationThresholdAllFixed":
            suggest = "duration_threshold_all_fixed"
        elif key == "durationThresholdSlowest":
            suggest = "duration_threshold_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesSlowUserActionsSlowUserActionsFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_avoid_overalerting: 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting',
                 duration_threshold_all_fixed: 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed',
                 duration_threshold_slowest: 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest',
                 sensitivity: str):
        """
        :param 'MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralertingArgs' duration_avoid_overalerting: To avoid over-alerting do not alert for low traffic applications with less than
        :param 'MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixedArgs' duration_threshold_all_fixed: Alert if the action duration of all user actions degrades beyond the absolute threshold:
        :param 'MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowestArgs' duration_threshold_slowest: Alert if the action duration of the slowest 10% of user actions degrades beyond the absolute threshold:
        :param str sensitivity: Possible Values: `Low`, `Medium`, `High`
        """
        pulumi.set(__self__, "duration_avoid_overalerting", duration_avoid_overalerting)
        pulumi.set(__self__, "duration_threshold_all_fixed", duration_threshold_all_fixed)
        pulumi.set(__self__, "duration_threshold_slowest", duration_threshold_slowest)
        pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="durationAvoidOveralerting")
    def duration_avoid_overalerting(self) -> 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting':
        """
        To avoid over-alerting do not alert for low traffic applications with less than
        """
        return pulumi.get(self, "duration_avoid_overalerting")

    @property
    @pulumi.getter(name="durationThresholdAllFixed")
    def duration_threshold_all_fixed(self) -> 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed':
        """
        Alert if the action duration of all user actions degrades beyond the absolute threshold:
        """
        return pulumi.get(self, "duration_threshold_all_fixed")

    @property
    @pulumi.getter(name="durationThresholdSlowest")
    def duration_threshold_slowest(self) -> 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest':
        """
        Alert if the action duration of the slowest 10% of user actions degrades beyond the absolute threshold:
        """
        return pulumi.get(self, "duration_threshold_slowest")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        """
        Possible Values: `Low`, `Medium`, `High`
        """
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minActionRate":
            suggest = "min_action_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_action_rate: int):
        """
        :param int min_action_rate: no documentation available
        """
        pulumi.set(__self__, "min_action_rate", min_action_rate)

    @property
    @pulumi.getter(name="minActionRate")
    def min_action_rate(self) -> int:
        """
        no documentation available
        """
        return pulumi.get(self, "min_action_rate")


@pulumi.output_type
class MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationThreshold":
            suggest = "duration_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_threshold: float):
        """
        :param float duration_threshold: Absolute threshold
        """
        pulumi.set(__self__, "duration_threshold", duration_threshold)

    @property
    @pulumi.getter(name="durationThreshold")
    def duration_threshold(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "duration_threshold")


@pulumi.output_type
class MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationThreshold":
            suggest = "duration_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_threshold: float):
        """
        :param float duration_threshold: Absolute threshold
        """
        pulumi.set(__self__, "duration_threshold", duration_threshold)

    @property
    @pulumi.getter(name="durationThreshold")
    def duration_threshold(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "duration_threshold")


@pulumi.output_type
class MobileAppAnomaliesUnexpectedHighLoad(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdPercentage":
            suggest = "threshold_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesUnexpectedHighLoad. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesUnexpectedHighLoad.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesUnexpectedHighLoad.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 threshold_percentage: Optional[float] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param float threshold_percentage: Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic spikes within your application.
        """
        pulumi.set(__self__, "enabled", enabled)
        if threshold_percentage is not None:
            pulumi.set(__self__, "threshold_percentage", threshold_percentage)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="thresholdPercentage")
    def threshold_percentage(self) -> Optional[float]:
        """
        Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic spikes within your application.
        """
        return pulumi.get(self, "threshold_percentage")


@pulumi.output_type
class MobileAppAnomaliesUnexpectedLowLoad(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdPercentage":
            suggest = "threshold_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesUnexpectedLowLoad. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesUnexpectedLowLoad.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesUnexpectedLowLoad.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 threshold_percentage: Optional[float] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param float threshold_percentage: Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic drops within your application.
        """
        pulumi.set(__self__, "enabled", enabled)
        if threshold_percentage is not None:
            pulumi.set(__self__, "threshold_percentage", threshold_percentage)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="thresholdPercentage")
    def threshold_percentage(self) -> Optional[float]:
        """
        Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic drops within your application.
        """
        return pulumi.get(self, "threshold_percentage")


@pulumi.output_type
class MobileAppCrashRateCrashRateIncrease(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crashRateIncreaseAuto":
            suggest = "crash_rate_increase_auto"
        elif key == "crashRateIncreaseFixed":
            suggest = "crash_rate_increase_fixed"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppCrashRateCrashRateIncrease. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppCrashRateCrashRateIncrease.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppCrashRateCrashRateIncrease.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 crash_rate_increase_auto: Optional['outputs.MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto'] = None,
                 crash_rate_increase_fixed: Optional['outputs.MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseAutoArgs' crash_rate_increase_auto: Alert crash rate increases when auto-detected baseline is exceeded by a certain number of users
        :param 'MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseFixedArgs' crash_rate_increase_fixed: Alert crash rate increases when the defined threshold is exceeded by a certain number of users
        :param str detection_mode: Possible Values: `Auto`, `Fixed`
        """
        pulumi.set(__self__, "enabled", enabled)
        if crash_rate_increase_auto is not None:
            pulumi.set(__self__, "crash_rate_increase_auto", crash_rate_increase_auto)
        if crash_rate_increase_fixed is not None:
            pulumi.set(__self__, "crash_rate_increase_fixed", crash_rate_increase_fixed)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="crashRateIncreaseAuto")
    def crash_rate_increase_auto(self) -> Optional['outputs.MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto']:
        """
        Alert crash rate increases when auto-detected baseline is exceeded by a certain number of users
        """
        return pulumi.get(self, "crash_rate_increase_auto")

    @property
    @pulumi.getter(name="crashRateIncreaseFixed")
    def crash_rate_increase_fixed(self) -> Optional['outputs.MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed']:
        """
        Alert crash rate increases when the defined threshold is exceeded by a certain number of users
        """
        return pulumi.get(self, "crash_rate_increase_fixed")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Fixed`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baselineViolationPercentage":
            suggest = "baseline_violation_percentage"
        elif key == "concurrentUsers":
            suggest = "concurrent_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 baseline_violation_percentage: float,
                 concurrent_users: float,
                 sensitivity: str):
        """
        :param float baseline_violation_percentage: Dynatrace learns the typical crash rate for all app versions and will create an alert if the baseline is violated by more than a specified threshold. Analysis happens based on a sliding window of 10 minutes.
        :param float concurrent_users: Amount of users
        :param str sensitivity: Possible Values: `Low`, `Medium`, `High`
        """
        pulumi.set(__self__, "baseline_violation_percentage", baseline_violation_percentage)
        pulumi.set(__self__, "concurrent_users", concurrent_users)
        pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="baselineViolationPercentage")
    def baseline_violation_percentage(self) -> float:
        """
        Dynatrace learns the typical crash rate for all app versions and will create an alert if the baseline is violated by more than a specified threshold. Analysis happens based on a sliding window of 10 minutes.
        """
        return pulumi.get(self, "baseline_violation_percentage")

    @property
    @pulumi.getter(name="concurrentUsers")
    def concurrent_users(self) -> float:
        """
        Amount of users
        """
        return pulumi.get(self, "concurrent_users")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        """
        Possible Values: `Low`, `Medium`, `High`
        """
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "absoluteCrashRate":
            suggest = "absolute_crash_rate"
        elif key == "concurrentUsers":
            suggest = "concurrent_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 absolute_crash_rate: float,
                 concurrent_users: int):
        """
        :param float absolute_crash_rate: Absolute threshold
        :param int concurrent_users: Amount of users
        """
        pulumi.set(__self__, "absolute_crash_rate", absolute_crash_rate)
        pulumi.set(__self__, "concurrent_users", concurrent_users)

    @property
    @pulumi.getter(name="absoluteCrashRate")
    def absolute_crash_rate(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "absolute_crash_rate")

    @property
    @pulumi.getter(name="concurrentUsers")
    def concurrent_users(self) -> int:
        """
        Amount of users
        """
        return pulumi.get(self, "concurrent_users")


@pulumi.output_type
class MobileAppEnablementRum(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costAndTrafficControl":
            suggest = "cost_and_traffic_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppEnablementRum. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppEnablementRum.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppEnablementRum.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_and_traffic_control: int,
                 enabled: bool):
        """
        :param int cost_and_traffic_control: Percentage of user sessions captured and analyzed. By default, Dynatrace captures all user actions and user sessions for analysis. This approach ensures complete insight into your application’s performance and customer experience. You can optionally reduce the granularity of user-action and user-session analysis by capturing a lower percentage of user sessions. While this approach can reduce monitoring costs, it also results in lower visibility into how your customers are using your applications. For example, a setting of 10% results in Dynatrace analyzing only every tenth user session.
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        """
        pulumi.set(__self__, "cost_and_traffic_control", cost_and_traffic_control)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="costAndTrafficControl")
    def cost_and_traffic_control(self) -> int:
        """
        Percentage of user sessions captured and analyzed. By default, Dynatrace captures all user actions and user sessions for analysis. This approach ensures complete insight into your application’s performance and customer experience. You can optionally reduce the granularity of user-action and user-session analysis by capturing a lower percentage of user sessions. While this approach can reduce monitoring costs, it also results in lower visibility into how your customers are using your applications. For example, a setting of 10% results in Dynatrace analyzing only every tenth user session.
        """
        return pulumi.get(self, "cost_and_traffic_control")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class MobileAppEnablementSessionReplay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onCrash":
            suggest = "on_crash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppEnablementSessionReplay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppEnablementSessionReplay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppEnablementSessionReplay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_crash: bool):
        """
        :param bool on_crash: Before enabling, Dynatrace checks your system against the [prerequisites for Session Replay](https://dt-url.net/t23s0ppi).
        """
        pulumi.set(__self__, "on_crash", on_crash)

    @property
    @pulumi.getter(name="onCrash")
    def on_crash(self) -> bool:
        """
        Before enabling, Dynatrace checks your system against the [prerequisites for Session Replay](https://dt-url.net/t23s0ppi).
        """
        return pulumi.get(self, "on_crash")


@pulumi.output_type
class MobileAppKeyPerformanceThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frustratingThresholdSeconds":
            suggest = "frustrating_threshold_seconds"
        elif key == "tolerableThresholdSeconds":
            suggest = "tolerable_threshold_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppKeyPerformanceThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppKeyPerformanceThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppKeyPerformanceThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frustrating_threshold_seconds: float,
                 tolerable_threshold_seconds: float):
        """
        :param float frustrating_threshold_seconds: If the action duration is above this value, the Apdex is considered to be **Frustrating**.
        :param float tolerable_threshold_seconds: If the action duration is below this value, the Apdex is considered to be **Satisfactory**.
        """
        pulumi.set(__self__, "frustrating_threshold_seconds", frustrating_threshold_seconds)
        pulumi.set(__self__, "tolerable_threshold_seconds", tolerable_threshold_seconds)

    @property
    @pulumi.getter(name="frustratingThresholdSeconds")
    def frustrating_threshold_seconds(self) -> float:
        """
        If the action duration is above this value, the Apdex is considered to be **Frustrating**.
        """
        return pulumi.get(self, "frustrating_threshold_seconds")

    @property
    @pulumi.getter(name="tolerableThresholdSeconds")
    def tolerable_threshold_seconds(self) -> float:
        """
        If the action duration is below this value, the Apdex is considered to be **Satisfactory**.
        """
        return pulumi.get(self, "tolerable_threshold_seconds")


@pulumi.output_type
class MobileAppRequestErrorsErrorRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorRules":
            suggest = "error_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppRequestErrorsErrorRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppRequestErrorsErrorRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppRequestErrorsErrorRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_rules: Sequence['outputs.MobileAppRequestErrorsErrorRulesErrorRule']):
        pulumi.set(__self__, "error_rules", error_rules)

    @property
    @pulumi.getter(name="errorRules")
    def error_rules(self) -> Sequence['outputs.MobileAppRequestErrorsErrorRulesErrorRule']:
        return pulumi.get(self, "error_rules")


@pulumi.output_type
class MobileAppRequestErrorsErrorRulesErrorRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorCodes":
            suggest = "error_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppRequestErrorsErrorRulesErrorRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppRequestErrorsErrorRulesErrorRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppRequestErrorsErrorRulesErrorRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_codes: str):
        """
        :param str error_codes: Exclude response codes
        """
        pulumi.set(__self__, "error_codes", error_codes)

    @property
    @pulumi.getter(name="errorCodes")
    def error_codes(self) -> str:
        """
        Exclude response codes
        """
        return pulumi.get(self, "error_codes")


@pulumi.output_type
class MobileApplicationApdex(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frustratedOnError":
            suggest = "frustrated_on_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileApplicationApdex. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileApplicationApdex.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileApplicationApdex.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frustrated: int,
                 tolerable: int,
                 frustrated_on_error: Optional[bool] = None):
        """
        :param int frustrated: Apdex **frustrated** threshold, in milliseconds: a duration greater than or equal to this value is considered frustrated
        :param int tolerable: Apdex **tolerable** threshold, in milliseconds: a duration greater than or equal to this value is considered tolerable
        :param bool frustrated_on_error: Apdex error condition: if `true` the user session is considered frustrated when an error is reported
        """
        pulumi.set(__self__, "frustrated", frustrated)
        pulumi.set(__self__, "tolerable", tolerable)
        if frustrated_on_error is not None:
            pulumi.set(__self__, "frustrated_on_error", frustrated_on_error)

    @property
    @pulumi.getter
    def frustrated(self) -> int:
        """
        Apdex **frustrated** threshold, in milliseconds: a duration greater than or equal to this value is considered frustrated
        """
        return pulumi.get(self, "frustrated")

    @property
    @pulumi.getter
    def tolerable(self) -> int:
        """
        Apdex **tolerable** threshold, in milliseconds: a duration greater than or equal to this value is considered tolerable
        """
        return pulumi.get(self, "tolerable")

    @property
    @pulumi.getter(name="frustratedOnError")
    def frustrated_on_error(self) -> Optional[bool]:
        """
        Apdex error condition: if `true` the user session is considered frustrated when an error is reported
        """
        return pulumi.get(self, "frustrated_on_error")


@pulumi.output_type
class MobileApplicationProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiValues":
            suggest = "api_values"
        elif key == "requestAttributes":
            suggest = "request_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileApplicationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileApplicationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileApplicationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_values: Optional[Sequence['outputs.MobileApplicationPropertiesApiValue']] = None,
                 request_attributes: Optional[Sequence['outputs.MobileApplicationPropertiesRequestAttribute']] = None):
        """
        :param Sequence['MobileApplicationPropertiesApiValueArgs'] api_values: A User Action / Session Property based on a value reported by the API
        :param Sequence['MobileApplicationPropertiesRequestAttributeArgs'] request_attributes: A User Action / Session Property based on a Server Side Request Attribute
        """
        if api_values is not None:
            pulumi.set(__self__, "api_values", api_values)
        if request_attributes is not None:
            pulumi.set(__self__, "request_attributes", request_attributes)

    @property
    @pulumi.getter(name="apiValues")
    def api_values(self) -> Optional[Sequence['outputs.MobileApplicationPropertiesApiValue']]:
        """
        A User Action / Session Property based on a value reported by the API
        """
        return pulumi.get(self, "api_values")

    @property
    @pulumi.getter(name="requestAttributes")
    def request_attributes(self) -> Optional[Sequence['outputs.MobileApplicationPropertiesRequestAttribute']]:
        """
        A User Action / Session Property based on a Server Side Request Attribute
        """
        return pulumi.get(self, "request_attributes")


@pulumi.output_type
class MobileApplicationPropertiesApiValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupRule":
            suggest = "cleanup_rule"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "storeAsSessionProperty":
            suggest = "store_as_session_property"
        elif key == "storeAsUserActionProperty":
            suggest = "store_as_user_action_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileApplicationPropertiesApiValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileApplicationPropertiesApiValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileApplicationPropertiesApiValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 type: str,
                 aggregation: Optional[str] = None,
                 cleanup_rule: Optional[str] = None,
                 display_name: Optional[str] = None,
                 name: Optional[str] = None,
                 store_as_session_property: Optional[bool] = None,
                 store_as_user_action_property: Optional[bool] = None):
        """
        :param str key: The unique key of the mobile session or user action property
        :param str type: The data type of the property. Possible values are `DOUBLE`, `LONG` and `STRING`
        :param str aggregation: The aggregation type of the property. It defines how multiple values of the property are aggregated. Possible values are `SUM`, `MIN`, `MAX`, `FIRST` and `LAST`
        :param str cleanup_rule: The cleanup rule of the property. Defines how to extract the data you need from a string value. Specify the [regular expression](https://dt-url.net/k9e0iaq) for the data you need there
        :param str display_name: The display name of the property
        :param str name: The name of the reported value
        :param bool store_as_session_property: If `true`, the property is stored as a session property
        :param bool store_as_user_action_property: If `true`, the property is stored as a user action property
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if cleanup_rule is not None:
            pulumi.set(__self__, "cleanup_rule", cleanup_rule)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if store_as_session_property is not None:
            pulumi.set(__self__, "store_as_session_property", store_as_session_property)
        if store_as_user_action_property is not None:
            pulumi.set(__self__, "store_as_user_action_property", store_as_user_action_property)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The unique key of the mobile session or user action property
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The data type of the property. Possible values are `DOUBLE`, `LONG` and `STRING`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        The aggregation type of the property. It defines how multiple values of the property are aggregated. Possible values are `SUM`, `MIN`, `MAX`, `FIRST` and `LAST`
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="cleanupRule")
    def cleanup_rule(self) -> Optional[str]:
        """
        The cleanup rule of the property. Defines how to extract the data you need from a string value. Specify the [regular expression](https://dt-url.net/k9e0iaq) for the data you need there
        """
        return pulumi.get(self, "cleanup_rule")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The display name of the property
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the reported value
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="storeAsSessionProperty")
    def store_as_session_property(self) -> Optional[bool]:
        """
        If `true`, the property is stored as a session property
        """
        return pulumi.get(self, "store_as_session_property")

    @property
    @pulumi.getter(name="storeAsUserActionProperty")
    def store_as_user_action_property(self) -> Optional[bool]:
        """
        If `true`, the property is stored as a user action property
        """
        return pulumi.get(self, "store_as_user_action_property")


@pulumi.output_type
class MobileApplicationPropertiesRequestAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupRule":
            suggest = "cleanup_rule"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "storeAsSessionProperty":
            suggest = "store_as_session_property"
        elif key == "storeAsUserActionProperty":
            suggest = "store_as_user_action_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileApplicationPropertiesRequestAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileApplicationPropertiesRequestAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileApplicationPropertiesRequestAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 key: str,
                 type: str,
                 aggregation: Optional[str] = None,
                 cleanup_rule: Optional[str] = None,
                 display_name: Optional[str] = None,
                 store_as_session_property: Optional[bool] = None,
                 store_as_user_action_property: Optional[bool] = None):
        """
        :param str id: The ID of the request attribute
        :param str key: The unique key of the mobile session or user action property
        :param str type: The data type of the property. Possible values are `DOUBLE`, `LONG` and `STRING`. The value MUST match the data type of the Request Attribute.
        :param str aggregation: The aggregation type of the property. It defines how multiple values of the property are aggregated. Possible values are `SUM`, `MIN`, `MAX`, `FIRST` and `LAST`
        :param str cleanup_rule: The cleanup rule of the property. Defines how to extract the data you need from a string value. Specify the [regular expression](https://dt-url.net/k9e0iaq) for the data you need there
        :param str display_name: The display name of the property
        :param bool store_as_session_property: If `true`, the property is stored as a session property
        :param bool store_as_user_action_property: If `true`, the property is stored as a user action property
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if cleanup_rule is not None:
            pulumi.set(__self__, "cleanup_rule", cleanup_rule)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if store_as_session_property is not None:
            pulumi.set(__self__, "store_as_session_property", store_as_session_property)
        if store_as_user_action_property is not None:
            pulumi.set(__self__, "store_as_user_action_property", store_as_user_action_property)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the request attribute
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The unique key of the mobile session or user action property
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The data type of the property. Possible values are `DOUBLE`, `LONG` and `STRING`. The value MUST match the data type of the Request Attribute.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        The aggregation type of the property. It defines how multiple values of the property are aggregated. Possible values are `SUM`, `MIN`, `MAX`, `FIRST` and `LAST`
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="cleanupRule")
    def cleanup_rule(self) -> Optional[str]:
        """
        The cleanup rule of the property. Defines how to extract the data you need from a string value. Specify the [regular expression](https://dt-url.net/k9e0iaq) for the data you need there
        """
        return pulumi.get(self, "cleanup_rule")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The display name of the property
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="storeAsSessionProperty")
    def store_as_session_property(self) -> Optional[bool]:
        """
        If `true`, the property is stored as a session property
        """
        return pulumi.get(self, "store_as_session_property")

    @property
    @pulumi.getter(name="storeAsUserActionProperty")
    def store_as_user_action_property(self) -> Optional[bool]:
        """
        If `true`, the property is stored as a user action property
        """
        return pulumi.get(self, "store_as_user_action_property")


@pulumi.output_type
class NetworkMonitorOutageHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "globalConsecutiveOutageCountThreshold":
            suggest = "global_consecutive_outage_count_threshold"
        elif key == "globalOutages":
            suggest = "global_outages"
        elif key == "localConsecutiveOutageCountThreshold":
            suggest = "local_consecutive_outage_count_threshold"
        elif key == "localLocationOutageCountThreshold":
            suggest = "local_location_outage_count_threshold"
        elif key == "localOutages":
            suggest = "local_outages"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkMonitorOutageHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkMonitorOutageHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkMonitorOutageHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 global_consecutive_outage_count_threshold: Optional[int] = None,
                 global_outages: Optional[bool] = None,
                 local_consecutive_outage_count_threshold: Optional[int] = None,
                 local_location_outage_count_threshold: Optional[int] = None,
                 local_outages: Optional[bool] = None):
        """
        :param int global_consecutive_outage_count_threshold: Number of consecutive failures for all locations
        :param bool global_outages: Generate a problem and send an alert when the monitor is unavailable at all configured locations
        :param int local_consecutive_outage_count_threshold: Number of consecutive failures
        :param int local_location_outage_count_threshold: Number of failing locations
        :param bool local_outages: Generate a problem and send an alert when the monitor is unavailable for one or more consecutive runs at any location
        """
        if global_consecutive_outage_count_threshold is not None:
            pulumi.set(__self__, "global_consecutive_outage_count_threshold", global_consecutive_outage_count_threshold)
        if global_outages is not None:
            pulumi.set(__self__, "global_outages", global_outages)
        if local_consecutive_outage_count_threshold is not None:
            pulumi.set(__self__, "local_consecutive_outage_count_threshold", local_consecutive_outage_count_threshold)
        if local_location_outage_count_threshold is not None:
            pulumi.set(__self__, "local_location_outage_count_threshold", local_location_outage_count_threshold)
        if local_outages is not None:
            pulumi.set(__self__, "local_outages", local_outages)

    @property
    @pulumi.getter(name="globalConsecutiveOutageCountThreshold")
    def global_consecutive_outage_count_threshold(self) -> Optional[int]:
        """
        Number of consecutive failures for all locations
        """
        return pulumi.get(self, "global_consecutive_outage_count_threshold")

    @property
    @pulumi.getter(name="globalOutages")
    def global_outages(self) -> Optional[bool]:
        """
        Generate a problem and send an alert when the monitor is unavailable at all configured locations
        """
        return pulumi.get(self, "global_outages")

    @property
    @pulumi.getter(name="localConsecutiveOutageCountThreshold")
    def local_consecutive_outage_count_threshold(self) -> Optional[int]:
        """
        Number of consecutive failures
        """
        return pulumi.get(self, "local_consecutive_outage_count_threshold")

    @property
    @pulumi.getter(name="localLocationOutageCountThreshold")
    def local_location_outage_count_threshold(self) -> Optional[int]:
        """
        Number of failing locations
        """
        return pulumi.get(self, "local_location_outage_count_threshold")

    @property
    @pulumi.getter(name="localOutages")
    def local_outages(self) -> Optional[bool]:
        """
        Generate a problem and send an alert when the monitor is unavailable for one or more consecutive runs at any location
        """
        return pulumi.get(self, "local_outages")


@pulumi.output_type
class NetworkMonitorPerformanceThresholds(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 thresholds: Optional['outputs.NetworkMonitorPerformanceThresholdsThresholds'] = None):
        """
        :param bool enabled: Performance threshold is enabled (true) or disabled (false)
        :param 'NetworkMonitorPerformanceThresholdsThresholdsArgs' thresholds: The list of performance threshold rules
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Performance threshold is enabled (true) or disabled (false)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.NetworkMonitorPerformanceThresholdsThresholds']:
        """
        The list of performance threshold rules
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class NetworkMonitorPerformanceThresholdsThresholds(dict):
    def __init__(__self__, *,
                 thresholds: Optional[Sequence['outputs.NetworkMonitorPerformanceThresholdsThresholdsThreshold']] = None):
        """
        :param Sequence['NetworkMonitorPerformanceThresholdsThresholdsThresholdArgs'] thresholds: The list of performance threshold rules
        """
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def thresholds(self) -> Optional[Sequence['outputs.NetworkMonitorPerformanceThresholdsThresholdsThreshold']]:
        """
        The list of performance threshold rules
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class NetworkMonitorPerformanceThresholdsThresholdsThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "stepIndex":
            suggest = "step_index"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkMonitorPerformanceThresholdsThresholdsThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkMonitorPerformanceThresholdsThresholdsThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkMonitorPerformanceThresholdsThresholdsThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation: Optional[str] = None,
                 dealerting_samples: Optional[int] = None,
                 samples: Optional[int] = None,
                 step_index: Optional[int] = None,
                 threshold: Optional[int] = None,
                 violating_samples: Optional[int] = None):
        """
        :param str aggregation: Aggregation type, possible values: `AVG`, `MAX`, `MIN`
        :param int dealerting_samples: Number of most recent non-violating request executions that closes the problem
        :param int samples: Number of request executions in analyzed sliding window (sliding window size)
        :param int step_index: Specify the step's index to which a threshold applies
        :param int threshold: Notify if monitor request takes longer than X milliseconds to execute
        :param int violating_samples: Number of violating request executions in analyzed sliding window
        """
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if dealerting_samples is not None:
            pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        if samples is not None:
            pulumi.set(__self__, "samples", samples)
        if step_index is not None:
            pulumi.set(__self__, "step_index", step_index)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if violating_samples is not None:
            pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        Aggregation type, possible values: `AVG`, `MAX`, `MIN`
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> Optional[int]:
        """
        Number of most recent non-violating request executions that closes the problem
        """
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter
    def samples(self) -> Optional[int]:
        """
        Number of request executions in analyzed sliding window (sliding window size)
        """
        return pulumi.get(self, "samples")

    @property
    @pulumi.getter(name="stepIndex")
    def step_index(self) -> Optional[int]:
        """
        Specify the step's index to which a threshold applies
        """
        return pulumi.get(self, "step_index")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[int]:
        """
        Notify if monitor request takes longer than X milliseconds to execute
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> Optional[int]:
        """
        Number of violating request executions in analyzed sliding window
        """
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class NetworkMonitorStep(dict):
    def __init__(__self__, *,
                 steps: Sequence['outputs.NetworkMonitorStepStep']):
        """
        :param Sequence['NetworkMonitorStepStepArgs'] steps: The step of a network availability monitor
        """
        pulumi.set(__self__, "steps", steps)

    @property
    @pulumi.getter
    def steps(self) -> Sequence['outputs.NetworkMonitorStepStep']:
        """
        The step of a network availability monitor
        """
        return pulumi.get(self, "steps")


@pulumi.output_type
class NetworkMonitorStepStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestType":
            suggest = "request_type"
        elif key == "targetLists":
            suggest = "target_lists"
        elif key == "requestConfigurations":
            suggest = "request_configurations"
        elif key == "targetFilter":
            suggest = "target_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkMonitorStepStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkMonitorStepStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkMonitorStepStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 constraints: Sequence['outputs.NetworkMonitorStepStepConstraint'],
                 name: str,
                 properties: Mapping[str, str],
                 request_type: str,
                 target_lists: Sequence[str],
                 request_configurations: Optional[Sequence['outputs.NetworkMonitorStepStepRequestConfiguration']] = None,
                 target_filter: Optional[str] = None):
        """
        :param Sequence['NetworkMonitorStepStepConstraintArgs'] constraints: The list of constraints which apply to all requests in the step
        :param str name: Step name
        :param Mapping[str, str] properties: Key/value pairs of properties which apply to all requests in the step
        :param str request_type: Request type, possible values `ICMP`, `TCP`, `DNS`
        :param Sequence[str] target_lists: Target list
        :param Sequence['NetworkMonitorStepStepRequestConfigurationArgs'] request_configurations: Request configurations
        :param str target_filter: Target filter
        """
        pulumi.set(__self__, "constraints", constraints)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "request_type", request_type)
        pulumi.set(__self__, "target_lists", target_lists)
        if request_configurations is not None:
            pulumi.set(__self__, "request_configurations", request_configurations)
        if target_filter is not None:
            pulumi.set(__self__, "target_filter", target_filter)

    @property
    @pulumi.getter
    def constraints(self) -> Sequence['outputs.NetworkMonitorStepStepConstraint']:
        """
        The list of constraints which apply to all requests in the step
        """
        return pulumi.get(self, "constraints")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Step name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def properties(self) -> Mapping[str, str]:
        """
        Key/value pairs of properties which apply to all requests in the step
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> str:
        """
        Request type, possible values `ICMP`, `TCP`, `DNS`
        """
        return pulumi.get(self, "request_type")

    @property
    @pulumi.getter(name="targetLists")
    def target_lists(self) -> Sequence[str]:
        """
        Target list
        """
        return pulumi.get(self, "target_lists")

    @property
    @pulumi.getter(name="requestConfigurations")
    def request_configurations(self) -> Optional[Sequence['outputs.NetworkMonitorStepStepRequestConfiguration']]:
        """
        Request configurations
        """
        return pulumi.get(self, "request_configurations")

    @property
    @pulumi.getter(name="targetFilter")
    def target_filter(self) -> Optional[str]:
        """
        Target filter
        """
        return pulumi.get(self, "target_filter")


@pulumi.output_type
class NetworkMonitorStepStepConstraint(dict):
    def __init__(__self__, *,
                 constraints: Sequence['outputs.NetworkMonitorStepStepConstraintConstraint']):
        """
        :param Sequence['NetworkMonitorStepStepConstraintConstraintArgs'] constraints: The network availability monitor constraint
        """
        pulumi.set(__self__, "constraints", constraints)

    @property
    @pulumi.getter
    def constraints(self) -> Sequence['outputs.NetworkMonitorStepStepConstraintConstraint']:
        """
        The network availability monitor constraint
        """
        return pulumi.get(self, "constraints")


@pulumi.output_type
class NetworkMonitorStepStepConstraintConstraint(dict):
    def __init__(__self__, *,
                 properties: Mapping[str, str],
                 type: str):
        """
        :param Mapping[str, str] properties: Key/value pairs of constraint properties
        :param str type: Constraint type
        """
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def properties(self) -> Mapping[str, str]:
        """
        Key/value pairs of constraint properties
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Constraint type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworkMonitorStepStepRequestConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestConfigurations":
            suggest = "request_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkMonitorStepStepRequestConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkMonitorStepStepRequestConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkMonitorStepStepRequestConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_configurations: Sequence['outputs.NetworkMonitorStepStepRequestConfigurationRequestConfiguration']):
        """
        :param Sequence['NetworkMonitorStepStepRequestConfigurationRequestConfigurationArgs'] request_configurations: The configuration of a network availability monitor request
        """
        pulumi.set(__self__, "request_configurations", request_configurations)

    @property
    @pulumi.getter(name="requestConfigurations")
    def request_configurations(self) -> Sequence['outputs.NetworkMonitorStepStepRequestConfigurationRequestConfiguration']:
        """
        The configuration of a network availability monitor request
        """
        return pulumi.get(self, "request_configurations")


@pulumi.output_type
class NetworkMonitorStepStepRequestConfigurationRequestConfiguration(dict):
    def __init__(__self__, *,
                 constraints: Optional[Sequence['outputs.NetworkMonitorStepStepRequestConfigurationRequestConfigurationConstraint']] = None):
        """
        :param Sequence['NetworkMonitorStepStepRequestConfigurationRequestConfigurationConstraintArgs'] constraints: Request constraints
        """
        if constraints is not None:
            pulumi.set(__self__, "constraints", constraints)

    @property
    @pulumi.getter
    def constraints(self) -> Optional[Sequence['outputs.NetworkMonitorStepStepRequestConfigurationRequestConfigurationConstraint']]:
        """
        Request constraints
        """
        return pulumi.get(self, "constraints")


@pulumi.output_type
class NetworkMonitorStepStepRequestConfigurationRequestConfigurationConstraint(dict):
    def __init__(__self__, *,
                 constraints: Sequence['outputs.NetworkMonitorStepStepRequestConfigurationRequestConfigurationConstraintConstraint']):
        """
        :param Sequence['NetworkMonitorStepStepRequestConfigurationRequestConfigurationConstraintConstraintArgs'] constraints: The network availability monitor constraint
        """
        pulumi.set(__self__, "constraints", constraints)

    @property
    @pulumi.getter
    def constraints(self) -> Sequence['outputs.NetworkMonitorStepStepRequestConfigurationRequestConfigurationConstraintConstraint']:
        """
        The network availability monitor constraint
        """
        return pulumi.get(self, "constraints")


@pulumi.output_type
class NetworkMonitorStepStepRequestConfigurationRequestConfigurationConstraintConstraint(dict):
    def __init__(__self__, *,
                 properties: Mapping[str, str],
                 type: str):
        """
        :param Mapping[str, str] properties: Key/value pairs of constraint properties
        :param str type: Constraint type
        """
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def properties(self) -> Mapping[str, str]:
        """
        Key/value pairs of constraint properties
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Constraint type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworkMonitorTag(dict):
    def __init__(__self__, *,
                 tags: Optional[Sequence['outputs.NetworkMonitorTagTag']] = None):
        """
        :param Sequence['NetworkMonitorTagTagArgs'] tags: Tag with source of a Dynatrace entity.
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.NetworkMonitorTagTag']]:
        """
        Tag with source of a Dynatrace entity.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class NetworkMonitorTagTag(dict):
    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 source: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key of the tag
        :param str context: The origin of the tag, such as AWS or Cloud Foundry.
        :param str source: The source of the tag, possible values: `AUTO`, `RULE_BASED` or `USER`
        :param str value: The value of the tag
        """
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        The origin of the tag, such as AWS or Cloud Foundry.
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        The source of the tag, possible values: `AUTO`, `RULE_BASED` or `USER`
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NetworkTrafficExcludeIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddressForms":
            suggest = "ip_address_forms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkTrafficExcludeIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkTrafficExcludeIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkTrafficExcludeIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address_forms: Sequence['outputs.NetworkTrafficExcludeIpIpAddressForm']):
        pulumi.set(__self__, "ip_address_forms", ip_address_forms)

    @property
    @pulumi.getter(name="ipAddressForms")
    def ip_address_forms(self) -> Sequence['outputs.NetworkTrafficExcludeIpIpAddressForm']:
        return pulumi.get(self, "ip_address_forms")


@pulumi.output_type
class NetworkTrafficExcludeIpIpAddressForm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkTrafficExcludeIpIpAddressForm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkTrafficExcludeIpIpAddressForm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkTrafficExcludeIpIpAddressForm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: str):
        """
        :param str ip_address: IP address
        """
        pulumi.set(__self__, "ip_address", ip_address)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        IP address
        """
        return pulumi.get(self, "ip_address")


@pulumi.output_type
class NetworkTrafficExcludeNic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nicForms":
            suggest = "nic_forms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkTrafficExcludeNic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkTrafficExcludeNic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkTrafficExcludeNic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nic_forms: Sequence['outputs.NetworkTrafficExcludeNicNicForm']):
        pulumi.set(__self__, "nic_forms", nic_forms)

    @property
    @pulumi.getter(name="nicForms")
    def nic_forms(self) -> Sequence['outputs.NetworkTrafficExcludeNicNicForm']:
        return pulumi.get(self, "nic_forms")


@pulumi.output_type
class NetworkTrafficExcludeNicNicForm(dict):
    def __init__(__self__, *,
                 interface: str,
                 os: str):
        """
        :param str interface: Network interface
        :param str os: Possible Values: `OS_TYPE_AIX`, `OS_TYPE_DARWIN`, `OS_TYPE_HPUX`, `OS_TYPE_LINUX`, `OS_TYPE_SOLARIS`, `OS_TYPE_UNKNOWN`, `OS_TYPE_WINDOWS`, `OS_TYPE_ZOS`
        """
        pulumi.set(__self__, "interface", interface)
        pulumi.set(__self__, "os", os)

    @property
    @pulumi.getter
    def interface(self) -> str:
        """
        Network interface
        """
        return pulumi.get(self, "interface")

    @property
    @pulumi.getter
    def os(self) -> str:
        """
        Possible Values: `OS_TYPE_AIX`, `OS_TYPE_DARWIN`, `OS_TYPE_HPUX`, `OS_TYPE_LINUX`, `OS_TYPE_SOLARIS`, `OS_TYPE_UNKNOWN`, `OS_TYPE_WINDOWS`, `OS_TYPE_ZOS`
        """
        return pulumi.get(self, "os")


@pulumi.output_type
class NotificationAnsibleTower(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptAnyCertificate":
            suggest = "accept_any_certificate"
        elif key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "customMessage":
            suggest = "custom_message"
        elif key == "jobTemplateId":
            suggest = "job_template_id"
        elif key == "jobTemplateUrl":
            suggest = "job_template_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationAnsibleTower. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationAnsibleTower.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationAnsibleTower.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept_any_certificate: bool,
                 active: bool,
                 alerting_profile: str,
                 custom_message: str,
                 job_template_id: int,
                 job_template_url: str,
                 name: str,
                 username: str,
                 password: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool accept_any_certificate: Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str custom_message: The custom message of the notification.   This message will be displayed in the extra variables **Message** field of your job template.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param int job_template_id: The ID of the target Ansible Tower job template
        :param str job_template_url: The URL of the target Ansible Tower job template
        :param str name: The name of the notification configuration
        :param str username: The username of the Ansible Tower account
        :param str password: The password for the Ansible Tower account
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "accept_any_certificate", accept_any_certificate)
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "custom_message", custom_message)
        pulumi.set(__self__, "job_template_id", job_template_id)
        pulumi.set(__self__, "job_template_url", job_template_url)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "username", username)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="acceptAnyCertificate")
    def accept_any_certificate(self) -> bool:
        """
        Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
        """
        return pulumi.get(self, "accept_any_certificate")

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter(name="customMessage")
    def custom_message(self) -> str:
        """
        The custom message of the notification.   This message will be displayed in the extra variables **Message** field of your job template.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "custom_message")

    @property
    @pulumi.getter(name="jobTemplateId")
    def job_template_id(self) -> int:
        """
        The ID of the target Ansible Tower job template
        """
        return pulumi.get(self, "job_template_id")

    @property
    @pulumi.getter(name="jobTemplateUrl")
    def job_template_url(self) -> str:
        """
        The URL of the target Ansible Tower job template
        """
        return pulumi.get(self, "job_template_url")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username of the Ansible Tower account
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password for the Ansible Tower account
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 name: str,
                 type: str,
                 unknowns: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str name: The name of the notification configuration
        :param str type: Defines the actual set of fields depending on the value. See one of the following objects:  * `EMAIL` > EmailNotificationConfig  * `PAGER_DUTY` > PagerDutyNotificationConfig  * `WEBHOOK` > WebHookNotificationConfig  * `SLACK` > SlackNotificationConfig  * `HIPCHAT` > HipChatNotificationConfig  * `VICTOROPS` > VictorOpsNotificationConfig  * `SERVICE_NOW` > ServiceNowNotificationConfig  * `XMATTERS` > XMattersNotificationConfig  * `ANSIBLETOWER` > AnsibleTowerNotificationConfig  * `OPS_GENIE` > OpsGenieNotificationConfig  * `JIRA` > JiraNotificationConfig  * `TRELLO` > TrelloNotificationConfig
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines the actual set of fields depending on the value. See one of the following objects:  * `EMAIL` > EmailNotificationConfig  * `PAGER_DUTY` > PagerDutyNotificationConfig  * `WEBHOOK` > WebHookNotificationConfig  * `SLACK` > SlackNotificationConfig  * `HIPCHAT` > HipChatNotificationConfig  * `VICTOROPS` > VictorOpsNotificationConfig  * `SERVICE_NOW` > ServiceNowNotificationConfig  * `XMATTERS` > XMattersNotificationConfig  * `ANSIBLETOWER` > AnsibleTowerNotificationConfig  * `OPS_GENIE` > OpsGenieNotificationConfig  * `JIRA` > JiraNotificationConfig  * `TRELLO` > TrelloNotificationConfig
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "bccReceivers":
            suggest = "bcc_receivers"
        elif key == "ccReceivers":
            suggest = "cc_receivers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 body: str,
                 name: str,
                 subject: str,
                 bcc_receivers: Optional[Sequence[str]] = None,
                 cc_receivers: Optional[Sequence[str]] = None,
                 receivers: Optional[Sequence[str]] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str body: The template of the email notification.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str name: The name of the notification configuration
        :param str subject: The subject of the email notifications
        :param Sequence[str] bcc_receivers: The list of the email BCC-recipients
        :param Sequence[str] cc_receivers: The list of the email CC-recipients
        :param Sequence[str] receivers: The list of the email recipients
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject", subject)
        if bcc_receivers is not None:
            pulumi.set(__self__, "bcc_receivers", bcc_receivers)
        if cc_receivers is not None:
            pulumi.set(__self__, "cc_receivers", cc_receivers)
        if receivers is not None:
            pulumi.set(__self__, "receivers", receivers)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def body(self) -> str:
        """
        The template of the email notification.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        The subject of the email notifications
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="bccReceivers")
    def bcc_receivers(self) -> Optional[Sequence[str]]:
        """
        The list of the email BCC-recipients
        """
        return pulumi.get(self, "bcc_receivers")

    @property
    @pulumi.getter(name="ccReceivers")
    def cc_receivers(self) -> Optional[Sequence[str]]:
        """
        The list of the email CC-recipients
        """
        return pulumi.get(self, "cc_receivers")

    @property
    @pulumi.getter
    def receivers(self) -> Optional[Sequence[str]]:
        """
        The list of the email recipients
        """
        return pulumi.get(self, "receivers")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationJira(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "issueType":
            suggest = "issue_type"
        elif key == "projectKey":
            suggest = "project_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationJira. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationJira.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationJira.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 description: str,
                 issue_type: str,
                 name: str,
                 project_key: str,
                 summary: str,
                 url: str,
                 username: str,
                 password: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str description: The description of the Jira issue to be created by this notification.   You can use same placeholders as in issue summary
        :param str issue_type: The type of the Jira issue to be created by this notification
        :param str name: The name of the notification configuration
        :param str project_key: The project key of the Jira issue to be created by this notification
        :param str summary: The summary of the Jira issue to be created by this notification.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str url: The URL of the Jira API endpoint
        :param str username: The username of the Jira profile
        :param str password: The password for the Jira profile
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "issue_type", issue_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_key", project_key)
        pulumi.set(__self__, "summary", summary)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the Jira issue to be created by this notification.   You can use same placeholders as in issue summary
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="issueType")
    def issue_type(self) -> str:
        """
        The type of the Jira issue to be created by this notification
        """
        return pulumi.get(self, "issue_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> str:
        """
        The project key of the Jira issue to be created by this notification
        """
        return pulumi.get(self, "project_key")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The summary of the Jira issue to be created by this notification.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the Jira API endpoint
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username of the Jira profile
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password for the Jira profile
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationOpsGenie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationOpsGenie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationOpsGenie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationOpsGenie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 domain: str,
                 message: str,
                 name: str,
                 api_key: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str domain: The region domain of the OpsGenie
        :param str message: The content of the message.  You can use the following placeholders:  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem
        :param str name: The name of the notification configuration
        :param str api_key: The API key to access OpsGenie
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "name", name)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The region domain of the OpsGenie
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The content of the message.  You can use the following placeholders:  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[str]:
        """
        The API key to access OpsGenie
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationPagerDuty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "serviceApiKey":
            suggest = "service_api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPagerDuty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPagerDuty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPagerDuty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account: str,
                 active: bool,
                 alerting_profile: str,
                 name: str,
                 service_name: str,
                 service_api_key: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str account: The name of the PagerDuty account
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str name: The name of the notification configuration
        :param str service_name: The name of the service
        :param str service_api_key: The API key to access PagerDuty
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "account", account)
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_name", service_name)
        if service_api_key is not None:
            pulumi.set(__self__, "service_api_key", service_api_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def account(self) -> str:
        """
        The name of the PagerDuty account
        """
        return pulumi.get(self, "account")

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        The name of the service
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="serviceApiKey")
    def service_api_key(self) -> Optional[str]:
        """
        The API key to access PagerDuty
        """
        return pulumi.get(self, "service_api_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationServiceNow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "sendEvents":
            suggest = "send_events"
        elif key == "sendIncidents":
            suggest = "send_incidents"
        elif key == "instanceName":
            suggest = "instance_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationServiceNow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationServiceNow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationServiceNow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 message: str,
                 name: str,
                 send_events: bool,
                 send_incidents: bool,
                 username: str,
                 instance_name: Optional[str] = None,
                 password: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str message: The content of the ServiceNow description.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str name: The name of the notification configuration
        :param bool send_events: Send events into ServiceNow ITOM (`true`)
        :param bool send_incidents: Send incidents into ServiceNow ITSM (`true`)
        :param str username: The username of the ServiceNow account.   Make sure that your user account has the `rest_service`, `web_request_admin`, and `x_dynat_ruxit.Integration` roles
        :param str instance_name: The ServiceNow instance identifier. It refers to the first part of your own ServiceNow URL.   This field is mutually exclusive with the **url** field. You can only use one of them
        :param str password: The username to the ServiceNow account
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str url: The URL of the on-premise ServiceNow installation.   This field is mutually exclusive with the **instanceName** field. You can only use one of them
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "send_events", send_events)
        pulumi.set(__self__, "send_incidents", send_incidents)
        pulumi.set(__self__, "username", username)
        if instance_name is not None:
            pulumi.set(__self__, "instance_name", instance_name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The content of the ServiceNow description.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sendEvents")
    def send_events(self) -> bool:
        """
        Send events into ServiceNow ITOM (`true`)
        """
        return pulumi.get(self, "send_events")

    @property
    @pulumi.getter(name="sendIncidents")
    def send_incidents(self) -> bool:
        """
        Send incidents into ServiceNow ITSM (`true`)
        """
        return pulumi.get(self, "send_incidents")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username of the ServiceNow account.   Make sure that your user account has the `rest_service`, `web_request_admin`, and `x_dynat_ruxit.Integration` roles
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> Optional[str]:
        """
        The ServiceNow instance identifier. It refers to the first part of your own ServiceNow URL.   This field is mutually exclusive with the **url** field. You can only use one of them
        """
        return pulumi.get(self, "instance_name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The username to the ServiceNow account
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL of the on-premise ServiceNow installation.   This field is mutually exclusive with the **instanceName** field. You can only use one of them
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class NotificationSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 channel: str,
                 name: str,
                 title: str,
                 unknowns: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str channel: The channel (for example, `#general`) or the user (for example, `@john.smith`) to send the message to
        :param str name: The name of the notification configuration
        :param str title: The content of the message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str url: The URL of the Slack WebHook.  This is confidential information, therefore GET requests return this field with the `null` value, and it is optional for PUT requests
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "title", title)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def channel(self) -> str:
        """
        The channel (for example, `#general`) or the user (for example, `@john.smith`) to send the message to
        """
        return pulumi.get(self, "channel")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The content of the message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL of the Slack WebHook.  This is confidential information, therefore GET requests return this field with the `null` value, and it is optional for PUT requests
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class NotificationTrello(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "applicationKey":
            suggest = "application_key"
        elif key == "boardId":
            suggest = "board_id"
        elif key == "listId":
            suggest = "list_id"
        elif key == "resolvedListId":
            suggest = "resolved_list_id"
        elif key == "authorizationToken":
            suggest = "authorization_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationTrello. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationTrello.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationTrello.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 application_key: str,
                 board_id: str,
                 description: str,
                 list_id: str,
                 name: str,
                 resolved_list_id: str,
                 text: str,
                 authorization_token: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str application_key: The application key for the Trello account
        :param str board_id: The Trello board to which the card should be assigned
        :param str description: The description of the Trello card.   You can use same placeholders as in card text
        :param str list_id: The Trello list to which the card should be assigned
        :param str name: The name of the notification configuration
        :param str resolved_list_id: The Trello list to which the card of the resolved problem should be assigned
        :param str text: The text of the generated Trello card.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str authorization_token: The application token for the Trello account
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "application_key", application_key)
        pulumi.set(__self__, "board_id", board_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "list_id", list_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resolved_list_id", resolved_list_id)
        pulumi.set(__self__, "text", text)
        if authorization_token is not None:
            pulumi.set(__self__, "authorization_token", authorization_token)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter(name="applicationKey")
    def application_key(self) -> str:
        """
        The application key for the Trello account
        """
        return pulumi.get(self, "application_key")

    @property
    @pulumi.getter(name="boardId")
    def board_id(self) -> str:
        """
        The Trello board to which the card should be assigned
        """
        return pulumi.get(self, "board_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the Trello card.   You can use same placeholders as in card text
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="listId")
    def list_id(self) -> str:
        """
        The Trello list to which the card should be assigned
        """
        return pulumi.get(self, "list_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resolvedListId")
    def resolved_list_id(self) -> str:
        """
        The Trello list to which the card of the resolved problem should be assigned
        """
        return pulumi.get(self, "resolved_list_id")

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        The text of the generated Trello card.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "text")

    @property
    @pulumi.getter(name="authorizationToken")
    def authorization_token(self) -> Optional[str]:
        """
        The application token for the Trello account
        """
        return pulumi.get(self, "authorization_token")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationVictorOps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "routingKey":
            suggest = "routing_key"
        elif key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationVictorOps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationVictorOps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationVictorOps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 message: str,
                 name: str,
                 routing_key: str,
                 api_key: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str message: The content of the message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`
        :param str name: The name of the notification configuration
        :param str routing_key: The routing key, defining the group to be notified
        :param str api_key: The API key for the target VictorOps account
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "routing_key", routing_key)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The content of the message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> str:
        """
        The routing key, defining the group to be notified
        """
        return pulumi.get(self, "routing_key")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[str]:
        """
        The API key for the target VictorOps account
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationWebHook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptAnyCertificate":
            suggest = "accept_any_certificate"
        elif key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "notifyEventMerges":
            suggest = "notify_event_merges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationWebHook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationWebHook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationWebHook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept_any_certificate: bool,
                 active: bool,
                 alerting_profile: str,
                 name: str,
                 payload: str,
                 url: str,
                 headers: Optional[Sequence['outputs.NotificationWebHookHeader']] = None,
                 notify_event_merges: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool accept_any_certificate: Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str name: The name of the notification configuration
        :param str payload: The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str url: The URL of the WebHook endpoint
        :param Sequence['NotificationWebHookHeaderArgs'] headers: A list of the additional HTTP headers
        :param bool notify_event_merges: Call webhook if new events merge into existing problems
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "accept_any_certificate", accept_any_certificate)
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "payload", payload)
        pulumi.set(__self__, "url", url)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if notify_event_merges is not None:
            pulumi.set(__self__, "notify_event_merges", notify_event_merges)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="acceptAnyCertificate")
    def accept_any_certificate(self) -> bool:
        """
        Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
        """
        return pulumi.get(self, "accept_any_certificate")

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def payload(self) -> str:
        """
        The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the WebHook endpoint
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.NotificationWebHookHeader']]:
        """
        A list of the additional HTTP headers
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="notifyEventMerges")
    def notify_event_merges(self) -> Optional[bool]:
        """
        Call webhook if new events merge into existing problems
        """
        return pulumi.get(self, "notify_event_merges")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationWebHookHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str name: The name of the HTTP header
        :param str value: The value of the HTTP header. May contain an empty value.   Required when creating a new notification.  For the **Authorization** header, GET requests return the `null` value.  If you want update a notification configuration with an **Authorization** header which you want to remain intact, set the **Authorization** header with the `null` value
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the HTTP header
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the HTTP header. May contain an empty value.   Required when creating a new notification.  For the **Authorization** header, GET requests return the `null` value.  If you want update a notification configuration with an **Authorization** header which you want to remain intact, set the **Authorization** header with the `null` value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NotificationXmatters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptAnyCertificate":
            suggest = "accept_any_certificate"
        elif key == "alertingProfile":
            suggest = "alerting_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationXmatters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationXmatters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationXmatters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept_any_certificate: bool,
                 active: bool,
                 alerting_profile: str,
                 name: str,
                 payload: str,
                 url: str,
                 headers: Optional[Sequence['outputs.NotificationXmattersHeader']] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool accept_any_certificate: Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str name: The name of the notification configuration
        :param str payload: The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str url: The URL of the xMatters WebHook
        :param Sequence['NotificationXmattersHeaderArgs'] headers: A list of the additional HTTP headers
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "accept_any_certificate", accept_any_certificate)
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "payload", payload)
        pulumi.set(__self__, "url", url)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="acceptAnyCertificate")
    def accept_any_certificate(self) -> bool:
        """
        Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
        """
        return pulumi.get(self, "accept_any_certificate")

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def payload(self) -> str:
        """
        The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the xMatters WebHook
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.NotificationXmattersHeader']]:
        """
        A list of the additional HTTP headers
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationXmattersHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str name: The name of the HTTP header
        :param str value: The value of the HTTP header. May contain an empty value.   Required when creating a new notification.  For the **Authorization** header, GET requests return the `null` value.  If you want update a notification configuration with an **Authorization** header which you want to remain intact, set the **Authorization** header with the `null` value
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the HTTP header
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the HTTP header. May contain an empty value.   Required when creating a new notification.  For the **Authorization** header, GET requests return the `null` value.  If you want update a notification configuration with an **Authorization** header which you want to remain intact, set the **Authorization** header with the `null` value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OneagentUpdatesMaintenanceWindows(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceWindows":
            suggest = "maintenance_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OneagentUpdatesMaintenanceWindows. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OneagentUpdatesMaintenanceWindows.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OneagentUpdatesMaintenanceWindows.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maintenance_windows: Sequence['outputs.OneagentUpdatesMaintenanceWindowsMaintenanceWindow']):
        pulumi.set(__self__, "maintenance_windows", maintenance_windows)

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.OneagentUpdatesMaintenanceWindowsMaintenanceWindow']:
        return pulumi.get(self, "maintenance_windows")


@pulumi.output_type
class OneagentUpdatesMaintenanceWindowsMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceWindow":
            suggest = "maintenance_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OneagentUpdatesMaintenanceWindowsMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OneagentUpdatesMaintenanceWindowsMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OneagentUpdatesMaintenanceWindowsMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maintenance_window: str):
        """
        :param str maintenance_window: Select a [maintenance window for OneAgent updates](https://www.terraform.io/ui/settings/builtin:deployment.management.update-windows)
        """
        pulumi.set(__self__, "maintenance_window", maintenance_window)

    @property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> str:
        """
        Select a [maintenance window for OneAgent updates](https://www.terraform.io/ui/settings/builtin:deployment.management.update-windows)
        """
        return pulumi.get(self, "maintenance_window")


@pulumi.output_type
class OpentelemetryMetricsAdditionalAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalAttributes":
            suggest = "additional_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpentelemetryMetricsAdditionalAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpentelemetryMetricsAdditionalAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpentelemetryMetricsAdditionalAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_attributes: Sequence['outputs.OpentelemetryMetricsAdditionalAttributesAdditionalAttribute']):
        pulumi.set(__self__, "additional_attributes", additional_attributes)

    @property
    @pulumi.getter(name="additionalAttributes")
    def additional_attributes(self) -> Sequence['outputs.OpentelemetryMetricsAdditionalAttributesAdditionalAttribute']:
        return pulumi.get(self, "additional_attributes")


@pulumi.output_type
class OpentelemetryMetricsAdditionalAttributesAdditionalAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeKey":
            suggest = "attribute_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpentelemetryMetricsAdditionalAttributesAdditionalAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpentelemetryMetricsAdditionalAttributesAdditionalAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpentelemetryMetricsAdditionalAttributesAdditionalAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_key: str,
                 enabled: bool):
        """
        :param str attribute_key: Attribute key
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        """
        pulumi.set(__self__, "attribute_key", attribute_key)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="attributeKey")
    def attribute_key(self) -> str:
        """
        Attribute key
        """
        return pulumi.get(self, "attribute_key")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class OpentelemetryMetricsToDropAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toDropAttributes":
            suggest = "to_drop_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpentelemetryMetricsToDropAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpentelemetryMetricsToDropAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpentelemetryMetricsToDropAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 to_drop_attributes: Sequence['outputs.OpentelemetryMetricsToDropAttributesToDropAttribute']):
        pulumi.set(__self__, "to_drop_attributes", to_drop_attributes)

    @property
    @pulumi.getter(name="toDropAttributes")
    def to_drop_attributes(self) -> Sequence['outputs.OpentelemetryMetricsToDropAttributesToDropAttribute']:
        return pulumi.get(self, "to_drop_attributes")


@pulumi.output_type
class OpentelemetryMetricsToDropAttributesToDropAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeKey":
            suggest = "attribute_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpentelemetryMetricsToDropAttributesToDropAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpentelemetryMetricsToDropAttributesToDropAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpentelemetryMetricsToDropAttributesToDropAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_key: str,
                 enabled: bool):
        """
        :param str attribute_key: Attribute key
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        """
        pulumi.set(__self__, "attribute_key", attribute_key)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="attributeKey")
    def attribute_key(self) -> str:
        """
        Attribute key
        """
        return pulumi.get(self, "attribute_key")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class OsServicesDetectionConditionsLinux(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linuxDetectionConditions":
            suggest = "linux_detection_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OsServicesDetectionConditionsLinux. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OsServicesDetectionConditionsLinux.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OsServicesDetectionConditionsLinux.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linux_detection_conditions: Sequence['outputs.OsServicesDetectionConditionsLinuxLinuxDetectionCondition']):
        pulumi.set(__self__, "linux_detection_conditions", linux_detection_conditions)

    @property
    @pulumi.getter(name="linuxDetectionConditions")
    def linux_detection_conditions(self) -> Sequence['outputs.OsServicesDetectionConditionsLinuxLinuxDetectionCondition']:
        return pulumi.get(self, "linux_detection_conditions")


@pulumi.output_type
class OsServicesDetectionConditionsLinuxLinuxDetectionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostMetadataCondition":
            suggest = "host_metadata_condition"
        elif key == "ruleType":
            suggest = "rule_type"
        elif key == "startupCondition":
            suggest = "startup_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OsServicesDetectionConditionsLinuxLinuxDetectionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OsServicesDetectionConditionsLinuxLinuxDetectionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OsServicesDetectionConditionsLinuxLinuxDetectionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: Optional[str] = None,
                 host_metadata_condition: Optional['outputs.OsServicesDetectionConditionsLinuxLinuxDetectionConditionHostMetadataCondition'] = None,
                 property: Optional[str] = None,
                 rule_type: Optional[str] = None,
                 startup_condition: Optional[str] = None):
        """
        :param str condition: This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk).
        :param 'OsServicesDetectionConditionsLinuxLinuxDetectionConditionHostMetadataConditionArgs' host_metadata_condition: Custom metadata
        :param str property: Possible Values: `ServiceName`, `StartupType`
        :param str rule_type: Possible Values: `RuleTypeHost`, `RuleTypeOsService`
        :param str startup_condition: This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk).
               
               - `$eq(enabled)` – Matches services with startup type equal to enabled.
               
               Available logic operations:
               - `$not($eq(enabled))` – Matches services with startup type different from enabled.
               - `$or($eq(enabled),$eq(disabled))` - Matches services that are either enabled or disabled.
               
               Use one of the following values as a parameter for this condition:
               
               - `enabled`
               - `enabled-runtime`
               - `static`
               - `disabled`
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if host_metadata_condition is not None:
            pulumi.set(__self__, "host_metadata_condition", host_metadata_condition)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if rule_type is not None:
            pulumi.set(__self__, "rule_type", rule_type)
        if startup_condition is not None:
            pulumi.set(__self__, "startup_condition", startup_condition)

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk).
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="hostMetadataCondition")
    def host_metadata_condition(self) -> Optional['outputs.OsServicesDetectionConditionsLinuxLinuxDetectionConditionHostMetadataCondition']:
        """
        Custom metadata
        """
        return pulumi.get(self, "host_metadata_condition")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> Optional[str]:
        """
        Possible Values: `RuleTypeHost`, `RuleTypeOsService`
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter(name="startupCondition")
    def startup_condition(self) -> Optional[str]:
        """
        This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk).

        - `$eq(enabled)` – Matches services with startup type equal to enabled.

        Available logic operations:
        - `$not($eq(enabled))` – Matches services with startup type different from enabled.
        - `$or($eq(enabled),$eq(disabled))` - Matches services that are either enabled or disabled.

        Use one of the following values as a parameter for this condition:

        - `enabled`
        - `enabled-runtime`
        - `static`
        - `disabled`
        """
        return pulumi.get(self, "startup_condition")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        """
        Possible Values: `ServiceName`, `StartupType`
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class OsServicesDetectionConditionsLinuxLinuxDetectionConditionHostMetadataCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataCondition":
            suggest = "metadata_condition"
        elif key == "metadataKey":
            suggest = "metadata_key"
        elif key == "keyMustExist":
            suggest = "key_must_exist"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OsServicesDetectionConditionsLinuxLinuxDetectionConditionHostMetadataCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OsServicesDetectionConditionsLinuxLinuxDetectionConditionHostMetadataCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OsServicesDetectionConditionsLinuxLinuxDetectionConditionHostMetadataCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_condition: str,
                 metadata_key: str,
                 key_must_exist: Optional[bool] = None):
        """
        :param str metadata_condition: This string has to match a required format.
        :param str metadata_key: Key
        :param bool key_must_exist: When enabled, the condition requires a metadata key to exist and match the constraints; when disabled, the key is optional but must still match the constrains if it is present.
        """
        pulumi.set(__self__, "metadata_condition", metadata_condition)
        pulumi.set(__self__, "metadata_key", metadata_key)
        if key_must_exist is not None:
            pulumi.set(__self__, "key_must_exist", key_must_exist)

    @property
    @pulumi.getter(name="metadataCondition")
    def metadata_condition(self) -> str:
        """
        This string has to match a required format.
        """
        return pulumi.get(self, "metadata_condition")

    @property
    @pulumi.getter(name="metadataKey")
    def metadata_key(self) -> str:
        """
        Key
        """
        return pulumi.get(self, "metadata_key")

    @property
    @pulumi.getter(name="keyMustExist")
    def key_must_exist(self) -> Optional[bool]:
        """
        When enabled, the condition requires a metadata key to exist and match the constraints; when disabled, the key is optional but must still match the constrains if it is present.
        """
        return pulumi.get(self, "key_must_exist")


@pulumi.output_type
class OsServicesDetectionConditionsWindows(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectionConditionsWindows":
            suggest = "detection_conditions_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OsServicesDetectionConditionsWindows. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OsServicesDetectionConditionsWindows.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OsServicesDetectionConditionsWindows.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 detection_conditions_windows: Sequence['outputs.OsServicesDetectionConditionsWindowsDetectionConditionsWindow']):
        pulumi.set(__self__, "detection_conditions_windows", detection_conditions_windows)

    @property
    @pulumi.getter(name="detectionConditionsWindows")
    def detection_conditions_windows(self) -> Sequence['outputs.OsServicesDetectionConditionsWindowsDetectionConditionsWindow']:
        return pulumi.get(self, "detection_conditions_windows")


@pulumi.output_type
class OsServicesDetectionConditionsWindowsDetectionConditionsWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostMetadataCondition":
            suggest = "host_metadata_condition"
        elif key == "ruleType":
            suggest = "rule_type"
        elif key == "startupCondition":
            suggest = "startup_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OsServicesDetectionConditionsWindowsDetectionConditionsWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OsServicesDetectionConditionsWindowsDetectionConditionsWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OsServicesDetectionConditionsWindowsDetectionConditionsWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: Optional[str] = None,
                 host_metadata_condition: Optional['outputs.OsServicesDetectionConditionsWindowsDetectionConditionsWindowHostMetadataCondition'] = None,
                 property: Optional[str] = None,
                 rule_type: Optional[str] = None,
                 startup_condition: Optional[str] = None):
        """
        :param str condition: This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk).
        :param 'OsServicesDetectionConditionsWindowsDetectionConditionsWindowHostMetadataConditionArgs' host_metadata_condition: Custom metadata
        :param str property: Possible Values: `DisplayName`, `Manufacturer`, `Path`, `ServiceName`, `StartupType`
        :param str rule_type: Possible Values: `RuleTypeHost`, `RuleTypeOsService`
        :param str startup_condition: This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk).
               
               - `$eq(manual)` – Matches services that are started manually.
               
               Available logic operations:
               - `$not($eq(auto))` – Matches services with startup type different from Automatic.
               - `$or($eq(auto),$eq(manual))` – Matches if service's startup type is either Automatic or Manual.
               
               Use one of the following values as a parameter for this condition:
               
               - `manual` for Manual
               - `manual_trigger` for Manual (Trigger Start)
               - `auto` for Automatic
               - `auto_delay` for Automatic (Delayed Start)
               - `auto_trigger` for Automatic (Trigger Start)
               - `auto_delay_trigger` for Automatic (Delayed Start, Trigger Start)
               - `disabled` for Disabled
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if host_metadata_condition is not None:
            pulumi.set(__self__, "host_metadata_condition", host_metadata_condition)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if rule_type is not None:
            pulumi.set(__self__, "rule_type", rule_type)
        if startup_condition is not None:
            pulumi.set(__self__, "startup_condition", startup_condition)

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk).
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="hostMetadataCondition")
    def host_metadata_condition(self) -> Optional['outputs.OsServicesDetectionConditionsWindowsDetectionConditionsWindowHostMetadataCondition']:
        """
        Custom metadata
        """
        return pulumi.get(self, "host_metadata_condition")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> Optional[str]:
        """
        Possible Values: `RuleTypeHost`, `RuleTypeOsService`
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter(name="startupCondition")
    def startup_condition(self) -> Optional[str]:
        """
        This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk).

        - `$eq(manual)` – Matches services that are started manually.

        Available logic operations:
        - `$not($eq(auto))` – Matches services with startup type different from Automatic.
        - `$or($eq(auto),$eq(manual))` – Matches if service's startup type is either Automatic or Manual.

        Use one of the following values as a parameter for this condition:

        - `manual` for Manual
        - `manual_trigger` for Manual (Trigger Start)
        - `auto` for Automatic
        - `auto_delay` for Automatic (Delayed Start)
        - `auto_trigger` for Automatic (Trigger Start)
        - `auto_delay_trigger` for Automatic (Delayed Start, Trigger Start)
        - `disabled` for Disabled
        """
        return pulumi.get(self, "startup_condition")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        """
        Possible Values: `DisplayName`, `Manufacturer`, `Path`, `ServiceName`, `StartupType`
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class OsServicesDetectionConditionsWindowsDetectionConditionsWindowHostMetadataCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataCondition":
            suggest = "metadata_condition"
        elif key == "metadataKey":
            suggest = "metadata_key"
        elif key == "keyMustExist":
            suggest = "key_must_exist"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OsServicesDetectionConditionsWindowsDetectionConditionsWindowHostMetadataCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OsServicesDetectionConditionsWindowsDetectionConditionsWindowHostMetadataCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OsServicesDetectionConditionsWindowsDetectionConditionsWindowHostMetadataCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_condition: str,
                 metadata_key: str,
                 key_must_exist: Optional[bool] = None):
        """
        :param str metadata_condition: This string has to match a required format.
        :param str metadata_key: Key
        :param bool key_must_exist: When enabled, the condition requires a metadata key to exist and match the constraints; when disabled, the key is optional but must still match the constrains if it is present.
        """
        pulumi.set(__self__, "metadata_condition", metadata_condition)
        pulumi.set(__self__, "metadata_key", metadata_key)
        if key_must_exist is not None:
            pulumi.set(__self__, "key_must_exist", key_must_exist)

    @property
    @pulumi.getter(name="metadataCondition")
    def metadata_condition(self) -> str:
        """
        This string has to match a required format.
        """
        return pulumi.get(self, "metadata_condition")

    @property
    @pulumi.getter(name="metadataKey")
    def metadata_key(self) -> str:
        """
        Key
        """
        return pulumi.get(self, "metadata_key")

    @property
    @pulumi.getter(name="keyMustExist")
    def key_must_exist(self) -> Optional[bool]:
        """
        When enabled, the condition requires a metadata key to exist and match the constraints; when disabled, the key is optional but must still match the constrains if it is present.
        """
        return pulumi.get(self, "key_must_exist")


@pulumi.output_type
class OsServicesMetadata(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.OsServicesMetadataItem']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.OsServicesMetadataItem']:
        return pulumi.get(self, "items")


@pulumi.output_type
class OsServicesMetadataItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataKey":
            suggest = "metadata_key"
        elif key == "metadataValue":
            suggest = "metadata_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OsServicesMetadataItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OsServicesMetadataItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OsServicesMetadataItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_key: str,
                 metadata_value: str):
        """
        :param str metadata_key: Type 'dt.' for key hints.
        :param str metadata_value: no documentation available
        """
        pulumi.set(__self__, "metadata_key", metadata_key)
        pulumi.set(__self__, "metadata_value", metadata_value)

    @property
    @pulumi.getter(name="metadataKey")
    def metadata_key(self) -> str:
        """
        Type 'dt.' for key hints.
        """
        return pulumi.get(self, "metadata_key")

    @property
    @pulumi.getter(name="metadataValue")
    def metadata_value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "metadata_value")


@pulumi.output_type
class OwnershipConfigOwnershipIdentifiers(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ownershipIdentifiers":
            suggest = "ownership_identifiers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipConfigOwnershipIdentifiers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipConfigOwnershipIdentifiers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipConfigOwnershipIdentifiers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ownership_identifiers: Sequence['outputs.OwnershipConfigOwnershipIdentifiersOwnershipIdentifier']):
        pulumi.set(__self__, "ownership_identifiers", ownership_identifiers)

    @property
    @pulumi.getter(name="ownershipIdentifiers")
    def ownership_identifiers(self) -> Sequence['outputs.OwnershipConfigOwnershipIdentifiersOwnershipIdentifier']:
        return pulumi.get(self, "ownership_identifiers")


@pulumi.output_type
class OwnershipConfigOwnershipIdentifiersOwnershipIdentifier(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 key: str):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param str key: Key for ownership metadata and tags
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for ownership metadata and tags
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class OwnershipTeamsAdditionalInformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalInformations":
            suggest = "additional_informations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipTeamsAdditionalInformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipTeamsAdditionalInformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipTeamsAdditionalInformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_informations: Sequence['outputs.OwnershipTeamsAdditionalInformationAdditionalInformation']):
        pulumi.set(__self__, "additional_informations", additional_informations)

    @property
    @pulumi.getter(name="additionalInformations")
    def additional_informations(self) -> Sequence['outputs.OwnershipTeamsAdditionalInformationAdditionalInformation']:
        return pulumi.get(self, "additional_informations")


@pulumi.output_type
class OwnershipTeamsAdditionalInformationAdditionalInformation(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 url: Optional[str] = None):
        """
        :param str key: Name
        :param str value: no documentation available
        :param str url: no documentation available
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Name
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class OwnershipTeamsContactDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contactDetails":
            suggest = "contact_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipTeamsContactDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipTeamsContactDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipTeamsContactDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contact_details: Sequence['outputs.OwnershipTeamsContactDetailsContactDetail']):
        pulumi.set(__self__, "contact_details", contact_details)

    @property
    @pulumi.getter(name="contactDetails")
    def contact_details(self) -> Sequence['outputs.OwnershipTeamsContactDetailsContactDetail']:
        return pulumi.get(self, "contact_details")


@pulumi.output_type
class OwnershipTeamsContactDetailsContactDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "msTeams":
            suggest = "ms_teams"
        elif key == "slackChannel":
            suggest = "slack_channel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipTeamsContactDetailsContactDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipTeamsContactDetailsContactDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipTeamsContactDetailsContactDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 email: Optional[str] = None,
                 jira: Optional['outputs.OwnershipTeamsContactDetailsContactDetailJira'] = None,
                 ms_teams: Optional[str] = None,
                 slack_channel: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str integration_type: Possible Values: `EMAIL`, `JIRA`, `MS_TEAMS`, `SLACK`
        :param str email: no documentation available
        :param 'OwnershipTeamsContactDetailsContactDetailJiraArgs' jira: no documentation available
        :param str ms_teams: Team
        :param str slack_channel: Channel
        :param str url: no documentation available
        """
        pulumi.set(__self__, "integration_type", integration_type)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if jira is not None:
            pulumi.set(__self__, "jira", jira)
        if ms_teams is not None:
            pulumi.set(__self__, "ms_teams", ms_teams)
        if slack_channel is not None:
            pulumi.set(__self__, "slack_channel", slack_channel)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        """
        Possible Values: `EMAIL`, `JIRA`, `MS_TEAMS`, `SLACK`
        """
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def jira(self) -> Optional['outputs.OwnershipTeamsContactDetailsContactDetailJira']:
        """
        no documentation available
        """
        return pulumi.get(self, "jira")

    @property
    @pulumi.getter(name="msTeams")
    def ms_teams(self) -> Optional[str]:
        """
        Team
        """
        return pulumi.get(self, "ms_teams")

    @property
    @pulumi.getter(name="slackChannel")
    def slack_channel(self) -> Optional[str]:
        """
        Channel
        """
        return pulumi.get(self, "slack_channel")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class OwnershipTeamsContactDetailsContactDetailJira(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultAssignee":
            suggest = "default_assignee"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipTeamsContactDetailsContactDetailJira. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipTeamsContactDetailsContactDetailJira.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipTeamsContactDetailsContactDetailJira.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_assignee: str,
                 project: str):
        """
        :param str default_assignee: Default Assignee
        :param str project: no documentation available
        """
        pulumi.set(__self__, "default_assignee", default_assignee)
        pulumi.set(__self__, "project", project)

    @property
    @pulumi.getter(name="defaultAssignee")
    def default_assignee(self) -> str:
        """
        Default Assignee
        """
        return pulumi.get(self, "default_assignee")

    @property
    @pulumi.getter
    def project(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "project")


@pulumi.output_type
class OwnershipTeamsLinks(dict):
    def __init__(__self__, *,
                 links: Sequence['outputs.OwnershipTeamsLinksLink']):
        pulumi.set(__self__, "links", links)

    @property
    @pulumi.getter
    def links(self) -> Sequence['outputs.OwnershipTeamsLinksLink']:
        return pulumi.get(self, "links")


@pulumi.output_type
class OwnershipTeamsLinksLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkType":
            suggest = "link_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipTeamsLinksLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipTeamsLinksLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipTeamsLinksLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 link_type: str,
                 url: str):
        """
        :param str link_type: Possible Values: `DASHBOARD`, `DOCUMENTATION`, `HEALTH_APP`, `REPOSITORY`, `RUNBOOK`, `URL`, `WIKI`
        :param str url: no documentation available
        """
        pulumi.set(__self__, "link_type", link_type)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="linkType")
    def link_type(self) -> str:
        """
        Possible Values: `DASHBOARD`, `DOCUMENTATION`, `HEALTH_APP`, `REPOSITORY`, `RUNBOOK`, `URL`, `WIKI`
        """
        return pulumi.get(self, "link_type")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class OwnershipTeamsResponsibilities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lineOfBusiness":
            suggest = "line_of_business"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipTeamsResponsibilities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipTeamsResponsibilities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipTeamsResponsibilities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 development: bool,
                 infrastructure: bool,
                 line_of_business: bool,
                 operations: bool,
                 security: bool):
        """
        :param bool development: Responsible for developing and maintaining high quality software. Development teams are responsible for making code changes to address performance regressions, errors, or security vulnerabilities.
        :param bool infrastructure: Responsible for the administration, management, and support of the IT infrastructure including physical servers, virtualization, and cloud. Teams with infrastructure responsibility are responsible for addressing hardware issues, resource limits, and operating system vulnerabilities.
        :param bool line_of_business: Responsible for ensuring that applications in development align with business needs and meet the usability requirements of users, stakeholders, customers, and external partners. Teams with line of business responsibility are responsible for understanding the customer experience and how it affects business goals.
        :param bool operations: Responsible for deploying and managing software, with a focus on high availability and performance. Teams with operations responsibilities needs to understand the impact, priority, and team responsible for addressing problems detected by Dynatrace.
        :param bool security: Responsible for the security posture of the organization. Teams with security responsibility must understand the impact, priority, and team responsible for addressing security vulnerabilities.
        """
        pulumi.set(__self__, "development", development)
        pulumi.set(__self__, "infrastructure", infrastructure)
        pulumi.set(__self__, "line_of_business", line_of_business)
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "security", security)

    @property
    @pulumi.getter
    def development(self) -> bool:
        """
        Responsible for developing and maintaining high quality software. Development teams are responsible for making code changes to address performance regressions, errors, or security vulnerabilities.
        """
        return pulumi.get(self, "development")

    @property
    @pulumi.getter
    def infrastructure(self) -> bool:
        """
        Responsible for the administration, management, and support of the IT infrastructure including physical servers, virtualization, and cloud. Teams with infrastructure responsibility are responsible for addressing hardware issues, resource limits, and operating system vulnerabilities.
        """
        return pulumi.get(self, "infrastructure")

    @property
    @pulumi.getter(name="lineOfBusiness")
    def line_of_business(self) -> bool:
        """
        Responsible for ensuring that applications in development align with business needs and meet the usability requirements of users, stakeholders, customers, and external partners. Teams with line of business responsibility are responsible for understanding the customer experience and how it affects business goals.
        """
        return pulumi.get(self, "line_of_business")

    @property
    @pulumi.getter
    def operations(self) -> bool:
        """
        Responsible for deploying and managing software, with a focus on high availability and performance. Teams with operations responsibilities needs to understand the impact, priority, and team responsible for addressing problems detected by Dynatrace.
        """
        return pulumi.get(self, "operations")

    @property
    @pulumi.getter
    def security(self) -> bool:
        """
        Responsible for the security posture of the organization. Teams with security responsibility must understand the impact, priority, and team responsible for addressing security vulnerabilities.
        """
        return pulumi.get(self, "security")


@pulumi.output_type
class OwnershipTeamsSupplementaryIdentifiers(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "supplementaryIdentifiers":
            suggest = "supplementary_identifiers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipTeamsSupplementaryIdentifiers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipTeamsSupplementaryIdentifiers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipTeamsSupplementaryIdentifiers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 supplementary_identifiers: Sequence['outputs.OwnershipTeamsSupplementaryIdentifiersSupplementaryIdentifier']):
        pulumi.set(__self__, "supplementary_identifiers", supplementary_identifiers)

    @property
    @pulumi.getter(name="supplementaryIdentifiers")
    def supplementary_identifiers(self) -> Sequence['outputs.OwnershipTeamsSupplementaryIdentifiersSupplementaryIdentifier']:
        return pulumi.get(self, "supplementary_identifiers")


@pulumi.output_type
class OwnershipTeamsSupplementaryIdentifiersSupplementaryIdentifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "supplementaryIdentifier":
            suggest = "supplementary_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipTeamsSupplementaryIdentifiersSupplementaryIdentifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipTeamsSupplementaryIdentifiersSupplementaryIdentifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipTeamsSupplementaryIdentifiersSupplementaryIdentifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 supplementary_identifier: str):
        """
        :param str supplementary_identifier: Supplementary Identifier
        """
        pulumi.set(__self__, "supplementary_identifier", supplementary_identifier)

    @property
    @pulumi.getter(name="supplementaryIdentifier")
    def supplementary_identifier(self) -> str:
        """
        Supplementary Identifier
        """
        return pulumi.get(self, "supplementary_identifier")


@pulumi.output_type
class PgAnomaliesAvailability(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumThreshold":
            suggest = "minimum_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgAnomaliesAvailability. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgAnomaliesAvailability.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgAnomaliesAvailability.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 minimum_threshold: Optional[int] = None):
        """
        :param str method: How to monitor the availability of the process group:  * `PROCESS_IMPACT`: Alert if any process of the group becomes unavailable.  * `MINIMUM_THRESHOLD`: Alert if the number of active processes in the group falls below the specified threshold.  * `OFF`: Availability monitoring is disabled.
        :param int minimum_threshold: Alert if the number of active processes in the group is lower than this value.
        """
        pulumi.set(__self__, "method", method)
        if minimum_threshold is not None:
            pulumi.set(__self__, "minimum_threshold", minimum_threshold)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        How to monitor the availability of the process group:  * `PROCESS_IMPACT`: Alert if any process of the group becomes unavailable.  * `MINIMUM_THRESHOLD`: Alert if the number of active processes in the group falls below the specified threshold.  * `OFF`: Availability monitoring is disabled.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="minimumThreshold")
    def minimum_threshold(self) -> Optional[int]:
        """
        Alert if the number of active processes in the group is lower than this value.
        """
        return pulumi.get(self, "minimum_threshold")


@pulumi.output_type
class ProcessAvailabilityMetadata(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.ProcessAvailabilityMetadataItem']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.ProcessAvailabilityMetadataItem']:
        return pulumi.get(self, "items")


@pulumi.output_type
class ProcessAvailabilityMetadataItem(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Type 'dt.' for key hints.
        :param str value: no documentation available
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Type 'dt.' for key hints.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessAvailabilityRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.ProcessAvailabilityRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.ProcessAvailabilityRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class ProcessAvailabilityRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostMetadataCondition":
            suggest = "host_metadata_condition"
        elif key == "ruleType":
            suggest = "rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessAvailabilityRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessAvailabilityRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessAvailabilityRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: Optional[str] = None,
                 host_metadata_condition: Optional['outputs.ProcessAvailabilityRulesRuleHostMetadataCondition'] = None,
                 property: Optional[str] = None,
                 rule_type: Optional[str] = None):
        """
        :param str condition: - $contains(svc) – Matches if svc appears anywhere in the process property value.
               - $eq(svc.exe) – Matches if svc.exe matches the process property value exactly.
               - $prefix(svc) – Matches if app matches the prefix of the process property value.
               - $suffix(svc.py) – Matches if svc.py matches the suffix of the process property value.
               
               For example, $suffix(svc.py) would detect processes named loyaltysvc.py and paymentssvc.py.
               
               For more details, see [Process availability](https://dt-url.net/v923x37).
        :param 'ProcessAvailabilityRulesRuleHostMetadataConditionArgs' host_metadata_condition: Host custom metadata refers to user-defined key-value pairs that you can assign to hosts monitored by Dynatrace.
               
               By defining custom metadata, you can enrich the monitoring data with context specific to your organization's needs, such as environment names, team ownership, application versions, or any other relevant details.
               
               See [Define tags and metadata for hosts](https://dt-url.net/w3hv0kbw).
        :param str property: Possible Values: `CommandLine`, `Executable`, `ExecutablePath`, `User`
        :param str rule_type: Possible Values: `RuleTypeHost`, `RuleTypeProcess`
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if host_metadata_condition is not None:
            pulumi.set(__self__, "host_metadata_condition", host_metadata_condition)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if rule_type is not None:
            pulumi.set(__self__, "rule_type", rule_type)

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        - $contains(svc) – Matches if svc appears anywhere in the process property value.
        - $eq(svc.exe) – Matches if svc.exe matches the process property value exactly.
        - $prefix(svc) – Matches if app matches the prefix of the process property value.
        - $suffix(svc.py) – Matches if svc.py matches the suffix of the process property value.

        For example, $suffix(svc.py) would detect processes named loyaltysvc.py and paymentssvc.py.

        For more details, see [Process availability](https://dt-url.net/v923x37).
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="hostMetadataCondition")
    def host_metadata_condition(self) -> Optional['outputs.ProcessAvailabilityRulesRuleHostMetadataCondition']:
        """
        Host custom metadata refers to user-defined key-value pairs that you can assign to hosts monitored by Dynatrace.

        By defining custom metadata, you can enrich the monitoring data with context specific to your organization's needs, such as environment names, team ownership, application versions, or any other relevant details.

        See [Define tags and metadata for hosts](https://dt-url.net/w3hv0kbw).
        """
        return pulumi.get(self, "host_metadata_condition")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> Optional[str]:
        """
        Possible Values: `RuleTypeHost`, `RuleTypeProcess`
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        """
        Possible Values: `CommandLine`, `Executable`, `ExecutablePath`, `User`
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class ProcessAvailabilityRulesRuleHostMetadataCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataCondition":
            suggest = "metadata_condition"
        elif key == "metadataKey":
            suggest = "metadata_key"
        elif key == "keyMustExist":
            suggest = "key_must_exist"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessAvailabilityRulesRuleHostMetadataCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessAvailabilityRulesRuleHostMetadataCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessAvailabilityRulesRuleHostMetadataCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_condition: str,
                 metadata_key: str,
                 key_must_exist: Optional[bool] = None):
        """
        :param str metadata_condition: This string has to match a required format.
               
               - `$contains(production)` – Matches if `production` appears anywhere in the host metadata value.
               - `$eq(production)` – Matches if `production` matches the host metadata value exactly.
               - `$prefix(production)` – Matches if `production` matches the prefix of the host metadata value.
               - `$suffix(production)` – Matches if `production` matches the suffix of the host metadata value.
               
               Available logic operations:
               - `$not($eq(production))` – Matches if the host metadata value is different from `production`.
               - `$and($prefix(production),$suffix(main))` – Matches if host metadata value starts with `production` and ends with `main`.
               - `$or($prefix(production),$suffix(main))` – Matches if host metadata value starts with `production` or ends with `main`.
               
               Brackets **(** and **)** that are part of the matched property **must be escaped with a tilde (~)**
        :param str metadata_key: Key
        :param bool key_must_exist: When enabled, the condition requires a metadata key to exist and match the constraints; when disabled, the key is optional but must still match the constrains if it is present.
        """
        pulumi.set(__self__, "metadata_condition", metadata_condition)
        pulumi.set(__self__, "metadata_key", metadata_key)
        if key_must_exist is not None:
            pulumi.set(__self__, "key_must_exist", key_must_exist)

    @property
    @pulumi.getter(name="metadataCondition")
    def metadata_condition(self) -> str:
        """
        This string has to match a required format.

        - `$contains(production)` – Matches if `production` appears anywhere in the host metadata value.
        - `$eq(production)` – Matches if `production` matches the host metadata value exactly.
        - `$prefix(production)` – Matches if `production` matches the prefix of the host metadata value.
        - `$suffix(production)` – Matches if `production` matches the suffix of the host metadata value.

        Available logic operations:
        - `$not($eq(production))` – Matches if the host metadata value is different from `production`.
        - `$and($prefix(production),$suffix(main))` – Matches if host metadata value starts with `production` and ends with `main`.
        - `$or($prefix(production),$suffix(main))` – Matches if host metadata value starts with `production` or ends with `main`.

        Brackets **(** and **)** that are part of the matched property **must be escaped with a tilde (~)**
        """
        return pulumi.get(self, "metadata_condition")

    @property
    @pulumi.getter(name="metadataKey")
    def metadata_key(self) -> str:
        """
        Key
        """
        return pulumi.get(self, "metadata_key")

    @property
    @pulumi.getter(name="keyMustExist")
    def key_must_exist(self) -> Optional[bool]:
        """
        When enabled, the condition requires a metadata key to exist and match the constraints; when disabled, the key is optional but must still match the constrains if it is present.
        """
        return pulumi.get(self, "key_must_exist")


@pulumi.output_type
class ProcessGroupDetectionGroupExtraction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "standaloneRule":
            suggest = "standalone_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessGroupDetectionGroupExtraction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessGroupDetectionGroupExtraction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessGroupDetectionGroupExtraction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: 'outputs.ProcessGroupDetectionGroupExtractionDelimiter',
                 property: str,
                 standalone_rule: Optional[bool] = None):
        """
        :param 'ProcessGroupDetectionGroupExtractionDelimiterArgs' delimiter: Optionally delimit this property between *From* and *To*.
        :param str property: Possible values: `DOTNET_COMMAND`, `DOTNET_COMMAND_PATH`, `ASP_NET_CORE_APPLICATION_PATH`, `AWS_ECR_ACCOUNT_ID`, `AWS_ECR_REGION`, `AWS_ECS_CLUSTER`, `AWS_ECS_CONTAINERNAME`, `AWS_ECS_FAMILY`, `AWS_ECS_REVISION`, `AWS_LAMBDA_FUNCTION_NAME`, `AWS_REGION`, `APACHE_SPARK_MASTER_IP_ADDRESS`, `APACHE_CONFIG_PATH`, `CATALINA_BASE`, `CATALINA_HOME`, `CLOUD_FOUNDRY_APP_NAME`, `CLOUD_FOUNDRY_APPLICATION_ID`, `CLOUD_FOUNDRY_INSTANCE_INDEX`, `CLOUD_FOUNDRY_SPACE_NAME`, `CLOUD_FOUNDRY_SPACE_ID`, `COLDFUSION_JVM_CONFIG_FILE`, `SERVICE_NAME`, `COMMAND_LINE_ARGS`, `CONTAINER_ID`, `CONTAINER_IMAGE_VERSION`, `CONTAINER_NAME`, `DECLARATIVE_ID`, `CONTAINER_IMAGE_NAME`, `RUXIT_CLUSTER_ID`, `RUXIT_NODE_ID`, `EXE_NAME`, `EXE_PATH`, `ELASTIC_SEARCH_CLUSTER_NAME`, `ELASTIC_SEARCH_NODE_NAME`, `EQUINOX_CONFIG_PATH`, `GLASSFISH_DOMAIN_NAME`, `GLASSFISH_INSTANCE_NAME`, `PG_ID_CALC_INPUT_KEY_LINKAGE`, `GAE_INSTANCE`, `GAE_SERVICE`, `GOOGLE_CLOUD_PROJECT`, `HYBRIS_BIN_DIR`, `HYBRIS_CONFIG_DIR`, `HYBRIS_DATA_DIR`, `IBM_CICS_REGION`, `IBM_CICS_IMS_APPLID`, `IBM_CICS_IMS_JOBNAME`, `IBM_CTG_NAME`, `IBM_IMS_CONNECT`, `IBM_IMS_CONTROL`, `IBM_IMS_MPR`, `IBM_IMS_SOAP_GW_NAME`, `IIB_BROKER_NAME`, `IIB_EXECUTION_GROUP_NAME`, `IIS_APP_POOL`, `IIS_ROLE_NAME`, `JBOSS_HOME`, `JBOSS_MODE`, `JBOSS_SERVER_NAME`, `JAVA_JAR_FILE`, `JAVA_JAR_PATH`, `JAVA_MAIN_CLASS`, `KUBERNETES_BASEPODNAME`, `KUBERNETES_CONTAINERNAME`, `KUBERNETES_FULLPODNAME`, `KUBERNETES_NAMESPACE`, `KUBERNETES_PODUID`, `MSSQL_INSTANCE_NAME`, `NODEJS_APP_NAME`, `NODEJS_APP_BASE_DIR`, `NODEJS_SCRIPT_NAME`, `ORACLE_SID`, `PHP_CLI_SCRIPT_PATH`, `PHP_CLI_WORKING_DIR`, `SOFTWAREAG_INSTALL_ROOT`, `SOFTWAREAG_PRODUCTPROPNAME`, `SPRINGBOOT_APP_NAME`, `SPRINGBOOT_PROFILE_NAME`, `SPRINGBOOT_STARTUP_CLASS`, `TIBCO_BUSINESSWORKS_CE_APP_NAME`, `TIBCO_BUSINESSWORKS_CE_VERSION`, `TIBCO_BUSINESSWORKS_APP_NODE_NAME`, `TIBCO_BUSINESSWORKS_APP_SPACE_NAME`, `TIBCO_BUSINESSWORKS_DOMAIN_NAME`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE_PATH`, `TIBCO_BUSINESSWORKS_HOME`, `VARNISH_INSTANCE_NAME`, `WEBLOGIC_NAME`, `WEBLOGIC_CLUSTER_NAME`, `WEBLOGIC_DOMAIN_NAME`, `WEBLOGIC_HOME`, `WEBSPHERE_LIBERTY_SERVER_NAME`, `WEBSPHERE_CELL_NAME`, `WEBSPHERE_CLUSTER_NAME`, `WEBSPHERE_NODE_NAME`, `WEBSPHERE_SERVER_NAME`
        :param bool standalone_rule: If this option is selected, the default Dynatrace behavior is disabled for these detected processes. Only this rule is used to separate the process group.
        """
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "property", property)
        if standalone_rule is not None:
            pulumi.set(__self__, "standalone_rule", standalone_rule)

    @property
    @pulumi.getter
    def delimiter(self) -> 'outputs.ProcessGroupDetectionGroupExtractionDelimiter':
        """
        Optionally delimit this property between *From* and *To*.
        """
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="standaloneRule")
    def standalone_rule(self) -> Optional[bool]:
        """
        If this option is selected, the default Dynatrace behavior is disabled for these detected processes. Only this rule is used to separate the process group.
        """
        return pulumi.get(self, "standalone_rule")

    @property
    @pulumi.getter
    def property(self) -> str:
        """
        Possible values: `DOTNET_COMMAND`, `DOTNET_COMMAND_PATH`, `ASP_NET_CORE_APPLICATION_PATH`, `AWS_ECR_ACCOUNT_ID`, `AWS_ECR_REGION`, `AWS_ECS_CLUSTER`, `AWS_ECS_CONTAINERNAME`, `AWS_ECS_FAMILY`, `AWS_ECS_REVISION`, `AWS_LAMBDA_FUNCTION_NAME`, `AWS_REGION`, `APACHE_SPARK_MASTER_IP_ADDRESS`, `APACHE_CONFIG_PATH`, `CATALINA_BASE`, `CATALINA_HOME`, `CLOUD_FOUNDRY_APP_NAME`, `CLOUD_FOUNDRY_APPLICATION_ID`, `CLOUD_FOUNDRY_INSTANCE_INDEX`, `CLOUD_FOUNDRY_SPACE_NAME`, `CLOUD_FOUNDRY_SPACE_ID`, `COLDFUSION_JVM_CONFIG_FILE`, `SERVICE_NAME`, `COMMAND_LINE_ARGS`, `CONTAINER_ID`, `CONTAINER_IMAGE_VERSION`, `CONTAINER_NAME`, `DECLARATIVE_ID`, `CONTAINER_IMAGE_NAME`, `RUXIT_CLUSTER_ID`, `RUXIT_NODE_ID`, `EXE_NAME`, `EXE_PATH`, `ELASTIC_SEARCH_CLUSTER_NAME`, `ELASTIC_SEARCH_NODE_NAME`, `EQUINOX_CONFIG_PATH`, `GLASSFISH_DOMAIN_NAME`, `GLASSFISH_INSTANCE_NAME`, `PG_ID_CALC_INPUT_KEY_LINKAGE`, `GAE_INSTANCE`, `GAE_SERVICE`, `GOOGLE_CLOUD_PROJECT`, `HYBRIS_BIN_DIR`, `HYBRIS_CONFIG_DIR`, `HYBRIS_DATA_DIR`, `IBM_CICS_REGION`, `IBM_CICS_IMS_APPLID`, `IBM_CICS_IMS_JOBNAME`, `IBM_CTG_NAME`, `IBM_IMS_CONNECT`, `IBM_IMS_CONTROL`, `IBM_IMS_MPR`, `IBM_IMS_SOAP_GW_NAME`, `IIB_BROKER_NAME`, `IIB_EXECUTION_GROUP_NAME`, `IIS_APP_POOL`, `IIS_ROLE_NAME`, `JBOSS_HOME`, `JBOSS_MODE`, `JBOSS_SERVER_NAME`, `JAVA_JAR_FILE`, `JAVA_JAR_PATH`, `JAVA_MAIN_CLASS`, `KUBERNETES_BASEPODNAME`, `KUBERNETES_CONTAINERNAME`, `KUBERNETES_FULLPODNAME`, `KUBERNETES_NAMESPACE`, `KUBERNETES_PODUID`, `MSSQL_INSTANCE_NAME`, `NODEJS_APP_NAME`, `NODEJS_APP_BASE_DIR`, `NODEJS_SCRIPT_NAME`, `ORACLE_SID`, `PHP_CLI_SCRIPT_PATH`, `PHP_CLI_WORKING_DIR`, `SOFTWAREAG_INSTALL_ROOT`, `SOFTWAREAG_PRODUCTPROPNAME`, `SPRINGBOOT_APP_NAME`, `SPRINGBOOT_PROFILE_NAME`, `SPRINGBOOT_STARTUP_CLASS`, `TIBCO_BUSINESSWORKS_CE_APP_NAME`, `TIBCO_BUSINESSWORKS_CE_VERSION`, `TIBCO_BUSINESSWORKS_APP_NODE_NAME`, `TIBCO_BUSINESSWORKS_APP_SPACE_NAME`, `TIBCO_BUSINESSWORKS_DOMAIN_NAME`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE_PATH`, `TIBCO_BUSINESSWORKS_HOME`, `VARNISH_INSTANCE_NAME`, `WEBLOGIC_NAME`, `WEBLOGIC_CLUSTER_NAME`, `WEBLOGIC_DOMAIN_NAME`, `WEBLOGIC_HOME`, `WEBSPHERE_LIBERTY_SERVER_NAME`, `WEBSPHERE_CELL_NAME`, `WEBSPHERE_CLUSTER_NAME`, `WEBSPHERE_NODE_NAME`, `WEBSPHERE_SERVER_NAME`
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class ProcessGroupDetectionGroupExtractionDelimiter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "removeIds":
            suggest = "remove_ids"
        elif key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessGroupDetectionGroupExtractionDelimiter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessGroupDetectionGroupExtractionDelimiter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessGroupDetectionGroupExtractionDelimiter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remove_ids: bool,
                 from_: Optional[str] = None,
                 to: Optional[str] = None):
        """
        :param bool remove_ids: (e.g. versions, hex, dates, and build numbers)
        :param str from_: Delimit from
        :param str to: Delimit to
        """
        pulumi.set(__self__, "remove_ids", remove_ids)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="removeIds")
    def remove_ids(self) -> bool:
        """
        (e.g. versions, hex, dates, and build numbers)
        """
        return pulumi.get(self, "remove_ids")

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[str]:
        """
        Delimit from
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[str]:
        """
        Delimit to
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class ProcessGroupDetectionInstanceExtraction(dict):
    def __init__(__self__, *,
                 delimiter: Optional['outputs.ProcessGroupDetectionInstanceExtractionDelimiter'] = None,
                 property: Optional[str] = None):
        """
        :param 'ProcessGroupDetectionInstanceExtractionDelimiterArgs' delimiter: Optionally delimit this property between *From* and *To*.
        :param str property: Possible values: `DOTNET_COMMAND`, `DOTNET_COMMAND_PATH`, `ASP_NET_CORE_APPLICATION_PATH`, `AWS_ECR_ACCOUNT_ID`, `AWS_ECR_REGION`, `AWS_ECS_CLUSTER`, `AWS_ECS_CONTAINERNAME`, `AWS_ECS_FAMILY`, `AWS_ECS_REVISION`, `AWS_LAMBDA_FUNCTION_NAME`, `AWS_REGION`, `APACHE_SPARK_MASTER_IP_ADDRESS`, `APACHE_CONFIG_PATH`, `CATALINA_BASE`, `CATALINA_HOME`, `CLOUD_FOUNDRY_APP_NAME`, `CLOUD_FOUNDRY_APPLICATION_ID`, `CLOUD_FOUNDRY_INSTANCE_INDEX`, `CLOUD_FOUNDRY_SPACE_NAME`, `CLOUD_FOUNDRY_SPACE_ID`, `COLDFUSION_JVM_CONFIG_FILE`, `SERVICE_NAME`, `COMMAND_LINE_ARGS`, `CONTAINER_ID`, `CONTAINER_IMAGE_VERSION`, `CONTAINER_NAME`, `DECLARATIVE_ID`, `CONTAINER_IMAGE_NAME`, `RUXIT_CLUSTER_ID`, `RUXIT_NODE_ID`, `EXE_NAME`, `EXE_PATH`, `ELASTIC_SEARCH_CLUSTER_NAME`, `ELASTIC_SEARCH_NODE_NAME`, `EQUINOX_CONFIG_PATH`, `GLASSFISH_DOMAIN_NAME`, `GLASSFISH_INSTANCE_NAME`, `PG_ID_CALC_INPUT_KEY_LINKAGE`, `GAE_INSTANCE`, `GAE_SERVICE`, `GOOGLE_CLOUD_PROJECT`, `HYBRIS_BIN_DIR`, `HYBRIS_CONFIG_DIR`, `HYBRIS_DATA_DIR`, `IBM_CICS_REGION`, `IBM_CICS_IMS_APPLID`, `IBM_CICS_IMS_JOBNAME`, `IBM_CTG_NAME`, `IBM_IMS_CONNECT`, `IBM_IMS_CONTROL`, `IBM_IMS_MPR`, `IBM_IMS_SOAP_GW_NAME`, `IIB_BROKER_NAME`, `IIB_EXECUTION_GROUP_NAME`, `IIS_APP_POOL`, `IIS_ROLE_NAME`, `JBOSS_HOME`, `JBOSS_MODE`, `JBOSS_SERVER_NAME`, `JAVA_JAR_FILE`, `JAVA_JAR_PATH`, `JAVA_MAIN_CLASS`, `KUBERNETES_BASEPODNAME`, `KUBERNETES_CONTAINERNAME`, `KUBERNETES_FULLPODNAME`, `KUBERNETES_NAMESPACE`, `KUBERNETES_PODUID`, `MSSQL_INSTANCE_NAME`, `NODEJS_APP_NAME`, `NODEJS_APP_BASE_DIR`, `NODEJS_SCRIPT_NAME`, `ORACLE_SID`, `PHP_CLI_SCRIPT_PATH`, `PHP_CLI_WORKING_DIR`, `SOFTWAREAG_INSTALL_ROOT`, `SOFTWAREAG_PRODUCTPROPNAME`, `SPRINGBOOT_APP_NAME`, `SPRINGBOOT_PROFILE_NAME`, `SPRINGBOOT_STARTUP_CLASS`, `TIBCO_BUSINESSWORKS_CE_APP_NAME`, `TIBCO_BUSINESSWORKS_CE_VERSION`, `TIBCO_BUSINESSWORKS_APP_NODE_NAME`, `TIBCO_BUSINESSWORKS_APP_SPACE_NAME`, `TIBCO_BUSINESSWORKS_DOMAIN_NAME`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE_PATH`, `TIBCO_BUSINESSWORKS_HOME`, `VARNISH_INSTANCE_NAME`, `WEBLOGIC_NAME`, `WEBLOGIC_CLUSTER_NAME`, `WEBLOGIC_DOMAIN_NAME`, `WEBLOGIC_HOME`, `WEBSPHERE_LIBERTY_SERVER_NAME`, `WEBSPHERE_CELL_NAME`, `WEBSPHERE_CLUSTER_NAME`, `WEBSPHERE_NODE_NAME`, `WEBSPHERE_SERVER_NAME`
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if property is not None:
            pulumi.set(__self__, "property", property)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional['outputs.ProcessGroupDetectionInstanceExtractionDelimiter']:
        """
        Optionally delimit this property between *From* and *To*.
        """
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        """
        Possible values: `DOTNET_COMMAND`, `DOTNET_COMMAND_PATH`, `ASP_NET_CORE_APPLICATION_PATH`, `AWS_ECR_ACCOUNT_ID`, `AWS_ECR_REGION`, `AWS_ECS_CLUSTER`, `AWS_ECS_CONTAINERNAME`, `AWS_ECS_FAMILY`, `AWS_ECS_REVISION`, `AWS_LAMBDA_FUNCTION_NAME`, `AWS_REGION`, `APACHE_SPARK_MASTER_IP_ADDRESS`, `APACHE_CONFIG_PATH`, `CATALINA_BASE`, `CATALINA_HOME`, `CLOUD_FOUNDRY_APP_NAME`, `CLOUD_FOUNDRY_APPLICATION_ID`, `CLOUD_FOUNDRY_INSTANCE_INDEX`, `CLOUD_FOUNDRY_SPACE_NAME`, `CLOUD_FOUNDRY_SPACE_ID`, `COLDFUSION_JVM_CONFIG_FILE`, `SERVICE_NAME`, `COMMAND_LINE_ARGS`, `CONTAINER_ID`, `CONTAINER_IMAGE_VERSION`, `CONTAINER_NAME`, `DECLARATIVE_ID`, `CONTAINER_IMAGE_NAME`, `RUXIT_CLUSTER_ID`, `RUXIT_NODE_ID`, `EXE_NAME`, `EXE_PATH`, `ELASTIC_SEARCH_CLUSTER_NAME`, `ELASTIC_SEARCH_NODE_NAME`, `EQUINOX_CONFIG_PATH`, `GLASSFISH_DOMAIN_NAME`, `GLASSFISH_INSTANCE_NAME`, `PG_ID_CALC_INPUT_KEY_LINKAGE`, `GAE_INSTANCE`, `GAE_SERVICE`, `GOOGLE_CLOUD_PROJECT`, `HYBRIS_BIN_DIR`, `HYBRIS_CONFIG_DIR`, `HYBRIS_DATA_DIR`, `IBM_CICS_REGION`, `IBM_CICS_IMS_APPLID`, `IBM_CICS_IMS_JOBNAME`, `IBM_CTG_NAME`, `IBM_IMS_CONNECT`, `IBM_IMS_CONTROL`, `IBM_IMS_MPR`, `IBM_IMS_SOAP_GW_NAME`, `IIB_BROKER_NAME`, `IIB_EXECUTION_GROUP_NAME`, `IIS_APP_POOL`, `IIS_ROLE_NAME`, `JBOSS_HOME`, `JBOSS_MODE`, `JBOSS_SERVER_NAME`, `JAVA_JAR_FILE`, `JAVA_JAR_PATH`, `JAVA_MAIN_CLASS`, `KUBERNETES_BASEPODNAME`, `KUBERNETES_CONTAINERNAME`, `KUBERNETES_FULLPODNAME`, `KUBERNETES_NAMESPACE`, `KUBERNETES_PODUID`, `MSSQL_INSTANCE_NAME`, `NODEJS_APP_NAME`, `NODEJS_APP_BASE_DIR`, `NODEJS_SCRIPT_NAME`, `ORACLE_SID`, `PHP_CLI_SCRIPT_PATH`, `PHP_CLI_WORKING_DIR`, `SOFTWAREAG_INSTALL_ROOT`, `SOFTWAREAG_PRODUCTPROPNAME`, `SPRINGBOOT_APP_NAME`, `SPRINGBOOT_PROFILE_NAME`, `SPRINGBOOT_STARTUP_CLASS`, `TIBCO_BUSINESSWORKS_CE_APP_NAME`, `TIBCO_BUSINESSWORKS_CE_VERSION`, `TIBCO_BUSINESSWORKS_APP_NODE_NAME`, `TIBCO_BUSINESSWORKS_APP_SPACE_NAME`, `TIBCO_BUSINESSWORKS_DOMAIN_NAME`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE_PATH`, `TIBCO_BUSINESSWORKS_HOME`, `VARNISH_INSTANCE_NAME`, `WEBLOGIC_NAME`, `WEBLOGIC_CLUSTER_NAME`, `WEBLOGIC_DOMAIN_NAME`, `WEBLOGIC_HOME`, `WEBSPHERE_LIBERTY_SERVER_NAME`, `WEBSPHERE_CELL_NAME`, `WEBSPHERE_CLUSTER_NAME`, `WEBSPHERE_NODE_NAME`, `WEBSPHERE_SERVER_NAME`
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class ProcessGroupDetectionInstanceExtractionDelimiter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "removeIds":
            suggest = "remove_ids"
        elif key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessGroupDetectionInstanceExtractionDelimiter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessGroupDetectionInstanceExtractionDelimiter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessGroupDetectionInstanceExtractionDelimiter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remove_ids: bool,
                 from_: Optional[str] = None,
                 to: Optional[str] = None):
        """
        :param bool remove_ids: (e.g. versions, hex, dates, and build numbers)
        :param str from_: Delimit from
        :param str to: Delimit to
        """
        pulumi.set(__self__, "remove_ids", remove_ids)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="removeIds")
    def remove_ids(self) -> bool:
        """
        (e.g. versions, hex, dates, and build numbers)
        """
        return pulumi.get(self, "remove_ids")

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[str]:
        """
        Delimit from
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[str]:
        """
        Delimit to
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class ProcessGroupDetectionProcessDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containedString":
            suggest = "contained_string"
        elif key == "restrictToProcessType":
            suggest = "restrict_to_process_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessGroupDetectionProcessDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessGroupDetectionProcessDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessGroupDetectionProcessDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contained_string: str,
                 property: str,
                 restrict_to_process_type: Optional[str] = None):
        """
        :param str contained_string: The substring to be contained in the value `property` refers to. Case Sensitive
        :param str property: Possible values: `DOTNET_COMMAND`, `DOTNET_COMMAND_PATH`, `ASP_NET_CORE_APPLICATION_PATH`, `AWS_ECR_ACCOUNT_ID`, `AWS_ECR_REGION`, `AWS_ECS_CLUSTER`, `AWS_ECS_CONTAINERNAME`, `AWS_ECS_FAMILY`, `AWS_ECS_REVISION`, `AWS_LAMBDA_FUNCTION_NAME`, `AWS_REGION`, `APACHE_SPARK_MASTER_IP_ADDRESS`, `APACHE_CONFIG_PATH`, `CATALINA_BASE`, `CATALINA_HOME`, `CLOUD_FOUNDRY_APP_NAME`, `CLOUD_FOUNDRY_APPLICATION_ID`, `CLOUD_FOUNDRY_INSTANCE_INDEX`, `CLOUD_FOUNDRY_SPACE_NAME`, `CLOUD_FOUNDRY_SPACE_ID`, `COLDFUSION_JVM_CONFIG_FILE`, `SERVICE_NAME`, `COMMAND_LINE_ARGS`, `CONTAINER_ID`, `CONTAINER_IMAGE_VERSION`, `CONTAINER_NAME`, `DECLARATIVE_ID`, `CONTAINER_IMAGE_NAME`, `RUXIT_CLUSTER_ID`, `RUXIT_NODE_ID`, `EXE_NAME`, `EXE_PATH`, `ELASTIC_SEARCH_CLUSTER_NAME`, `ELASTIC_SEARCH_NODE_NAME`, `EQUINOX_CONFIG_PATH`, `GLASSFISH_DOMAIN_NAME`, `GLASSFISH_INSTANCE_NAME`, `PG_ID_CALC_INPUT_KEY_LINKAGE`, `GAE_INSTANCE`, `GAE_SERVICE`, `GOOGLE_CLOUD_PROJECT`, `HYBRIS_BIN_DIR`, `HYBRIS_CONFIG_DIR`, `HYBRIS_DATA_DIR`, `IBM_CICS_REGION`, `IBM_CICS_IMS_APPLID`, `IBM_CICS_IMS_JOBNAME`, `IBM_CTG_NAME`, `IBM_IMS_CONNECT`, `IBM_IMS_CONTROL`, `IBM_IMS_MPR`, `IBM_IMS_SOAP_GW_NAME`, `IIB_BROKER_NAME`, `IIB_EXECUTION_GROUP_NAME`, `IIS_APP_POOL`, `IIS_ROLE_NAME`, `JBOSS_HOME`, `JBOSS_MODE`, `JBOSS_SERVER_NAME`, `JAVA_JAR_FILE`, `JAVA_JAR_PATH`, `JAVA_MAIN_CLASS`, `KUBERNETES_BASEPODNAME`, `KUBERNETES_CONTAINERNAME`, `KUBERNETES_FULLPODNAME`, `KUBERNETES_NAMESPACE`, `KUBERNETES_PODUID`, `MSSQL_INSTANCE_NAME`, `NODEJS_APP_NAME`, `NODEJS_APP_BASE_DIR`, `NODEJS_SCRIPT_NAME`, `ORACLE_SID`, `PHP_CLI_SCRIPT_PATH`, `PHP_CLI_WORKING_DIR`, `SOFTWAREAG_INSTALL_ROOT`, `SOFTWAREAG_PRODUCTPROPNAME`, `SPRINGBOOT_APP_NAME`, `SPRINGBOOT_PROFILE_NAME`, `SPRINGBOOT_STARTUP_CLASS`, `TIBCO_BUSINESSWORKS_CE_APP_NAME`, `TIBCO_BUSINESSWORKS_CE_VERSION`, `TIBCO_BUSINESSWORKS_APP_NODE_NAME`, `TIBCO_BUSINESSWORKS_APP_SPACE_NAME`, `TIBCO_BUSINESSWORKS_DOMAIN_NAME`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE_PATH`, `TIBCO_BUSINESSWORKS_HOME`, `VARNISH_INSTANCE_NAME`, `WEBLOGIC_NAME`, `WEBLOGIC_CLUSTER_NAME`, `WEBLOGIC_DOMAIN_NAME`, `WEBLOGIC_HOME`, `WEBSPHERE_LIBERTY_SERVER_NAME`, `WEBSPHERE_CELL_NAME`, `WEBSPHERE_CLUSTER_NAME`, `WEBSPHERE_NODE_NAME`, `WEBSPHERE_SERVER_NAME`
        :param str restrict_to_process_type: Restrict this rule to specific process types. Note: Not all types can be detected at startup. Possible values: `PROCESS_TYPE_APACHE_HTTPD`, `PROCESS_TYPE_GLASSFISH`, `PROCESS_TYPE_GO`, `PROCESS_TYPE_IIS_APP_POOL`, `PROCESS_TYPE_JBOSS`, `PROCESS_TYPE_JAVA`, `PROCESS_TYPE_NGINX`, `PROCESS_TYPE_NODE_JS`, `PROCESS_TYPE_PHP`, `PROCESS_TYPE_TOMCAT`, `PROCESS_TYPE_WEBLOGIC`, `PROCESS_TYPE_WEBSPHERE`
        """
        pulumi.set(__self__, "contained_string", contained_string)
        pulumi.set(__self__, "property", property)
        if restrict_to_process_type is not None:
            pulumi.set(__self__, "restrict_to_process_type", restrict_to_process_type)

    @property
    @pulumi.getter(name="containedString")
    def contained_string(self) -> str:
        """
        The substring to be contained in the value `property` refers to. Case Sensitive
        """
        return pulumi.get(self, "contained_string")

    @property
    @pulumi.getter(name="restrictToProcessType")
    def restrict_to_process_type(self) -> Optional[str]:
        """
        Restrict this rule to specific process types. Note: Not all types can be detected at startup. Possible values: `PROCESS_TYPE_APACHE_HTTPD`, `PROCESS_TYPE_GLASSFISH`, `PROCESS_TYPE_GO`, `PROCESS_TYPE_IIS_APP_POOL`, `PROCESS_TYPE_JBOSS`, `PROCESS_TYPE_JAVA`, `PROCESS_TYPE_NGINX`, `PROCESS_TYPE_NODE_JS`, `PROCESS_TYPE_PHP`, `PROCESS_TYPE_TOMCAT`, `PROCESS_TYPE_WEBLOGIC`, `PROCESS_TYPE_WEBSPHERE`
        """
        return pulumi.get(self, "restrict_to_process_type")

    @property
    @pulumi.getter
    def property(self) -> str:
        """
        Possible values: `DOTNET_COMMAND`, `DOTNET_COMMAND_PATH`, `ASP_NET_CORE_APPLICATION_PATH`, `AWS_ECR_ACCOUNT_ID`, `AWS_ECR_REGION`, `AWS_ECS_CLUSTER`, `AWS_ECS_CONTAINERNAME`, `AWS_ECS_FAMILY`, `AWS_ECS_REVISION`, `AWS_LAMBDA_FUNCTION_NAME`, `AWS_REGION`, `APACHE_SPARK_MASTER_IP_ADDRESS`, `APACHE_CONFIG_PATH`, `CATALINA_BASE`, `CATALINA_HOME`, `CLOUD_FOUNDRY_APP_NAME`, `CLOUD_FOUNDRY_APPLICATION_ID`, `CLOUD_FOUNDRY_INSTANCE_INDEX`, `CLOUD_FOUNDRY_SPACE_NAME`, `CLOUD_FOUNDRY_SPACE_ID`, `COLDFUSION_JVM_CONFIG_FILE`, `SERVICE_NAME`, `COMMAND_LINE_ARGS`, `CONTAINER_ID`, `CONTAINER_IMAGE_VERSION`, `CONTAINER_NAME`, `DECLARATIVE_ID`, `CONTAINER_IMAGE_NAME`, `RUXIT_CLUSTER_ID`, `RUXIT_NODE_ID`, `EXE_NAME`, `EXE_PATH`, `ELASTIC_SEARCH_CLUSTER_NAME`, `ELASTIC_SEARCH_NODE_NAME`, `EQUINOX_CONFIG_PATH`, `GLASSFISH_DOMAIN_NAME`, `GLASSFISH_INSTANCE_NAME`, `PG_ID_CALC_INPUT_KEY_LINKAGE`, `GAE_INSTANCE`, `GAE_SERVICE`, `GOOGLE_CLOUD_PROJECT`, `HYBRIS_BIN_DIR`, `HYBRIS_CONFIG_DIR`, `HYBRIS_DATA_DIR`, `IBM_CICS_REGION`, `IBM_CICS_IMS_APPLID`, `IBM_CICS_IMS_JOBNAME`, `IBM_CTG_NAME`, `IBM_IMS_CONNECT`, `IBM_IMS_CONTROL`, `IBM_IMS_MPR`, `IBM_IMS_SOAP_GW_NAME`, `IIB_BROKER_NAME`, `IIB_EXECUTION_GROUP_NAME`, `IIS_APP_POOL`, `IIS_ROLE_NAME`, `JBOSS_HOME`, `JBOSS_MODE`, `JBOSS_SERVER_NAME`, `JAVA_JAR_FILE`, `JAVA_JAR_PATH`, `JAVA_MAIN_CLASS`, `KUBERNETES_BASEPODNAME`, `KUBERNETES_CONTAINERNAME`, `KUBERNETES_FULLPODNAME`, `KUBERNETES_NAMESPACE`, `KUBERNETES_PODUID`, `MSSQL_INSTANCE_NAME`, `NODEJS_APP_NAME`, `NODEJS_APP_BASE_DIR`, `NODEJS_SCRIPT_NAME`, `ORACLE_SID`, `PHP_CLI_SCRIPT_PATH`, `PHP_CLI_WORKING_DIR`, `SOFTWAREAG_INSTALL_ROOT`, `SOFTWAREAG_PRODUCTPROPNAME`, `SPRINGBOOT_APP_NAME`, `SPRINGBOOT_PROFILE_NAME`, `SPRINGBOOT_STARTUP_CLASS`, `TIBCO_BUSINESSWORKS_CE_APP_NAME`, `TIBCO_BUSINESSWORKS_CE_VERSION`, `TIBCO_BUSINESSWORKS_APP_NODE_NAME`, `TIBCO_BUSINESSWORKS_APP_SPACE_NAME`, `TIBCO_BUSINESSWORKS_DOMAIN_NAME`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE_PATH`, `TIBCO_BUSINESSWORKS_HOME`, `VARNISH_INSTANCE_NAME`, `WEBLOGIC_NAME`, `WEBLOGIC_CLUSTER_NAME`, `WEBLOGIC_DOMAIN_NAME`, `WEBLOGIC_HOME`, `WEBSPHERE_LIBERTY_SERVER_NAME`, `WEBSPHERE_CELL_NAME`, `WEBSPHERE_CLUSTER_NAME`, `WEBSPHERE_NODE_NAME`, `WEBSPHERE_SERVER_NAME`
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class ProcessMonitoringRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "envVar":
            suggest = "env_var"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessMonitoringRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessMonitoringRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessMonitoringRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 item: str,
                 operator: str,
                 env_var: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str item: Condition target
        :param str operator: Condition operator
        :param str env_var: supported only with OneAgent 1.167+
        :param str value: Condition value
        """
        pulumi.set(__self__, "item", item)
        pulumi.set(__self__, "operator", operator)
        if env_var is not None:
            pulumi.set(__self__, "env_var", env_var)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def item(self) -> str:
        """
        Condition target
        """
        return pulumi.get(self, "item")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Condition operator
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="envVar")
    def env_var(self) -> Optional[str]:
        """
        supported only with OneAgent 1.167+
        """
        return pulumi.get(self, "env_var")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Condition value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingCondition(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.ProcessgroupNamingConditionCondition']] = None):
        """
        :param Sequence['ProcessgroupNamingConditionConditionArgs'] conditions: A conditions for the metric usage
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionCondition']]:
        """
        A conditions for the metric usage
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ProcessgroupNamingConditionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationTypeComparisons":
            suggest = "application_type_comparisons"
        elif key == "applicationTypes":
            suggest = "application_types"
        elif key == "azureComputeModeComparisons":
            suggest = "azure_compute_mode_comparisons"
        elif key == "azureComputeModes":
            suggest = "azure_compute_modes"
        elif key == "azureSkuComparisions":
            suggest = "azure_sku_comparisions"
        elif key == "azureSkus":
            suggest = "azure_skus"
        elif key == "baseComparisonBasics":
            suggest = "base_comparison_basics"
        elif key == "baseConditionKeys":
            suggest = "base_condition_keys"
        elif key == "bitnessComparisions":
            suggest = "bitness_comparisions"
        elif key == "cloudTypeComparisons":
            suggest = "cloud_type_comparisons"
        elif key == "cloudTypes":
            suggest = "cloud_types"
        elif key == "customApplicationTypeComparisons":
            suggest = "custom_application_type_comparisons"
        elif key == "customApplicationTypes":
            suggest = "custom_application_types"
        elif key == "customHostMetadataConditionKeys":
            suggest = "custom_host_metadata_condition_keys"
        elif key == "customHostMetadatas":
            suggest = "custom_host_metadatas"
        elif key == "customProcessMetadataConditionKeys":
            suggest = "custom_process_metadata_condition_keys"
        elif key == "customProcessMetadatas":
            suggest = "custom_process_metadatas"
        elif key == "databaseTopologies":
            suggest = "database_topologies"
        elif key == "databaseTopologyComparisons":
            suggest = "database_topology_comparisons"
        elif key == "dcrumDecoderComparisons":
            suggest = "dcrum_decoder_comparisons"
        elif key == "dcrumDecoders":
            suggest = "dcrum_decoders"
        elif key == "entityIdComparisons":
            suggest = "entity_id_comparisons"
        elif key == "hostTeches":
            suggest = "host_teches"
        elif key == "hypervisorTypeComparisions":
            suggest = "hypervisor_type_comparisions"
        elif key == "indexedNameComparisons":
            suggest = "indexed_name_comparisons"
        elif key == "indexedNames":
            suggest = "indexed_names"
        elif key == "indexedStringComparisons":
            suggest = "indexed_string_comparisons"
        elif key == "indexedStrings":
            suggest = "indexed_strings"
        elif key == "indexedTagComparisons":
            suggest = "indexed_tag_comparisons"
        elif key == "indexedTags":
            suggest = "indexed_tags"
        elif key == "integerComparisons":
            suggest = "integer_comparisons"
        elif key == "ipaddressComparisons":
            suggest = "ipaddress_comparisons"
        elif key == "mobilePlatformComparisons":
            suggest = "mobile_platform_comparisons"
        elif key == "mobilePlatforms":
            suggest = "mobile_platforms"
        elif key == "osArches":
            suggest = "os_arches"
        elif key == "osTypes":
            suggest = "os_types"
        elif key == "osarchitectureComparisons":
            suggest = "osarchitecture_comparisons"
        elif key == "ostypeComparisons":
            suggest = "ostype_comparisons"
        elif key == "paasTypeComparisons":
            suggest = "paas_type_comparisons"
        elif key == "paasTypes":
            suggest = "paas_types"
        elif key == "processMetadataConditionKeys":
            suggest = "process_metadata_condition_keys"
        elif key == "processMetadatas":
            suggest = "process_metadatas"
        elif key == "serviceTopologies":
            suggest = "service_topologies"
        elif key == "serviceTopologyComparisons":
            suggest = "service_topology_comparisons"
        elif key == "serviceTypeComparisons":
            suggest = "service_type_comparisons"
        elif key == "serviceTypes":
            suggest = "service_types"
        elif key == "simpleHostTechComparisons":
            suggest = "simple_host_tech_comparisons"
        elif key == "simpleTechComparisons":
            suggest = "simple_tech_comparisons"
        elif key == "stringComparisons":
            suggest = "string_comparisons"
        elif key == "stringConditionKeys":
            suggest = "string_condition_keys"
        elif key == "stringKeys":
            suggest = "string_keys"
        elif key == "syntheticEngineTypeComparisons":
            suggest = "synthetic_engine_type_comparisons"
        elif key == "syntheticEngines":
            suggest = "synthetic_engines"
        elif key == "tagComparisons":
            suggest = "tag_comparisons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_type_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionApplicationTypeComparison']] = None,
                 application_types: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionApplicationType']] = None,
                 azure_compute_mode_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureComputeModeComparison']] = None,
                 azure_compute_modes: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureComputeMode']] = None,
                 azure_sku_comparisions: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureSkuComparision']] = None,
                 azure_skus: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureSkus']] = None,
                 base_comparison_basics: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBaseComparisonBasic']] = None,
                 base_condition_keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBaseConditionKey']] = None,
                 bitness_comparisions: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBitnessComparision']] = None,
                 bitnesses: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBitness']] = None,
                 cloud_type_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCloudTypeComparison']] = None,
                 cloud_types: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCloudType']] = None,
                 comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionComparison']] = None,
                 custom_application_type_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomApplicationTypeComparison']] = None,
                 custom_application_types: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomApplicationType']] = None,
                 custom_host_metadata_condition_keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey']] = None,
                 custom_host_metadatas: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomHostMetadata']] = None,
                 custom_process_metadata_condition_keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey']] = None,
                 custom_process_metadatas: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomProcessMetadata']] = None,
                 database_topologies: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDatabaseTopology']] = None,
                 database_topology_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDatabaseTopologyComparison']] = None,
                 dcrum_decoder_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDcrumDecoderComparison']] = None,
                 dcrum_decoders: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDcrumDecoder']] = None,
                 entities: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionEntity']] = None,
                 entity_id_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionEntityIdComparison']] = None,
                 host_teches: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionHostTech']] = None,
                 hypervisor_type_comparisions: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionHypervisorTypeComparision']] = None,
                 hypervisors: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionHypervisor']] = None,
                 indexed_name_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedNameComparison']] = None,
                 indexed_names: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedName']] = None,
                 indexed_string_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedStringComparison']] = None,
                 indexed_strings: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedString']] = None,
                 indexed_tag_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedTagComparison']] = None,
                 indexed_tags: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedTag']] = None,
                 integer_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIntegerComparison']] = None,
                 integers: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionInteger']] = None,
                 ipaddress_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIpaddressComparison']] = None,
                 ipaddresses: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIpaddress']] = None,
                 keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionKey']] = None,
                 mobile_platform_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionMobilePlatformComparison']] = None,
                 mobile_platforms: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionMobilePlatform']] = None,
                 os_arches: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOsArch']] = None,
                 os_types: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOsType']] = None,
                 osarchitecture_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOsarchitectureComparison']] = None,
                 ostype_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOstypeComparison']] = None,
                 paas_type_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionPaasTypeComparison']] = None,
                 paas_types: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionPaasType']] = None,
                 process_metadata_condition_keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionProcessMetadataConditionKey']] = None,
                 process_metadatas: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionProcessMetadata']] = None,
                 service_topologies: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceTopology']] = None,
                 service_topology_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceTopologyComparison']] = None,
                 service_type_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceTypeComparison']] = None,
                 service_types: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceType']] = None,
                 simple_host_tech_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSimpleHostTechComparison']] = None,
                 simple_tech_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSimpleTechComparison']] = None,
                 string_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionStringComparison']] = None,
                 string_condition_keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionStringConditionKey']] = None,
                 string_keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionStringKey']] = None,
                 strings: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionString']] = None,
                 synthetic_engine_type_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSyntheticEngineTypeComparison']] = None,
                 synthetic_engines: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSyntheticEngine']] = None,
                 tag_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionTagComparison']] = None,
                 tags: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionTag']] = None,
                 teches: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionTech']] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence['ProcessgroupNamingConditionConditionApplicationTypeComparisonArgs'] application_type_comparisons: Comparison for `APPLICATION_TYPE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionApplicationTypeArgs'] application_types: Comparison for `APPLICATION_TYPE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionAzureComputeModeComparisonArgs'] azure_compute_mode_comparisons: Comparison for `AZURE_COMPUTE_MODE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionAzureComputeModeArgs'] azure_compute_modes: Comparison for `AZURE_COMPUTE_MODE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionAzureSkuComparisionArgs'] azure_sku_comparisions: Comparison for `AZURE_SKU` attributes
        :param Sequence['ProcessgroupNamingConditionConditionAzureSkusArgs'] azure_skus: Comparison for `AZURE_SKU` attributes
        :param Sequence['ProcessgroupNamingConditionConditionBaseComparisonBasicArgs'] base_comparison_basics: A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        :param Sequence['ProcessgroupNamingConditionConditionBaseConditionKeyArgs'] base_condition_keys: Fallback for not yet known type
        :param Sequence['ProcessgroupNamingConditionConditionBitnessComparisionArgs'] bitness_comparisions: Comparison for `BITNESS` attributes
        :param Sequence['ProcessgroupNamingConditionConditionBitnessArgs'] bitnesses: Comparison for `BITNESS` attributes
        :param Sequence['ProcessgroupNamingConditionConditionCloudTypeComparisonArgs'] cloud_type_comparisons: Comparison for `CLOUD_TYPE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionCloudTypeArgs'] cloud_types: Comparison for `CLOUD_TYPE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionComparisonArgs'] comparisons: A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        :param Sequence['ProcessgroupNamingConditionConditionCustomApplicationTypeComparisonArgs'] custom_application_type_comparisons: Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionCustomApplicationTypeArgs'] custom_application_types: Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionCustomHostMetadataConditionKeyArgs'] custom_host_metadata_condition_keys: Key for Custom Host Metadata
        :param Sequence['ProcessgroupNamingConditionConditionCustomHostMetadataArgs'] custom_host_metadatas: Key for Custom Host Metadata
        :param Sequence['ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKeyArgs'] custom_process_metadata_condition_keys: Key for Custom Process Metadata
        :param Sequence['ProcessgroupNamingConditionConditionCustomProcessMetadataArgs'] custom_process_metadatas: Key for Custom Process Metadata
        :param Sequence['ProcessgroupNamingConditionConditionDatabaseTopologyArgs'] database_topologies: Comparison for `DATABASE_TOPOLOGY` attributes
        :param Sequence['ProcessgroupNamingConditionConditionDatabaseTopologyComparisonArgs'] database_topology_comparisons: Comparison for `DATABASE_TOPOLOGY` attributes
        :param Sequence['ProcessgroupNamingConditionConditionDcrumDecoderComparisonArgs'] dcrum_decoder_comparisons: Comparison for `DCRUM_DECODER_TYPE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionDcrumDecoderArgs'] dcrum_decoders: Comparison for `DCRUM_DECODER_TYPE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionEntityArgs'] entities: Comparison for `ENTITY_ID` attributes
        :param Sequence['ProcessgroupNamingConditionConditionEntityIdComparisonArgs'] entity_id_comparisons: Comparison for `ENTITY_ID` attributes
        :param Sequence['ProcessgroupNamingConditionConditionHostTechArgs'] host_teches: Comparison for `SIMPLE_HOST_TECH` attributes
        :param Sequence['ProcessgroupNamingConditionConditionHypervisorTypeComparisionArgs'] hypervisor_type_comparisions: `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
        :param Sequence['ProcessgroupNamingConditionConditionHypervisorArgs'] hypervisors: Comparison for `HYPERVISOR_TYPE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionIndexedNameComparisonArgs'] indexed_name_comparisons: Comparison for `INDEXED_NAME` attributes
        :param Sequence['ProcessgroupNamingConditionConditionIndexedNameArgs'] indexed_names: Comparison for `INDEXED_NAME` attributes
        :param Sequence['ProcessgroupNamingConditionConditionIndexedStringComparisonArgs'] indexed_string_comparisons: Comparison for `INDEXED_STRING` attributes
        :param Sequence['ProcessgroupNamingConditionConditionIndexedStringArgs'] indexed_strings: Comparison for `INDEXED_STRING` attributes
        :param Sequence['ProcessgroupNamingConditionConditionIndexedTagComparisonArgs'] indexed_tag_comparisons: Comparison for `INDEXED_TAG` attributes
        :param Sequence['ProcessgroupNamingConditionConditionIndexedTagArgs'] indexed_tags: Comparison for `INDEXED_TAG` attributes
        :param Sequence['ProcessgroupNamingConditionConditionIntegerComparisonArgs'] integer_comparisons: Comparison for `INTEGER` attributes
        :param Sequence['ProcessgroupNamingConditionConditionIntegerArgs'] integers: Comparison for `INTEGER` attributes
        :param Sequence['ProcessgroupNamingConditionConditionIpaddressComparisonArgs'] ipaddress_comparisons: Comparison for `IP_ADDRESS` attributes
        :param Sequence['ProcessgroupNamingConditionConditionIpaddressArgs'] ipaddresses: Comparison for `IP_ADDRESS` attributes
        :param Sequence['ProcessgroupNamingConditionConditionKeyArgs'] keys: Fallback for not yet known type
        :param Sequence['ProcessgroupNamingConditionConditionMobilePlatformComparisonArgs'] mobile_platform_comparisons: Comparison for `MOBILE_PLATFORM` attributes
        :param Sequence['ProcessgroupNamingConditionConditionMobilePlatformArgs'] mobile_platforms: Comparison for `MOBILE_PLATFORM` attributes
        :param Sequence['ProcessgroupNamingConditionConditionOsArchArgs'] os_arches: Comparison for `OS_ARCHITECTURE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionOsTypeArgs'] os_types: Comparison for `OS_TYPE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionOsarchitectureComparisonArgs'] osarchitecture_comparisons: Comparison for `OS_ARCHITECTURE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionOstypeComparisonArgs'] ostype_comparisons: Comparison for `OS_TYPE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionPaasTypeComparisonArgs'] paas_type_comparisons: Comparison for `PAAS_TYPE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionPaasTypeArgs'] paas_types: Comparison for `PAAS_TYPE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionProcessMetadataConditionKeyArgs'] process_metadata_condition_keys: The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        :param Sequence['ProcessgroupNamingConditionConditionProcessMetadataArgs'] process_metadatas: The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        :param Sequence['ProcessgroupNamingConditionConditionServiceTopologyArgs'] service_topologies: Comparison for `SERVICE_TOPOLOGY` attributes
        :param Sequence['ProcessgroupNamingConditionConditionServiceTopologyComparisonArgs'] service_topology_comparisons: Comparison for `SERVICE_TOPOLOGY` attributes
        :param Sequence['ProcessgroupNamingConditionConditionServiceTypeComparisonArgs'] service_type_comparisons: Comparison for `SERVICE_TYPE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionServiceTypeArgs'] service_types: Comparison for `SERVICE_TYPE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionSimpleHostTechComparisonArgs'] simple_host_tech_comparisons: Comparison for `SIMPLE_HOST_TECH` attributes
        :param Sequence['ProcessgroupNamingConditionConditionSimpleTechComparisonArgs'] simple_tech_comparisons: Comparison for `SIMPLE_TECH` attributes
        :param Sequence['ProcessgroupNamingConditionConditionStringComparisonArgs'] string_comparisons: Comparison for `STRING` attributes
        :param Sequence['ProcessgroupNamingConditionConditionStringConditionKeyArgs'] string_condition_keys: The key for dynamic attributes of the `STRING` type
        :param Sequence['ProcessgroupNamingConditionConditionStringKeyArgs'] string_keys: The key for dynamic attributes of the `STRING` type
        :param Sequence['ProcessgroupNamingConditionConditionStringArgs'] strings: Comparison for `STRING` attributes
        :param Sequence['ProcessgroupNamingConditionConditionSyntheticEngineTypeComparisonArgs'] synthetic_engine_type_comparisons: Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionSyntheticEngineArgs'] synthetic_engines: Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        :param Sequence['ProcessgroupNamingConditionConditionTagComparisonArgs'] tag_comparisons: Comparison for `TAG` attributes
        :param Sequence['ProcessgroupNamingConditionConditionTagArgs'] tags: Comparison for `TAG` attributes
        :param Sequence['ProcessgroupNamingConditionConditionTechArgs'] teches: Comparison for `SIMPLE_TECH` attributes
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if application_type_comparisons is not None:
            pulumi.set(__self__, "application_type_comparisons", application_type_comparisons)
        if application_types is not None:
            pulumi.set(__self__, "application_types", application_types)
        if azure_compute_mode_comparisons is not None:
            pulumi.set(__self__, "azure_compute_mode_comparisons", azure_compute_mode_comparisons)
        if azure_compute_modes is not None:
            pulumi.set(__self__, "azure_compute_modes", azure_compute_modes)
        if azure_sku_comparisions is not None:
            pulumi.set(__self__, "azure_sku_comparisions", azure_sku_comparisions)
        if azure_skus is not None:
            pulumi.set(__self__, "azure_skus", azure_skus)
        if base_comparison_basics is not None:
            pulumi.set(__self__, "base_comparison_basics", base_comparison_basics)
        if base_condition_keys is not None:
            pulumi.set(__self__, "base_condition_keys", base_condition_keys)
        if bitness_comparisions is not None:
            pulumi.set(__self__, "bitness_comparisions", bitness_comparisions)
        if bitnesses is not None:
            pulumi.set(__self__, "bitnesses", bitnesses)
        if cloud_type_comparisons is not None:
            pulumi.set(__self__, "cloud_type_comparisons", cloud_type_comparisons)
        if cloud_types is not None:
            pulumi.set(__self__, "cloud_types", cloud_types)
        if comparisons is not None:
            pulumi.set(__self__, "comparisons", comparisons)
        if custom_application_type_comparisons is not None:
            pulumi.set(__self__, "custom_application_type_comparisons", custom_application_type_comparisons)
        if custom_application_types is not None:
            pulumi.set(__self__, "custom_application_types", custom_application_types)
        if custom_host_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_host_metadata_condition_keys", custom_host_metadata_condition_keys)
        if custom_host_metadatas is not None:
            pulumi.set(__self__, "custom_host_metadatas", custom_host_metadatas)
        if custom_process_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_process_metadata_condition_keys", custom_process_metadata_condition_keys)
        if custom_process_metadatas is not None:
            pulumi.set(__self__, "custom_process_metadatas", custom_process_metadatas)
        if database_topologies is not None:
            pulumi.set(__self__, "database_topologies", database_topologies)
        if database_topology_comparisons is not None:
            pulumi.set(__self__, "database_topology_comparisons", database_topology_comparisons)
        if dcrum_decoder_comparisons is not None:
            pulumi.set(__self__, "dcrum_decoder_comparisons", dcrum_decoder_comparisons)
        if dcrum_decoders is not None:
            pulumi.set(__self__, "dcrum_decoders", dcrum_decoders)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if entity_id_comparisons is not None:
            pulumi.set(__self__, "entity_id_comparisons", entity_id_comparisons)
        if host_teches is not None:
            pulumi.set(__self__, "host_teches", host_teches)
        if hypervisor_type_comparisions is not None:
            pulumi.set(__self__, "hypervisor_type_comparisions", hypervisor_type_comparisions)
        if hypervisors is not None:
            pulumi.set(__self__, "hypervisors", hypervisors)
        if indexed_name_comparisons is not None:
            pulumi.set(__self__, "indexed_name_comparisons", indexed_name_comparisons)
        if indexed_names is not None:
            pulumi.set(__self__, "indexed_names", indexed_names)
        if indexed_string_comparisons is not None:
            pulumi.set(__self__, "indexed_string_comparisons", indexed_string_comparisons)
        if indexed_strings is not None:
            pulumi.set(__self__, "indexed_strings", indexed_strings)
        if indexed_tag_comparisons is not None:
            pulumi.set(__self__, "indexed_tag_comparisons", indexed_tag_comparisons)
        if indexed_tags is not None:
            pulumi.set(__self__, "indexed_tags", indexed_tags)
        if integer_comparisons is not None:
            pulumi.set(__self__, "integer_comparisons", integer_comparisons)
        if integers is not None:
            pulumi.set(__self__, "integers", integers)
        if ipaddress_comparisons is not None:
            pulumi.set(__self__, "ipaddress_comparisons", ipaddress_comparisons)
        if ipaddresses is not None:
            pulumi.set(__self__, "ipaddresses", ipaddresses)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if mobile_platform_comparisons is not None:
            pulumi.set(__self__, "mobile_platform_comparisons", mobile_platform_comparisons)
        if mobile_platforms is not None:
            pulumi.set(__self__, "mobile_platforms", mobile_platforms)
        if os_arches is not None:
            pulumi.set(__self__, "os_arches", os_arches)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if osarchitecture_comparisons is not None:
            pulumi.set(__self__, "osarchitecture_comparisons", osarchitecture_comparisons)
        if ostype_comparisons is not None:
            pulumi.set(__self__, "ostype_comparisons", ostype_comparisons)
        if paas_type_comparisons is not None:
            pulumi.set(__self__, "paas_type_comparisons", paas_type_comparisons)
        if paas_types is not None:
            pulumi.set(__self__, "paas_types", paas_types)
        if process_metadata_condition_keys is not None:
            pulumi.set(__self__, "process_metadata_condition_keys", process_metadata_condition_keys)
        if process_metadatas is not None:
            pulumi.set(__self__, "process_metadatas", process_metadatas)
        if service_topologies is not None:
            pulumi.set(__self__, "service_topologies", service_topologies)
        if service_topology_comparisons is not None:
            pulumi.set(__self__, "service_topology_comparisons", service_topology_comparisons)
        if service_type_comparisons is not None:
            pulumi.set(__self__, "service_type_comparisons", service_type_comparisons)
        if service_types is not None:
            pulumi.set(__self__, "service_types", service_types)
        if simple_host_tech_comparisons is not None:
            pulumi.set(__self__, "simple_host_tech_comparisons", simple_host_tech_comparisons)
        if simple_tech_comparisons is not None:
            pulumi.set(__self__, "simple_tech_comparisons", simple_tech_comparisons)
        if string_comparisons is not None:
            pulumi.set(__self__, "string_comparisons", string_comparisons)
        if string_condition_keys is not None:
            pulumi.set(__self__, "string_condition_keys", string_condition_keys)
        if string_keys is not None:
            pulumi.set(__self__, "string_keys", string_keys)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)
        if synthetic_engine_type_comparisons is not None:
            pulumi.set(__self__, "synthetic_engine_type_comparisons", synthetic_engine_type_comparisons)
        if synthetic_engines is not None:
            pulumi.set(__self__, "synthetic_engines", synthetic_engines)
        if tag_comparisons is not None:
            pulumi.set(__self__, "tag_comparisons", tag_comparisons)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if teches is not None:
            pulumi.set(__self__, "teches", teches)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="applicationTypeComparisons")
    @_utilities.deprecated("""You should use 'application_type' instead of 'application_type_comparison'. This attribute still exists for backwards compatibility.""")
    def application_type_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionApplicationTypeComparison']]:
        """
        Comparison for `APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "application_type_comparisons")

    @property
    @pulumi.getter(name="applicationTypes")
    def application_types(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionApplicationType']]:
        """
        Comparison for `APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "application_types")

    @property
    @pulumi.getter(name="azureComputeModeComparisons")
    def azure_compute_mode_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureComputeModeComparison']]:
        """
        Comparison for `AZURE_COMPUTE_MODE` attributes
        """
        return pulumi.get(self, "azure_compute_mode_comparisons")

    @property
    @pulumi.getter(name="azureComputeModes")
    @_utilities.deprecated("""You should use 'azure_compute_mode' instead of 'azure_compute_mode_comparison'. This attribute still exists for backwards compatibility.""")
    def azure_compute_modes(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureComputeMode']]:
        """
        Comparison for `AZURE_COMPUTE_MODE` attributes
        """
        return pulumi.get(self, "azure_compute_modes")

    @property
    @pulumi.getter(name="azureSkuComparisions")
    @_utilities.deprecated("""You should use 'azure_sku' instead of 'azure_sku_comparision'. This attribute still exists for backwards compatibility.""")
    def azure_sku_comparisions(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureSkuComparision']]:
        """
        Comparison for `AZURE_SKU` attributes
        """
        return pulumi.get(self, "azure_sku_comparisions")

    @property
    @pulumi.getter(name="azureSkus")
    def azure_skus(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureSkus']]:
        """
        Comparison for `AZURE_SKU` attributes
        """
        return pulumi.get(self, "azure_skus")

    @property
    @pulumi.getter(name="baseComparisonBasics")
    @_utilities.deprecated("""You should use 'comparison' instead of 'base_comparison_basic'. This attribute still exists for backwards compatibility.""")
    def base_comparison_basics(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBaseComparisonBasic']]:
        """
        A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        """
        return pulumi.get(self, "base_comparison_basics")

    @property
    @pulumi.getter(name="baseConditionKeys")
    @_utilities.deprecated("""'base_condition_key' is deprecated. You should use 'key'""")
    def base_condition_keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBaseConditionKey']]:
        """
        Fallback for not yet known type
        """
        return pulumi.get(self, "base_condition_keys")

    @property
    @pulumi.getter(name="bitnessComparisions")
    @_utilities.deprecated("""You should use 'bitness' instead of 'bitness_comparision'. This attribute still exists for backwards compatibility.""")
    def bitness_comparisions(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBitnessComparision']]:
        """
        Comparison for `BITNESS` attributes
        """
        return pulumi.get(self, "bitness_comparisions")

    @property
    @pulumi.getter
    def bitnesses(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBitness']]:
        """
        Comparison for `BITNESS` attributes
        """
        return pulumi.get(self, "bitnesses")

    @property
    @pulumi.getter(name="cloudTypeComparisons")
    @_utilities.deprecated("""You should use 'cloud_type' instead of 'cloud_type_comparison'. This attribute still exists for backwards compatibility.""")
    def cloud_type_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCloudTypeComparison']]:
        """
        Comparison for `CLOUD_TYPE` attributes
        """
        return pulumi.get(self, "cloud_type_comparisons")

    @property
    @pulumi.getter(name="cloudTypes")
    def cloud_types(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCloudType']]:
        """
        Comparison for `CLOUD_TYPE` attributes
        """
        return pulumi.get(self, "cloud_types")

    @property
    @pulumi.getter
    def comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionComparison']]:
        """
        A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        """
        return pulumi.get(self, "comparisons")

    @property
    @pulumi.getter(name="customApplicationTypeComparisons")
    @_utilities.deprecated("""You should use 'custom_application_type' instead of 'custom_application_type_comparison'. This attribute still exists for backwards compatibility.""")
    def custom_application_type_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomApplicationTypeComparison']]:
        """
        Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "custom_application_type_comparisons")

    @property
    @pulumi.getter(name="customApplicationTypes")
    def custom_application_types(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomApplicationType']]:
        """
        Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "custom_application_types")

    @property
    @pulumi.getter(name="customHostMetadataConditionKeys")
    @_utilities.deprecated("""'custom_host_metadata_condition_key' is deprecated. You should use 'custom_host_metadata'""")
    def custom_host_metadata_condition_keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey']]:
        """
        Key for Custom Host Metadata
        """
        return pulumi.get(self, "custom_host_metadata_condition_keys")

    @property
    @pulumi.getter(name="customHostMetadatas")
    def custom_host_metadatas(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomHostMetadata']]:
        """
        Key for Custom Host Metadata
        """
        return pulumi.get(self, "custom_host_metadatas")

    @property
    @pulumi.getter(name="customProcessMetadataConditionKeys")
    @_utilities.deprecated("""'custom_process_metadata_condition_key' is deprecated. You should use 'custom_process_metadata'""")
    def custom_process_metadata_condition_keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey']]:
        """
        Key for Custom Process Metadata
        """
        return pulumi.get(self, "custom_process_metadata_condition_keys")

    @property
    @pulumi.getter(name="customProcessMetadatas")
    def custom_process_metadatas(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomProcessMetadata']]:
        """
        Key for Custom Process Metadata
        """
        return pulumi.get(self, "custom_process_metadatas")

    @property
    @pulumi.getter(name="databaseTopologies")
    def database_topologies(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDatabaseTopology']]:
        """
        Comparison for `DATABASE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "database_topologies")

    @property
    @pulumi.getter(name="databaseTopologyComparisons")
    @_utilities.deprecated("""You should use 'database_topology' instead of 'database_topology_comparison'. This attribute still exists for backwards compatibility.""")
    def database_topology_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDatabaseTopologyComparison']]:
        """
        Comparison for `DATABASE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "database_topology_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoderComparisons")
    @_utilities.deprecated("""You should use 'dcrum_decoder' instead of 'dcrum_decoder_comparison'. This attribute still exists for backwards compatibility.""")
    def dcrum_decoder_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDcrumDecoderComparison']]:
        """
        Comparison for `DCRUM_DECODER_TYPE` attributes
        """
        return pulumi.get(self, "dcrum_decoder_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoders")
    def dcrum_decoders(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDcrumDecoder']]:
        """
        Comparison for `DCRUM_DECODER_TYPE` attributes
        """
        return pulumi.get(self, "dcrum_decoders")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionEntity']]:
        """
        Comparison for `ENTITY_ID` attributes
        """
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="entityIdComparisons")
    @_utilities.deprecated("""You should use 'entity' instead of 'entity_id_comparison'. This attribute still exists for backwards compatibility.""")
    def entity_id_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionEntityIdComparison']]:
        """
        Comparison for `ENTITY_ID` attributes
        """
        return pulumi.get(self, "entity_id_comparisons")

    @property
    @pulumi.getter(name="hostTeches")
    def host_teches(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionHostTech']]:
        """
        Comparison for `SIMPLE_HOST_TECH` attributes
        """
        return pulumi.get(self, "host_teches")

    @property
    @pulumi.getter(name="hypervisorTypeComparisions")
    @_utilities.deprecated("""`hypervisor_type_comparision` is deprecated. Use `hypervisor` instead""")
    def hypervisor_type_comparisions(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionHypervisorTypeComparision']]:
        """
        `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
        """
        return pulumi.get(self, "hypervisor_type_comparisions")

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionHypervisor']]:
        """
        Comparison for `HYPERVISOR_TYPE` attributes
        """
        return pulumi.get(self, "hypervisors")

    @property
    @pulumi.getter(name="indexedNameComparisons")
    @_utilities.deprecated("""You should use 'indexed_name' instead of 'indexed_name_comparison'. This attribute still exists for backwards compatibility.""")
    def indexed_name_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedNameComparison']]:
        """
        Comparison for `INDEXED_NAME` attributes
        """
        return pulumi.get(self, "indexed_name_comparisons")

    @property
    @pulumi.getter(name="indexedNames")
    def indexed_names(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedName']]:
        """
        Comparison for `INDEXED_NAME` attributes
        """
        return pulumi.get(self, "indexed_names")

    @property
    @pulumi.getter(name="indexedStringComparisons")
    @_utilities.deprecated("""You should use 'indexed_string' instead of 'indexed_string_comparison'. This attribute still exists for backwards compatibility.""")
    def indexed_string_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedStringComparison']]:
        """
        Comparison for `INDEXED_STRING` attributes
        """
        return pulumi.get(self, "indexed_string_comparisons")

    @property
    @pulumi.getter(name="indexedStrings")
    def indexed_strings(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedString']]:
        """
        Comparison for `INDEXED_STRING` attributes
        """
        return pulumi.get(self, "indexed_strings")

    @property
    @pulumi.getter(name="indexedTagComparisons")
    @_utilities.deprecated("""You should use 'indexed_tag' instead of 'indexed_tag_comparison'. This attribute still exists for backwards compatibility.""")
    def indexed_tag_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedTagComparison']]:
        """
        Comparison for `INDEXED_TAG` attributes
        """
        return pulumi.get(self, "indexed_tag_comparisons")

    @property
    @pulumi.getter(name="indexedTags")
    def indexed_tags(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedTag']]:
        """
        Comparison for `INDEXED_TAG` attributes
        """
        return pulumi.get(self, "indexed_tags")

    @property
    @pulumi.getter(name="integerComparisons")
    @_utilities.deprecated("""You should use 'integer' instead of 'integer_comparison'. This attribute still exists for backwards compatibility.""")
    def integer_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIntegerComparison']]:
        """
        Comparison for `INTEGER` attributes
        """
        return pulumi.get(self, "integer_comparisons")

    @property
    @pulumi.getter
    def integers(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionInteger']]:
        """
        Comparison for `INTEGER` attributes
        """
        return pulumi.get(self, "integers")

    @property
    @pulumi.getter(name="ipaddressComparisons")
    @_utilities.deprecated("""You should use 'ipaddress' instead of 'ipaddress_comparison'. This attribute still exists for backwards compatibility.""")
    def ipaddress_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIpaddressComparison']]:
        """
        Comparison for `IP_ADDRESS` attributes
        """
        return pulumi.get(self, "ipaddress_comparisons")

    @property
    @pulumi.getter
    def ipaddresses(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIpaddress']]:
        """
        Comparison for `IP_ADDRESS` attributes
        """
        return pulumi.get(self, "ipaddresses")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionKey']]:
        """
        Fallback for not yet known type
        """
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter(name="mobilePlatformComparisons")
    @_utilities.deprecated("""You should use 'mobile_platform' instead of 'mobile_platform_comparison'. This attribute still exists for backwards compatibility.""")
    def mobile_platform_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionMobilePlatformComparison']]:
        """
        Comparison for `MOBILE_PLATFORM` attributes
        """
        return pulumi.get(self, "mobile_platform_comparisons")

    @property
    @pulumi.getter(name="mobilePlatforms")
    def mobile_platforms(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionMobilePlatform']]:
        """
        Comparison for `MOBILE_PLATFORM` attributes
        """
        return pulumi.get(self, "mobile_platforms")

    @property
    @pulumi.getter(name="osArches")
    def os_arches(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOsArch']]:
        """
        Comparison for `OS_ARCHITECTURE` attributes
        """
        return pulumi.get(self, "os_arches")

    @property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOsType']]:
        """
        Comparison for `OS_TYPE` attributes
        """
        return pulumi.get(self, "os_types")

    @property
    @pulumi.getter(name="osarchitectureComparisons")
    @_utilities.deprecated("""You should use 'os_arch' instead of 'osarchitecture_comparison'. This attribute still exists for backwards compatibility.""")
    def osarchitecture_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOsarchitectureComparison']]:
        """
        Comparison for `OS_ARCHITECTURE` attributes
        """
        return pulumi.get(self, "osarchitecture_comparisons")

    @property
    @pulumi.getter(name="ostypeComparisons")
    @_utilities.deprecated("""You should use 'os_type' instead of 'ostype_comparison'. This attribute still exists for backwards compatibility.""")
    def ostype_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOstypeComparison']]:
        """
        Comparison for `OS_TYPE` attributes
        """
        return pulumi.get(self, "ostype_comparisons")

    @property
    @pulumi.getter(name="paasTypeComparisons")
    @_utilities.deprecated("""You should use 'paas_type' instead of 'paas_type_comparison'. This attribute still exists for backwards compatibility.""")
    def paas_type_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionPaasTypeComparison']]:
        """
        Comparison for `PAAS_TYPE` attributes
        """
        return pulumi.get(self, "paas_type_comparisons")

    @property
    @pulumi.getter(name="paasTypes")
    def paas_types(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionPaasType']]:
        """
        Comparison for `PAAS_TYPE` attributes
        """
        return pulumi.get(self, "paas_types")

    @property
    @pulumi.getter(name="processMetadataConditionKeys")
    @_utilities.deprecated("""'process_metadata_condition_key' is deprecated. You should use 'process_metadata'""")
    def process_metadata_condition_keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionProcessMetadataConditionKey']]:
        """
        The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        """
        return pulumi.get(self, "process_metadata_condition_keys")

    @property
    @pulumi.getter(name="processMetadatas")
    def process_metadatas(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionProcessMetadata']]:
        """
        The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        """
        return pulumi.get(self, "process_metadatas")

    @property
    @pulumi.getter(name="serviceTopologies")
    def service_topologies(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceTopology']]:
        """
        Comparison for `SERVICE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "service_topologies")

    @property
    @pulumi.getter(name="serviceTopologyComparisons")
    @_utilities.deprecated("""You should use 'service_topology' instead of 'service_topology_comparison'. This attribute still exists for backwards compatibility.""")
    def service_topology_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceTopologyComparison']]:
        """
        Comparison for `SERVICE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "service_topology_comparisons")

    @property
    @pulumi.getter(name="serviceTypeComparisons")
    @_utilities.deprecated("""You should use 'service_type' instead of 'service_type_comparison'. This attribute still exists for backwards compatibility.""")
    def service_type_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceTypeComparison']]:
        """
        Comparison for `SERVICE_TYPE` attributes
        """
        return pulumi.get(self, "service_type_comparisons")

    @property
    @pulumi.getter(name="serviceTypes")
    def service_types(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceType']]:
        """
        Comparison for `SERVICE_TYPE` attributes
        """
        return pulumi.get(self, "service_types")

    @property
    @pulumi.getter(name="simpleHostTechComparisons")
    @_utilities.deprecated("""You should use 'host_tech' instead of 'simple_host_tech_comparison'. This attribute still exists for backwards compatibility.""")
    def simple_host_tech_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSimpleHostTechComparison']]:
        """
        Comparison for `SIMPLE_HOST_TECH` attributes
        """
        return pulumi.get(self, "simple_host_tech_comparisons")

    @property
    @pulumi.getter(name="simpleTechComparisons")
    @_utilities.deprecated("""You should use 'tech' instead of 'simple_tech_comparison'. This attribute still exists for backwards compatibility.""")
    def simple_tech_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSimpleTechComparison']]:
        """
        Comparison for `SIMPLE_TECH` attributes
        """
        return pulumi.get(self, "simple_tech_comparisons")

    @property
    @pulumi.getter(name="stringComparisons")
    @_utilities.deprecated("""You should use 'string' instead of 'string_comparison'. This attribute still exists for backwards compatibility.""")
    def string_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionStringComparison']]:
        """
        Comparison for `STRING` attributes
        """
        return pulumi.get(self, "string_comparisons")

    @property
    @pulumi.getter(name="stringConditionKeys")
    @_utilities.deprecated("""'string_condition_key' is deprecated. You should use 'string_key'""")
    def string_condition_keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionStringConditionKey']]:
        """
        The key for dynamic attributes of the `STRING` type
        """
        return pulumi.get(self, "string_condition_keys")

    @property
    @pulumi.getter(name="stringKeys")
    def string_keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionStringKey']]:
        """
        The key for dynamic attributes of the `STRING` type
        """
        return pulumi.get(self, "string_keys")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionString']]:
        """
        Comparison for `STRING` attributes
        """
        return pulumi.get(self, "strings")

    @property
    @pulumi.getter(name="syntheticEngineTypeComparisons")
    @_utilities.deprecated("""You should use 'synthetic_engine' instead of 'synthetic_engine_type_comparison'. This attribute still exists for backwards compatibility.""")
    def synthetic_engine_type_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSyntheticEngineTypeComparison']]:
        """
        Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        """
        return pulumi.get(self, "synthetic_engine_type_comparisons")

    @property
    @pulumi.getter(name="syntheticEngines")
    def synthetic_engines(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSyntheticEngine']]:
        """
        Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        """
        return pulumi.get(self, "synthetic_engines")

    @property
    @pulumi.getter(name="tagComparisons")
    @_utilities.deprecated("""You should use 'tag' instead of 'tag_comparison'. This attribute still exists for backwards compatibility.""")
    def tag_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionTagComparison']]:
        """
        Comparison for `TAG` attributes
        """
        return pulumi.get(self, "tag_comparisons")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionTag']]:
        """
        Comparison for `TAG` attributes
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def teches(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionTech']]:
        """
        Comparison for `SIMPLE_TECH` attributes
        """
        return pulumi.get(self, "teches")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be APPLICATION_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be APPLICATION_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionAzureComputeMode(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are DEDICATED or SHARED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are DEDICATED or SHARED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionAzureComputeModeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are DEDICATED or SHARED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are DEDICATED or SHARED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionAzureSkuComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be AZURE_SKU
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be AZURE_SKU
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionAzureSkus(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionBaseComparisonBasic(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str type: The type of comparison
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of comparison
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionBaseConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str type: Defines the actual set of fields depending on the value
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defines the actual set of fields depending on the value
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionBitness(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are 32 and 64.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are 32 and 64.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionBitnessComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be BITNESS
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are 32 and 64.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be BITNESS
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are 32 and 64.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCloudType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCloudTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be CLOUD_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be CLOUD_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionComparison(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str type: The type of comparison
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of comparison
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be CUSTOM_APPLICATION_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be CUSTOM_APPLICATION_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomHostMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionCustomHostMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionCustomHostMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionCustomHostMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ProcessgroupNamingConditionConditionCustomHostMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'ProcessgroupNamingConditionConditionCustomHostMetadataDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ProcessgroupNamingConditionConditionCustomHostMetadataDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ProcessgroupNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'ProcessgroupNamingConditionConditionCustomHostMetadataConditionKeyDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str type: if specified, needs to be HOST_CUSTOM_METADATA_KEY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ProcessgroupNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be HOST_CUSTOM_METADATA_KEY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomHostMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionCustomProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionCustomProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionCustomProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'ProcessgroupNamingConditionConditionCustomProcessMetadataDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str type: if specified, needs to be PROCESS_CUSTOM_METADATA_KEY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be PROCESS_CUSTOM_METADATA_KEY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomProcessMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionDatabaseTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionDatabaseTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be DATABASE_TOPOLOGY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be DATABASE_TOPOLOGY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionDcrumDecoder(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionDcrumDecoderComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be DCRUM_DECODER_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be DCRUM_DECODER_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionEntity(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionEntityIdComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be ENTITY_ID
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be ENTITY_ID
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionHostTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionHostTechValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'ProcessgroupNamingConditionConditionHostTechValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionHostTechValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionHostTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionHostTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionHostTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionHostTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ProcessgroupNamingConditionConditionHypervisor(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionHypervisorTypeComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be HYPERVISOR_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be HYPERVISOR_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedName(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedNameComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be INDEXED_NAME
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INDEXED_NAME
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedString(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedStringComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be INDEXED_STRING
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INDEXED_STRING
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionIndexedTagValue'] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param 'ProcessgroupNamingConditionConditionIndexedTagValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionIndexedTagValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionIndexedTagComparisonValue'] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be INDEXED_TAG
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param 'ProcessgroupNamingConditionConditionIndexedTagComparisonValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INDEXED_TAG
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionIndexedTagComparisonValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionInteger(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param int value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIntegerComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be INTEGER
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param int value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INTEGER
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIpaddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionIpaddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionIpaddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionIpaddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIpaddressComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionIpaddressComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionIpaddressComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionIpaddressComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be IP_ADDRESS
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be IP_ADDRESS
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str type: Defines the actual set of fields depending on the value
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defines the actual set of fields depending on the value
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionMobilePlatform(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionMobilePlatformComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be MOBILE_PLATFORM
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be MOBILE_PLATFORM
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionOsArch(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionOsType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionOsarchitectureComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be OS_ARCHITECTURE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be OS_ARCHITECTURE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionOstypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be OS_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be OS_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionPaasType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionPaasTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be PAAS_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be PAAS_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        :param str type: if specified, needs to be PROCESS_PREDEFINED_METADATA_KEY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be PROCESS_PREDEFINED_METADATA_KEY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionServiceTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionServiceTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SERVICE_TOPOLOGY
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SERVICE_TOPOLOGY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionServiceType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionServiceTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SERVICE_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SERVICE_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionSimpleHostTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SIMPLE_HOST_TECH
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'ProcessgroupNamingConditionConditionSimpleHostTechComparisonValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SIMPLE_HOST_TECH
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ProcessgroupNamingConditionConditionSimpleTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionSimpleTechComparisonValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SIMPLE_TECH
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'ProcessgroupNamingConditionConditionSimpleTechComparisonValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SIMPLE_TECH
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionSimpleTechComparisonValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionSimpleTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionSimpleTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionSimpleTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionSimpleTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ProcessgroupNamingConditionConditionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionStringComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionStringComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionStringComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionStringComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be STRING
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be STRING
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionStringConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionStringConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionStringConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionStringConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
                  - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
                  - `AMAZON_ECR_IMAGE_REGION`
                  - `AMAZON_LAMBDA_FUNCTION_NAME`
                  - `AMAZON_REGION`
                  - `APACHE_CONFIG_PATH`
                  - `APACHE_SPARK_MASTER_IP_ADDRESS`
                  - `ASP_DOT_NET_CORE_APPLICATION_PATH`
                  - `AWS_ECS_CLUSTER`
                  - `AWS_ECS_CONTAINERNAME`
                  - `AWS_ECS_FAMILY`
                  - `AWS_ECS_REVISION`
                  - `CASSANDRA_CLUSTER_NAME`
                  - `CATALINA_BASE`
                  - `CATALINA_HOME`
                  - `CLOUD_FOUNDRY_APP_ID`
                  - `CLOUD_FOUNDRY_APP_NAME`
                  - `CLOUD_FOUNDRY_INSTANCE_INDEX`
                  - `CLOUD_FOUNDRY_SPACE_ID`
                  - `CLOUD_FOUNDRY_SPACE_NAME`
                  - `COLDFUSION_JVM_CONFIG_FILE`
                  - `COLDFUSION_SERVICE_NAME`
                  - `COMMAND_LINE_ARGS`
                  - `DOTNET_COMMAND`
                  - `DOTNET_COMMAND_PATH`
                  - `DYNATRACE_CLUSTER_ID`
                  - `DYNATRACE_NODE_ID`
                  - `ELASTICSEARCH_CLUSTER_NAME`
                  - `ELASTICSEARCH_NODE_NAME`
                  - `EQUINOX_CONFIG_PATH`
                  - `EXE_NAME`
                  - `EXE_PATH`
                  - `GLASS_FISH_DOMAIN_NAME`
                  - `GLASS_FISH_INSTANCE_NAME`
                  - `GOOGLE_APP_ENGINE_INSTANCE`
                  - `GOOGLE_APP_ENGINE_SERVICE`
                  - `GOOGLE_CLOUD_PROJECT`
                  - `HYBRIS_BIN_DIRECTORY`
                  - `HYBRIS_CONFIG_DIRECTORY`
                  - `HYBRIS_DATA_DIRECTORY`
                  - `IBM_CICS_REGION`
                  - `IBM_CTG_NAME`
                  - `IBM_IMS_CONNECT_REGION`
                  - `IBM_IMS_CONTROL_REGION`
                  - `IBM_IMS_MESSAGE_PROCESSING_REGION`
                  - `IBM_IMS_SOAP_GW_NAME`
                  - `IBM_INTEGRATION_NODE_NAME`
                  - `IBM_INTEGRATION_SERVER_NAME`
                  - `IIS_APP_POOL`
                  - `IIS_ROLE_NAME`
                  - `JAVA_JAR_FILE`
                  - `JAVA_JAR_PATH`
                  - `JAVA_MAIN_CLASS`
                  - `JAVA_MAIN_MODULE`
                  - `JBOSS_HOME`
                  - `JBOSS_MODE`
                  - `JBOSS_SERVER_NAME`
                  - `KUBERNETES_BASE_POD_NAME`
                  - `KUBERNETES_CONTAINER_NAME`
                  - `KUBERNETES_FULL_POD_NAME`
                  - `KUBERNETES_NAMESPACE`
                  - `KUBERNETES_POD_UID`
                  - `MSSQL_INSTANCE_NAME`
                  - `NODE_JS_APP_BASE_DIRECTORY`
                  - `NODE_JS_APP_NAME`
                  - `NODE_JS_SCRIPT_NAME`
                  - `ORACLE_SID`
                  - `PG_ID_CALC_INPUT_KEY_LINKAGE`
                  - `PHP_SCRIPT_PATH`
                  - `PHP_WORKING_DIRECTORY`
                  - `RUBY_APP_ROOT_PATH`
                  - `RUBY_SCRIPT_PATH`
                  - `RULE_RESULT`
                  - `SOFTWAREAG_INSTALL_ROOT`
                  - `SOFTWAREAG_PRODUCTPROPNAME`
                  - `SPRINGBOOT_APP_NAME`
                  - `SPRINGBOOT_PROFILE_NAME`
                  - `SPRINGBOOT_STARTUP_CLASS`
                  - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
                  - `TIBCO_BUSINESSWORKS_CE_VERSION`
                  - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
                  - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
                  - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
                  - `TIBCO_BUSINESS_WORKS_HOME`
                  - `VARNISH_INSTANCE_NAME`
                  - `WEB_LOGIC_CLUSTER_NAME`
                  - `WEB_LOGIC_DOMAIN_NAME`
                  - `WEB_LOGIC_HOME`
                  - `WEB_LOGIC_NAME`
                  - `WEB_SPHERE_CELL_NAME`
                  - `WEB_SPHERE_CLUSTER_NAME`
                  - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        :param str type: if specified, needs to be `STRING`
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
           - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
           - `AMAZON_ECR_IMAGE_REGION`
           - `AMAZON_LAMBDA_FUNCTION_NAME`
           - `AMAZON_REGION`
           - `APACHE_CONFIG_PATH`
           - `APACHE_SPARK_MASTER_IP_ADDRESS`
           - `ASP_DOT_NET_CORE_APPLICATION_PATH`
           - `AWS_ECS_CLUSTER`
           - `AWS_ECS_CONTAINERNAME`
           - `AWS_ECS_FAMILY`
           - `AWS_ECS_REVISION`
           - `CASSANDRA_CLUSTER_NAME`
           - `CATALINA_BASE`
           - `CATALINA_HOME`
           - `CLOUD_FOUNDRY_APP_ID`
           - `CLOUD_FOUNDRY_APP_NAME`
           - `CLOUD_FOUNDRY_INSTANCE_INDEX`
           - `CLOUD_FOUNDRY_SPACE_ID`
           - `CLOUD_FOUNDRY_SPACE_NAME`
           - `COLDFUSION_JVM_CONFIG_FILE`
           - `COLDFUSION_SERVICE_NAME`
           - `COMMAND_LINE_ARGS`
           - `DOTNET_COMMAND`
           - `DOTNET_COMMAND_PATH`
           - `DYNATRACE_CLUSTER_ID`
           - `DYNATRACE_NODE_ID`
           - `ELASTICSEARCH_CLUSTER_NAME`
           - `ELASTICSEARCH_NODE_NAME`
           - `EQUINOX_CONFIG_PATH`
           - `EXE_NAME`
           - `EXE_PATH`
           - `GLASS_FISH_DOMAIN_NAME`
           - `GLASS_FISH_INSTANCE_NAME`
           - `GOOGLE_APP_ENGINE_INSTANCE`
           - `GOOGLE_APP_ENGINE_SERVICE`
           - `GOOGLE_CLOUD_PROJECT`
           - `HYBRIS_BIN_DIRECTORY`
           - `HYBRIS_CONFIG_DIRECTORY`
           - `HYBRIS_DATA_DIRECTORY`
           - `IBM_CICS_REGION`
           - `IBM_CTG_NAME`
           - `IBM_IMS_CONNECT_REGION`
           - `IBM_IMS_CONTROL_REGION`
           - `IBM_IMS_MESSAGE_PROCESSING_REGION`
           - `IBM_IMS_SOAP_GW_NAME`
           - `IBM_INTEGRATION_NODE_NAME`
           - `IBM_INTEGRATION_SERVER_NAME`
           - `IIS_APP_POOL`
           - `IIS_ROLE_NAME`
           - `JAVA_JAR_FILE`
           - `JAVA_JAR_PATH`
           - `JAVA_MAIN_CLASS`
           - `JAVA_MAIN_MODULE`
           - `JBOSS_HOME`
           - `JBOSS_MODE`
           - `JBOSS_SERVER_NAME`
           - `KUBERNETES_BASE_POD_NAME`
           - `KUBERNETES_CONTAINER_NAME`
           - `KUBERNETES_FULL_POD_NAME`
           - `KUBERNETES_NAMESPACE`
           - `KUBERNETES_POD_UID`
           - `MSSQL_INSTANCE_NAME`
           - `NODE_JS_APP_BASE_DIRECTORY`
           - `NODE_JS_APP_NAME`
           - `NODE_JS_SCRIPT_NAME`
           - `ORACLE_SID`
           - `PG_ID_CALC_INPUT_KEY_LINKAGE`
           - `PHP_SCRIPT_PATH`
           - `PHP_WORKING_DIRECTORY`
           - `RUBY_APP_ROOT_PATH`
           - `RUBY_SCRIPT_PATH`
           - `RULE_RESULT`
           - `SOFTWAREAG_INSTALL_ROOT`
           - `SOFTWAREAG_PRODUCTPROPNAME`
           - `SPRINGBOOT_APP_NAME`
           - `SPRINGBOOT_PROFILE_NAME`
           - `SPRINGBOOT_STARTUP_CLASS`
           - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
           - `TIBCO_BUSINESSWORKS_CE_VERSION`
           - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
           - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
           - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
           - `TIBCO_BUSINESS_WORKS_HOME`
           - `VARNISH_INSTANCE_NAME`
           - `WEB_LOGIC_CLUSTER_NAME`
           - `WEB_LOGIC_DOMAIN_NAME`
           - `WEB_LOGIC_HOME`
           - `WEB_LOGIC_NAME`
           - `WEB_SPHERE_CELL_NAME`
           - `WEB_SPHERE_CLUSTER_NAME`
           - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be `STRING`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionStringKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionStringKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionStringKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionStringKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
                  - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
                  - `AMAZON_ECR_IMAGE_REGION`
                  - `AMAZON_LAMBDA_FUNCTION_NAME`
                  - `AMAZON_REGION`
                  - `APACHE_CONFIG_PATH`
                  - `APACHE_SPARK_MASTER_IP_ADDRESS`
                  - `ASP_DOT_NET_CORE_APPLICATION_PATH`
                  - `AWS_ECS_CLUSTER`
                  - `AWS_ECS_CONTAINERNAME`
                  - `AWS_ECS_FAMILY`
                  - `AWS_ECS_REVISION`
                  - `CASSANDRA_CLUSTER_NAME`
                  - `CATALINA_BASE`
                  - `CATALINA_HOME`
                  - `CLOUD_FOUNDRY_APP_ID`
                  - `CLOUD_FOUNDRY_APP_NAME`
                  - `CLOUD_FOUNDRY_INSTANCE_INDEX`
                  - `CLOUD_FOUNDRY_SPACE_ID`
                  - `CLOUD_FOUNDRY_SPACE_NAME`
                  - `COLDFUSION_JVM_CONFIG_FILE`
                  - `COLDFUSION_SERVICE_NAME`
                  - `COMMAND_LINE_ARGS`
                  - `DOTNET_COMMAND`
                  - `DOTNET_COMMAND_PATH`
                  - `DYNATRACE_CLUSTER_ID`
                  - `DYNATRACE_NODE_ID`
                  - `ELASTICSEARCH_CLUSTER_NAME`
                  - `ELASTICSEARCH_NODE_NAME`
                  - `EQUINOX_CONFIG_PATH`
                  - `EXE_NAME`
                  - `EXE_PATH`
                  - `GLASS_FISH_DOMAIN_NAME`
                  - `GLASS_FISH_INSTANCE_NAME`
                  - `GOOGLE_APP_ENGINE_INSTANCE`
                  - `GOOGLE_APP_ENGINE_SERVICE`
                  - `GOOGLE_CLOUD_PROJECT`
                  - `HYBRIS_BIN_DIRECTORY`
                  - `HYBRIS_CONFIG_DIRECTORY`
                  - `HYBRIS_DATA_DIRECTORY`
                  - `IBM_CICS_REGION`
                  - `IBM_CTG_NAME`
                  - `IBM_IMS_CONNECT_REGION`
                  - `IBM_IMS_CONTROL_REGION`
                  - `IBM_IMS_MESSAGE_PROCESSING_REGION`
                  - `IBM_IMS_SOAP_GW_NAME`
                  - `IBM_INTEGRATION_NODE_NAME`
                  - `IBM_INTEGRATION_SERVER_NAME`
                  - `IIS_APP_POOL`
                  - `IIS_ROLE_NAME`
                  - `JAVA_JAR_FILE`
                  - `JAVA_JAR_PATH`
                  - `JAVA_MAIN_CLASS`
                  - `JAVA_MAIN_MODULE`
                  - `JBOSS_HOME`
                  - `JBOSS_MODE`
                  - `JBOSS_SERVER_NAME`
                  - `KUBERNETES_BASE_POD_NAME`
                  - `KUBERNETES_CONTAINER_NAME`
                  - `KUBERNETES_FULL_POD_NAME`
                  - `KUBERNETES_NAMESPACE`
                  - `KUBERNETES_POD_UID`
                  - `MSSQL_INSTANCE_NAME`
                  - `NODE_JS_APP_BASE_DIRECTORY`
                  - `NODE_JS_APP_NAME`
                  - `NODE_JS_SCRIPT_NAME`
                  - `ORACLE_SID`
                  - `PG_ID_CALC_INPUT_KEY_LINKAGE`
                  - `PHP_SCRIPT_PATH`
                  - `PHP_WORKING_DIRECTORY`
                  - `RUBY_APP_ROOT_PATH`
                  - `RUBY_SCRIPT_PATH`
                  - `RULE_RESULT`
                  - `SOFTWAREAG_INSTALL_ROOT`
                  - `SOFTWAREAG_PRODUCTPROPNAME`
                  - `SPRINGBOOT_APP_NAME`
                  - `SPRINGBOOT_PROFILE_NAME`
                  - `SPRINGBOOT_STARTUP_CLASS`
                  - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
                  - `TIBCO_BUSINESSWORKS_CE_VERSION`
                  - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
                  - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
                  - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
                  - `TIBCO_BUSINESS_WORKS_HOME`
                  - `VARNISH_INSTANCE_NAME`
                  - `WEB_LOGIC_CLUSTER_NAME`
                  - `WEB_LOGIC_DOMAIN_NAME`
                  - `WEB_LOGIC_HOME`
                  - `WEB_LOGIC_NAME`
                  - `WEB_SPHERE_CELL_NAME`
                  - `WEB_SPHERE_CLUSTER_NAME`
                  - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
           - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
           - `AMAZON_ECR_IMAGE_REGION`
           - `AMAZON_LAMBDA_FUNCTION_NAME`
           - `AMAZON_REGION`
           - `APACHE_CONFIG_PATH`
           - `APACHE_SPARK_MASTER_IP_ADDRESS`
           - `ASP_DOT_NET_CORE_APPLICATION_PATH`
           - `AWS_ECS_CLUSTER`
           - `AWS_ECS_CONTAINERNAME`
           - `AWS_ECS_FAMILY`
           - `AWS_ECS_REVISION`
           - `CASSANDRA_CLUSTER_NAME`
           - `CATALINA_BASE`
           - `CATALINA_HOME`
           - `CLOUD_FOUNDRY_APP_ID`
           - `CLOUD_FOUNDRY_APP_NAME`
           - `CLOUD_FOUNDRY_INSTANCE_INDEX`
           - `CLOUD_FOUNDRY_SPACE_ID`
           - `CLOUD_FOUNDRY_SPACE_NAME`
           - `COLDFUSION_JVM_CONFIG_FILE`
           - `COLDFUSION_SERVICE_NAME`
           - `COMMAND_LINE_ARGS`
           - `DOTNET_COMMAND`
           - `DOTNET_COMMAND_PATH`
           - `DYNATRACE_CLUSTER_ID`
           - `DYNATRACE_NODE_ID`
           - `ELASTICSEARCH_CLUSTER_NAME`
           - `ELASTICSEARCH_NODE_NAME`
           - `EQUINOX_CONFIG_PATH`
           - `EXE_NAME`
           - `EXE_PATH`
           - `GLASS_FISH_DOMAIN_NAME`
           - `GLASS_FISH_INSTANCE_NAME`
           - `GOOGLE_APP_ENGINE_INSTANCE`
           - `GOOGLE_APP_ENGINE_SERVICE`
           - `GOOGLE_CLOUD_PROJECT`
           - `HYBRIS_BIN_DIRECTORY`
           - `HYBRIS_CONFIG_DIRECTORY`
           - `HYBRIS_DATA_DIRECTORY`
           - `IBM_CICS_REGION`
           - `IBM_CTG_NAME`
           - `IBM_IMS_CONNECT_REGION`
           - `IBM_IMS_CONTROL_REGION`
           - `IBM_IMS_MESSAGE_PROCESSING_REGION`
           - `IBM_IMS_SOAP_GW_NAME`
           - `IBM_INTEGRATION_NODE_NAME`
           - `IBM_INTEGRATION_SERVER_NAME`
           - `IIS_APP_POOL`
           - `IIS_ROLE_NAME`
           - `JAVA_JAR_FILE`
           - `JAVA_JAR_PATH`
           - `JAVA_MAIN_CLASS`
           - `JAVA_MAIN_MODULE`
           - `JBOSS_HOME`
           - `JBOSS_MODE`
           - `JBOSS_SERVER_NAME`
           - `KUBERNETES_BASE_POD_NAME`
           - `KUBERNETES_CONTAINER_NAME`
           - `KUBERNETES_FULL_POD_NAME`
           - `KUBERNETES_NAMESPACE`
           - `KUBERNETES_POD_UID`
           - `MSSQL_INSTANCE_NAME`
           - `NODE_JS_APP_BASE_DIRECTORY`
           - `NODE_JS_APP_NAME`
           - `NODE_JS_SCRIPT_NAME`
           - `ORACLE_SID`
           - `PG_ID_CALC_INPUT_KEY_LINKAGE`
           - `PHP_SCRIPT_PATH`
           - `PHP_WORKING_DIRECTORY`
           - `RUBY_APP_ROOT_PATH`
           - `RUBY_SCRIPT_PATH`
           - `RULE_RESULT`
           - `SOFTWAREAG_INSTALL_ROOT`
           - `SOFTWAREAG_PRODUCTPROPNAME`
           - `SPRINGBOOT_APP_NAME`
           - `SPRINGBOOT_PROFILE_NAME`
           - `SPRINGBOOT_STARTUP_CLASS`
           - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
           - `TIBCO_BUSINESSWORKS_CE_VERSION`
           - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
           - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
           - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
           - `TIBCO_BUSINESS_WORKS_HOME`
           - `VARNISH_INSTANCE_NAME`
           - `WEB_LOGIC_CLUSTER_NAME`
           - `WEB_LOGIC_DOMAIN_NAME`
           - `WEB_LOGIC_HOME`
           - `WEB_LOGIC_NAME`
           - `WEB_SPHERE_CELL_NAME`
           - `WEB_SPHERE_CLUSTER_NAME`
           - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionSyntheticEngine(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionSyntheticEngineTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SYNTHETIC_ENGINE_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SYNTHETIC_ENGINE_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionTagValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'ProcessgroupNamingConditionConditionTagValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionTagValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionTagComparisonValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be TAG
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'ProcessgroupNamingConditionConditionTagComparisonValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be TAG
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionTagComparisonValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionTechValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'ProcessgroupNamingConditionConditionTechValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionTechValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class QueueManagerAliasQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasQueues":
            suggest = "alias_queues"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueManagerAliasQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueManagerAliasQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueManagerAliasQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias_queues: Optional[Sequence['outputs.QueueManagerAliasQueueAliasQueue']] = None):
        """
        :param Sequence['QueueManagerAliasQueueAliasQueueArgs'] alias_queues: Alias queue definitions for queue manager
        """
        if alias_queues is not None:
            pulumi.set(__self__, "alias_queues", alias_queues)

    @property
    @pulumi.getter(name="aliasQueues")
    def alias_queues(self) -> Optional[Sequence['outputs.QueueManagerAliasQueueAliasQueue']]:
        """
        Alias queue definitions for queue manager
        """
        return pulumi.get(self, "alias_queues")


@pulumi.output_type
class QueueManagerAliasQueueAliasQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasQueueName":
            suggest = "alias_queue_name"
        elif key == "baseQueueName":
            suggest = "base_queue_name"
        elif key == "clusterVisibilities":
            suggest = "cluster_visibilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueManagerAliasQueueAliasQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueManagerAliasQueueAliasQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueManagerAliasQueueAliasQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias_queue_name: str,
                 base_queue_name: str,
                 cluster_visibilities: Optional[Sequence[str]] = None):
        """
        :param str alias_queue_name: The name of the alias queue
        :param str base_queue_name: The name of the base queue
        :param Sequence[str] cluster_visibilities: Name of the cluster(s) this alias should be visible in
        """
        pulumi.set(__self__, "alias_queue_name", alias_queue_name)
        pulumi.set(__self__, "base_queue_name", base_queue_name)
        if cluster_visibilities is not None:
            pulumi.set(__self__, "cluster_visibilities", cluster_visibilities)

    @property
    @pulumi.getter(name="aliasQueueName")
    def alias_queue_name(self) -> str:
        """
        The name of the alias queue
        """
        return pulumi.get(self, "alias_queue_name")

    @property
    @pulumi.getter(name="baseQueueName")
    def base_queue_name(self) -> str:
        """
        The name of the base queue
        """
        return pulumi.get(self, "base_queue_name")

    @property
    @pulumi.getter(name="clusterVisibilities")
    def cluster_visibilities(self) -> Optional[Sequence[str]]:
        """
        Name of the cluster(s) this alias should be visible in
        """
        return pulumi.get(self, "cluster_visibilities")


@pulumi.output_type
class QueueManagerClusterQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterQueues":
            suggest = "cluster_queues"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueManagerClusterQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueManagerClusterQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueManagerClusterQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_queues: Optional[Sequence['outputs.QueueManagerClusterQueueClusterQueue']] = None):
        """
        :param Sequence['QueueManagerClusterQueueClusterQueueArgs'] cluster_queues: Cluster queue definitions for queue manager
        """
        if cluster_queues is not None:
            pulumi.set(__self__, "cluster_queues", cluster_queues)

    @property
    @pulumi.getter(name="clusterQueues")
    def cluster_queues(self) -> Optional[Sequence['outputs.QueueManagerClusterQueueClusterQueue']]:
        """
        Cluster queue definitions for queue manager
        """
        return pulumi.get(self, "cluster_queues")


@pulumi.output_type
class QueueManagerClusterQueueClusterQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localQueueName":
            suggest = "local_queue_name"
        elif key == "clusterVisibilities":
            suggest = "cluster_visibilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueManagerClusterQueueClusterQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueManagerClusterQueueClusterQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueManagerClusterQueueClusterQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_queue_name: str,
                 cluster_visibilities: Optional[Sequence[str]] = None):
        """
        :param str local_queue_name: The name of the local queue
        :param Sequence[str] cluster_visibilities: Name of the cluster(s) this local queue should be visible in
        """
        pulumi.set(__self__, "local_queue_name", local_queue_name)
        if cluster_visibilities is not None:
            pulumi.set(__self__, "cluster_visibilities", cluster_visibilities)

    @property
    @pulumi.getter(name="localQueueName")
    def local_queue_name(self) -> str:
        """
        The name of the local queue
        """
        return pulumi.get(self, "local_queue_name")

    @property
    @pulumi.getter(name="clusterVisibilities")
    def cluster_visibilities(self) -> Optional[Sequence[str]]:
        """
        Name of the cluster(s) this local queue should be visible in
        """
        return pulumi.get(self, "cluster_visibilities")


@pulumi.output_type
class QueueManagerRemoteQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remoteQueues":
            suggest = "remote_queues"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueManagerRemoteQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueManagerRemoteQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueManagerRemoteQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remote_queues: Optional[Sequence['outputs.QueueManagerRemoteQueueRemoteQueue']] = None):
        """
        :param Sequence['QueueManagerRemoteQueueRemoteQueueArgs'] remote_queues: Remote queue definitions for queue manager
        """
        if remote_queues is not None:
            pulumi.set(__self__, "remote_queues", remote_queues)

    @property
    @pulumi.getter(name="remoteQueues")
    def remote_queues(self) -> Optional[Sequence['outputs.QueueManagerRemoteQueueRemoteQueue']]:
        """
        Remote queue definitions for queue manager
        """
        return pulumi.get(self, "remote_queues")


@pulumi.output_type
class QueueManagerRemoteQueueRemoteQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localQueueName":
            suggest = "local_queue_name"
        elif key == "remoteQueueManager":
            suggest = "remote_queue_manager"
        elif key == "remoteQueueName":
            suggest = "remote_queue_name"
        elif key == "clusterVisibilities":
            suggest = "cluster_visibilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueManagerRemoteQueueRemoteQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueManagerRemoteQueueRemoteQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueManagerRemoteQueueRemoteQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_queue_name: str,
                 remote_queue_manager: str,
                 remote_queue_name: str,
                 cluster_visibilities: Optional[Sequence[str]] = None):
        """
        :param str local_queue_name: The name of the local queue
        :param str remote_queue_manager: The name of the remote queue manager
        :param str remote_queue_name: The name of the remote queue
        :param Sequence[str] cluster_visibilities: Name of the cluster(s) this local definition of the remote queue should be visible in
        """
        pulumi.set(__self__, "local_queue_name", local_queue_name)
        pulumi.set(__self__, "remote_queue_manager", remote_queue_manager)
        pulumi.set(__self__, "remote_queue_name", remote_queue_name)
        if cluster_visibilities is not None:
            pulumi.set(__self__, "cluster_visibilities", cluster_visibilities)

    @property
    @pulumi.getter(name="localQueueName")
    def local_queue_name(self) -> str:
        """
        The name of the local queue
        """
        return pulumi.get(self, "local_queue_name")

    @property
    @pulumi.getter(name="remoteQueueManager")
    def remote_queue_manager(self) -> str:
        """
        The name of the remote queue manager
        """
        return pulumi.get(self, "remote_queue_manager")

    @property
    @pulumi.getter(name="remoteQueueName")
    def remote_queue_name(self) -> str:
        """
        The name of the remote queue
        """
        return pulumi.get(self, "remote_queue_name")

    @property
    @pulumi.getter(name="clusterVisibilities")
    def cluster_visibilities(self) -> Optional[Sequence[str]]:
        """
        Name of the cluster(s) this local definition of the remote queue should be visible in
        """
        return pulumi.get(self, "cluster_visibilities")


@pulumi.output_type
class ReportSubscriptions(dict):
    def __init__(__self__, *,
                 months: Optional[Sequence[str]] = None,
                 weeks: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] months: A list of monthly subscribers.
               Monthly subscribers receive the report on the first Monday of the month at midnight.
               You can specify email addresses or Dynatrace user IDs here.
        :param Sequence[str] weeks: A list of weekly subscribers.
               Weekly subscribers receive the report every Monday at midnight.
               You can specify email addresses or Dynatrace user IDs here.
        """
        if months is not None:
            pulumi.set(__self__, "months", months)
        if weeks is not None:
            pulumi.set(__self__, "weeks", weeks)

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence[str]]:
        """
        A list of monthly subscribers.
        Monthly subscribers receive the report on the first Monday of the month at midnight.
        You can specify email addresses or Dynatrace user IDs here.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter
    def weeks(self) -> Optional[Sequence[str]]:
        """
        A list of weekly subscribers.
        Weekly subscribers receive the report every Monday at midnight.
        You can specify email addresses or Dynatrace user IDs here.
        """
        return pulumi.get(self, "weeks")


@pulumi.output_type
class RequestAttributeDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capturingAndStorageLocation":
            suggest = "capturing_and_storage_location"
        elif key == "cicsSdkMethodNodeCondition":
            suggest = "cics_sdk_method_node_condition"
        elif key == "iibLabelMethodNodeCondition":
            suggest = "iib_label_method_node_condition"
        elif key == "iibMethodNodeCondition":
            suggest = "iib_method_node_condition"
        elif key == "iibNodeType":
            suggest = "iib_node_type"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "sessionAttributeTechnology":
            suggest = "session_attribute_technology"
        elif key == "valueProcessing":
            suggest = "value_processing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestAttributeDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestAttributeDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestAttributeDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 source: str,
                 capturing_and_storage_location: Optional[str] = None,
                 cics_sdk_method_node_condition: Optional['outputs.RequestAttributeDataSourceCicsSdkMethodNodeCondition'] = None,
                 iib_label_method_node_condition: Optional['outputs.RequestAttributeDataSourceIibLabelMethodNodeCondition'] = None,
                 iib_method_node_condition: Optional['outputs.RequestAttributeDataSourceIibMethodNodeCondition'] = None,
                 iib_node_type: Optional[str] = None,
                 methods: Optional[Sequence['outputs.RequestAttributeDataSourceMethod']] = None,
                 parameter_name: Optional[str] = None,
                 scope: Optional['outputs.RequestAttributeDataSourceScope'] = None,
                 session_attribute_technology: Optional[str] = None,
                 technology: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value_processing: Optional['outputs.RequestAttributeDataSourceValueProcessing'] = None):
        """
        :param bool enabled: The data source is enabled (`true`) or disabled (`false`)
        :param str source: The source of the attribute to capture. Works in conjunction with **parameterName** or **methods** and **technology**
        :param str capturing_and_storage_location: Specifies the location where the values are captured and stored.  Required if the **source** is one of the following: `GET_PARAMETER`, `URI`, `REQUEST_HEADER`, `RESPONSE_HEADER`.   Not applicable in other cases.   If the **source** value is `REQUEST_HEADER` or `RESPONSE_HEADER`, the `CAPTURE_AND_STORE_ON_BOTH` location is not allowed
        :param 'RequestAttributeDataSourceCicsSdkMethodNodeConditionArgs' cics_sdk_method_node_condition: IBM integration bus label node name condition for which the value is captured
        :param 'RequestAttributeDataSourceIibLabelMethodNodeConditionArgs' iib_label_method_node_condition: IBM integration bus label node name condition for which the value is captured
        :param 'RequestAttributeDataSourceIibMethodNodeConditionArgs' iib_method_node_condition: IBM integration bus label node name condition for which the value is captured
        :param str iib_node_type: The IBM integration bus node type for which the value is captured.  This or `iibMethodNodeCondition` is required if the **source** is: `IIB_NODE`.  Not applicable in other cases
        :param Sequence['RequestAttributeDataSourceMethodArgs'] methods: The method specification if the **source** value is `METHOD_PARAM`.   Not applicable in other cases
        :param str parameter_name: The name of the web request parameter to capture.  Required if the **source** is one of the following: `POST_PARAMETER`, `GET_PARAMETER`, `REQUEST_HEADER`, `RESPONSE_HEADER`, `CUSTOM_ATTRIBUTE`.  Not applicable in other cases
        :param 'RequestAttributeDataSourceScopeArgs' scope: Conditions for data capturing
        :param str session_attribute_technology: The technology of the session attribute to capture if the **source** value is `SESSION_ATTRIBUTE`.
        :param str technology: The technology of the method to capture if the **source** value is `METHOD_PARAM`. 
               
                Not applicable in other cases
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param 'RequestAttributeDataSourceValueProcessingArgs' value_processing: Process values as specified
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "source", source)
        if capturing_and_storage_location is not None:
            pulumi.set(__self__, "capturing_and_storage_location", capturing_and_storage_location)
        if cics_sdk_method_node_condition is not None:
            pulumi.set(__self__, "cics_sdk_method_node_condition", cics_sdk_method_node_condition)
        if iib_label_method_node_condition is not None:
            pulumi.set(__self__, "iib_label_method_node_condition", iib_label_method_node_condition)
        if iib_method_node_condition is not None:
            pulumi.set(__self__, "iib_method_node_condition", iib_method_node_condition)
        if iib_node_type is not None:
            pulumi.set(__self__, "iib_node_type", iib_node_type)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if parameter_name is not None:
            pulumi.set(__self__, "parameter_name", parameter_name)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if session_attribute_technology is not None:
            pulumi.set(__self__, "session_attribute_technology", session_attribute_technology)
        if technology is not None:
            pulumi.set(__self__, "technology", technology)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value_processing is not None:
            pulumi.set(__self__, "value_processing", value_processing)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The data source is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the attribute to capture. Works in conjunction with **parameterName** or **methods** and **technology**
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="capturingAndStorageLocation")
    def capturing_and_storage_location(self) -> Optional[str]:
        """
        Specifies the location where the values are captured and stored.  Required if the **source** is one of the following: `GET_PARAMETER`, `URI`, `REQUEST_HEADER`, `RESPONSE_HEADER`.   Not applicable in other cases.   If the **source** value is `REQUEST_HEADER` or `RESPONSE_HEADER`, the `CAPTURE_AND_STORE_ON_BOTH` location is not allowed
        """
        return pulumi.get(self, "capturing_and_storage_location")

    @property
    @pulumi.getter(name="cicsSdkMethodNodeCondition")
    def cics_sdk_method_node_condition(self) -> Optional['outputs.RequestAttributeDataSourceCicsSdkMethodNodeCondition']:
        """
        IBM integration bus label node name condition for which the value is captured
        """
        return pulumi.get(self, "cics_sdk_method_node_condition")

    @property
    @pulumi.getter(name="iibLabelMethodNodeCondition")
    def iib_label_method_node_condition(self) -> Optional['outputs.RequestAttributeDataSourceIibLabelMethodNodeCondition']:
        """
        IBM integration bus label node name condition for which the value is captured
        """
        return pulumi.get(self, "iib_label_method_node_condition")

    @property
    @pulumi.getter(name="iibMethodNodeCondition")
    def iib_method_node_condition(self) -> Optional['outputs.RequestAttributeDataSourceIibMethodNodeCondition']:
        """
        IBM integration bus label node name condition for which the value is captured
        """
        return pulumi.get(self, "iib_method_node_condition")

    @property
    @pulumi.getter(name="iibNodeType")
    def iib_node_type(self) -> Optional[str]:
        """
        The IBM integration bus node type for which the value is captured.  This or `iibMethodNodeCondition` is required if the **source** is: `IIB_NODE`.  Not applicable in other cases
        """
        return pulumi.get(self, "iib_node_type")

    @property
    @pulumi.getter
    def methods(self) -> Optional[Sequence['outputs.RequestAttributeDataSourceMethod']]:
        """
        The method specification if the **source** value is `METHOD_PARAM`.   Not applicable in other cases
        """
        return pulumi.get(self, "methods")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        """
        The name of the web request parameter to capture.  Required if the **source** is one of the following: `POST_PARAMETER`, `GET_PARAMETER`, `REQUEST_HEADER`, `RESPONSE_HEADER`, `CUSTOM_ATTRIBUTE`.  Not applicable in other cases
        """
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter
    def scope(self) -> Optional['outputs.RequestAttributeDataSourceScope']:
        """
        Conditions for data capturing
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="sessionAttributeTechnology")
    def session_attribute_technology(self) -> Optional[str]:
        """
        The technology of the session attribute to capture if the **source** value is `SESSION_ATTRIBUTE`.
        """
        return pulumi.get(self, "session_attribute_technology")

    @property
    @pulumi.getter
    def technology(self) -> Optional[str]:
        """
        The technology of the method to capture if the **source** value is `METHOD_PARAM`. 

         Not applicable in other cases
        """
        return pulumi.get(self, "technology")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="valueProcessing")
    def value_processing(self) -> Optional['outputs.RequestAttributeDataSourceValueProcessing']:
        """
        Process values as specified
        """
        return pulumi.get(self, "value_processing")


@pulumi.output_type
class RequestAttributeDataSourceCicsSdkMethodNodeCondition(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str operator: Operator comparing the extracted value to the comparison value
        :param str value: The value to compare to
        :param bool negate: Negate the comparison
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator comparing the extracted value to the comparison value
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Negate the comparison
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceIibLabelMethodNodeCondition(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str operator: Operator comparing the extracted value to the comparison value
        :param str value: The value to compare to
        :param bool negate: Negate the comparison
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator comparing the extracted value to the comparison value
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Negate the comparison
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceIibMethodNodeCondition(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str operator: Operator comparing the extracted value to the comparison value
        :param str value: The value to compare to
        :param bool negate: Negate the comparison
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator comparing the extracted value to the comparison value
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Negate the comparison
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "argumentIndex":
            suggest = "argument_index"
        elif key == "deepObjectAccess":
            suggest = "deep_object_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestAttributeDataSourceMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestAttributeDataSourceMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestAttributeDataSourceMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture: str,
                 argument_index: Optional[int] = None,
                 deep_object_access: Optional[str] = None,
                 method: Optional['outputs.RequestAttributeDataSourceMethodMethod'] = None,
                 unknowns: Optional[str] = None):
        """
        :param str capture: What to capture from the method
        :param int argument_index: The index of the argument to capture. Set `0` to capture the return value, `1` or higher to capture a mehtod argument.   Required if the **capture** is set to `ARGUMENT`.  Not applicable in other cases
        :param str deep_object_access: The getter chain to apply to the captured object. It is required in one of the following cases:  The **capture** is set to `THIS`.    The **capture** is set to `ARGUMENT`, and the argument is not a primitive, a primitive wrapper class, a string, or an array.   Not applicable in other cases
        :param 'RequestAttributeDataSourceMethodMethodArgs' method: Configuration of a method to be captured
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "capture", capture)
        if argument_index is not None:
            pulumi.set(__self__, "argument_index", argument_index)
        if deep_object_access is not None:
            pulumi.set(__self__, "deep_object_access", deep_object_access)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def capture(self) -> str:
        """
        What to capture from the method
        """
        return pulumi.get(self, "capture")

    @property
    @pulumi.getter(name="argumentIndex")
    def argument_index(self) -> Optional[int]:
        """
        The index of the argument to capture. Set `0` to capture the return value, `1` or higher to capture a mehtod argument.   Required if the **capture** is set to `ARGUMENT`.  Not applicable in other cases
        """
        return pulumi.get(self, "argument_index")

    @property
    @pulumi.getter(name="deepObjectAccess")
    def deep_object_access(self) -> Optional[str]:
        """
        The getter chain to apply to the captured object. It is required in one of the following cases:  The **capture** is set to `THIS`.    The **capture** is set to `ARGUMENT`, and the argument is not a primitive, a primitive wrapper class, a string, or an array.   Not applicable in other cases
        """
        return pulumi.get(self, "deep_object_access")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.RequestAttributeDataSourceMethodMethod']:
        """
        Configuration of a method to be captured
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceMethodMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "methodName":
            suggest = "method_name"
        elif key == "returnType":
            suggest = "return_type"
        elif key == "argumentTypes":
            suggest = "argument_types"
        elif key == "className":
            suggest = "class_name"
        elif key == "fileName":
            suggest = "file_name"
        elif key == "fileNameMatcher":
            suggest = "file_name_matcher"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestAttributeDataSourceMethodMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestAttributeDataSourceMethodMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestAttributeDataSourceMethodMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method_name: str,
                 return_type: str,
                 visibility: str,
                 argument_types: Optional[Sequence[str]] = None,
                 class_name: Optional[str] = None,
                 file_name: Optional[str] = None,
                 file_name_matcher: Optional[str] = None,
                 modifiers: Optional[Sequence[str]] = None,
                 unknowns: Optional[str] = None):
        """
        :param str method_name: The name of the method to capture
        :param str return_type: The return type
        :param str visibility: The visibility of the method to capture
        :param Sequence[str] argument_types: Configuration of a method to be captured
        :param str class_name: The class name where the method to capture resides.   Either this or the **fileName** must be set
        :param str file_name: The file name where the method to capture resides.   Either this or **className** must be set
        :param str file_name_matcher: The operator of the comparison. If not set, `EQUALS` is used
        :param Sequence[str] modifiers: The modifiers of the method to capture
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "method_name", method_name)
        pulumi.set(__self__, "return_type", return_type)
        pulumi.set(__self__, "visibility", visibility)
        if argument_types is not None:
            pulumi.set(__self__, "argument_types", argument_types)
        if class_name is not None:
            pulumi.set(__self__, "class_name", class_name)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if file_name_matcher is not None:
            pulumi.set(__self__, "file_name_matcher", file_name_matcher)
        if modifiers is not None:
            pulumi.set(__self__, "modifiers", modifiers)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="methodName")
    def method_name(self) -> str:
        """
        The name of the method to capture
        """
        return pulumi.get(self, "method_name")

    @property
    @pulumi.getter(name="returnType")
    def return_type(self) -> str:
        """
        The return type
        """
        return pulumi.get(self, "return_type")

    @property
    @pulumi.getter
    def visibility(self) -> str:
        """
        The visibility of the method to capture
        """
        return pulumi.get(self, "visibility")

    @property
    @pulumi.getter(name="argumentTypes")
    def argument_types(self) -> Optional[Sequence[str]]:
        """
        Configuration of a method to be captured
        """
        return pulumi.get(self, "argument_types")

    @property
    @pulumi.getter(name="className")
    def class_name(self) -> Optional[str]:
        """
        The class name where the method to capture resides.   Either this or the **fileName** must be set
        """
        return pulumi.get(self, "class_name")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[str]:
        """
        The file name where the method to capture resides.   Either this or **className** must be set
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter(name="fileNameMatcher")
    def file_name_matcher(self) -> Optional[str]:
        """
        The operator of the comparison. If not set, `EQUALS` is used
        """
        return pulumi.get(self, "file_name_matcher")

    @property
    @pulumi.getter
    def modifiers(self) -> Optional[Sequence[str]]:
        """
        The modifiers of the method to capture
        """
        return pulumi.get(self, "modifiers")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostGroup":
            suggest = "host_group"
        elif key == "processGroup":
            suggest = "process_group"
        elif key == "serviceTechnology":
            suggest = "service_technology"
        elif key == "tagOfProcessGroup":
            suggest = "tag_of_process_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestAttributeDataSourceScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestAttributeDataSourceScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestAttributeDataSourceScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_group: Optional[str] = None,
                 process_group: Optional[str] = None,
                 service_technology: Optional[str] = None,
                 tag_of_process_group: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str host_group: Only applies to this host group
        :param str process_group: Only applies to this process group. Note that this can't be transferred between different clusters or environments
        :param str service_technology: Only applies to this service technology
        :param str tag_of_process_group: Only apply to process groups matching this tag
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if host_group is not None:
            pulumi.set(__self__, "host_group", host_group)
        if process_group is not None:
            pulumi.set(__self__, "process_group", process_group)
        if service_technology is not None:
            pulumi.set(__self__, "service_technology", service_technology)
        if tag_of_process_group is not None:
            pulumi.set(__self__, "tag_of_process_group", tag_of_process_group)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="hostGroup")
    def host_group(self) -> Optional[str]:
        """
        Only applies to this host group
        """
        return pulumi.get(self, "host_group")

    @property
    @pulumi.getter(name="processGroup")
    def process_group(self) -> Optional[str]:
        """
        Only applies to this process group. Note that this can't be transferred between different clusters or environments
        """
        return pulumi.get(self, "process_group")

    @property
    @pulumi.getter(name="serviceTechnology")
    def service_technology(self) -> Optional[str]:
        """
        Only applies to this service technology
        """
        return pulumi.get(self, "service_technology")

    @property
    @pulumi.getter(name="tagOfProcessGroup")
    def tag_of_process_group(self) -> Optional[str]:
        """
        Only apply to process groups matching this tag
        """
        return pulumi.get(self, "tag_of_process_group")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceValueProcessing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extractSubstring":
            suggest = "extract_substring"
        elif key == "splitAt":
            suggest = "split_at"
        elif key == "valueCondition":
            suggest = "value_condition"
        elif key == "valueExtractorRegex":
            suggest = "value_extractor_regex"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestAttributeDataSourceValueProcessing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestAttributeDataSourceValueProcessing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestAttributeDataSourceValueProcessing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extract_substring: Optional['outputs.RequestAttributeDataSourceValueProcessingExtractSubstring'] = None,
                 split_at: Optional[str] = None,
                 trim: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value_condition: Optional['outputs.RequestAttributeDataSourceValueProcessingValueCondition'] = None,
                 value_extractor_regex: Optional[str] = None):
        """
        :param 'RequestAttributeDataSourceValueProcessingExtractSubstringArgs' extract_substring: Preprocess by extracting a substring from the original value
        :param str split_at: Split (preprocessed) string values at this separator
        :param bool trim: Prune Whitespaces. Defaults to false
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param 'RequestAttributeDataSourceValueProcessingValueConditionArgs' value_condition: IBM integration bus label node name condition for which the value is captured
        :param str value_extractor_regex: Extract value from captured data per regex
        """
        if extract_substring is not None:
            pulumi.set(__self__, "extract_substring", extract_substring)
        if split_at is not None:
            pulumi.set(__self__, "split_at", split_at)
        if trim is not None:
            pulumi.set(__self__, "trim", trim)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value_condition is not None:
            pulumi.set(__self__, "value_condition", value_condition)
        if value_extractor_regex is not None:
            pulumi.set(__self__, "value_extractor_regex", value_extractor_regex)

    @property
    @pulumi.getter(name="extractSubstring")
    def extract_substring(self) -> Optional['outputs.RequestAttributeDataSourceValueProcessingExtractSubstring']:
        """
        Preprocess by extracting a substring from the original value
        """
        return pulumi.get(self, "extract_substring")

    @property
    @pulumi.getter(name="splitAt")
    def split_at(self) -> Optional[str]:
        """
        Split (preprocessed) string values at this separator
        """
        return pulumi.get(self, "split_at")

    @property
    @pulumi.getter
    def trim(self) -> Optional[bool]:
        """
        Prune Whitespaces. Defaults to false
        """
        return pulumi.get(self, "trim")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="valueCondition")
    def value_condition(self) -> Optional['outputs.RequestAttributeDataSourceValueProcessingValueCondition']:
        """
        IBM integration bus label node name condition for which the value is captured
        """
        return pulumi.get(self, "value_condition")

    @property
    @pulumi.getter(name="valueExtractorRegex")
    def value_extractor_regex(self) -> Optional[str]:
        """
        Extract value from captured data per regex
        """
        return pulumi.get(self, "value_extractor_regex")


@pulumi.output_type
class RequestAttributeDataSourceValueProcessingExtractSubstring(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDelimiter":
            suggest = "end_delimiter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestAttributeDataSourceValueProcessingExtractSubstring. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestAttributeDataSourceValueProcessingExtractSubstring.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestAttributeDataSourceValueProcessingExtractSubstring.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: str,
                 position: str,
                 end_delimiter: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str delimiter: The delimiter string
        :param str position: The position of the extracted string relative to delimiters
        :param str end_delimiter: The end-delimiter string.   Required if the **position** value is `BETWEEN`. Otherwise not allowed
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "position", position)
        if end_delimiter is not None:
            pulumi.set(__self__, "end_delimiter", end_delimiter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def delimiter(self) -> str:
        """
        The delimiter string
        """
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter
    def position(self) -> str:
        """
        The position of the extracted string relative to delimiters
        """
        return pulumi.get(self, "position")

    @property
    @pulumi.getter(name="endDelimiter")
    def end_delimiter(self) -> Optional[str]:
        """
        The end-delimiter string.   Required if the **position** value is `BETWEEN`. Otherwise not allowed
        """
        return pulumi.get(self, "end_delimiter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceValueProcessingValueCondition(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str operator: Operator comparing the extracted value to the comparison value
        :param str value: The value to compare to
        :param bool negate: Negate the comparison
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator comparing the extracted value to the comparison value
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Negate the comparison
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestNamingConditions(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.RequestNamingConditionsCondition']] = None):
        """
        :param Sequence['RequestNamingConditionsConditionArgs'] conditions: A conditions for the metric usage
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.RequestNamingConditionsCondition']]:
        """
        A conditions for the metric usage
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class RequestNamingConditionsCondition(dict):
    def __init__(__self__, *,
                 attribute: str,
                 comparison: 'outputs.RequestNamingConditionsConditionComparison',
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be matched.  Note that for a service property attribute you must use the comparison of the `FAST_STRING` type. Possible values are `ACTOR_SYSTEM`, `AKKA_ACTOR_CLASS_NAME`, `AKKA_ACTOR_MESSAGE_TYPE`, `AKKA_ACTOR_PATH`, `APPLICATION_BUILD_VERSION`, `APPLICATION_RELEASE_VERSION`, `AZURE_FUNCTIONS_FUNCTION_NAME`, `AZURE_FUNCTIONS_SITE_NAME`, `CICS_PROGRAM_NAME`, `CICS_SYSTEM_ID`, `CICS_TASK_ID`, `CICS_TRANSACTION_ID`, `CICS_USER_ID`, `CPU_TIME`, `CTG_GATEWAY_URL`, `CTG_PROGRAM`, `CTG_SERVER_NAME`, `CTG_TRANSACTION_ID`, `CUSTOMSERVICE_CLASS`, `CUSTOMSERVICE_METHOD`, `DATABASE_CHILD_CALL_COUNT`, `DATABASE_CHILD_CALL_TIME`, `DATABASE_HOST`, `DATABASE_NAME`, `DATABASE_TYPE`, `DATABASE_URL`, `DISK_IO_TIME`, `ERROR_COUNT`, `ESB_APPLICATION_NAME`, `ESB_INPUT_TYPE`, `ESB_LIBRARY_NAME`, `ESB_MESSAGE_FLOW_NAME`, `EXCEPTION_CLASS`, `EXCEPTION_MESSAGE`, `FAILED_STATE`, `FAILURE_REASON`, `FLAW_STATE`, `HTTP_REQUEST_METHOD`, `HTTP_STATUS`, `HTTP_STATUS_CLASS`, `IMS_PROGRAM_NAME`, `IMS_TRANSACTION_ID`, `IMS_USER_ID`, `IO_TIME`, `IS_KEY_REQUEST`, `LAMBDA_COLDSTART`, `LOCK_TIME`, `MESSAGING_DESTINATION_TYPE`, `MESSAGING_IS_TEMPORARY_QUEUE`, `MESSAGING_QUEUE_NAME`, `MESSAGING_QUEUE_VENDOR`, `NETWORK_IO_TIME`, `NON_DATABASE_CHILD_CALL_COUNT`, `NON_DATABASE_CHILD_CALL_TIME`, `PROCESS_GROUP_NAME`, `PROCESS_GROUP_TAG`, `REMOTE_ENDPOINT`, `REMOTE_METHOD`, `REMOTE_SERVICE_NAME`, `REQUEST_NAME`, `REQUEST_TYPE`, `RESPONSE_TIME`, `RESPONSE_TIME_CLIENT`, `RMI_CLASS`, `RMI_METHOD`, `SERVICE_DISPLAY_NAME`, `SERVICE_NAME`, `SERVICE_PORT`, `SERVICE_PUBLIC_DOMAIN_NAME`, `SERVICE_REQUEST_ATTRIBUTE`, `SERVICE_TAG`, `SERVICE_TYPE`, `SERVICE_WEB_APPLICATION_ID`, `SERVICE_WEB_CONTEXT_ROOT`, `SERVICE_WEB_SERVER_NAME`, `SERVICE_WEB_SERVICE_NAME`, `SERVICE_WEB_SERVICE_NAMESPACE`, `SUSPENSION_TIME`, `TOTAL_PROCESSING_TIME`, `WAIT_TIME`, `WEBREQUEST_QUERY`, `WEBREQUEST_RELATIVE_URL`, `WEBREQUEST_URL`, `WEBREQUEST_URL_HOST`, `WEBREQUEST_URL_PATH`, `WEBREQUEST_URL_PORT`, `WEBSERVICE_ENDPOINT`, `WEBSERVICE_METHOD` and `ZOS_CALL_TYPE`
        :param 'RequestNamingConditionsConditionComparisonArgs' comparison: Type-specific comparison for attributes
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "comparison", comparison)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be matched.  Note that for a service property attribute you must use the comparison of the `FAST_STRING` type. Possible values are `ACTOR_SYSTEM`, `AKKA_ACTOR_CLASS_NAME`, `AKKA_ACTOR_MESSAGE_TYPE`, `AKKA_ACTOR_PATH`, `APPLICATION_BUILD_VERSION`, `APPLICATION_RELEASE_VERSION`, `AZURE_FUNCTIONS_FUNCTION_NAME`, `AZURE_FUNCTIONS_SITE_NAME`, `CICS_PROGRAM_NAME`, `CICS_SYSTEM_ID`, `CICS_TASK_ID`, `CICS_TRANSACTION_ID`, `CICS_USER_ID`, `CPU_TIME`, `CTG_GATEWAY_URL`, `CTG_PROGRAM`, `CTG_SERVER_NAME`, `CTG_TRANSACTION_ID`, `CUSTOMSERVICE_CLASS`, `CUSTOMSERVICE_METHOD`, `DATABASE_CHILD_CALL_COUNT`, `DATABASE_CHILD_CALL_TIME`, `DATABASE_HOST`, `DATABASE_NAME`, `DATABASE_TYPE`, `DATABASE_URL`, `DISK_IO_TIME`, `ERROR_COUNT`, `ESB_APPLICATION_NAME`, `ESB_INPUT_TYPE`, `ESB_LIBRARY_NAME`, `ESB_MESSAGE_FLOW_NAME`, `EXCEPTION_CLASS`, `EXCEPTION_MESSAGE`, `FAILED_STATE`, `FAILURE_REASON`, `FLAW_STATE`, `HTTP_REQUEST_METHOD`, `HTTP_STATUS`, `HTTP_STATUS_CLASS`, `IMS_PROGRAM_NAME`, `IMS_TRANSACTION_ID`, `IMS_USER_ID`, `IO_TIME`, `IS_KEY_REQUEST`, `LAMBDA_COLDSTART`, `LOCK_TIME`, `MESSAGING_DESTINATION_TYPE`, `MESSAGING_IS_TEMPORARY_QUEUE`, `MESSAGING_QUEUE_NAME`, `MESSAGING_QUEUE_VENDOR`, `NETWORK_IO_TIME`, `NON_DATABASE_CHILD_CALL_COUNT`, `NON_DATABASE_CHILD_CALL_TIME`, `PROCESS_GROUP_NAME`, `PROCESS_GROUP_TAG`, `REMOTE_ENDPOINT`, `REMOTE_METHOD`, `REMOTE_SERVICE_NAME`, `REQUEST_NAME`, `REQUEST_TYPE`, `RESPONSE_TIME`, `RESPONSE_TIME_CLIENT`, `RMI_CLASS`, `RMI_METHOD`, `SERVICE_DISPLAY_NAME`, `SERVICE_NAME`, `SERVICE_PORT`, `SERVICE_PUBLIC_DOMAIN_NAME`, `SERVICE_REQUEST_ATTRIBUTE`, `SERVICE_TAG`, `SERVICE_TYPE`, `SERVICE_WEB_APPLICATION_ID`, `SERVICE_WEB_CONTEXT_ROOT`, `SERVICE_WEB_SERVER_NAME`, `SERVICE_WEB_SERVICE_NAME`, `SERVICE_WEB_SERVICE_NAMESPACE`, `SUSPENSION_TIME`, `TOTAL_PROCESSING_TIME`, `WAIT_TIME`, `WEBREQUEST_QUERY`, `WEBREQUEST_RELATIVE_URL`, `WEBREQUEST_URL`, `WEBREQUEST_URL_HOST`, `WEBREQUEST_URL_PATH`, `WEBREQUEST_URL_PORT`, `WEBSERVICE_ENDPOINT`, `WEBSERVICE_METHOD` and `ZOS_CALL_TYPE`
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def comparison(self) -> 'outputs.RequestNamingConditionsConditionComparison':
        """
        Type-specific comparison for attributes
        """
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestNamingConditionsConditionComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "esbInputNodeType":
            suggest = "esb_input_node_type"
        elif key == "failedState":
            suggest = "failed_state"
        elif key == "failureReason":
            suggest = "failure_reason"
        elif key == "fastString":
            suggest = "fast_string"
        elif key == "flawState":
            suggest = "flaw_state"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "httpStatusClass":
            suggest = "http_status_class"
        elif key == "iibInputNodeType":
            suggest = "iib_input_node_type"
        elif key == "numberRequestAttribute":
            suggest = "number_request_attribute"
        elif key == "serviceType":
            suggest = "service_type"
        elif key == "stringRequestAttribute":
            suggest = "string_request_attribute"
        elif key == "zosCallType":
            suggest = "zos_call_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boolean: Optional['outputs.RequestNamingConditionsConditionComparisonBoolean'] = None,
                 esb_input_node_type: Optional['outputs.RequestNamingConditionsConditionComparisonEsbInputNodeType'] = None,
                 failed_state: Optional['outputs.RequestNamingConditionsConditionComparisonFailedState'] = None,
                 failure_reason: Optional['outputs.RequestNamingConditionsConditionComparisonFailureReason'] = None,
                 fast_string: Optional['outputs.RequestNamingConditionsConditionComparisonFastString'] = None,
                 flaw_state: Optional['outputs.RequestNamingConditionsConditionComparisonFlawState'] = None,
                 generic: Optional['outputs.RequestNamingConditionsConditionComparisonGeneric'] = None,
                 http_method: Optional['outputs.RequestNamingConditionsConditionComparisonHttpMethod'] = None,
                 http_status_class: Optional['outputs.RequestNamingConditionsConditionComparisonHttpStatusClass'] = None,
                 iib_input_node_type: Optional['outputs.RequestNamingConditionsConditionComparisonIibInputNodeType'] = None,
                 negate: Optional[bool] = None,
                 number: Optional['outputs.RequestNamingConditionsConditionComparisonNumber'] = None,
                 number_request_attribute: Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttribute'] = None,
                 service_type: Optional['outputs.RequestNamingConditionsConditionComparisonServiceType'] = None,
                 string: Optional['outputs.RequestNamingConditionsConditionComparisonString'] = None,
                 string_request_attribute: Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttribute'] = None,
                 tag: Optional['outputs.RequestNamingConditionsConditionComparisonTag'] = None,
                 zos_call_type: Optional['outputs.RequestNamingConditionsConditionComparisonZosCallType'] = None):
        """
        :param 'RequestNamingConditionsConditionComparisonBooleanArgs' boolean: Boolean Comparison for `BOOLEAN` attributes
        :param 'RequestNamingConditionsConditionComparisonEsbInputNodeTypeArgs' esb_input_node_type: Type-specific comparison information for attributes of type 'ESB_INPUT_NODE_TYPE'
        :param 'RequestNamingConditionsConditionComparisonFailedStateArgs' failed_state: Comparison for `FAILED_STATE` attributes
        :param 'RequestNamingConditionsConditionComparisonFailureReasonArgs' failure_reason: Comparison for `FAILURE_REASON` attributes
        :param 'RequestNamingConditionsConditionComparisonFastStringArgs' fast_string: Comparison for `FAST_STRING` attributes. Use it for all service property attributes
        :param 'RequestNamingConditionsConditionComparisonFlawStateArgs' flaw_state: Comparison for `FLAW_STATE` attributes
        :param 'RequestNamingConditionsConditionComparisonGenericArgs' generic: Comparison for `NUMBER` attributes
        :param 'RequestNamingConditionsConditionComparisonHttpMethodArgs' http_method: Comparison for `HTTP_METHOD` attributes
        :param 'RequestNamingConditionsConditionComparisonHttpStatusClassArgs' http_status_class: Comparison for `HTTP_STATUS_CLASS` attributes
        :param 'RequestNamingConditionsConditionComparisonIibInputNodeTypeArgs' iib_input_node_type: Comparison for `IIB_INPUT_NODE_TYPE` attributes
        :param bool negate: Reverse the comparison **operator**. For example, it turns **equals** into **does not equal**
        :param 'RequestNamingConditionsConditionComparisonNumberArgs' number: Comparison for `NUMBER` attributes
        :param 'RequestNamingConditionsConditionComparisonNumberRequestAttributeArgs' number_request_attribute: Comparison for `NUMBER_REQUEST_ATTRIBUTE` attributes
        :param 'RequestNamingConditionsConditionComparisonServiceTypeArgs' service_type: Comparison for `SERVICE_TYPE` attributes
        :param 'RequestNamingConditionsConditionComparisonStringArgs' string: Comparison for `STRING` attributes
        :param 'RequestNamingConditionsConditionComparisonStringRequestAttributeArgs' string_request_attribute: Comparison for `STRING_REQUEST_ATTRIBUTE` attributes
        :param 'RequestNamingConditionsConditionComparisonTagArgs' tag: Comparison for `TAG` attributes
        :param 'RequestNamingConditionsConditionComparisonZosCallTypeArgs' zos_call_type: Comparison for `ZOS_CALL_TYPE` attributes
        """
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if esb_input_node_type is not None:
            pulumi.set(__self__, "esb_input_node_type", esb_input_node_type)
        if failed_state is not None:
            pulumi.set(__self__, "failed_state", failed_state)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if fast_string is not None:
            pulumi.set(__self__, "fast_string", fast_string)
        if flaw_state is not None:
            pulumi.set(__self__, "flaw_state", flaw_state)
        if generic is not None:
            pulumi.set(__self__, "generic", generic)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if http_status_class is not None:
            pulumi.set(__self__, "http_status_class", http_status_class)
        if iib_input_node_type is not None:
            pulumi.set(__self__, "iib_input_node_type", iib_input_node_type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if number_request_attribute is not None:
            pulumi.set(__self__, "number_request_attribute", number_request_attribute)
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_request_attribute is not None:
            pulumi.set(__self__, "string_request_attribute", string_request_attribute)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if zos_call_type is not None:
            pulumi.set(__self__, "zos_call_type", zos_call_type)

    @property
    @pulumi.getter
    def boolean(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonBoolean']:
        """
        Boolean Comparison for `BOOLEAN` attributes
        """
        return pulumi.get(self, "boolean")

    @property
    @pulumi.getter(name="esbInputNodeType")
    def esb_input_node_type(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonEsbInputNodeType']:
        """
        Type-specific comparison information for attributes of type 'ESB_INPUT_NODE_TYPE'
        """
        return pulumi.get(self, "esb_input_node_type")

    @property
    @pulumi.getter(name="failedState")
    def failed_state(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonFailedState']:
        """
        Comparison for `FAILED_STATE` attributes
        """
        return pulumi.get(self, "failed_state")

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonFailureReason']:
        """
        Comparison for `FAILURE_REASON` attributes
        """
        return pulumi.get(self, "failure_reason")

    @property
    @pulumi.getter(name="fastString")
    def fast_string(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonFastString']:
        """
        Comparison for `FAST_STRING` attributes. Use it for all service property attributes
        """
        return pulumi.get(self, "fast_string")

    @property
    @pulumi.getter(name="flawState")
    def flaw_state(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonFlawState']:
        """
        Comparison for `FLAW_STATE` attributes
        """
        return pulumi.get(self, "flaw_state")

    @property
    @pulumi.getter
    def generic(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonGeneric']:
        """
        Comparison for `NUMBER` attributes
        """
        return pulumi.get(self, "generic")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonHttpMethod']:
        """
        Comparison for `HTTP_METHOD` attributes
        """
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter(name="httpStatusClass")
    def http_status_class(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonHttpStatusClass']:
        """
        Comparison for `HTTP_STATUS_CLASS` attributes
        """
        return pulumi.get(self, "http_status_class")

    @property
    @pulumi.getter(name="iibInputNodeType")
    def iib_input_node_type(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonIibInputNodeType']:
        """
        Comparison for `IIB_INPUT_NODE_TYPE` attributes
        """
        return pulumi.get(self, "iib_input_node_type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverse the comparison **operator**. For example, it turns **equals** into **does not equal**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def number(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonNumber']:
        """
        Comparison for `NUMBER` attributes
        """
        return pulumi.get(self, "number")

    @property
    @pulumi.getter(name="numberRequestAttribute")
    def number_request_attribute(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttribute']:
        """
        Comparison for `NUMBER_REQUEST_ATTRIBUTE` attributes
        """
        return pulumi.get(self, "number_request_attribute")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonServiceType']:
        """
        Comparison for `SERVICE_TYPE` attributes
        """
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def string(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonString']:
        """
        Comparison for `STRING` attributes
        """
        return pulumi.get(self, "string")

    @property
    @pulumi.getter(name="stringRequestAttribute")
    def string_request_attribute(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttribute']:
        """
        Comparison for `STRING_REQUEST_ATTRIBUTE` attributes
        """
        return pulumi.get(self, "string_request_attribute")

    @property
    @pulumi.getter
    def tag(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonTag']:
        """
        Comparison for `TAG` attributes
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="zosCallType")
    def zos_call_type(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonZosCallType']:
        """
        Comparison for `ZOS_CALL_TYPE` attributes
        """
        return pulumi.get(self, "zos_call_type")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonBoolean(dict):
    def __init__(__self__, *,
                 value: bool,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 values: Optional[Sequence[bool]] = None):
        """
        :param bool value: The value to compare to
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param Sequence[bool] values: The values to compare to
        """
        pulumi.set(__self__, "value", value)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def value(self) -> bool:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[bool]]:
        """
        The values to compare to
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonEsbInputNodeType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
        :param Sequence[str] values: The values to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonFailedState(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to. Possible values are `FAILED` and `FAILED`
        :param Sequence[str] values: The values to compare to. Possible values are `FAILED` and `FAILED`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are `FAILED` and `FAILED`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to. Possible values are `FAILED` and `FAILED`
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonFailureReason(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to. Possible values are `EXCEPTION_AT_ENTRY_NODE`, `EXCEPTION_ON_ANY_NODE`, `HTTP_CODE` and `REQUEST_ATTRIBUTE`
        :param Sequence[str] values: The values to compare to. Possible values are `EXCEPTION_AT_ENTRY_NODE`, `EXCEPTION_ON_ANY_NODE`, `HTTP_CODE` and `REQUEST_ATTRIBUTE`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are `EXCEPTION_AT_ENTRY_NODE`, `EXCEPTION_ON_ANY_NODE`, `HTTP_CODE` and `REQUEST_ATTRIBUTE`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to. Possible values are `EXCEPTION_AT_ENTRY_NODE`, `EXCEPTION_ON_ANY_NODE`, `HTTP_CODE` and `REQUEST_ATTRIBUTE`
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonFastString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonFastString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonFastString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonFastString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or not case-sensitive (`false`)
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `CONTAINS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to
        :param Sequence[str] values: The values to compare to
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or not case-sensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `CONTAINS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonFlawState(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to. Possible values are `FLAWED` and `NOT_FLAWED`
        :param Sequence[str] values: The values to compare to. Possible values are `FLAWED` and `NOT_FLAWED`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are `FLAWED` and `NOT_FLAWED`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to. Possible values are `FLAWED` and `NOT_FLAWED`
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonGeneric(dict):
    def __init__(__self__, *,
                 type: str,
                 unknowns: Optional[str] = None):
        """
        :param str type: Defines the actual set of fields depending on the value
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines the actual set of fields depending on the value
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonHttpMethod(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to. Possible values are `CONNECT`, `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, `PUT` and `TRACE`
        :param Sequence[str] values: The values to compare to. Possible values are `CONNECT`, `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, `PUT` and `TRACE`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are `CONNECT`, `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, `PUT` and `TRACE`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to. Possible values are `CONNECT`, `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, `PUT` and `TRACE`
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonHttpStatusClass(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to. Possible values are `C_1XX`, `C_2XX`, `C_3XX`, `C_4XX`, `C_5XX` and `NO_RESPONSE`
        :param Sequence[str] values: The values to compare to. Possible values are `C_1XX`, `C_2XX`, `C_3XX`, `C_4XX`, `C_5XX` and `NO_RESPONSE`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are `C_1XX`, `C_2XX`, `C_3XX`, `C_4XX`, `C_5XX` and `NO_RESPONSE`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to. Possible values are `C_1XX`, `C_2XX`, `C_3XX`, `C_4XX`, `C_5XX` and `NO_RESPONSE`
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonIibInputNodeType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
        :param Sequence[str] values: The values to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonNumber(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[float] = None,
                 values: Optional[Sequence[float]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF`, `EXISTS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LOWER_THAN` and `LOWER_THAN_OR_EQUAL`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param float value: The value to compare to
        :param Sequence[float] values: The values to compare to
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF`, `EXISTS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LOWER_THAN` and `LOWER_THAN_OR_EQUAL`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[float]]:
        """
        The values to compare to
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonNumberRequestAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"
        elif key == "matchOnChildCalls":
            suggest = "match_on_child_calls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonNumberRequestAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonNumberRequestAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonNumberRequestAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_attribute: str,
                 match_on_child_calls: Optional[bool] = None,
                 operator: Optional[str] = None,
                 source: Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSource'] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[float] = None,
                 values: Optional[Sequence[float]] = None):
        """
        :param str request_attribute: No documentation available for this attribute
        :param bool match_on_child_calls: If `true`, the request attribute is matched on child service calls. Default is `false`
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF`, `EXISTS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LOWER_THAN` and `LOWER_THAN_OR_EQUAL`
        :param 'RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceArgs' source: Defines valid sources of request attributes for conditions or placeholders
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param float value: The value to compare to
        :param Sequence[float] values: The values to compare to
        """
        pulumi.set(__self__, "request_attribute", request_attribute)
        if match_on_child_calls is not None:
            pulumi.set(__self__, "match_on_child_calls", match_on_child_calls)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> str:
        """
        No documentation available for this attribute
        """
        return pulumi.get(self, "request_attribute")

    @property
    @pulumi.getter(name="matchOnChildCalls")
    def match_on_child_calls(self) -> Optional[bool]:
        """
        If `true`, the request attribute is matched on child service calls. Default is `false`
        """
        return pulumi.get(self, "match_on_child_calls")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF`, `EXISTS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LOWER_THAN` and `LOWER_THAN_OR_EQUAL`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSource']:
        """
        Defines valid sources of request attributes for conditions or placeholders
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[float]]:
        """
        The values to compare to
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonNumberRequestAttributeSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZone":
            suggest = "management_zone"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonNumberRequestAttributeSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonNumberRequestAttributeSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonNumberRequestAttributeSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zone: Optional[str] = None,
                 service_tag: Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag'] = None,
                 unknowns: Optional[str] = None):
        """
        :param str management_zone: Use only request attributes from services that belong to this management zone.. Use either this or `serviceTag`
        :param 'RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTagArgs' service_tag: Use only request attributes from services that have this tag. Use either this or `managementZone`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        """
        Use only request attributes from services that belong to this management zone.. Use either this or `serviceTag`
        """
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag']:
        """
        Use only request attributes from services that have this tag. Use either this or `managementZone`
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 tag_key: Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey'] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key of the tag. For custom tags, put the tag value here. The key allows categorization of multiple tags. It is possible that there are multiple values for a single key which will all be represented as standalone tags. Therefore, the key does not have the semantic of a map key but is more like a key of a key-value tuple. In some cases, for example custom tags, the key represents the actual tag value and the value field is not set – those are called valueless tags
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. For custom tags use the `CONTEXTLESS` value. The context is set for tags that are automatically imported by OneAgent (for example, from the AWS console or environment variables). It’s useful for determining the origin of tags when not manually defined, and it also helps to prevent clashes with other existing tags. If the tag is not automatically imported, `CONTEXTLESS` set. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_COMPUTE_ENGINE` and `KUBERNETES`
        :param 'RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKeyArgs' tag_key: has no documentation
        :param str value: The value of the tag. Not applicable to custom tags. If a tag does have a separate key and value (in the textual representation they are split by the colon ‘:’), this field is set with the actual value. Key-value pairs can occur for automatically imported tags and tags set by rules if extractors are used
        """
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. For custom tags, put the tag value here. The key allows categorization of multiple tags. It is possible that there are multiple values for a single key which will all be represented as standalone tags. Therefore, the key does not have the semantic of a map key but is more like a key of a key-value tuple. In some cases, for example custom tags, the key represents the actual tag value and the value field is not set – those are called valueless tags
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        The origin of the tag, such as AWS or Cloud Foundry. For custom tags use the `CONTEXTLESS` value. The context is set for tags that are automatically imported by OneAgent (for example, from the AWS console or environment variables). It’s useful for determining the origin of tags when not manually defined, and it also helps to prevent clashes with other existing tags. If the tag is not automatically imported, `CONTEXTLESS` set. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_COMPUTE_ENGINE` and `KUBERNETES`
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey']:
        """
        has no documentation
        """
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags. If a tag does have a separate key and value (in the textual representation they are split by the colon ‘:’), this field is set with the actual value. Key-value pairs can occur for automatically imported tags and tags set by rules if extractors are used
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey(dict):
    def __init__(__self__, *,
                 context: Optional[str] = None,
                 key: Optional[str] = None):
        """
        :param str context: has no documentation
        :param str key: has no documentation
        """
        if context is not None:
            pulumi.set(__self__, "context", context)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        has no documentation
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        has no documentation
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonServiceType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to. Possible values are `BACKGROUND_ACTIVITY`, `CICS_SERVICE`, `CUSTOM_SERVICE`, `DATABASE_SERVICE`, `ENTERPRISE_SERVICE_BUS_SERVICE`, `EXTERNAL`, `IBM_INTEGRATION_BUS_SERVICE`, `IMS_SERVICE`, `MESSAGING_SERVICE`, `RMI_SERVICE`, `RPC_SERVICE`, `WEB_REQUEST_SERVICE` and `WEB_SERVICE`
        :param Sequence[str] values: The values to compare to. Possible values are `BACKGROUND_ACTIVITY`, `CICS_SERVICE`, `CUSTOM_SERVICE`, `DATABASE_SERVICE`, `ENTERPRISE_SERVICE_BUS_SERVICE`, `EXTERNAL`, `IBM_INTEGRATION_BUS_SERVICE`, `IMS_SERVICE`, `MESSAGING_SERVICE`, `RMI_SERVICE`, `RPC_SERVICE`, `WEB_REQUEST_SERVICE` and `WEB_SERVICE`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are `BACKGROUND_ACTIVITY`, `CICS_SERVICE`, `CUSTOM_SERVICE`, `DATABASE_SERVICE`, `ENTERPRISE_SERVICE_BUS_SERVICE`, `EXTERNAL`, `IBM_INTEGRATION_BUS_SERVICE`, `IMS_SERVICE`, `MESSAGING_SERVICE`, `RMI_SERVICE`, `RPC_SERVICE`, `WEB_REQUEST_SERVICE` and `WEB_SERVICE`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to. Possible values are `BACKGROUND_ACTIVITY`, `CICS_SERVICE`, `CUSTOM_SERVICE`, `DATABASE_SERVICE`, `ENTERPRISE_SERVICE_BUS_SERVICE`, `EXTERNAL`, `IBM_INTEGRATION_BUS_SERVICE`, `IMS_SERVICE`, `MESSAGING_SERVICE`, `RMI_SERVICE`, `RPC_SERVICE`, `WEB_REQUEST_SERVICE` and `WEB_SERVICE`
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or not case-sensitive (`false`)
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `BEGINS_WITH`, `BEGINS_WITH_ANY_OF`, `CONTAINS`, `ENDS_WITH`, `ENDS_WITH_ANY_OF`, `EQUALS`, `EQUALS_ANY_OF`, `EXISTS` and `REGEX_MATCHES`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to
        :param Sequence[str] values: The values to compare to
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or not case-sensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `BEGINS_WITH`, `BEGINS_WITH_ANY_OF`, `CONTAINS`, `ENDS_WITH`, `ENDS_WITH_ANY_OF`, `EQUALS`, `EQUALS_ANY_OF`, `EXISTS` and `REGEX_MATCHES`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonStringRequestAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchOnChildCalls":
            suggest = "match_on_child_calls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonStringRequestAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonStringRequestAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonStringRequestAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_attribute: str,
                 case_sensitive: Optional[bool] = None,
                 match_on_child_calls: Optional[bool] = None,
                 operator: Optional[str] = None,
                 source: Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSource'] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str request_attribute: No documentation available for this attribute
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or not case-sensitive (`false`)
        :param bool match_on_child_calls: If `true`, the request attribute is matched on child service calls. Default is `false`
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `BEGINS_WITH`, `BEGINS_WITH_ANY_OF`, `CONTAINS`, `ENDS_WITH`, `ENDS_WITH_ANY_OF`, `EQUALS`, `EQUALS_ANY_OF`, `EXISTS` and `REGEX_MATCHES`
        :param 'RequestNamingConditionsConditionComparisonStringRequestAttributeSourceArgs' source: Defines valid sources of request attributes for conditions or placeholders
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to
        :param Sequence[str] values: The values to compare to
        """
        pulumi.set(__self__, "request_attribute", request_attribute)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_on_child_calls is not None:
            pulumi.set(__self__, "match_on_child_calls", match_on_child_calls)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> str:
        """
        No documentation available for this attribute
        """
        return pulumi.get(self, "request_attribute")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or not case-sensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchOnChildCalls")
    def match_on_child_calls(self) -> Optional[bool]:
        """
        If `true`, the request attribute is matched on child service calls. Default is `false`
        """
        return pulumi.get(self, "match_on_child_calls")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `BEGINS_WITH`, `BEGINS_WITH_ANY_OF`, `CONTAINS`, `ENDS_WITH`, `ENDS_WITH_ANY_OF`, `EQUALS`, `EQUALS_ANY_OF`, `EXISTS` and `REGEX_MATCHES`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSource']:
        """
        Defines valid sources of request attributes for conditions or placeholders
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonStringRequestAttributeSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZone":
            suggest = "management_zone"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonStringRequestAttributeSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonStringRequestAttributeSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonStringRequestAttributeSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zone: Optional[str] = None,
                 service_tag: Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag'] = None,
                 unknowns: Optional[str] = None):
        """
        :param str management_zone: Use only request attributes from services that belong to this management zone.. Use either this or `serviceTag`
        :param 'RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTagArgs' service_tag: Use only request attributes from services that have this tag. Use either this or `managementZone`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        """
        Use only request attributes from services that belong to this management zone.. Use either this or `serviceTag`
        """
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag']:
        """
        Use only request attributes from services that have this tag. Use either this or `managementZone`
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 tag_key: Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey'] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key of the tag. For custom tags, put the tag value here. The key allows categorization of multiple tags. It is possible that there are multiple values for a single key which will all be represented as standalone tags. Therefore, the key does not have the semantic of a map key but is more like a key of a key-value tuple. In some cases, for example custom tags, the key represents the actual tag value and the value field is not set – those are called valueless tags
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. For custom tags use the `CONTEXTLESS` value. The context is set for tags that are automatically imported by OneAgent (for example, from the AWS console or environment variables). It’s useful for determining the origin of tags when not manually defined, and it also helps to prevent clashes with other existing tags. If the tag is not automatically imported, `CONTEXTLESS` set. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_COMPUTE_ENGINE` and `KUBERNETES`
        :param 'RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKeyArgs' tag_key: has no documentation
        :param str value: The value of the tag. Not applicable to custom tags. If a tag does have a separate key and value (in the textual representation they are split by the colon ‘:’), this field is set with the actual value. Key-value pairs can occur for automatically imported tags and tags set by rules if extractors are used
        """
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. For custom tags, put the tag value here. The key allows categorization of multiple tags. It is possible that there are multiple values for a single key which will all be represented as standalone tags. Therefore, the key does not have the semantic of a map key but is more like a key of a key-value tuple. In some cases, for example custom tags, the key represents the actual tag value and the value field is not set – those are called valueless tags
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        The origin of the tag, such as AWS or Cloud Foundry. For custom tags use the `CONTEXTLESS` value. The context is set for tags that are automatically imported by OneAgent (for example, from the AWS console or environment variables). It’s useful for determining the origin of tags when not manually defined, and it also helps to prevent clashes with other existing tags. If the tag is not automatically imported, `CONTEXTLESS` set. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_COMPUTE_ENGINE` and `KUBERNETES`
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey']:
        """
        has no documentation
        """
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags. If a tag does have a separate key and value (in the textual representation they are split by the colon ‘:’), this field is set with the actual value. Key-value pairs can occur for automatically imported tags and tags set by rules if extractors are used
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey(dict):
    def __init__(__self__, *,
                 context: Optional[str] = None,
                 key: Optional[str] = None):
        """
        :param str context: has no documentation
        :param str key: has no documentation
        """
        if context is not None:
            pulumi.set(__self__, "context", context)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        has no documentation
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        has no documentation
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonTag(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.RequestNamingConditionsConditionComparisonTagValue'] = None,
                 values: Optional['outputs.RequestNamingConditionsConditionComparisonTagValues'] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF`, `TAG_KEY_EQUALS` and `TAG_KEY_EQUALS_ANY_OF`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param 'RequestNamingConditionsConditionComparisonTagValueArgs' value: The values to compare to
        :param 'RequestNamingConditionsConditionComparisonTagValuesArgs' values: The values to compare to
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF`, `TAG_KEY_EQUALS` and `TAG_KEY_EQUALS_ANY_OF`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonTagValue']:
        """
        The values to compare to
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonTagValues']:
        """
        The values to compare to
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_CLOUD` and `KUBERNETES`
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_CLOUD` and `KUBERNETES`
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonTagValues(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence['outputs.RequestNamingConditionsConditionComparisonTagValuesValue']] = None):
        """
        :param Sequence['RequestNamingConditionsConditionComparisonTagValuesValueArgs'] values: The values to compare to
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.RequestNamingConditionsConditionComparisonTagValuesValue']]:
        """
        The values to compare to
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonTagValuesValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_CLOUD` and `KUBERNETES`
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_CLOUD` and `KUBERNETES`
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonZosCallType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str value: The value to compare to. Possible values are `CTG`, `DPL`, `EXPLICIT_ADK`, `IMS_CONNECT`, `IMS_CONNECT_API`, `IMS_ITRA`, `IMS_MSC`, `IMS_PGM_SWITCH`, `IMS_SHARED_QUEUES`, `IMS_TRANS_EXEC`, `MQ`, `SOAP`, `START`, `TX` and `UNKNOWN`
        :param Sequence[str] values: The values to compare to. Possible values are `CTG`, `DPL`, `EXPLICIT_ADK`, `IMS_CONNECT`, `IMS_CONNECT_API`, `IMS_ITRA`, `IMS_MSC`, `IMS_PGM_SWITCH`, `IMS_SHARED_QUEUES`, `IMS_TRANS_EXEC`, `MQ`, `SOAP`, `START`, `TX` and `UNKNOWN`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are `CTG`, `DPL`, `EXPLICIT_ADK`, `IMS_CONNECT`, `IMS_CONNECT_API`, `IMS_ITRA`, `IMS_MSC`, `IMS_PGM_SWITCH`, `IMS_SHARED_QUEUES`, `IMS_TRANS_EXEC`, `MQ`, `SOAP`, `START`, `TX` and `UNKNOWN`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        The values to compare to. Possible values are `CTG`, `DPL`, `EXPLICIT_ADK`, `IMS_CONNECT`, `IMS_CONNECT_API`, `IMS_ITRA`, `IMS_MSC`, `IMS_PGM_SWITCH`, `IMS_SHARED_QUEUES`, `IMS_TRANS_EXEC`, `MQ`, `SOAP`, `START`, `TX` and `UNKNOWN`
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingPlaceholders(dict):
    def __init__(__self__, *,
                 placeholders: Optional[Sequence['outputs.RequestNamingPlaceholdersPlaceholder']] = None):
        """
        :param Sequence['RequestNamingPlaceholdersPlaceholderArgs'] placeholders: A custom placeholder to be used in a dimension value pattern
        """
        if placeholders is not None:
            pulumi.set(__self__, "placeholders", placeholders)

    @property
    @pulumi.getter
    def placeholders(self) -> Optional[Sequence['outputs.RequestNamingPlaceholdersPlaceholder']]:
        """
        A custom placeholder to be used in a dimension value pattern
        """
        return pulumi.get(self, "placeholders")


@pulumi.output_type
class RequestNamingPlaceholdersPlaceholder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delimiterOrRegex":
            suggest = "delimiter_or_regex"
        elif key == "endDelimiter":
            suggest = "end_delimiter"
        elif key == "requestAttribute":
            suggest = "request_attribute"
        elif key == "useFromChildCalls":
            suggest = "use_from_child_calls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingPlaceholdersPlaceholder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingPlaceholdersPlaceholder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingPlaceholdersPlaceholder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 kind: str,
                 name: str,
                 aggregation: Optional[str] = None,
                 delimiter_or_regex: Optional[str] = None,
                 end_delimiter: Optional[str] = None,
                 normalization: Optional[str] = None,
                 request_attribute: Optional[str] = None,
                 source: Optional['outputs.RequestNamingPlaceholdersPlaceholderSource'] = None,
                 unknowns: Optional[str] = None,
                 use_from_child_calls: Optional[bool] = None):
        """
        :param str attribute: The attribute to extract from. You can only use attributes of the **string** type. Possible values are `ACTOR_SYSTEM`, `AKKA_ACTOR_CLASS_NAME`, `AKKA_ACTOR_MESSAGE_TYPE`, `AKKA_ACTOR_PATH`, `APPLICATION_BUILD_VERSION`, `APPLICATION_RELEASE_VERSION`, `AZURE_FUNCTIONS_FUNCTION_NAME`, `AZURE_FUNCTIONS_SITE_NAME`, `CICS_PROGRAM_NAME`, `CICS_SYSTEM_ID`, `CICS_TASK_ID`, `CICS_TRANSACTION_ID`, `CICS_USER_ID`, `CPU_TIME`, `CTG_GATEWAY_URL`, `CTG_PROGRAM`, `CTG_SERVER_NAME`, `CTG_TRANSACTION_ID`, `CUSTOMSERVICE_CLASS`, `CUSTOMSERVICE_METHOD`, `DATABASE_CHILD_CALL_COUNT`, `DATABASE_CHILD_CALL_TIME`, `DATABASE_HOST`, `DATABASE_NAME`, `DATABASE_TYPE`, `DATABASE_URL`, `DISK_IO_TIME`, `ERROR_COUNT`, `ESB_APPLICATION_NAME`, `ESB_INPUT_TYPE`, `ESB_LIBRARY_NAME`, `ESB_MESSAGE_FLOW_NAME`, `EXCEPTION_CLASS`, `EXCEPTION_MESSAGE`, `FAILED_STATE`, `FAILURE_REASON`, `FLAW_STATE`, `HTTP_REQUEST_METHOD`, `HTTP_STATUS`, `HTTP_STATUS_CLASS`, `IMS_PROGRAM_NAME`, `IMS_TRANSACTION_ID`, `IMS_USER_ID`, `IO_TIME`, `IS_KEY_REQUEST`, `LAMBDA_COLDSTART`, `LOCK_TIME`, `MESSAGING_DESTINATION_TYPE`, `MESSAGING_IS_TEMPORARY_QUEUE`, `MESSAGING_QUEUE_NAME`, `MESSAGING_QUEUE_VENDOR`, `NETWORK_IO_TIME`, `NON_DATABASE_CHILD_CALL_COUNT`, `NON_DATABASE_CHILD_CALL_TIME`, `PROCESS_GROUP_NAME`, `PROCESS_GROUP_TAG`, `REMOTE_ENDPOINT`, `REMOTE_METHOD`, `REMOTE_SERVICE_NAME`, `REQUEST_NAME`, `REQUEST_TYPE`, `RESPONSE_TIME`, `RESPONSE_TIME_CLIENT`, `RMI_CLASS`, `RMI_METHOD`, `SERVICE_DISPLAY_NAME`, `SERVICE_NAME`, `SERVICE_PORT`, `SERVICE_PUBLIC_DOMAIN_NAME`, `SERVICE_REQUEST_ATTRIBUTE`, `SERVICE_TAG`, `SERVICE_TYPE`, `SERVICE_WEB_APPLICATION_ID`, `SERVICE_WEB_CONTEXT_ROOT`, `SERVICE_WEB_SERVER_NAME`, `SERVICE_WEB_SERVICE_NAME`, `SERVICE_WEB_SERVICE_NAMESPACE`, `SUSPENSION_TIME`, `TOTAL_PROCESSING_TIME`, `WAIT_TIME`, `WEBREQUEST_QUERY`, `WEBREQUEST_RELATIVE_URL`, `WEBREQUEST_URL`, `WEBREQUEST_URL_HOST`, `WEBREQUEST_URL_PATH`, `WEBREQUEST_URL_PORT`, `WEBSERVICE_ENDPOINT`, `WEBSERVICE_METHOD` and `ZOS_CALL_TYPE`
        :param str kind: The type of extraction. Defines either usage of regular expression (`regex`) or the position of request attribute value to be extracted. When the `attribute` is `SERVICE_REQUEST_ATTRIBUTE` attribute and `aggregation` is `COUNT`, needs to be set to `ORIGINAL_TEXT`. Possible values are 	`AFTER_DELIMITER`, `BEFORE_DELIMITER`, `BETWEEN_DELIMITER`, `ORIGINAL_TEXT` and `REGEX_EXTRACTION`
        :param str name: The name of the placeholder. Use it in the naming pattern as `{name}`
        :param str aggregation: Which value of the request attribute must be used when it occurs across multiple child requests. Only applicable for the `SERVICE_REQUEST_ATTRIBUTE` attribute, when **useFromChildCalls** is `true`. For the `COUNT` aggregation, the **kind** field is not applicable. Possible values are `COUNT`, `FIRST` and `LAST`.
        :param str delimiter_or_regex: Depending on the `kind` value:
               
               
               * `REGEX_EXTRACTION`: The regular expression.
               
               
               * `BETWEEN_DELIMITER`: The opening delimiter string to look for.
               
               
               * All other values: The delimiter string to look for
        :param str end_delimiter: The closing delimiter string to look for. Required if the `kind` value is `BETWEEN_DELIMITER`. Not applicable otherwise
        :param str normalization: The format of the extracted string. Possible values are `ORIGINAL`, `TO_LOWER_CASE` and `TO_UPPER_CASE`
        :param str request_attribute: The request attribute to extract from. Required if the `kind` value is `SERVICE_REQUEST_ATTRIBUTE`. Not applicable otherwise
        :param 'RequestNamingPlaceholdersPlaceholderSourceArgs' source: Defines valid sources of request attributes for conditions or placeholders
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param bool use_from_child_calls: If `true` request attribute will be taken from a child service call. Only applicable for the `SERVICE_REQUEST_ATTRIBUTE` attribute. Defaults to `false`
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if delimiter_or_regex is not None:
            pulumi.set(__self__, "delimiter_or_regex", delimiter_or_regex)
        if end_delimiter is not None:
            pulumi.set(__self__, "end_delimiter", end_delimiter)
        if normalization is not None:
            pulumi.set(__self__, "normalization", normalization)
        if request_attribute is not None:
            pulumi.set(__self__, "request_attribute", request_attribute)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if use_from_child_calls is not None:
            pulumi.set(__self__, "use_from_child_calls", use_from_child_calls)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to extract from. You can only use attributes of the **string** type. Possible values are `ACTOR_SYSTEM`, `AKKA_ACTOR_CLASS_NAME`, `AKKA_ACTOR_MESSAGE_TYPE`, `AKKA_ACTOR_PATH`, `APPLICATION_BUILD_VERSION`, `APPLICATION_RELEASE_VERSION`, `AZURE_FUNCTIONS_FUNCTION_NAME`, `AZURE_FUNCTIONS_SITE_NAME`, `CICS_PROGRAM_NAME`, `CICS_SYSTEM_ID`, `CICS_TASK_ID`, `CICS_TRANSACTION_ID`, `CICS_USER_ID`, `CPU_TIME`, `CTG_GATEWAY_URL`, `CTG_PROGRAM`, `CTG_SERVER_NAME`, `CTG_TRANSACTION_ID`, `CUSTOMSERVICE_CLASS`, `CUSTOMSERVICE_METHOD`, `DATABASE_CHILD_CALL_COUNT`, `DATABASE_CHILD_CALL_TIME`, `DATABASE_HOST`, `DATABASE_NAME`, `DATABASE_TYPE`, `DATABASE_URL`, `DISK_IO_TIME`, `ERROR_COUNT`, `ESB_APPLICATION_NAME`, `ESB_INPUT_TYPE`, `ESB_LIBRARY_NAME`, `ESB_MESSAGE_FLOW_NAME`, `EXCEPTION_CLASS`, `EXCEPTION_MESSAGE`, `FAILED_STATE`, `FAILURE_REASON`, `FLAW_STATE`, `HTTP_REQUEST_METHOD`, `HTTP_STATUS`, `HTTP_STATUS_CLASS`, `IMS_PROGRAM_NAME`, `IMS_TRANSACTION_ID`, `IMS_USER_ID`, `IO_TIME`, `IS_KEY_REQUEST`, `LAMBDA_COLDSTART`, `LOCK_TIME`, `MESSAGING_DESTINATION_TYPE`, `MESSAGING_IS_TEMPORARY_QUEUE`, `MESSAGING_QUEUE_NAME`, `MESSAGING_QUEUE_VENDOR`, `NETWORK_IO_TIME`, `NON_DATABASE_CHILD_CALL_COUNT`, `NON_DATABASE_CHILD_CALL_TIME`, `PROCESS_GROUP_NAME`, `PROCESS_GROUP_TAG`, `REMOTE_ENDPOINT`, `REMOTE_METHOD`, `REMOTE_SERVICE_NAME`, `REQUEST_NAME`, `REQUEST_TYPE`, `RESPONSE_TIME`, `RESPONSE_TIME_CLIENT`, `RMI_CLASS`, `RMI_METHOD`, `SERVICE_DISPLAY_NAME`, `SERVICE_NAME`, `SERVICE_PORT`, `SERVICE_PUBLIC_DOMAIN_NAME`, `SERVICE_REQUEST_ATTRIBUTE`, `SERVICE_TAG`, `SERVICE_TYPE`, `SERVICE_WEB_APPLICATION_ID`, `SERVICE_WEB_CONTEXT_ROOT`, `SERVICE_WEB_SERVER_NAME`, `SERVICE_WEB_SERVICE_NAME`, `SERVICE_WEB_SERVICE_NAMESPACE`, `SUSPENSION_TIME`, `TOTAL_PROCESSING_TIME`, `WAIT_TIME`, `WEBREQUEST_QUERY`, `WEBREQUEST_RELATIVE_URL`, `WEBREQUEST_URL`, `WEBREQUEST_URL_HOST`, `WEBREQUEST_URL_PATH`, `WEBREQUEST_URL_PORT`, `WEBSERVICE_ENDPOINT`, `WEBSERVICE_METHOD` and `ZOS_CALL_TYPE`
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The type of extraction. Defines either usage of regular expression (`regex`) or the position of request attribute value to be extracted. When the `attribute` is `SERVICE_REQUEST_ATTRIBUTE` attribute and `aggregation` is `COUNT`, needs to be set to `ORIGINAL_TEXT`. Possible values are 	`AFTER_DELIMITER`, `BEFORE_DELIMITER`, `BETWEEN_DELIMITER`, `ORIGINAL_TEXT` and `REGEX_EXTRACTION`
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the placeholder. Use it in the naming pattern as `{name}`
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        Which value of the request attribute must be used when it occurs across multiple child requests. Only applicable for the `SERVICE_REQUEST_ATTRIBUTE` attribute, when **useFromChildCalls** is `true`. For the `COUNT` aggregation, the **kind** field is not applicable. Possible values are `COUNT`, `FIRST` and `LAST`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="delimiterOrRegex")
    def delimiter_or_regex(self) -> Optional[str]:
        """
        Depending on the `kind` value:


        * `REGEX_EXTRACTION`: The regular expression.


        * `BETWEEN_DELIMITER`: The opening delimiter string to look for.


        * All other values: The delimiter string to look for
        """
        return pulumi.get(self, "delimiter_or_regex")

    @property
    @pulumi.getter(name="endDelimiter")
    def end_delimiter(self) -> Optional[str]:
        """
        The closing delimiter string to look for. Required if the `kind` value is `BETWEEN_DELIMITER`. Not applicable otherwise
        """
        return pulumi.get(self, "end_delimiter")

    @property
    @pulumi.getter
    def normalization(self) -> Optional[str]:
        """
        The format of the extracted string. Possible values are `ORIGINAL`, `TO_LOWER_CASE` and `TO_UPPER_CASE`
        """
        return pulumi.get(self, "normalization")

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> Optional[str]:
        """
        The request attribute to extract from. Required if the `kind` value is `SERVICE_REQUEST_ATTRIBUTE`. Not applicable otherwise
        """
        return pulumi.get(self, "request_attribute")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.RequestNamingPlaceholdersPlaceholderSource']:
        """
        Defines valid sources of request attributes for conditions or placeholders
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="useFromChildCalls")
    def use_from_child_calls(self) -> Optional[bool]:
        """
        If `true` request attribute will be taken from a child service call. Only applicable for the `SERVICE_REQUEST_ATTRIBUTE` attribute. Defaults to `false`
        """
        return pulumi.get(self, "use_from_child_calls")


@pulumi.output_type
class RequestNamingPlaceholdersPlaceholderSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZone":
            suggest = "management_zone"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingPlaceholdersPlaceholderSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingPlaceholdersPlaceholderSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingPlaceholdersPlaceholderSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zone: Optional[str] = None,
                 service_tag: Optional['outputs.RequestNamingPlaceholdersPlaceholderSourceServiceTag'] = None,
                 unknowns: Optional[str] = None):
        """
        :param str management_zone: Use only request attributes from services that belong to this management zone.. Use either this or `serviceTag`
        :param 'RequestNamingPlaceholdersPlaceholderSourceServiceTagArgs' service_tag: Use only request attributes from services that have this tag. Use either this or `managementZone`
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        """
        Use only request attributes from services that belong to this management zone.. Use either this or `serviceTag`
        """
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional['outputs.RequestNamingPlaceholdersPlaceholderSourceServiceTag']:
        """
        Use only request attributes from services that have this tag. Use either this or `managementZone`
        """
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestNamingPlaceholdersPlaceholderSourceServiceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingPlaceholdersPlaceholderSourceServiceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingPlaceholdersPlaceholderSourceServiceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingPlaceholdersPlaceholderSourceServiceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 tag_key: Optional['outputs.RequestNamingPlaceholdersPlaceholderSourceServiceTagTagKey'] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key of the tag. For custom tags, put the tag value here. The key allows categorization of multiple tags. It is possible that there are multiple values for a single key which will all be represented as standalone tags. Therefore, the key does not have the semantic of a map key but is more like a key of a key-value tuple. In some cases, for example custom tags, the key represents the actual tag value and the value field is not set – those are called valueless tags
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. For custom tags use the `CONTEXTLESS` value. The context is set for tags that are automatically imported by OneAgent (for example, from the AWS console or environment variables). It’s useful for determining the origin of tags when not manually defined, and it also helps to prevent clashes with other existing tags. If the tag is not automatically imported, `CONTEXTLESS` set. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_COMPUTE_ENGINE` and `KUBERNETES`
        :param 'RequestNamingPlaceholdersPlaceholderSourceServiceTagTagKeyArgs' tag_key: has no documentation
        :param str value: The value of the tag. Not applicable to custom tags. If a tag does have a separate key and value (in the textual representation they are split by the colon ‘:’), this field is set with the actual value. Key-value pairs can occur for automatically imported tags and tags set by rules if extractors are used
        """
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. For custom tags, put the tag value here. The key allows categorization of multiple tags. It is possible that there are multiple values for a single key which will all be represented as standalone tags. Therefore, the key does not have the semantic of a map key but is more like a key of a key-value tuple. In some cases, for example custom tags, the key represents the actual tag value and the value field is not set – those are called valueless tags
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        The origin of the tag, such as AWS or Cloud Foundry. For custom tags use the `CONTEXTLESS` value. The context is set for tags that are automatically imported by OneAgent (for example, from the AWS console or environment variables). It’s useful for determining the origin of tags when not manually defined, and it also helps to prevent clashes with other existing tags. If the tag is not automatically imported, `CONTEXTLESS` set. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_COMPUTE_ENGINE` and `KUBERNETES`
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional['outputs.RequestNamingPlaceholdersPlaceholderSourceServiceTagTagKey']:
        """
        has no documentation
        """
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags. If a tag does have a separate key and value (in the textual representation they are split by the colon ‘:’), this field is set with the actual value. Key-value pairs can occur for automatically imported tags and tags set by rules if extractors are used
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RequestNamingPlaceholdersPlaceholderSourceServiceTagTagKey(dict):
    def __init__(__self__, *,
                 context: Optional[str] = None,
                 key: Optional[str] = None):
        """
        :param str context: has no documentation
        :param str key: has no documentation
        """
        if context is not None:
            pulumi.set(__self__, "context", context)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        has no documentation
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        has no documentation
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class ResourceAttributesKeys(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.ResourceAttributesKeysRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.ResourceAttributesKeysRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class ResourceAttributesKeysRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeKey":
            suggest = "attribute_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAttributesKeysRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAttributesKeysRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAttributesKeysRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_key: str,
                 enabled: bool,
                 masking: str):
        """
        :param str attribute_key: Attribute key **service.name** is automatically captured by default
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param str masking: Possible Values: `MASK_ENTIRE_VALUE`, `MASK_ONLY_CONFIDENTIAL_DATA`, `NOT_MASKED`
        """
        pulumi.set(__self__, "attribute_key", attribute_key)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "masking", masking)

    @property
    @pulumi.getter(name="attributeKey")
    def attribute_key(self) -> str:
        """
        Attribute key **service.name** is automatically captured by default
        """
        return pulumi.get(self, "attribute_key")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def masking(self) -> str:
        """
        Possible Values: `MASK_ENTIRE_VALUE`, `MASK_ONLY_CONFIDENTIAL_DATA`, `NOT_MASKED`
        """
        return pulumi.get(self, "masking")


@pulumi.output_type
class RumProviderBreakdownDomainNamePatternList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainNamePatterns":
            suggest = "domain_name_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RumProviderBreakdownDomainNamePatternList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RumProviderBreakdownDomainNamePatternList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RumProviderBreakdownDomainNamePatternList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name_patterns: Sequence['outputs.RumProviderBreakdownDomainNamePatternListDomainNamePattern']):
        pulumi.set(__self__, "domain_name_patterns", domain_name_patterns)

    @property
    @pulumi.getter(name="domainNamePatterns")
    def domain_name_patterns(self) -> Sequence['outputs.RumProviderBreakdownDomainNamePatternListDomainNamePattern']:
        return pulumi.get(self, "domain_name_patterns")


@pulumi.output_type
class RumProviderBreakdownDomainNamePatternListDomainNamePattern(dict):
    def __init__(__self__, *,
                 pattern: str):
        """
        :param str pattern: Use a ends-with pattern for this content provider's domain
        """
        pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def pattern(self) -> str:
        """
        Use a ends-with pattern for this content provider's domain
        """
        return pulumi.get(self, "pattern")


@pulumi.output_type
class ServiceAnomaliesFailureRates(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.ServiceAnomaliesFailureRatesAuto'] = None,
                 thresholds: Optional['outputs.ServiceAnomaliesFailureRatesThresholds'] = None):
        """
        :param 'ServiceAnomaliesFailureRatesAutoArgs' auto: Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
        :param 'ServiceAnomaliesFailureRatesThresholdsArgs' thresholds: Fixed thresholds for failure rate increase detection
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.ServiceAnomaliesFailureRatesAuto']:
        """
        Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.ServiceAnomaliesFailureRatesThresholds']:
        """
        Fixed thresholds for failure rate increase detection
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class ServiceAnomaliesFailureRatesAuto(dict):
    def __init__(__self__, *,
                 absolute: int,
                 relative: int,
                 unknowns: Optional[str] = None):
        """
        :param int absolute: Absolute increase of failing service calls to trigger an alert, %
        :param int relative: Relative increase of failing service calls to trigger an alert, %
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "absolute", absolute)
        pulumi.set(__self__, "relative", relative)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def absolute(self) -> int:
        """
        Absolute increase of failing service calls to trigger an alert, %
        """
        return pulumi.get(self, "absolute")

    @property
    @pulumi.getter
    def relative(self) -> int:
        """
        Relative increase of failing service calls to trigger an alert, %
        """
        return pulumi.get(self, "relative")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceAnomaliesFailureRatesThresholds(dict):
    def __init__(__self__, *,
                 sensitivity: str,
                 threshold: int,
                 unknowns: Optional[str] = None):
        """
        :param str sensitivity: Sensitivity of the threshold.  With `low` sensitivity, high statistical confidence is used. Brief violations (for example, due to a surge in load) won't trigger alerts.  With `high` sensitivity, no statistical confidence is used. Each violation triggers alert
        :param int threshold: Failure rate during any 5-minute period to trigger an alert, %
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold", threshold)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        """
        Sensitivity of the threshold.  With `low` sensitivity, high statistical confidence is used. Brief violations (for example, due to a surge in load) won't trigger alerts.  With `high` sensitivity, no statistical confidence is used. Each violation triggers alert
        """
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        Failure rate during any 5-minute period to trigger an alert, %
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceAnomaliesLoad(dict):
    def __init__(__self__, *,
                 drops: Optional['outputs.ServiceAnomaliesLoadDrops'] = None,
                 spikes: Optional['outputs.ServiceAnomaliesLoadSpikes'] = None):
        """
        :param 'ServiceAnomaliesLoadDropsArgs' drops: The configuration of traffic drops detection
        :param 'ServiceAnomaliesLoadSpikesArgs' spikes: The configuration of traffic spikes detection
        """
        if drops is not None:
            pulumi.set(__self__, "drops", drops)
        if spikes is not None:
            pulumi.set(__self__, "spikes", spikes)

    @property
    @pulumi.getter
    def drops(self) -> Optional['outputs.ServiceAnomaliesLoadDrops']:
        """
        The configuration of traffic drops detection
        """
        return pulumi.get(self, "drops")

    @property
    @pulumi.getter
    def spikes(self) -> Optional['outputs.ServiceAnomaliesLoadSpikes']:
        """
        The configuration of traffic spikes detection
        """
        return pulumi.get(self, "spikes")


@pulumi.output_type
class ServiceAnomaliesLoadDrops(dict):
    def __init__(__self__, *,
                 minutes: Optional[int] = None,
                 percent: Optional[int] = None):
        """
        :param int minutes: Alert if the service stays in abnormal state for at least *X* minutes
        :param int percent: Alert if the observed load is more than *X* % of the expected value
        """
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        Alert if the service stays in abnormal state for at least *X* minutes
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        """
        Alert if the observed load is more than *X* % of the expected value
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class ServiceAnomaliesLoadSpikes(dict):
    def __init__(__self__, *,
                 minutes: Optional[int] = None,
                 percent: Optional[int] = None,
                 unknowns: Optional[str] = None):
        """
        :param int minutes: Alert if the service stays in abnormal state for at least *X* minutes
        :param int percent: Alert if the observed load is more than *X* % of the expected value
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        Alert if the service stays in abnormal state for at least *X* minutes
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        """
        Alert if the observed load is more than *X* % of the expected value
        """
        return pulumi.get(self, "percent")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceAnomaliesResponseTimes(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.ServiceAnomaliesResponseTimesAuto'] = None,
                 thresholds: Optional['outputs.ServiceAnomaliesResponseTimesThresholds'] = None):
        """
        :param 'ServiceAnomaliesResponseTimesAutoArgs' auto: Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
        :param 'ServiceAnomaliesResponseTimesThresholdsArgs' thresholds: Fixed thresholds for response time degradation detection
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.ServiceAnomaliesResponseTimesAuto']:
        """
        Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.ServiceAnomaliesResponseTimesThresholds']:
        """
        Fixed thresholds for response time degradation detection
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class ServiceAnomaliesResponseTimesAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestMilliseconds":
            suggest = "slowest_milliseconds"
        elif key == "slowestPercent":
            suggest = "slowest_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesResponseTimesAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesResponseTimesAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesResponseTimesAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load: str,
                 milliseconds: int,
                 percent: int,
                 slowest_milliseconds: int,
                 slowest_percent: int,
                 unknowns: Optional[str] = None):
        """
        :param str load: Minimal service load to detect response time degradation. Response time degradation of services with smaller load won't trigger alerts. Possible values are `FIFTEEN_REQUESTS_PER_MINUTE`, `FIVE_REQUESTS_PER_MINUTE`, `ONE_REQUEST_PER_MINUTE` and `TEN_REQUESTS_PER_MINUTE`
        :param int milliseconds: Alert if the response time degrades by more than *X* milliseconds
        :param int percent: Alert if the response time degrades by more than *X* %
        :param int slowest_milliseconds: Alert if the response time of the slowest 10% degrades by more than *X* milliseconds
        :param int slowest_percent: Alert if the response time of the slowest 10% degrades by more than *X* milliseconds
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "load", load)
        pulumi.set(__self__, "milliseconds", milliseconds)
        pulumi.set(__self__, "percent", percent)
        pulumi.set(__self__, "slowest_milliseconds", slowest_milliseconds)
        pulumi.set(__self__, "slowest_percent", slowest_percent)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def load(self) -> str:
        """
        Minimal service load to detect response time degradation. Response time degradation of services with smaller load won't trigger alerts. Possible values are `FIFTEEN_REQUESTS_PER_MINUTE`, `FIVE_REQUESTS_PER_MINUTE`, `ONE_REQUEST_PER_MINUTE` and `TEN_REQUESTS_PER_MINUTE`
        """
        return pulumi.get(self, "load")

    @property
    @pulumi.getter
    def milliseconds(self) -> int:
        """
        Alert if the response time degrades by more than *X* milliseconds
        """
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def percent(self) -> int:
        """
        Alert if the response time degrades by more than *X* %
        """
        return pulumi.get(self, "percent")

    @property
    @pulumi.getter(name="slowestMilliseconds")
    def slowest_milliseconds(self) -> int:
        """
        Alert if the response time of the slowest 10% degrades by more than *X* milliseconds
        """
        return pulumi.get(self, "slowest_milliseconds")

    @property
    @pulumi.getter(name="slowestPercent")
    def slowest_percent(self) -> int:
        """
        Alert if the response time of the slowest 10% degrades by more than *X* milliseconds
        """
        return pulumi.get(self, "slowest_percent")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceAnomaliesResponseTimesThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestMilliseconds":
            suggest = "slowest_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesResponseTimesThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesResponseTimesThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesResponseTimesThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load: str,
                 milliseconds: int,
                 sensitivity: str,
                 slowest_milliseconds: int,
                 unknowns: Optional[str] = None):
        """
        :param str load: Minimal service load to detect response time degradation. Response time degradation of services with smaller load won't trigger alerts. Possible values are `FIFTEEN_REQUESTS_PER_MINUTE`, `FIVE_REQUESTS_PER_MINUTE`, `ONE_REQUEST_PER_MINUTE` and `TEN_REQUESTS_PER_MINUTE`
        :param int milliseconds: Response time during any 5-minute period to trigger an alert, in milliseconds
        :param str sensitivity: Sensitivity of the threshold.  With `low` sensitivity, high statistical confidence is used. Brief violations (for example, due to a surge in load) won't trigger alerts.  With `high` sensitivity, no statistical confidence is used. Each violation triggers an alert
        :param int slowest_milliseconds: Response time of the 10% slowest during any 5-minute period to trigger an alert, in milliseconds
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "load", load)
        pulumi.set(__self__, "milliseconds", milliseconds)
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "slowest_milliseconds", slowest_milliseconds)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def load(self) -> str:
        """
        Minimal service load to detect response time degradation. Response time degradation of services with smaller load won't trigger alerts. Possible values are `FIFTEEN_REQUESTS_PER_MINUTE`, `FIVE_REQUESTS_PER_MINUTE`, `ONE_REQUEST_PER_MINUTE` and `TEN_REQUESTS_PER_MINUTE`
        """
        return pulumi.get(self, "load")

    @property
    @pulumi.getter
    def milliseconds(self) -> int:
        """
        Response time during any 5-minute period to trigger an alert, in milliseconds
        """
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        """
        Sensitivity of the threshold.  With `low` sensitivity, high statistical confidence is used. Brief violations (for example, due to a surge in load) won't trigger alerts.  With `high` sensitivity, no statistical confidence is used. Each violation triggers an alert
        """
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter(name="slowestMilliseconds")
    def slowest_milliseconds(self) -> int:
        """
        Response time of the 10% slowest during any 5-minute period to trigger an alert, in milliseconds
        """
        return pulumi.get(self, "slowest_milliseconds")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceAnomaliesV2FailureRate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDetection":
            suggest = "auto_detection"
        elif key == "detectionMode":
            suggest = "detection_mode"
        elif key == "fixedDetection":
            suggest = "fixed_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2FailureRate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2FailureRate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2FailureRate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 auto_detection: Optional['outputs.ServiceAnomaliesV2FailureRateAutoDetection'] = None,
                 detection_mode: Optional[str] = None,
                 fixed_detection: Optional['outputs.ServiceAnomaliesV2FailureRateFixedDetection'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'ServiceAnomaliesV2FailureRateAutoDetectionArgs' auto_detection: Alert if the percentage of failing service calls increases by **both** the absolute and relative thresholds:
        :param str detection_mode: Possible Values: `Auto`, `Fixed`
        :param 'ServiceAnomaliesV2FailureRateFixedDetectionArgs' fixed_detection: Alert if a given failure rate is exceeded during any 5-minute-period
        """
        pulumi.set(__self__, "enabled", enabled)
        if auto_detection is not None:
            pulumi.set(__self__, "auto_detection", auto_detection)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if fixed_detection is not None:
            pulumi.set(__self__, "fixed_detection", fixed_detection)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="autoDetection")
    def auto_detection(self) -> Optional['outputs.ServiceAnomaliesV2FailureRateAutoDetection']:
        """
        Alert if the percentage of failing service calls increases by **both** the absolute and relative thresholds:
        """
        return pulumi.get(self, "auto_detection")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Fixed`
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter(name="fixedDetection")
    def fixed_detection(self) -> Optional['outputs.ServiceAnomaliesV2FailureRateFixedDetection']:
        """
        Alert if a given failure rate is exceeded during any 5-minute-period
        """
        return pulumi.get(self, "fixed_detection")


@pulumi.output_type
class ServiceAnomaliesV2FailureRateAutoDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "absoluteIncrease":
            suggest = "absolute_increase"
        elif key == "overAlertingProtection":
            suggest = "over_alerting_protection"
        elif key == "relativeIncrease":
            suggest = "relative_increase"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2FailureRateAutoDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2FailureRateAutoDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2FailureRateAutoDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 absolute_increase: float,
                 over_alerting_protection: 'outputs.ServiceAnomaliesV2FailureRateAutoDetectionOverAlertingProtection',
                 relative_increase: float):
        """
        :param float absolute_increase: Absolute threshold
        :param 'ServiceAnomaliesV2FailureRateAutoDetectionOverAlertingProtectionArgs' over_alerting_protection: Avoid over-alerting
        :param float relative_increase: Relative threshold
        """
        pulumi.set(__self__, "absolute_increase", absolute_increase)
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "relative_increase", relative_increase)

    @property
    @pulumi.getter(name="absoluteIncrease")
    def absolute_increase(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "absolute_increase")

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.ServiceAnomaliesV2FailureRateAutoDetectionOverAlertingProtection':
        """
        Avoid over-alerting
        """
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter(name="relativeIncrease")
    def relative_increase(self) -> float:
        """
        Relative threshold
        """
        return pulumi.get(self, "relative_increase")


@pulumi.output_type
class ServiceAnomaliesV2FailureRateAutoDetectionOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"
        elif key == "requestsPerMinute":
            suggest = "requests_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2FailureRateAutoDetectionOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2FailureRateAutoDetectionOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2FailureRateAutoDetectionOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_abnormal_state: int,
                 requests_per_minute: float):
        """
        :param int minutes_abnormal_state: Only alert if the abnormal state remains for at least
        :param float requests_per_minute: Only alert if there are at least
        """
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)
        pulumi.set(__self__, "requests_per_minute", requests_per_minute)

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> int:
        """
        Only alert if the abnormal state remains for at least
        """
        return pulumi.get(self, "minutes_abnormal_state")

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> float:
        """
        Only alert if there are at least
        """
        return pulumi.get(self, "requests_per_minute")


@pulumi.output_type
class ServiceAnomaliesV2FailureRateFixedDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overAlertingProtection":
            suggest = "over_alerting_protection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2FailureRateFixedDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2FailureRateFixedDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2FailureRateFixedDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 over_alerting_protection: 'outputs.ServiceAnomaliesV2FailureRateFixedDetectionOverAlertingProtection',
                 sensitivity: str,
                 threshold: float):
        """
        :param 'ServiceAnomaliesV2FailureRateFixedDetectionOverAlertingProtectionArgs' over_alerting_protection: Avoid over-alerting
        :param str sensitivity: Possible Values: `High`, `Low`, `Medium`
        :param float threshold: no documentation available
        """
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.ServiceAnomaliesV2FailureRateFixedDetectionOverAlertingProtection':
        """
        Avoid over-alerting
        """
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        """
        Possible Values: `High`, `Low`, `Medium`
        """
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        no documentation available
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class ServiceAnomaliesV2FailureRateFixedDetectionOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"
        elif key == "requestsPerMinute":
            suggest = "requests_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2FailureRateFixedDetectionOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2FailureRateFixedDetectionOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2FailureRateFixedDetectionOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_abnormal_state: int,
                 requests_per_minute: float):
        """
        :param int minutes_abnormal_state: Only alert if the abnormal state remains for at least
        :param float requests_per_minute: Only alert if there are at least
        """
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)
        pulumi.set(__self__, "requests_per_minute", requests_per_minute)

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> int:
        """
        Only alert if the abnormal state remains for at least
        """
        return pulumi.get(self, "minutes_abnormal_state")

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> float:
        """
        Only alert if there are at least
        """
        return pulumi.get(self, "requests_per_minute")


@pulumi.output_type
class ServiceAnomaliesV2LoadDrops(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadDropPercent":
            suggest = "load_drop_percent"
        elif key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2LoadDrops. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2LoadDrops.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2LoadDrops.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 load_drop_percent: Optional[float] = None,
                 minutes_abnormal_state: Optional[int] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param float load_drop_percent: Threshold
        :param int minutes_abnormal_state: Time span
        """
        pulumi.set(__self__, "enabled", enabled)
        if load_drop_percent is not None:
            pulumi.set(__self__, "load_drop_percent", load_drop_percent)
        if minutes_abnormal_state is not None:
            pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="loadDropPercent")
    def load_drop_percent(self) -> Optional[float]:
        """
        Threshold
        """
        return pulumi.get(self, "load_drop_percent")

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> Optional[int]:
        """
        Time span
        """
        return pulumi.get(self, "minutes_abnormal_state")


@pulumi.output_type
class ServiceAnomaliesV2LoadSpikes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadSpikePercent":
            suggest = "load_spike_percent"
        elif key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2LoadSpikes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2LoadSpikes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2LoadSpikes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 load_spike_percent: Optional[float] = None,
                 minutes_abnormal_state: Optional[int] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param float load_spike_percent: Threshold
        :param int minutes_abnormal_state: Time span
        """
        pulumi.set(__self__, "enabled", enabled)
        if load_spike_percent is not None:
            pulumi.set(__self__, "load_spike_percent", load_spike_percent)
        if minutes_abnormal_state is not None:
            pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="loadSpikePercent")
    def load_spike_percent(self) -> Optional[float]:
        """
        Threshold
        """
        return pulumi.get(self, "load_spike_percent")

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> Optional[int]:
        """
        Time span
        """
        return pulumi.get(self, "minutes_abnormal_state")


@pulumi.output_type
class ServiceAnomaliesV2ResponseTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDetection":
            suggest = "auto_detection"
        elif key == "detectionMode":
            suggest = "detection_mode"
        elif key == "fixedDetection":
            suggest = "fixed_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2ResponseTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2ResponseTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2ResponseTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 auto_detection: Optional['outputs.ServiceAnomaliesV2ResponseTimeAutoDetection'] = None,
                 detection_mode: Optional[str] = None,
                 fixed_detection: Optional['outputs.ServiceAnomaliesV2ResponseTimeFixedDetection'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'ServiceAnomaliesV2ResponseTimeAutoDetectionArgs' auto_detection: no documentation available
        :param str detection_mode: Possible Values: `Auto`, `Fixed`
        :param 'ServiceAnomaliesV2ResponseTimeFixedDetectionArgs' fixed_detection: no documentation available
        """
        pulumi.set(__self__, "enabled", enabled)
        if auto_detection is not None:
            pulumi.set(__self__, "auto_detection", auto_detection)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if fixed_detection is not None:
            pulumi.set(__self__, "fixed_detection", fixed_detection)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="autoDetection")
    def auto_detection(self) -> Optional['outputs.ServiceAnomaliesV2ResponseTimeAutoDetection']:
        """
        no documentation available
        """
        return pulumi.get(self, "auto_detection")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Fixed`
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter(name="fixedDetection")
    def fixed_detection(self) -> Optional['outputs.ServiceAnomaliesV2ResponseTimeFixedDetection']:
        """
        no documentation available
        """
        return pulumi.get(self, "fixed_detection")


@pulumi.output_type
class ServiceAnomaliesV2ResponseTimeAutoDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overAlertingProtection":
            suggest = "over_alerting_protection"
        elif key == "responseTimeAll":
            suggest = "response_time_all"
        elif key == "responseTimeSlowest":
            suggest = "response_time_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2ResponseTimeAutoDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2ResponseTimeAutoDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2ResponseTimeAutoDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 over_alerting_protection: 'outputs.ServiceAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection',
                 response_time_all: 'outputs.ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll',
                 response_time_slowest: 'outputs.ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest'):
        """
        :param 'ServiceAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtectionArgs' over_alerting_protection: Avoid over-alerting
        :param 'ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeAllArgs' response_time_all: Alert if the median response time of all requests degrades beyond **both** the absolute and relative thresholds:
        :param 'ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowestArgs' response_time_slowest: Alert if the response time of the slowest 10% of requests degrades beyond **both** the absolute and relative thresholds:
        """
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "response_time_all", response_time_all)
        pulumi.set(__self__, "response_time_slowest", response_time_slowest)

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.ServiceAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection':
        """
        Avoid over-alerting
        """
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter(name="responseTimeAll")
    def response_time_all(self) -> 'outputs.ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll':
        """
        Alert if the median response time of all requests degrades beyond **both** the absolute and relative thresholds:
        """
        return pulumi.get(self, "response_time_all")

    @property
    @pulumi.getter(name="responseTimeSlowest")
    def response_time_slowest(self) -> 'outputs.ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest':
        """
        Alert if the response time of the slowest 10% of requests degrades beyond **both** the absolute and relative thresholds:
        """
        return pulumi.get(self, "response_time_slowest")


@pulumi.output_type
class ServiceAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"
        elif key == "requestsPerMinute":
            suggest = "requests_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_abnormal_state: int,
                 requests_per_minute: float):
        """
        :param int minutes_abnormal_state: Only alert if the abnormal state remains for at least
        :param float requests_per_minute: Only alert if there are at least
        """
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)
        pulumi.set(__self__, "requests_per_minute", requests_per_minute)

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> int:
        """
        Only alert if the abnormal state remains for at least
        """
        return pulumi.get(self, "minutes_abnormal_state")

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> float:
        """
        Only alert if there are at least
        """
        return pulumi.get(self, "requests_per_minute")


@pulumi.output_type
class ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "degradationMilliseconds":
            suggest = "degradation_milliseconds"
        elif key == "degradationPercent":
            suggest = "degradation_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 degradation_milliseconds: float,
                 degradation_percent: float):
        """
        :param float degradation_milliseconds: Absolute threshold
        :param float degradation_percent: Relative threshold
        """
        pulumi.set(__self__, "degradation_milliseconds", degradation_milliseconds)
        pulumi.set(__self__, "degradation_percent", degradation_percent)

    @property
    @pulumi.getter(name="degradationMilliseconds")
    def degradation_milliseconds(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "degradation_milliseconds")

    @property
    @pulumi.getter(name="degradationPercent")
    def degradation_percent(self) -> float:
        """
        Relative threshold
        """
        return pulumi.get(self, "degradation_percent")


@pulumi.output_type
class ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestDegradationMilliseconds":
            suggest = "slowest_degradation_milliseconds"
        elif key == "slowestDegradationPercent":
            suggest = "slowest_degradation_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slowest_degradation_milliseconds: float,
                 slowest_degradation_percent: float):
        """
        :param float slowest_degradation_milliseconds: Absolute threshold
        :param float slowest_degradation_percent: Relative threshold
        """
        pulumi.set(__self__, "slowest_degradation_milliseconds", slowest_degradation_milliseconds)
        pulumi.set(__self__, "slowest_degradation_percent", slowest_degradation_percent)

    @property
    @pulumi.getter(name="slowestDegradationMilliseconds")
    def slowest_degradation_milliseconds(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "slowest_degradation_milliseconds")

    @property
    @pulumi.getter(name="slowestDegradationPercent")
    def slowest_degradation_percent(self) -> float:
        """
        Relative threshold
        """
        return pulumi.get(self, "slowest_degradation_percent")


@pulumi.output_type
class ServiceAnomaliesV2ResponseTimeFixedDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overAlertingProtection":
            suggest = "over_alerting_protection"
        elif key == "responseTimeAll":
            suggest = "response_time_all"
        elif key == "responseTimeSlowest":
            suggest = "response_time_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2ResponseTimeFixedDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2ResponseTimeFixedDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2ResponseTimeFixedDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 over_alerting_protection: 'outputs.ServiceAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection',
                 response_time_all: 'outputs.ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll',
                 response_time_slowest: 'outputs.ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest',
                 sensitivity: str):
        """
        :param 'ServiceAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtectionArgs' over_alerting_protection: Avoid over-alerting
        :param 'ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeAllArgs' response_time_all: Alert if the median response time of all requests degrades beyond this threshold:
        :param 'ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowestArgs' response_time_slowest: Alert if the response time of the slowest 10% of requests degrades beyond this threshold:
        :param str sensitivity: Possible Values: `High`, `Low`, `Medium`
        """
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "response_time_all", response_time_all)
        pulumi.set(__self__, "response_time_slowest", response_time_slowest)
        pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.ServiceAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection':
        """
        Avoid over-alerting
        """
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter(name="responseTimeAll")
    def response_time_all(self) -> 'outputs.ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll':
        """
        Alert if the median response time of all requests degrades beyond this threshold:
        """
        return pulumi.get(self, "response_time_all")

    @property
    @pulumi.getter(name="responseTimeSlowest")
    def response_time_slowest(self) -> 'outputs.ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest':
        """
        Alert if the response time of the slowest 10% of requests degrades beyond this threshold:
        """
        return pulumi.get(self, "response_time_slowest")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        """
        Possible Values: `High`, `Low`, `Medium`
        """
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class ServiceAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"
        elif key == "requestsPerMinute":
            suggest = "requests_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_abnormal_state: int,
                 requests_per_minute: float):
        """
        :param int minutes_abnormal_state: Only alert if the abnormal state remains for at least
        :param float requests_per_minute: Only alert if there are at least
        """
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)
        pulumi.set(__self__, "requests_per_minute", requests_per_minute)

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> int:
        """
        Only alert if the abnormal state remains for at least
        """
        return pulumi.get(self, "minutes_abnormal_state")

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> float:
        """
        Only alert if there are at least
        """
        return pulumi.get(self, "requests_per_minute")


@pulumi.output_type
class ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "degradationMilliseconds":
            suggest = "degradation_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 degradation_milliseconds: float):
        """
        :param float degradation_milliseconds: Alert if the response time degrades beyond this many ms within an observation period of 5 minutes
        """
        pulumi.set(__self__, "degradation_milliseconds", degradation_milliseconds)

    @property
    @pulumi.getter(name="degradationMilliseconds")
    def degradation_milliseconds(self) -> float:
        """
        Alert if the response time degrades beyond this many ms within an observation period of 5 minutes
        """
        return pulumi.get(self, "degradation_milliseconds")


@pulumi.output_type
class ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestDegradationMilliseconds":
            suggest = "slowest_degradation_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slowest_degradation_milliseconds: float):
        """
        :param float slowest_degradation_milliseconds: Alert if the response time of the slowest 10% degrades beyond this many ms within an observation period of 5 minutes
        """
        pulumi.set(__self__, "slowest_degradation_milliseconds", slowest_degradation_milliseconds)

    @property
    @pulumi.getter(name="slowestDegradationMilliseconds")
    def slowest_degradation_milliseconds(self) -> float:
        """
        Alert if the response time of the slowest 10% degrades beyond this many ms within an observation period of 5 minutes
        """
        return pulumi.get(self, "slowest_degradation_milliseconds")


@pulumi.output_type
class ServiceExternalWebRequestConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.ServiceExternalWebRequestConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.ServiceExternalWebRequestConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ServiceExternalWebRequestConditionsCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compareOperationType":
            suggest = "compare_operation_type"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "intValue":
            suggest = "int_value"
        elif key == "intValues":
            suggest = "int_values"
        elif key == "ipRangeFrom":
            suggest = "ip_range_from"
        elif key == "ipRangeTo":
            suggest = "ip_range_to"
        elif key == "tagValues":
            suggest = "tag_values"
        elif key == "textValues":
            suggest = "text_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestConditionsCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestConditionsCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestConditionsCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 compare_operation_type: str,
                 frameworks: Optional[Sequence[str]] = None,
                 ignore_case: Optional[bool] = None,
                 int_value: Optional[int] = None,
                 int_values: Optional[Sequence[int]] = None,
                 ip_range_from: Optional[str] = None,
                 ip_range_to: Optional[str] = None,
                 tag_values: Optional[Sequence[str]] = None,
                 text_values: Optional[Sequence[str]] = None):
        """
        :param str attribute: Take the value of this attribute
        :param str compare_operation_type: Apply this operation
        :param Sequence[str] frameworks: Technology
        :param bool ignore_case: Ignore case sensitivity for texts.
        :param int int_value: Value
        :param Sequence[int] int_values: Values
        :param str ip_range_from: From
        :param str ip_range_to: To
        :param Sequence[str] tag_values: If multiple values are specified, at least one of them must match for the condition to match
        :param Sequence[str] text_values: If multiple values are specified, at least one of them must match for the condition to match
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "compare_operation_type", compare_operation_type)
        if frameworks is not None:
            pulumi.set(__self__, "frameworks", frameworks)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if int_value is not None:
            pulumi.set(__self__, "int_value", int_value)
        if int_values is not None:
            pulumi.set(__self__, "int_values", int_values)
        if ip_range_from is not None:
            pulumi.set(__self__, "ip_range_from", ip_range_from)
        if ip_range_to is not None:
            pulumi.set(__self__, "ip_range_to", ip_range_to)
        if tag_values is not None:
            pulumi.set(__self__, "tag_values", tag_values)
        if text_values is not None:
            pulumi.set(__self__, "text_values", text_values)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        Take the value of this attribute
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="compareOperationType")
    def compare_operation_type(self) -> str:
        """
        Apply this operation
        """
        return pulumi.get(self, "compare_operation_type")

    @property
    @pulumi.getter
    def frameworks(self) -> Optional[Sequence[str]]:
        """
        Technology
        """
        return pulumi.get(self, "frameworks")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Ignore case sensitivity for texts.
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="intValue")
    def int_value(self) -> Optional[int]:
        """
        Value
        """
        return pulumi.get(self, "int_value")

    @property
    @pulumi.getter(name="intValues")
    def int_values(self) -> Optional[Sequence[int]]:
        """
        Values
        """
        return pulumi.get(self, "int_values")

    @property
    @pulumi.getter(name="ipRangeFrom")
    def ip_range_from(self) -> Optional[str]:
        """
        From
        """
        return pulumi.get(self, "ip_range_from")

    @property
    @pulumi.getter(name="ipRangeTo")
    def ip_range_to(self) -> Optional[str]:
        """
        To
        """
        return pulumi.get(self, "ip_range_to")

    @property
    @pulumi.getter(name="tagValues")
    def tag_values(self) -> Optional[Sequence[str]]:
        """
        If multiple values are specified, at least one of them must match for the condition to match
        """
        return pulumi.get(self, "tag_values")

    @property
    @pulumi.getter(name="textValues")
    def text_values(self) -> Optional[Sequence[str]]:
        """
        If multiple values are specified, at least one of them must match for the condition to match
        """
        return pulumi.get(self, "text_values")


@pulumi.output_type
class ServiceExternalWebRequestIdContributors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "contextRoot":
            suggest = "context_root"
        elif key == "portForServiceId":
            suggest = "port_for_service_id"
        elif key == "publicDomainName":
            suggest = "public_domain_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: 'outputs.ServiceExternalWebRequestIdContributorsApplicationId',
                 context_root: 'outputs.ServiceExternalWebRequestIdContributorsContextRoot',
                 port_for_service_id: bool,
                 public_domain_name: 'outputs.ServiceExternalWebRequestIdContributorsPublicDomainName'):
        """
        :param 'ServiceExternalWebRequestIdContributorsApplicationIdArgs' application_id: Application identifier
        :param 'ServiceExternalWebRequestIdContributorsContextRootArgs' context_root: URL context root
        :param bool port_for_service_id: Let the port contribute to the Service Id
        :param 'ServiceExternalWebRequestIdContributorsPublicDomainNameArgs' public_domain_name: Public domain name
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "context_root", context_root)
        pulumi.set(__self__, "port_for_service_id", port_for_service_id)
        pulumi.set(__self__, "public_domain_name", public_domain_name)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> 'outputs.ServiceExternalWebRequestIdContributorsApplicationId':
        """
        Application identifier
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="contextRoot")
    def context_root(self) -> 'outputs.ServiceExternalWebRequestIdContributorsContextRoot':
        """
        URL context root
        """
        return pulumi.get(self, "context_root")

    @property
    @pulumi.getter(name="portForServiceId")
    def port_for_service_id(self) -> bool:
        """
        Let the port contribute to the Service Id
        """
        return pulumi.get(self, "port_for_service_id")

    @property
    @pulumi.getter(name="publicDomainName")
    def public_domain_name(self) -> 'outputs.ServiceExternalWebRequestIdContributorsPublicDomainName':
        """
        Public domain name
        """
        return pulumi.get(self, "public_domain_name")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsApplicationId(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributorsApplicationId. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributorsApplicationId.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributorsApplicationId.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributor'] = None):
        """
        :param bool enable_id_contributor: Transform this value before letting it contribute to the Service Id
        :param 'ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorArgs' service_id_contributor: no documentation available
        """
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        """
        Transform this value before letting it contribute to the Service Id
        """
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributor']:
        """
        no documentation available
        """
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 transformations: Optional['outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride'] = None):
        """
        :param str contribution_type: Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
        :param 'ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsArgs' transformations: Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        :param 'ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorValueOverrideArgs' value_override: The value to be used instead of the detected value.
        """
        pulumi.set(__self__, "contribution_type", contribution_type)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        """
        Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
        """
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformations']:
        """
        Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        """
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride']:
        """
        The value to be used instead of the detected value.
        """
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "selectIndex":
            suggest = "select_index"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "takeFromEnd":
            suggest = "take_from_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 segment_count: Optional[int] = None,
                 select_index: Optional[int] = None,
                 split_delimiter: Optional[str] = None,
                 suffix: Optional[str] = None,
                 take_from_end: Optional[bool] = None):
        """
        :param str transformation_type: Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
        :param bool include_hex_numbers: include hexadecimal numbers
        :param int min_digit_count: min digit count
        :param str prefix: no documentation available
        :param str replacement_value: replacement
        :param int segment_count: How many segments should be taken.
        :param int select_index: select index
        :param str split_delimiter: split by
        :param str suffix: no documentation available
        :param bool take_from_end: take from end
        """
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if select_index is not None:
            pulumi.set(__self__, "select_index", select_index)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if take_from_end is not None:
            pulumi.set(__self__, "take_from_end", take_from_end)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        """
        Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
        """
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        """
        include hexadecimal numbers
        """
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        """
        min digit count
        """
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        """
        replacement
        """
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        """
        How many segments should be taken.
        """
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter(name="selectIndex")
    def select_index(self) -> Optional[int]:
        """
        select index
        """
        return pulumi.get(self, "select_index")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        """
        split by
        """
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="takeFromEnd")
    def take_from_end(self) -> Optional[bool]:
        """
        take from end
        """
        return pulumi.get(self, "take_from_end")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        """
        :param str value: no documentation available
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsContextRoot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributorsContextRoot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributorsContextRoot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributorsContextRoot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributor'] = None):
        """
        :param bool enable_id_contributor: Transform this value before letting it contribute to the Service Id
        :param 'ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorArgs' service_id_contributor: no documentation available
        """
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        """
        Transform this value before letting it contribute to the Service Id
        """
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributor']:
        """
        no documentation available
        """
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsContextRootServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributorsContextRootServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributorsContextRootServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributorsContextRootServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 segment_count: Optional[int] = None,
                 transformations: Optional['outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorValueOverride'] = None):
        """
        :param str contribution_type: Possible Values: `OriginalValue`, `OverrideValue`, `TransformURL`, `TransformValue`
        :param int segment_count: The number of segments of the URL to be kept. The URL is divided by slashes (/), the indexing starts with 1 at context root. For example, if you specify 2 for the `www.dynatrace.com/support/help/dynatrace-api/` URL, the value of `support/help` is used.
        :param 'ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformationsArgs' transformations: Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        :param 'ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorValueOverrideArgs' value_override: The value to be used instead of the detected value.
        """
        pulumi.set(__self__, "contribution_type", contribution_type)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        """
        Possible Values: `OriginalValue`, `OverrideValue`, `TransformURL`, `TransformValue`
        """
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        """
        The number of segments of the URL to be kept. The URL is divided by slashes (/), the indexing starts with 1 at context root. For example, if you specify 2 for the `www.dynatrace.com/support/help/dynatrace-api/` URL, the value of `support/help` is used.
        """
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformations']:
        """
        Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        """
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorValueOverride']:
        """
        The value to be used instead of the detected value.
        """
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 suffix: Optional[str] = None):
        """
        :param str transformation_type: Possible Values: `BEFORE`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`
        :param bool include_hex_numbers: include hexadecimal numbers
        :param int min_digit_count: min digit count
        :param str prefix: no documentation available
        :param str replacement_value: replacement
        :param str suffix: no documentation available
        """
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        """
        Possible Values: `BEFORE`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`
        """
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        """
        include hexadecimal numbers
        """
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        """
        min digit count
        """
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        """
        replacement
        """
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        """
        :param str value: no documentation available
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsPublicDomainName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributorsPublicDomainName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributorsPublicDomainName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributorsPublicDomainName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributor'] = None):
        """
        :param bool enable_id_contributor: Transform this value before letting it contribute to the Service Id
        :param 'ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorArgs' service_id_contributor: no documentation available
        """
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        """
        Transform this value before letting it contribute to the Service Id
        """
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributor']:
        """
        no documentation available
        """
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "copyFromHostName":
            suggest = "copy_from_host_name"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 copy_from_host_name: Optional[bool] = None,
                 transformations: Optional['outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorValueOverride'] = None):
        """
        :param str contribution_type: Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
        :param bool copy_from_host_name: Use the detected host name instead of the request's domain name.
        :param 'ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformationsArgs' transformations: Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        :param 'ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorValueOverrideArgs' value_override: The value to be used instead of the detected value.
        """
        pulumi.set(__self__, "contribution_type", contribution_type)
        if copy_from_host_name is not None:
            pulumi.set(__self__, "copy_from_host_name", copy_from_host_name)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        """
        Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
        """
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter(name="copyFromHostName")
    def copy_from_host_name(self) -> Optional[bool]:
        """
        Use the detected host name instead of the request's domain name.
        """
        return pulumi.get(self, "copy_from_host_name")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformations']:
        """
        Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        """
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorValueOverride']:
        """
        The value to be used instead of the detected value.
        """
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "selectIndex":
            suggest = "select_index"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "takeFromEnd":
            suggest = "take_from_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 segment_count: Optional[int] = None,
                 select_index: Optional[int] = None,
                 split_delimiter: Optional[str] = None,
                 suffix: Optional[str] = None,
                 take_from_end: Optional[bool] = None):
        """
        :param str transformation_type: Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
        :param bool include_hex_numbers: include hexadecimal numbers
        :param int min_digit_count: min digit count
        :param str prefix: no documentation available
        :param str replacement_value: replacement
        :param int segment_count: How many segments should be taken.
        :param int select_index: select index
        :param str split_delimiter: split by
        :param str suffix: no documentation available
        :param bool take_from_end: take from end
        """
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if select_index is not None:
            pulumi.set(__self__, "select_index", select_index)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if take_from_end is not None:
            pulumi.set(__self__, "take_from_end", take_from_end)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        """
        Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
        """
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        """
        include hexadecimal numbers
        """
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        """
        min digit count
        """
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        """
        replacement
        """
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        """
        How many segments should be taken.
        """
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter(name="selectIndex")
    def select_index(self) -> Optional[int]:
        """
        select index
        """
        return pulumi.get(self, "select_index")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        """
        split by
        """
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="takeFromEnd")
    def take_from_end(self) -> Optional[bool]:
        """
        take from end
        """
        return pulumi.get(self, "take_from_end")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        """
        :param str value: no documentation available
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceExternalWebServiceConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.ServiceExternalWebServiceConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.ServiceExternalWebServiceConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ServiceExternalWebServiceConditionsCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compareOperationType":
            suggest = "compare_operation_type"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "intValue":
            suggest = "int_value"
        elif key == "intValues":
            suggest = "int_values"
        elif key == "ipRangeFrom":
            suggest = "ip_range_from"
        elif key == "ipRangeTo":
            suggest = "ip_range_to"
        elif key == "tagValues":
            suggest = "tag_values"
        elif key == "textValues":
            suggest = "text_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebServiceConditionsCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebServiceConditionsCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebServiceConditionsCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 compare_operation_type: str,
                 frameworks: Optional[Sequence[str]] = None,
                 ignore_case: Optional[bool] = None,
                 int_value: Optional[int] = None,
                 int_values: Optional[Sequence[int]] = None,
                 ip_range_from: Optional[str] = None,
                 ip_range_to: Optional[str] = None,
                 tag_values: Optional[Sequence[str]] = None,
                 text_values: Optional[Sequence[str]] = None):
        """
        :param str attribute: Take the value of this attribute
        :param str compare_operation_type: Apply this operation
        :param Sequence[str] frameworks: Technology
        :param bool ignore_case: Ignore case sensitivity for texts.
        :param int int_value: Value
        :param Sequence[int] int_values: Values
        :param str ip_range_from: From
        :param str ip_range_to: To
        :param Sequence[str] tag_values: If multiple values are specified, at least one of them must match for the condition to match
        :param Sequence[str] text_values: If multiple values are specified, at least one of them must match for the condition to match
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "compare_operation_type", compare_operation_type)
        if frameworks is not None:
            pulumi.set(__self__, "frameworks", frameworks)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if int_value is not None:
            pulumi.set(__self__, "int_value", int_value)
        if int_values is not None:
            pulumi.set(__self__, "int_values", int_values)
        if ip_range_from is not None:
            pulumi.set(__self__, "ip_range_from", ip_range_from)
        if ip_range_to is not None:
            pulumi.set(__self__, "ip_range_to", ip_range_to)
        if tag_values is not None:
            pulumi.set(__self__, "tag_values", tag_values)
        if text_values is not None:
            pulumi.set(__self__, "text_values", text_values)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        Take the value of this attribute
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="compareOperationType")
    def compare_operation_type(self) -> str:
        """
        Apply this operation
        """
        return pulumi.get(self, "compare_operation_type")

    @property
    @pulumi.getter
    def frameworks(self) -> Optional[Sequence[str]]:
        """
        Technology
        """
        return pulumi.get(self, "frameworks")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Ignore case sensitivity for texts.
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="intValue")
    def int_value(self) -> Optional[int]:
        """
        Value
        """
        return pulumi.get(self, "int_value")

    @property
    @pulumi.getter(name="intValues")
    def int_values(self) -> Optional[Sequence[int]]:
        """
        Values
        """
        return pulumi.get(self, "int_values")

    @property
    @pulumi.getter(name="ipRangeFrom")
    def ip_range_from(self) -> Optional[str]:
        """
        From
        """
        return pulumi.get(self, "ip_range_from")

    @property
    @pulumi.getter(name="ipRangeTo")
    def ip_range_to(self) -> Optional[str]:
        """
        To
        """
        return pulumi.get(self, "ip_range_to")

    @property
    @pulumi.getter(name="tagValues")
    def tag_values(self) -> Optional[Sequence[str]]:
        """
        If multiple values are specified, at least one of them must match for the condition to match
        """
        return pulumi.get(self, "tag_values")

    @property
    @pulumi.getter(name="textValues")
    def text_values(self) -> Optional[Sequence[str]]:
        """
        If multiple values are specified, at least one of them must match for the condition to match
        """
        return pulumi.get(self, "text_values")


@pulumi.output_type
class ServiceExternalWebServiceIdContributors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectAsWebRequestService":
            suggest = "detect_as_web_request_service"
        elif key == "portForServiceId":
            suggest = "port_for_service_id"
        elif key == "urlPath":
            suggest = "url_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebServiceIdContributors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebServiceIdContributors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebServiceIdContributors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 detect_as_web_request_service: bool,
                 port_for_service_id: Optional[bool] = None,
                 url_path: Optional['outputs.ServiceExternalWebServiceIdContributorsUrlPath'] = None):
        """
        :param bool detect_as_web_request_service: Detect the matching requests as web request services instead of web services.
        :param bool port_for_service_id: Let the port contribute to the Service Id
        :param 'ServiceExternalWebServiceIdContributorsUrlPathArgs' url_path: URL path
        """
        pulumi.set(__self__, "detect_as_web_request_service", detect_as_web_request_service)
        if port_for_service_id is not None:
            pulumi.set(__self__, "port_for_service_id", port_for_service_id)
        if url_path is not None:
            pulumi.set(__self__, "url_path", url_path)

    @property
    @pulumi.getter(name="detectAsWebRequestService")
    def detect_as_web_request_service(self) -> bool:
        """
        Detect the matching requests as web request services instead of web services.
        """
        return pulumi.get(self, "detect_as_web_request_service")

    @property
    @pulumi.getter(name="portForServiceId")
    def port_for_service_id(self) -> Optional[bool]:
        """
        Let the port contribute to the Service Id
        """
        return pulumi.get(self, "port_for_service_id")

    @property
    @pulumi.getter(name="urlPath")
    def url_path(self) -> Optional['outputs.ServiceExternalWebServiceIdContributorsUrlPath']:
        """
        URL path
        """
        return pulumi.get(self, "url_path")


@pulumi.output_type
class ServiceExternalWebServiceIdContributorsUrlPath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebServiceIdContributorsUrlPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebServiceIdContributorsUrlPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebServiceIdContributorsUrlPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributor'] = None):
        """
        :param bool enable_id_contributor: Transform this value before letting it contribute to the Service Id
        :param 'ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorArgs' service_id_contributor: no documentation available
        """
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        """
        Transform this value before letting it contribute to the Service Id
        """
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributor']:
        """
        no documentation available
        """
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 transformations: Optional['outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorValueOverride'] = None):
        """
        :param str contribution_type: Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
        :param 'ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformationsArgs' transformations: Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        :param 'ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorValueOverrideArgs' value_override: The value to be used instead of the detected value.
        """
        pulumi.set(__self__, "contribution_type", contribution_type)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        """
        Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
        """
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformations']:
        """
        Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        """
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorValueOverride']:
        """
        The value to be used instead of the detected value.
        """
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "selectIndex":
            suggest = "select_index"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "takeFromEnd":
            suggest = "take_from_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 segment_count: Optional[int] = None,
                 select_index: Optional[int] = None,
                 split_delimiter: Optional[str] = None,
                 suffix: Optional[str] = None,
                 take_from_end: Optional[bool] = None):
        """
        :param str transformation_type: Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
        :param bool include_hex_numbers: include hexadecimal numbers
        :param int min_digit_count: min digit count
        :param str prefix: no documentation available
        :param str replacement_value: replacement
        :param int segment_count: How many segments should be taken.
        :param int select_index: select index
        :param str split_delimiter: split by
        :param str suffix: no documentation available
        :param bool take_from_end: take from end
        """
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if select_index is not None:
            pulumi.set(__self__, "select_index", select_index)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if take_from_end is not None:
            pulumi.set(__self__, "take_from_end", take_from_end)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        """
        Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
        """
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        """
        include hexadecimal numbers
        """
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        """
        min digit count
        """
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        """
        replacement
        """
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        """
        How many segments should be taken.
        """
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter(name="selectIndex")
    def select_index(self) -> Optional[int]:
        """
        select index
        """
        return pulumi.get(self, "select_index")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        """
        split by
        """
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="takeFromEnd")
    def take_from_end(self) -> Optional[bool]:
        """
        take from end
        """
        return pulumi.get(self, "take_from_end")


@pulumi.output_type
class ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        """
        :param str value: no documentation available
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceFailureExceptionRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreAllExceptions":
            suggest = "ignore_all_exceptions"
        elif key == "ignoreSpanFailureDetection":
            suggest = "ignore_span_failure_detection"
        elif key == "customErrorRules":
            suggest = "custom_error_rules"
        elif key == "customHandledExceptions":
            suggest = "custom_handled_exceptions"
        elif key == "ignoredExceptions":
            suggest = "ignored_exceptions"
        elif key == "successForcingExceptions":
            suggest = "success_forcing_exceptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ignore_all_exceptions: bool,
                 ignore_span_failure_detection: bool,
                 custom_error_rules: Optional['outputs.ServiceFailureExceptionRulesCustomErrorRules'] = None,
                 custom_handled_exceptions: Optional['outputs.ServiceFailureExceptionRulesCustomHandledExceptions'] = None,
                 ignored_exceptions: Optional['outputs.ServiceFailureExceptionRulesIgnoredExceptions'] = None,
                 success_forcing_exceptions: Optional['outputs.ServiceFailureExceptionRulesSuccessForcingExceptions'] = None):
        """
        :param bool ignore_all_exceptions: Ignore all exceptions
        :param bool ignore_span_failure_detection: Ignore span failure detection
        :param 'ServiceFailureExceptionRulesCustomErrorRulesArgs' custom_error_rules: Some custom error situations are only detectable via a return value or other means. To support such cases, [define a request attribute](https://dt-url.net/ys5k0p4y) that captures the required data. Then define a custom error rule that determines if the request has failed based on the value of the request attribute.
        :param 'ServiceFailureExceptionRulesCustomHandledExceptionsArgs' custom_handled_exceptions: There may be situations where your application code handles exceptions gracefully in a manner that these failures aren't detected by Dynatrace. Use this setting to define specific gracefully-handled exceptions that should be treated as service failures.
        :param 'ServiceFailureExceptionRulesIgnoredExceptionsArgs' ignored_exceptions: Some exceptions that are thrown by legacy or 3rd-party code indicate a specific response, not an error. Use this setting to instruct Dynatrace to treat such exceptions as non-failed requests.. If an exception matching any of the defined patterns occurs in a request, it will not be considered as a failure. Other exceptions occurring at the same request might still mark the request as failed.
        :param 'ServiceFailureExceptionRulesSuccessForcingExceptionsArgs' success_forcing_exceptions: Define exceptions which indicate that a service call should not be considered as failed. E.g. an exception indicating that the client aborted the operation.. If an exception matching any of the defined patterns occurs on the entry node of the service, it will be considered successful. Compared to ignored exceptions, the request will be considered successful even if other exceptions occur in the same request.
        """
        pulumi.set(__self__, "ignore_all_exceptions", ignore_all_exceptions)
        pulumi.set(__self__, "ignore_span_failure_detection", ignore_span_failure_detection)
        if custom_error_rules is not None:
            pulumi.set(__self__, "custom_error_rules", custom_error_rules)
        if custom_handled_exceptions is not None:
            pulumi.set(__self__, "custom_handled_exceptions", custom_handled_exceptions)
        if ignored_exceptions is not None:
            pulumi.set(__self__, "ignored_exceptions", ignored_exceptions)
        if success_forcing_exceptions is not None:
            pulumi.set(__self__, "success_forcing_exceptions", success_forcing_exceptions)

    @property
    @pulumi.getter(name="ignoreAllExceptions")
    def ignore_all_exceptions(self) -> bool:
        """
        Ignore all exceptions
        """
        return pulumi.get(self, "ignore_all_exceptions")

    @property
    @pulumi.getter(name="ignoreSpanFailureDetection")
    def ignore_span_failure_detection(self) -> bool:
        """
        Ignore span failure detection
        """
        return pulumi.get(self, "ignore_span_failure_detection")

    @property
    @pulumi.getter(name="customErrorRules")
    def custom_error_rules(self) -> Optional['outputs.ServiceFailureExceptionRulesCustomErrorRules']:
        """
        Some custom error situations are only detectable via a return value or other means. To support such cases, [define a request attribute](https://dt-url.net/ys5k0p4y) that captures the required data. Then define a custom error rule that determines if the request has failed based on the value of the request attribute.
        """
        return pulumi.get(self, "custom_error_rules")

    @property
    @pulumi.getter(name="customHandledExceptions")
    def custom_handled_exceptions(self) -> Optional['outputs.ServiceFailureExceptionRulesCustomHandledExceptions']:
        """
        There may be situations where your application code handles exceptions gracefully in a manner that these failures aren't detected by Dynatrace. Use this setting to define specific gracefully-handled exceptions that should be treated as service failures.
        """
        return pulumi.get(self, "custom_handled_exceptions")

    @property
    @pulumi.getter(name="ignoredExceptions")
    def ignored_exceptions(self) -> Optional['outputs.ServiceFailureExceptionRulesIgnoredExceptions']:
        """
        Some exceptions that are thrown by legacy or 3rd-party code indicate a specific response, not an error. Use this setting to instruct Dynatrace to treat such exceptions as non-failed requests.. If an exception matching any of the defined patterns occurs in a request, it will not be considered as a failure. Other exceptions occurring at the same request might still mark the request as failed.
        """
        return pulumi.get(self, "ignored_exceptions")

    @property
    @pulumi.getter(name="successForcingExceptions")
    def success_forcing_exceptions(self) -> Optional['outputs.ServiceFailureExceptionRulesSuccessForcingExceptions']:
        """
        Define exceptions which indicate that a service call should not be considered as failed. E.g. an exception indicating that the client aborted the operation.. If an exception matching any of the defined patterns occurs on the entry node of the service, it will be considered successful. Compared to ignored exceptions, the request will be considered successful even if other exceptions occur in the same request.
        """
        return pulumi.get(self, "success_forcing_exceptions")


@pulumi.output_type
class ServiceFailureExceptionRulesCustomErrorRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customErrorRules":
            suggest = "custom_error_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRulesCustomErrorRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRulesCustomErrorRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRulesCustomErrorRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_error_rules: Sequence['outputs.ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRule']):
        pulumi.set(__self__, "custom_error_rules", custom_error_rules)

    @property
    @pulumi.getter(name="customErrorRules")
    def custom_error_rules(self) -> Sequence['outputs.ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRule']:
        return pulumi.get(self, "custom_error_rules")


@pulumi.output_type
class ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: 'outputs.ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRuleCondition',
                 request_attribute: str):
        """
        :param 'ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRuleConditionArgs' condition: Request attribute condition
        :param str request_attribute: Request attribute
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "request_attribute", request_attribute)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRuleCondition':
        """
        Request attribute condition
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> str:
        """
        Request attribute
        """
        return pulumi.get(self, "request_attribute")


@pulumi.output_type
class ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compareOperationType":
            suggest = "compare_operation_type"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "doubleValue":
            suggest = "double_value"
        elif key == "intValue":
            suggest = "int_value"
        elif key == "textValue":
            suggest = "text_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compare_operation_type: str,
                 case_sensitive: Optional[bool] = None,
                 double_value: Optional[float] = None,
                 int_value: Optional[int] = None,
                 text_value: Optional[str] = None):
        """
        :param str compare_operation_type: Apply this comparison
        :param bool case_sensitive: Case sensitive
        :param float double_value: Value
        :param int int_value: Value
        :param str text_value: Value
        """
        pulumi.set(__self__, "compare_operation_type", compare_operation_type)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int_value is not None:
            pulumi.set(__self__, "int_value", int_value)
        if text_value is not None:
            pulumi.set(__self__, "text_value", text_value)

    @property
    @pulumi.getter(name="compareOperationType")
    def compare_operation_type(self) -> str:
        """
        Apply this comparison
        """
        return pulumi.get(self, "compare_operation_type")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        Case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[float]:
        """
        Value
        """
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="intValue")
    def int_value(self) -> Optional[int]:
        """
        Value
        """
        return pulumi.get(self, "int_value")

    @property
    @pulumi.getter(name="textValue")
    def text_value(self) -> Optional[str]:
        """
        Value
        """
        return pulumi.get(self, "text_value")


@pulumi.output_type
class ServiceFailureExceptionRulesCustomHandledExceptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHandledExceptions":
            suggest = "custom_handled_exceptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRulesCustomHandledExceptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRulesCustomHandledExceptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRulesCustomHandledExceptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_handled_exceptions: Sequence['outputs.ServiceFailureExceptionRulesCustomHandledExceptionsCustomHandledException']):
        pulumi.set(__self__, "custom_handled_exceptions", custom_handled_exceptions)

    @property
    @pulumi.getter(name="customHandledExceptions")
    def custom_handled_exceptions(self) -> Sequence['outputs.ServiceFailureExceptionRulesCustomHandledExceptionsCustomHandledException']:
        return pulumi.get(self, "custom_handled_exceptions")


@pulumi.output_type
class ServiceFailureExceptionRulesCustomHandledExceptionsCustomHandledException(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPattern":
            suggest = "class_pattern"
        elif key == "messagePattern":
            suggest = "message_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRulesCustomHandledExceptionsCustomHandledException. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRulesCustomHandledExceptionsCustomHandledException.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRulesCustomHandledExceptionsCustomHandledException.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_pattern: Optional[str] = None,
                 message_pattern: Optional[str] = None):
        """
        :param str class_pattern: The pattern will match if it is contained within the actual class name.
        :param str message_pattern: Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
        """
        if class_pattern is not None:
            pulumi.set(__self__, "class_pattern", class_pattern)
        if message_pattern is not None:
            pulumi.set(__self__, "message_pattern", message_pattern)

    @property
    @pulumi.getter(name="classPattern")
    def class_pattern(self) -> Optional[str]:
        """
        The pattern will match if it is contained within the actual class name.
        """
        return pulumi.get(self, "class_pattern")

    @property
    @pulumi.getter(name="messagePattern")
    def message_pattern(self) -> Optional[str]:
        """
        Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
        """
        return pulumi.get(self, "message_pattern")


@pulumi.output_type
class ServiceFailureExceptionRulesIgnoredExceptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHandledExceptions":
            suggest = "custom_handled_exceptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRulesIgnoredExceptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRulesIgnoredExceptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRulesIgnoredExceptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_handled_exceptions: Sequence['outputs.ServiceFailureExceptionRulesIgnoredExceptionsCustomHandledException']):
        pulumi.set(__self__, "custom_handled_exceptions", custom_handled_exceptions)

    @property
    @pulumi.getter(name="customHandledExceptions")
    def custom_handled_exceptions(self) -> Sequence['outputs.ServiceFailureExceptionRulesIgnoredExceptionsCustomHandledException']:
        return pulumi.get(self, "custom_handled_exceptions")


@pulumi.output_type
class ServiceFailureExceptionRulesIgnoredExceptionsCustomHandledException(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPattern":
            suggest = "class_pattern"
        elif key == "messagePattern":
            suggest = "message_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRulesIgnoredExceptionsCustomHandledException. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRulesIgnoredExceptionsCustomHandledException.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRulesIgnoredExceptionsCustomHandledException.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_pattern: Optional[str] = None,
                 message_pattern: Optional[str] = None):
        """
        :param str class_pattern: The pattern will match if it is contained within the actual class name.
        :param str message_pattern: Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
        """
        if class_pattern is not None:
            pulumi.set(__self__, "class_pattern", class_pattern)
        if message_pattern is not None:
            pulumi.set(__self__, "message_pattern", message_pattern)

    @property
    @pulumi.getter(name="classPattern")
    def class_pattern(self) -> Optional[str]:
        """
        The pattern will match if it is contained within the actual class name.
        """
        return pulumi.get(self, "class_pattern")

    @property
    @pulumi.getter(name="messagePattern")
    def message_pattern(self) -> Optional[str]:
        """
        Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
        """
        return pulumi.get(self, "message_pattern")


@pulumi.output_type
class ServiceFailureExceptionRulesSuccessForcingExceptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHandledExceptions":
            suggest = "custom_handled_exceptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRulesSuccessForcingExceptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRulesSuccessForcingExceptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRulesSuccessForcingExceptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_handled_exceptions: Sequence['outputs.ServiceFailureExceptionRulesSuccessForcingExceptionsCustomHandledException']):
        pulumi.set(__self__, "custom_handled_exceptions", custom_handled_exceptions)

    @property
    @pulumi.getter(name="customHandledExceptions")
    def custom_handled_exceptions(self) -> Sequence['outputs.ServiceFailureExceptionRulesSuccessForcingExceptionsCustomHandledException']:
        return pulumi.get(self, "custom_handled_exceptions")


@pulumi.output_type
class ServiceFailureExceptionRulesSuccessForcingExceptionsCustomHandledException(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPattern":
            suggest = "class_pattern"
        elif key == "messagePattern":
            suggest = "message_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRulesSuccessForcingExceptionsCustomHandledException. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRulesSuccessForcingExceptionsCustomHandledException.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRulesSuccessForcingExceptionsCustomHandledException.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_pattern: Optional[str] = None,
                 message_pattern: Optional[str] = None):
        """
        :param str class_pattern: The pattern will match if it is contained within the actual class name.
        :param str message_pattern: Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
        """
        if class_pattern is not None:
            pulumi.set(__self__, "class_pattern", class_pattern)
        if message_pattern is not None:
            pulumi.set(__self__, "message_pattern", message_pattern)

    @property
    @pulumi.getter(name="classPattern")
    def class_pattern(self) -> Optional[str]:
        """
        The pattern will match if it is contained within the actual class name.
        """
        return pulumi.get(self, "class_pattern")

    @property
    @pulumi.getter(name="messagePattern")
    def message_pattern(self) -> Optional[str]:
        """
        Optionally, define an exception message pattern. The pattern will match if the actual exception message contains the pattern.
        """
        return pulumi.get(self, "message_pattern")


@pulumi.output_type
class ServiceFullWebRequestConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.ServiceFullWebRequestConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.ServiceFullWebRequestConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ServiceFullWebRequestConditionsCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compareOperationType":
            suggest = "compare_operation_type"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "intValue":
            suggest = "int_value"
        elif key == "intValues":
            suggest = "int_values"
        elif key == "ipRangeFrom":
            suggest = "ip_range_from"
        elif key == "ipRangeTo":
            suggest = "ip_range_to"
        elif key == "tagValues":
            suggest = "tag_values"
        elif key == "textValues":
            suggest = "text_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestConditionsCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestConditionsCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestConditionsCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 compare_operation_type: str,
                 frameworks: Optional[Sequence[str]] = None,
                 ignore_case: Optional[bool] = None,
                 int_value: Optional[int] = None,
                 int_values: Optional[Sequence[int]] = None,
                 ip_range_from: Optional[str] = None,
                 ip_range_to: Optional[str] = None,
                 tag_values: Optional[Sequence[str]] = None,
                 text_values: Optional[Sequence[str]] = None):
        """
        :param str attribute: Take the value of this attribute
        :param str compare_operation_type: Apply this operation
        :param Sequence[str] frameworks: Technology
        :param bool ignore_case: Ignore case sensitivity for texts.
        :param int int_value: Value
        :param Sequence[int] int_values: Values
        :param str ip_range_from: From
        :param str ip_range_to: To
        :param Sequence[str] tag_values: If multiple values are specified, at least one of them must match for the condition to match
        :param Sequence[str] text_values: If multiple values are specified, at least one of them must match for the condition to match
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "compare_operation_type", compare_operation_type)
        if frameworks is not None:
            pulumi.set(__self__, "frameworks", frameworks)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if int_value is not None:
            pulumi.set(__self__, "int_value", int_value)
        if int_values is not None:
            pulumi.set(__self__, "int_values", int_values)
        if ip_range_from is not None:
            pulumi.set(__self__, "ip_range_from", ip_range_from)
        if ip_range_to is not None:
            pulumi.set(__self__, "ip_range_to", ip_range_to)
        if tag_values is not None:
            pulumi.set(__self__, "tag_values", tag_values)
        if text_values is not None:
            pulumi.set(__self__, "text_values", text_values)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        Take the value of this attribute
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="compareOperationType")
    def compare_operation_type(self) -> str:
        """
        Apply this operation
        """
        return pulumi.get(self, "compare_operation_type")

    @property
    @pulumi.getter
    def frameworks(self) -> Optional[Sequence[str]]:
        """
        Technology
        """
        return pulumi.get(self, "frameworks")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Ignore case sensitivity for texts.
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="intValue")
    def int_value(self) -> Optional[int]:
        """
        Value
        """
        return pulumi.get(self, "int_value")

    @property
    @pulumi.getter(name="intValues")
    def int_values(self) -> Optional[Sequence[int]]:
        """
        Values
        """
        return pulumi.get(self, "int_values")

    @property
    @pulumi.getter(name="ipRangeFrom")
    def ip_range_from(self) -> Optional[str]:
        """
        From
        """
        return pulumi.get(self, "ip_range_from")

    @property
    @pulumi.getter(name="ipRangeTo")
    def ip_range_to(self) -> Optional[str]:
        """
        To
        """
        return pulumi.get(self, "ip_range_to")

    @property
    @pulumi.getter(name="tagValues")
    def tag_values(self) -> Optional[Sequence[str]]:
        """
        If multiple values are specified, at least one of them must match for the condition to match
        """
        return pulumi.get(self, "tag_values")

    @property
    @pulumi.getter(name="textValues")
    def text_values(self) -> Optional[Sequence[str]]:
        """
        If multiple values are specified, at least one of them must match for the condition to match
        """
        return pulumi.get(self, "text_values")


@pulumi.output_type
class ServiceFullWebRequestIdContributors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "contextRoot":
            suggest = "context_root"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: 'outputs.ServiceFullWebRequestIdContributorsApplicationId',
                 context_root: 'outputs.ServiceFullWebRequestIdContributorsContextRoot',
                 server_name: 'outputs.ServiceFullWebRequestIdContributorsServerName'):
        """
        :param 'ServiceFullWebRequestIdContributorsApplicationIdArgs' application_id: Application identifier
        :param 'ServiceFullWebRequestIdContributorsContextRootArgs' context_root: The context root is the first segment of the request URL after the Server name. For example, in the `www.dynatrace.com/support/help/dynatrace-api/` URL the context root is `/support`. The context root value can be found on the **Service overview page** under **Properties and tags**.
        :param 'ServiceFullWebRequestIdContributorsServerNameArgs' server_name: Server Name
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "context_root", context_root)
        pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> 'outputs.ServiceFullWebRequestIdContributorsApplicationId':
        """
        Application identifier
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="contextRoot")
    def context_root(self) -> 'outputs.ServiceFullWebRequestIdContributorsContextRoot':
        """
        The context root is the first segment of the request URL after the Server name. For example, in the `www.dynatrace.com/support/help/dynatrace-api/` URL the context root is `/support`. The context root value can be found on the **Service overview page** under **Properties and tags**.
        """
        return pulumi.get(self, "context_root")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> 'outputs.ServiceFullWebRequestIdContributorsServerName':
        """
        Server Name
        """
        return pulumi.get(self, "server_name")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsApplicationId(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributorsApplicationId. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributorsApplicationId.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributorsApplicationId.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributor'] = None):
        """
        :param bool enable_id_contributor: Transform this value before letting it contribute to the Service Id
        :param 'ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorArgs' service_id_contributor: no documentation available
        """
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        """
        Transform this value before letting it contribute to the Service Id
        """
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributor']:
        """
        no documentation available
        """
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 transformations: Optional['outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride'] = None):
        """
        :param str contribution_type: Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
        :param 'ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsArgs' transformations: Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        :param 'ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorValueOverrideArgs' value_override: The value to be used instead of the detected value.
        """
        pulumi.set(__self__, "contribution_type", contribution_type)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        """
        Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
        """
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformations']:
        """
        Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        """
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride']:
        """
        The value to be used instead of the detected value.
        """
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "selectIndex":
            suggest = "select_index"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "takeFromEnd":
            suggest = "take_from_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 segment_count: Optional[int] = None,
                 select_index: Optional[int] = None,
                 split_delimiter: Optional[str] = None,
                 suffix: Optional[str] = None,
                 take_from_end: Optional[bool] = None):
        """
        :param str transformation_type: Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
        :param bool include_hex_numbers: include hexadecimal numbers
        :param int min_digit_count: min digit count
        :param str prefix: no documentation available
        :param str replacement_value: replacement
        :param int segment_count: How many segments should be taken.
        :param int select_index: select index
        :param str split_delimiter: split by
        :param str suffix: no documentation available
        :param bool take_from_end: take from end
        """
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if select_index is not None:
            pulumi.set(__self__, "select_index", select_index)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if take_from_end is not None:
            pulumi.set(__self__, "take_from_end", take_from_end)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        """
        Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
        """
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        """
        include hexadecimal numbers
        """
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        """
        min digit count
        """
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        """
        replacement
        """
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        """
        How many segments should be taken.
        """
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter(name="selectIndex")
    def select_index(self) -> Optional[int]:
        """
        select index
        """
        return pulumi.get(self, "select_index")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        """
        split by
        """
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="takeFromEnd")
    def take_from_end(self) -> Optional[bool]:
        """
        take from end
        """
        return pulumi.get(self, "take_from_end")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        """
        :param str value: no documentation available
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsContextRoot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributorsContextRoot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributorsContextRoot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributorsContextRoot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributor'] = None):
        """
        :param bool enable_id_contributor: Transform this value before letting it contribute to the Service Id
        :param 'ServiceFullWebRequestIdContributorsContextRootServiceIdContributorArgs' service_id_contributor: no documentation available
        """
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        """
        Transform this value before letting it contribute to the Service Id
        """
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributor']:
        """
        no documentation available
        """
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsContextRootServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributorsContextRootServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributorsContextRootServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributorsContextRootServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 segment_count: Optional[int] = None,
                 transformations: Optional['outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributorValueOverride'] = None):
        """
        :param str contribution_type: Possible Values: `OriginalValue`, `OverrideValue`, `TransformURL`, `TransformValue`
        :param int segment_count: The number of segments of the URL to be kept. The URL is divided by slashes (/), the indexing starts with 1 at context root. For example, if you specify 2 for the `www.dynatrace.com/support/help/dynatrace-api/` URL, the value of `support/help` is used.
        :param 'ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformationsArgs' transformations: Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        :param 'ServiceFullWebRequestIdContributorsContextRootServiceIdContributorValueOverrideArgs' value_override: The value to be used instead of the detected value.
        """
        pulumi.set(__self__, "contribution_type", contribution_type)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        """
        Possible Values: `OriginalValue`, `OverrideValue`, `TransformURL`, `TransformValue`
        """
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        """
        The number of segments of the URL to be kept. The URL is divided by slashes (/), the indexing starts with 1 at context root. For example, if you specify 2 for the `www.dynatrace.com/support/help/dynatrace-api/` URL, the value of `support/help` is used.
        """
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformations']:
        """
        Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        """
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributorValueOverride']:
        """
        The value to be used instead of the detected value.
        """
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 suffix: Optional[str] = None):
        """
        :param str transformation_type: Possible Values: `BEFORE`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`
        :param bool include_hex_numbers: include hexadecimal numbers
        :param int min_digit_count: min digit count
        :param str prefix: no documentation available
        :param str replacement_value: replacement
        :param str suffix: no documentation available
        """
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        """
        Possible Values: `BEFORE`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`
        """
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        """
        include hexadecimal numbers
        """
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        """
        min digit count
        """
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        """
        replacement
        """
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsContextRootServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        """
        :param str value: no documentation available
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsServerName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributorsServerName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributorsServerName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributorsServerName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributor'] = None):
        """
        :param bool enable_id_contributor: Transform this value before letting it contribute to the Service Id
        :param 'ServiceFullWebRequestIdContributorsServerNameServiceIdContributorArgs' service_id_contributor: no documentation available
        """
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        """
        Transform this value before letting it contribute to the Service Id
        """
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributor']:
        """
        no documentation available
        """
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsServerNameServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributorsServerNameServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributorsServerNameServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributorsServerNameServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 transformations: Optional['outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributorValueOverride'] = None):
        """
        :param str contribution_type: Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
        :param 'ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformationsArgs' transformations: Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        :param 'ServiceFullWebRequestIdContributorsServerNameServiceIdContributorValueOverrideArgs' value_override: The value to be used instead of the detected value.
        """
        pulumi.set(__self__, "contribution_type", contribution_type)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        """
        Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
        """
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformations']:
        """
        Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        """
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributorValueOverride']:
        """
        The value to be used instead of the detected value.
        """
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "selectIndex":
            suggest = "select_index"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "takeFromEnd":
            suggest = "take_from_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 segment_count: Optional[int] = None,
                 select_index: Optional[int] = None,
                 split_delimiter: Optional[str] = None,
                 suffix: Optional[str] = None,
                 take_from_end: Optional[bool] = None):
        """
        :param str transformation_type: Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
        :param bool include_hex_numbers: include hexadecimal numbers
        :param int min_digit_count: min digit count
        :param str prefix: no documentation available
        :param str replacement_value: replacement
        :param int segment_count: How many segments should be taken.
        :param int select_index: select index
        :param str split_delimiter: split by
        :param str suffix: no documentation available
        :param bool take_from_end: take from end
        """
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if select_index is not None:
            pulumi.set(__self__, "select_index", select_index)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if take_from_end is not None:
            pulumi.set(__self__, "take_from_end", take_from_end)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        """
        Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
        """
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        """
        include hexadecimal numbers
        """
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        """
        min digit count
        """
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        """
        replacement
        """
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        """
        How many segments should be taken.
        """
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter(name="selectIndex")
    def select_index(self) -> Optional[int]:
        """
        select index
        """
        return pulumi.get(self, "select_index")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        """
        split by
        """
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="takeFromEnd")
    def take_from_end(self) -> Optional[bool]:
        """
        take from end
        """
        return pulumi.get(self, "take_from_end")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsServerNameServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        """
        :param str value: no documentation available
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceFullWebServiceConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.ServiceFullWebServiceConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.ServiceFullWebServiceConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ServiceFullWebServiceConditionsCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compareOperationType":
            suggest = "compare_operation_type"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "intValue":
            suggest = "int_value"
        elif key == "intValues":
            suggest = "int_values"
        elif key == "ipRangeFrom":
            suggest = "ip_range_from"
        elif key == "ipRangeTo":
            suggest = "ip_range_to"
        elif key == "tagValues":
            suggest = "tag_values"
        elif key == "textValues":
            suggest = "text_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceConditionsCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceConditionsCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceConditionsCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 compare_operation_type: str,
                 frameworks: Optional[Sequence[str]] = None,
                 ignore_case: Optional[bool] = None,
                 int_value: Optional[int] = None,
                 int_values: Optional[Sequence[int]] = None,
                 ip_range_from: Optional[str] = None,
                 ip_range_to: Optional[str] = None,
                 tag_values: Optional[Sequence[str]] = None,
                 text_values: Optional[Sequence[str]] = None):
        """
        :param str attribute: Take the value of this attribute
        :param str compare_operation_type: Apply this operation
        :param Sequence[str] frameworks: Technology
        :param bool ignore_case: Ignore case sensitivity for texts.
        :param int int_value: Value
        :param Sequence[int] int_values: Values
        :param str ip_range_from: From
        :param str ip_range_to: To
        :param Sequence[str] tag_values: If multiple values are specified, at least one of them must match for the condition to match
        :param Sequence[str] text_values: If multiple values are specified, at least one of them must match for the condition to match
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "compare_operation_type", compare_operation_type)
        if frameworks is not None:
            pulumi.set(__self__, "frameworks", frameworks)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if int_value is not None:
            pulumi.set(__self__, "int_value", int_value)
        if int_values is not None:
            pulumi.set(__self__, "int_values", int_values)
        if ip_range_from is not None:
            pulumi.set(__self__, "ip_range_from", ip_range_from)
        if ip_range_to is not None:
            pulumi.set(__self__, "ip_range_to", ip_range_to)
        if tag_values is not None:
            pulumi.set(__self__, "tag_values", tag_values)
        if text_values is not None:
            pulumi.set(__self__, "text_values", text_values)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        Take the value of this attribute
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="compareOperationType")
    def compare_operation_type(self) -> str:
        """
        Apply this operation
        """
        return pulumi.get(self, "compare_operation_type")

    @property
    @pulumi.getter
    def frameworks(self) -> Optional[Sequence[str]]:
        """
        Technology
        """
        return pulumi.get(self, "frameworks")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Ignore case sensitivity for texts.
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="intValue")
    def int_value(self) -> Optional[int]:
        """
        Value
        """
        return pulumi.get(self, "int_value")

    @property
    @pulumi.getter(name="intValues")
    def int_values(self) -> Optional[Sequence[int]]:
        """
        Values
        """
        return pulumi.get(self, "int_values")

    @property
    @pulumi.getter(name="ipRangeFrom")
    def ip_range_from(self) -> Optional[str]:
        """
        From
        """
        return pulumi.get(self, "ip_range_from")

    @property
    @pulumi.getter(name="ipRangeTo")
    def ip_range_to(self) -> Optional[str]:
        """
        To
        """
        return pulumi.get(self, "ip_range_to")

    @property
    @pulumi.getter(name="tagValues")
    def tag_values(self) -> Optional[Sequence[str]]:
        """
        If multiple values are specified, at least one of them must match for the condition to match
        """
        return pulumi.get(self, "tag_values")

    @property
    @pulumi.getter(name="textValues")
    def text_values(self) -> Optional[Sequence[str]]:
        """
        If multiple values are specified, at least one of them must match for the condition to match
        """
        return pulumi.get(self, "text_values")


@pulumi.output_type
class ServiceFullWebServiceIdContributors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectAsWebRequestService":
            suggest = "detect_as_web_request_service"
        elif key == "applicationId":
            suggest = "application_id"
        elif key == "contextRoot":
            suggest = "context_root"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "webServiceName":
            suggest = "web_service_name"
        elif key == "webServiceNamespace":
            suggest = "web_service_namespace"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 detect_as_web_request_service: bool,
                 application_id: Optional['outputs.ServiceFullWebServiceIdContributorsApplicationId'] = None,
                 context_root: Optional['outputs.ServiceFullWebServiceIdContributorsContextRoot'] = None,
                 server_name: Optional['outputs.ServiceFullWebServiceIdContributorsServerName'] = None,
                 web_service_name: Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceName'] = None,
                 web_service_namespace: Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespace'] = None):
        """
        :param bool detect_as_web_request_service: Detect the matching requests as full web services (false) or web request services (true).
        :param 'ServiceFullWebServiceIdContributorsApplicationIdArgs' application_id: Application identifier
        :param 'ServiceFullWebServiceIdContributorsContextRootArgs' context_root: The context root is the first segment of the request URL after the Server name. For example, in the `www.dynatrace.com/support/help/dynatrace-api/` URL the context root is `/support`. The context root value can be found on the **Service overview page** under **Properties and tags**.
        :param 'ServiceFullWebServiceIdContributorsServerNameArgs' server_name: Server name
        :param 'ServiceFullWebServiceIdContributorsWebServiceNameArgs' web_service_name: Web service name
        :param 'ServiceFullWebServiceIdContributorsWebServiceNamespaceArgs' web_service_namespace: Web service namespace
        """
        pulumi.set(__self__, "detect_as_web_request_service", detect_as_web_request_service)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if context_root is not None:
            pulumi.set(__self__, "context_root", context_root)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if web_service_name is not None:
            pulumi.set(__self__, "web_service_name", web_service_name)
        if web_service_namespace is not None:
            pulumi.set(__self__, "web_service_namespace", web_service_namespace)

    @property
    @pulumi.getter(name="detectAsWebRequestService")
    def detect_as_web_request_service(self) -> bool:
        """
        Detect the matching requests as full web services (false) or web request services (true).
        """
        return pulumi.get(self, "detect_as_web_request_service")

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsApplicationId']:
        """
        Application identifier
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="contextRoot")
    def context_root(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsContextRoot']:
        """
        The context root is the first segment of the request URL after the Server name. For example, in the `www.dynatrace.com/support/help/dynatrace-api/` URL the context root is `/support`. The context root value can be found on the **Service overview page** under **Properties and tags**.
        """
        return pulumi.get(self, "context_root")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsServerName']:
        """
        Server name
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter(name="webServiceName")
    def web_service_name(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceName']:
        """
        Web service name
        """
        return pulumi.get(self, "web_service_name")

    @property
    @pulumi.getter(name="webServiceNamespace")
    def web_service_namespace(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespace']:
        """
        Web service namespace
        """
        return pulumi.get(self, "web_service_namespace")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsApplicationId(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsApplicationId. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsApplicationId.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsApplicationId.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributor'] = None):
        """
        :param bool enable_id_contributor: Transform this value before letting it contribute to the Service Id
        :param 'ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorArgs' service_id_contributor: no documentation available
        """
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        """
        Transform this value before letting it contribute to the Service Id
        """
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributor']:
        """
        no documentation available
        """
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 transformations: Optional['outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorValueOverride'] = None):
        """
        :param str contribution_type: Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
        :param 'ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformationsArgs' transformations: Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        :param 'ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorValueOverrideArgs' value_override: The value to be used instead of the detected value.
        """
        pulumi.set(__self__, "contribution_type", contribution_type)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        """
        Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
        """
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformations']:
        """
        Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        """
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorValueOverride']:
        """
        The value to be used instead of the detected value.
        """
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "selectIndex":
            suggest = "select_index"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "takeFromEnd":
            suggest = "take_from_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 segment_count: Optional[int] = None,
                 select_index: Optional[int] = None,
                 split_delimiter: Optional[str] = None,
                 suffix: Optional[str] = None,
                 take_from_end: Optional[bool] = None):
        """
        :param str transformation_type: Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
        :param bool include_hex_numbers: include hexadecimal numbers
        :param int min_digit_count: min digit count
        :param str prefix: no documentation available
        :param str replacement_value: replacement
        :param int segment_count: How many segments should be taken.
        :param int select_index: select index
        :param str split_delimiter: split by
        :param str suffix: no documentation available
        :param bool take_from_end: take from end
        """
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if select_index is not None:
            pulumi.set(__self__, "select_index", select_index)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if take_from_end is not None:
            pulumi.set(__self__, "take_from_end", take_from_end)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        """
        Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
        """
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        """
        include hexadecimal numbers
        """
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        """
        min digit count
        """
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        """
        replacement
        """
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        """
        How many segments should be taken.
        """
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter(name="selectIndex")
    def select_index(self) -> Optional[int]:
        """
        select index
        """
        return pulumi.get(self, "select_index")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        """
        split by
        """
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="takeFromEnd")
    def take_from_end(self) -> Optional[bool]:
        """
        take from end
        """
        return pulumi.get(self, "take_from_end")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        """
        :param str value: no documentation available
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsContextRoot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsContextRoot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsContextRoot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsContextRoot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributor'] = None):
        """
        :param bool enable_id_contributor: Transform this value before letting it contribute to the Service Id
        :param 'ServiceFullWebServiceIdContributorsContextRootServiceIdContributorArgs' service_id_contributor: no documentation available
        """
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        """
        Transform this value before letting it contribute to the Service Id
        """
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributor']:
        """
        no documentation available
        """
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsContextRootServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsContextRootServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsContextRootServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsContextRootServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 segment_count: Optional[int] = None,
                 transformations: Optional['outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributorValueOverride'] = None):
        """
        :param str contribution_type: Possible Values: `OriginalValue`, `OverrideValue`, `TransformURL`, `TransformValue`
        :param int segment_count: The number of segments of the URL to be kept. The URL is divided by slashes (/), the indexing starts with 1 at context root. For example, if you specify 2 for the `www.dynatrace.com/support/help/dynatrace-api/` URL, the value of `support/help` is used.
        :param 'ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformationsArgs' transformations: Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        :param 'ServiceFullWebServiceIdContributorsContextRootServiceIdContributorValueOverrideArgs' value_override: The value to be used instead of the detected value.
        """
        pulumi.set(__self__, "contribution_type", contribution_type)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        """
        Possible Values: `OriginalValue`, `OverrideValue`, `TransformURL`, `TransformValue`
        """
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        """
        The number of segments of the URL to be kept. The URL is divided by slashes (/), the indexing starts with 1 at context root. For example, if you specify 2 for the `www.dynatrace.com/support/help/dynatrace-api/` URL, the value of `support/help` is used.
        """
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformations']:
        """
        Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        """
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributorValueOverride']:
        """
        The value to be used instead of the detected value.
        """
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 suffix: Optional[str] = None):
        """
        :param str transformation_type: Possible Values: `BEFORE`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`
        :param bool include_hex_numbers: include hexadecimal numbers
        :param int min_digit_count: min digit count
        :param str prefix: no documentation available
        :param str replacement_value: replacement
        :param str suffix: no documentation available
        """
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        """
        Possible Values: `BEFORE`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`
        """
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        """
        include hexadecimal numbers
        """
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        """
        min digit count
        """
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        """
        replacement
        """
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsContextRootServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        """
        :param str value: no documentation available
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsServerName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsServerName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsServerName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsServerName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributor'] = None):
        """
        :param bool enable_id_contributor: Transform this value before letting it contribute to the Service Id
        :param 'ServiceFullWebServiceIdContributorsServerNameServiceIdContributorArgs' service_id_contributor: no documentation available
        """
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        """
        Transform this value before letting it contribute to the Service Id
        """
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributor']:
        """
        no documentation available
        """
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsServerNameServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsServerNameServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsServerNameServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsServerNameServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 transformations: Optional['outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributorValueOverride'] = None):
        """
        :param str contribution_type: Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
        :param 'ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformationsArgs' transformations: Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        :param 'ServiceFullWebServiceIdContributorsServerNameServiceIdContributorValueOverrideArgs' value_override: The value to be used instead of the detected value.
        """
        pulumi.set(__self__, "contribution_type", contribution_type)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        """
        Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
        """
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformations']:
        """
        Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        """
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributorValueOverride']:
        """
        The value to be used instead of the detected value.
        """
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "selectIndex":
            suggest = "select_index"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "takeFromEnd":
            suggest = "take_from_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 segment_count: Optional[int] = None,
                 select_index: Optional[int] = None,
                 split_delimiter: Optional[str] = None,
                 suffix: Optional[str] = None,
                 take_from_end: Optional[bool] = None):
        """
        :param str transformation_type: Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
        :param bool include_hex_numbers: include hexadecimal numbers
        :param int min_digit_count: min digit count
        :param str prefix: no documentation available
        :param str replacement_value: replacement
        :param int segment_count: How many segments should be taken.
        :param int select_index: select index
        :param str split_delimiter: split by
        :param str suffix: no documentation available
        :param bool take_from_end: take from end
        """
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if select_index is not None:
            pulumi.set(__self__, "select_index", select_index)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if take_from_end is not None:
            pulumi.set(__self__, "take_from_end", take_from_end)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        """
        Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
        """
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        """
        include hexadecimal numbers
        """
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        """
        min digit count
        """
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        """
        replacement
        """
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        """
        How many segments should be taken.
        """
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter(name="selectIndex")
    def select_index(self) -> Optional[int]:
        """
        select index
        """
        return pulumi.get(self, "select_index")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        """
        split by
        """
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="takeFromEnd")
    def take_from_end(self) -> Optional[bool]:
        """
        take from end
        """
        return pulumi.get(self, "take_from_end")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsServerNameServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        """
        :param str value: no documentation available
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsWebServiceName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributor'] = None):
        """
        :param bool enable_id_contributor: Transform this value before letting it contribute to the Service Id
        :param 'ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorArgs' service_id_contributor: no documentation available
        """
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        """
        Transform this value before letting it contribute to the Service Id
        """
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributor']:
        """
        no documentation available
        """
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 transformations: Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorValueOverride'] = None):
        """
        :param str contribution_type: Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
        :param 'ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformationsArgs' transformations: Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        :param 'ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorValueOverrideArgs' value_override: The value to be used instead of the detected value.
        """
        pulumi.set(__self__, "contribution_type", contribution_type)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        """
        Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
        """
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformations']:
        """
        Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        """
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorValueOverride']:
        """
        The value to be used instead of the detected value.
        """
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "selectIndex":
            suggest = "select_index"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "takeFromEnd":
            suggest = "take_from_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 segment_count: Optional[int] = None,
                 select_index: Optional[int] = None,
                 split_delimiter: Optional[str] = None,
                 suffix: Optional[str] = None,
                 take_from_end: Optional[bool] = None):
        """
        :param str transformation_type: Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
        :param bool include_hex_numbers: include hexadecimal numbers
        :param int min_digit_count: min digit count
        :param str prefix: no documentation available
        :param str replacement_value: replacement
        :param int segment_count: How many segments should be taken.
        :param int select_index: select index
        :param str split_delimiter: split by
        :param str suffix: no documentation available
        :param bool take_from_end: take from end
        """
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if select_index is not None:
            pulumi.set(__self__, "select_index", select_index)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if take_from_end is not None:
            pulumi.set(__self__, "take_from_end", take_from_end)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        """
        Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
        """
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        """
        include hexadecimal numbers
        """
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        """
        min digit count
        """
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        """
        replacement
        """
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        """
        How many segments should be taken.
        """
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter(name="selectIndex")
    def select_index(self) -> Optional[int]:
        """
        select index
        """
        return pulumi.get(self, "select_index")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        """
        split by
        """
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="takeFromEnd")
    def take_from_end(self) -> Optional[bool]:
        """
        take from end
        """
        return pulumi.get(self, "take_from_end")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        """
        :param str value: no documentation available
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceNamespace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsWebServiceNamespace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNamespace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNamespace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributor'] = None):
        """
        :param bool enable_id_contributor: Transform this value before letting it contribute to the Service Id
        :param 'ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorArgs' service_id_contributor: no documentation available
        """
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        """
        Transform this value before letting it contribute to the Service Id
        """
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributor']:
        """
        no documentation available
        """
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 transformations: Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorValueOverride'] = None):
        """
        :param str contribution_type: Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
        :param 'ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformationsArgs' transformations: Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        :param 'ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorValueOverrideArgs' value_override: The value to be used instead of the detected value.
        """
        pulumi.set(__self__, "contribution_type", contribution_type)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        """
        Possible Values: `OriginalValue`, `OverrideValue`, `TransformValue`
        """
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformations']:
        """
        Choose how to transform a value before it contributes to the Service Id. Note that all of the Transformations are always applied. Transformations are applied in the order they are specified, and the output of the previous transformation is the input for the next one. The resulting value contributes to the Service Id and can be found on the **Service overview page** under **Properties and tags**.
        """
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorValueOverride']:
        """
        The value to be used instead of the detected value.
        """
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "selectIndex":
            suggest = "select_index"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "takeFromEnd":
            suggest = "take_from_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 segment_count: Optional[int] = None,
                 select_index: Optional[int] = None,
                 split_delimiter: Optional[str] = None,
                 suffix: Optional[str] = None,
                 take_from_end: Optional[bool] = None):
        """
        :param str transformation_type: Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
        :param bool include_hex_numbers: include hexadecimal numbers
        :param int min_digit_count: min digit count
        :param str prefix: no documentation available
        :param str replacement_value: replacement
        :param int segment_count: How many segments should be taken.
        :param int select_index: select index
        :param str split_delimiter: split by
        :param str suffix: no documentation available
        :param bool take_from_end: take from end
        """
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if select_index is not None:
            pulumi.set(__self__, "select_index", select_index)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if take_from_end is not None:
            pulumi.set(__self__, "take_from_end", take_from_end)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        """
        Possible Values: `AFTER`, `BEFORE`, `BETWEEN`, `REMOVE_CREDIT_CARDS`, `REMOVE_IBANS`, `REMOVE_IPS`, `REMOVE_NUMBERS`, `REPLACE_BETWEEN`, `SPLIT_SELECT`, `TAKE_SEGMENTS`
        """
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        """
        include hexadecimal numbers
        """
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        """
        min digit count
        """
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        """
        replacement
        """
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        """
        How many segments should be taken.
        """
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter(name="selectIndex")
    def select_index(self) -> Optional[int]:
        """
        select index
        """
        return pulumi.get(self, "select_index")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        """
        split by
        """
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="takeFromEnd")
    def take_from_end(self) -> Optional[bool]:
        """
        take from end
        """
        return pulumi.get(self, "take_from_end")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        """
        :param str value: no documentation available
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceHttpFailureBrokenLinks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "http404NotFoundFailures":
            suggest = "http404_not_found_failures"
        elif key == "brokenLinkDomains":
            suggest = "broken_link_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceHttpFailureBrokenLinks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceHttpFailureBrokenLinks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceHttpFailureBrokenLinks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http404_not_found_failures: bool,
                 broken_link_domains: Optional[Sequence[str]] = None):
        """
        :param bool http404_not_found_failures: Consider 404 HTTP response codes as failures
        :param Sequence[str] broken_link_domains: If your application relies on other hosts at other domains, add the associated domain names here. Once configured, Dynatrace will consider 404s thrown by hosts at these domains to be service failures related to your application.
        """
        pulumi.set(__self__, "http404_not_found_failures", http404_not_found_failures)
        if broken_link_domains is not None:
            pulumi.set(__self__, "broken_link_domains", broken_link_domains)

    @property
    @pulumi.getter(name="http404NotFoundFailures")
    def http404_not_found_failures(self) -> bool:
        """
        Consider 404 HTTP response codes as failures
        """
        return pulumi.get(self, "http404_not_found_failures")

    @property
    @pulumi.getter(name="brokenLinkDomains")
    def broken_link_domains(self) -> Optional[Sequence[str]]:
        """
        If your application relies on other hosts at other domains, add the associated domain names here. Once configured, Dynatrace will consider 404s thrown by hosts at these domains to be service failures related to your application.
        """
        return pulumi.get(self, "broken_link_domains")


@pulumi.output_type
class ServiceHttpFailureHttpResponseCodes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientSideErrors":
            suggest = "client_side_errors"
        elif key == "failOnMissingResponseCodeClientSide":
            suggest = "fail_on_missing_response_code_client_side"
        elif key == "failOnMissingResponseCodeServerSide":
            suggest = "fail_on_missing_response_code_server_side"
        elif key == "serverSideErrors":
            suggest = "server_side_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceHttpFailureHttpResponseCodes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceHttpFailureHttpResponseCodes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceHttpFailureHttpResponseCodes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_side_errors: str,
                 fail_on_missing_response_code_client_side: bool,
                 fail_on_missing_response_code_server_side: bool,
                 server_side_errors: str):
        """
        :param str client_side_errors: HTTP response codes which indicate client side errors
        :param bool fail_on_missing_response_code_client_side: Treat missing HTTP response code as client side error
        :param bool fail_on_missing_response_code_server_side: Treat missing HTTP response code as server side errors
        :param str server_side_errors: HTTP response codes which indicate an error on the server side
        """
        pulumi.set(__self__, "client_side_errors", client_side_errors)
        pulumi.set(__self__, "fail_on_missing_response_code_client_side", fail_on_missing_response_code_client_side)
        pulumi.set(__self__, "fail_on_missing_response_code_server_side", fail_on_missing_response_code_server_side)
        pulumi.set(__self__, "server_side_errors", server_side_errors)

    @property
    @pulumi.getter(name="clientSideErrors")
    def client_side_errors(self) -> str:
        """
        HTTP response codes which indicate client side errors
        """
        return pulumi.get(self, "client_side_errors")

    @property
    @pulumi.getter(name="failOnMissingResponseCodeClientSide")
    def fail_on_missing_response_code_client_side(self) -> bool:
        """
        Treat missing HTTP response code as client side error
        """
        return pulumi.get(self, "fail_on_missing_response_code_client_side")

    @property
    @pulumi.getter(name="failOnMissingResponseCodeServerSide")
    def fail_on_missing_response_code_server_side(self) -> bool:
        """
        Treat missing HTTP response code as server side errors
        """
        return pulumi.get(self, "fail_on_missing_response_code_server_side")

    @property
    @pulumi.getter(name="serverSideErrors")
    def server_side_errors(self) -> str:
        """
        HTTP response codes which indicate an error on the server side
        """
        return pulumi.get(self, "server_side_errors")


@pulumi.output_type
class ServiceNamingCondition(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.ServiceNamingConditionCondition']] = None):
        """
        :param Sequence['ServiceNamingConditionConditionArgs'] conditions: A conditions for the metric usage
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ServiceNamingConditionCondition']]:
        """
        A conditions for the metric usage
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ServiceNamingConditionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationTypeComparisons":
            suggest = "application_type_comparisons"
        elif key == "applicationTypes":
            suggest = "application_types"
        elif key == "azureComputeModeComparisons":
            suggest = "azure_compute_mode_comparisons"
        elif key == "azureComputeModes":
            suggest = "azure_compute_modes"
        elif key == "azureSkuComparisions":
            suggest = "azure_sku_comparisions"
        elif key == "azureSkus":
            suggest = "azure_skus"
        elif key == "baseComparisonBasics":
            suggest = "base_comparison_basics"
        elif key == "baseConditionKeys":
            suggest = "base_condition_keys"
        elif key == "bitnessComparisions":
            suggest = "bitness_comparisions"
        elif key == "cloudTypeComparisons":
            suggest = "cloud_type_comparisons"
        elif key == "cloudTypes":
            suggest = "cloud_types"
        elif key == "customApplicationTypeComparisons":
            suggest = "custom_application_type_comparisons"
        elif key == "customApplicationTypes":
            suggest = "custom_application_types"
        elif key == "customHostMetadataConditionKeys":
            suggest = "custom_host_metadata_condition_keys"
        elif key == "customHostMetadatas":
            suggest = "custom_host_metadatas"
        elif key == "customProcessMetadataConditionKeys":
            suggest = "custom_process_metadata_condition_keys"
        elif key == "customProcessMetadatas":
            suggest = "custom_process_metadatas"
        elif key == "databaseTopologies":
            suggest = "database_topologies"
        elif key == "databaseTopologyComparisons":
            suggest = "database_topology_comparisons"
        elif key == "dcrumDecoderComparisons":
            suggest = "dcrum_decoder_comparisons"
        elif key == "dcrumDecoders":
            suggest = "dcrum_decoders"
        elif key == "entityIdComparisons":
            suggest = "entity_id_comparisons"
        elif key == "hostTeches":
            suggest = "host_teches"
        elif key == "hypervisorTypeComparisions":
            suggest = "hypervisor_type_comparisions"
        elif key == "indexedNameComparisons":
            suggest = "indexed_name_comparisons"
        elif key == "indexedNames":
            suggest = "indexed_names"
        elif key == "indexedStringComparisons":
            suggest = "indexed_string_comparisons"
        elif key == "indexedStrings":
            suggest = "indexed_strings"
        elif key == "indexedTagComparisons":
            suggest = "indexed_tag_comparisons"
        elif key == "indexedTags":
            suggest = "indexed_tags"
        elif key == "integerComparisons":
            suggest = "integer_comparisons"
        elif key == "ipaddressComparisons":
            suggest = "ipaddress_comparisons"
        elif key == "mobilePlatformComparisons":
            suggest = "mobile_platform_comparisons"
        elif key == "mobilePlatforms":
            suggest = "mobile_platforms"
        elif key == "osArches":
            suggest = "os_arches"
        elif key == "osTypes":
            suggest = "os_types"
        elif key == "osarchitectureComparisons":
            suggest = "osarchitecture_comparisons"
        elif key == "ostypeComparisons":
            suggest = "ostype_comparisons"
        elif key == "paasTypeComparisons":
            suggest = "paas_type_comparisons"
        elif key == "paasTypes":
            suggest = "paas_types"
        elif key == "processMetadataConditionKeys":
            suggest = "process_metadata_condition_keys"
        elif key == "processMetadatas":
            suggest = "process_metadatas"
        elif key == "serviceTopologies":
            suggest = "service_topologies"
        elif key == "serviceTopologyComparisons":
            suggest = "service_topology_comparisons"
        elif key == "serviceTypeComparisons":
            suggest = "service_type_comparisons"
        elif key == "serviceTypes":
            suggest = "service_types"
        elif key == "simpleHostTechComparisons":
            suggest = "simple_host_tech_comparisons"
        elif key == "simpleTechComparisons":
            suggest = "simple_tech_comparisons"
        elif key == "stringComparisons":
            suggest = "string_comparisons"
        elif key == "stringConditionKeys":
            suggest = "string_condition_keys"
        elif key == "stringKeys":
            suggest = "string_keys"
        elif key == "syntheticEngineTypeComparisons":
            suggest = "synthetic_engine_type_comparisons"
        elif key == "syntheticEngines":
            suggest = "synthetic_engines"
        elif key == "tagComparisons":
            suggest = "tag_comparisons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_type_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionApplicationTypeComparison']] = None,
                 application_types: Optional[Sequence['outputs.ServiceNamingConditionConditionApplicationType']] = None,
                 azure_compute_mode_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionAzureComputeModeComparison']] = None,
                 azure_compute_modes: Optional[Sequence['outputs.ServiceNamingConditionConditionAzureComputeMode']] = None,
                 azure_sku_comparisions: Optional[Sequence['outputs.ServiceNamingConditionConditionAzureSkuComparision']] = None,
                 azure_skus: Optional[Sequence['outputs.ServiceNamingConditionConditionAzureSkus']] = None,
                 base_comparison_basics: Optional[Sequence['outputs.ServiceNamingConditionConditionBaseComparisonBasic']] = None,
                 base_condition_keys: Optional[Sequence['outputs.ServiceNamingConditionConditionBaseConditionKey']] = None,
                 bitness_comparisions: Optional[Sequence['outputs.ServiceNamingConditionConditionBitnessComparision']] = None,
                 bitnesses: Optional[Sequence['outputs.ServiceNamingConditionConditionBitness']] = None,
                 cloud_type_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionCloudTypeComparison']] = None,
                 cloud_types: Optional[Sequence['outputs.ServiceNamingConditionConditionCloudType']] = None,
                 comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionComparison']] = None,
                 custom_application_type_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionCustomApplicationTypeComparison']] = None,
                 custom_application_types: Optional[Sequence['outputs.ServiceNamingConditionConditionCustomApplicationType']] = None,
                 custom_host_metadata_condition_keys: Optional[Sequence['outputs.ServiceNamingConditionConditionCustomHostMetadataConditionKey']] = None,
                 custom_host_metadatas: Optional[Sequence['outputs.ServiceNamingConditionConditionCustomHostMetadata']] = None,
                 custom_process_metadata_condition_keys: Optional[Sequence['outputs.ServiceNamingConditionConditionCustomProcessMetadataConditionKey']] = None,
                 custom_process_metadatas: Optional[Sequence['outputs.ServiceNamingConditionConditionCustomProcessMetadata']] = None,
                 database_topologies: Optional[Sequence['outputs.ServiceNamingConditionConditionDatabaseTopology']] = None,
                 database_topology_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionDatabaseTopologyComparison']] = None,
                 dcrum_decoder_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionDcrumDecoderComparison']] = None,
                 dcrum_decoders: Optional[Sequence['outputs.ServiceNamingConditionConditionDcrumDecoder']] = None,
                 entities: Optional[Sequence['outputs.ServiceNamingConditionConditionEntity']] = None,
                 entity_id_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionEntityIdComparison']] = None,
                 host_teches: Optional[Sequence['outputs.ServiceNamingConditionConditionHostTech']] = None,
                 hypervisor_type_comparisions: Optional[Sequence['outputs.ServiceNamingConditionConditionHypervisorTypeComparision']] = None,
                 hypervisors: Optional[Sequence['outputs.ServiceNamingConditionConditionHypervisor']] = None,
                 indexed_name_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedNameComparison']] = None,
                 indexed_names: Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedName']] = None,
                 indexed_string_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedStringComparison']] = None,
                 indexed_strings: Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedString']] = None,
                 indexed_tag_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedTagComparison']] = None,
                 indexed_tags: Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedTag']] = None,
                 integer_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionIntegerComparison']] = None,
                 integers: Optional[Sequence['outputs.ServiceNamingConditionConditionInteger']] = None,
                 ipaddress_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionIpaddressComparison']] = None,
                 ipaddresses: Optional[Sequence['outputs.ServiceNamingConditionConditionIpaddress']] = None,
                 keys: Optional[Sequence['outputs.ServiceNamingConditionConditionKey']] = None,
                 mobile_platform_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionMobilePlatformComparison']] = None,
                 mobile_platforms: Optional[Sequence['outputs.ServiceNamingConditionConditionMobilePlatform']] = None,
                 os_arches: Optional[Sequence['outputs.ServiceNamingConditionConditionOsArch']] = None,
                 os_types: Optional[Sequence['outputs.ServiceNamingConditionConditionOsType']] = None,
                 osarchitecture_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionOsarchitectureComparison']] = None,
                 ostype_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionOstypeComparison']] = None,
                 paas_type_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionPaasTypeComparison']] = None,
                 paas_types: Optional[Sequence['outputs.ServiceNamingConditionConditionPaasType']] = None,
                 process_metadata_condition_keys: Optional[Sequence['outputs.ServiceNamingConditionConditionProcessMetadataConditionKey']] = None,
                 process_metadatas: Optional[Sequence['outputs.ServiceNamingConditionConditionProcessMetadata']] = None,
                 service_topologies: Optional[Sequence['outputs.ServiceNamingConditionConditionServiceTopology']] = None,
                 service_topology_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionServiceTopologyComparison']] = None,
                 service_type_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionServiceTypeComparison']] = None,
                 service_types: Optional[Sequence['outputs.ServiceNamingConditionConditionServiceType']] = None,
                 simple_host_tech_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionSimpleHostTechComparison']] = None,
                 simple_tech_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionSimpleTechComparison']] = None,
                 string_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionStringComparison']] = None,
                 string_condition_keys: Optional[Sequence['outputs.ServiceNamingConditionConditionStringConditionKey']] = None,
                 string_keys: Optional[Sequence['outputs.ServiceNamingConditionConditionStringKey']] = None,
                 strings: Optional[Sequence['outputs.ServiceNamingConditionConditionString']] = None,
                 synthetic_engine_type_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionSyntheticEngineTypeComparison']] = None,
                 synthetic_engines: Optional[Sequence['outputs.ServiceNamingConditionConditionSyntheticEngine']] = None,
                 tag_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionTagComparison']] = None,
                 tags: Optional[Sequence['outputs.ServiceNamingConditionConditionTag']] = None,
                 teches: Optional[Sequence['outputs.ServiceNamingConditionConditionTech']] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence['ServiceNamingConditionConditionApplicationTypeComparisonArgs'] application_type_comparisons: Comparison for `APPLICATION_TYPE` attributes
        :param Sequence['ServiceNamingConditionConditionApplicationTypeArgs'] application_types: Comparison for `APPLICATION_TYPE` attributes
        :param Sequence['ServiceNamingConditionConditionAzureComputeModeComparisonArgs'] azure_compute_mode_comparisons: Comparison for `AZURE_COMPUTE_MODE` attributes
        :param Sequence['ServiceNamingConditionConditionAzureComputeModeArgs'] azure_compute_modes: Comparison for `AZURE_COMPUTE_MODE` attributes
        :param Sequence['ServiceNamingConditionConditionAzureSkuComparisionArgs'] azure_sku_comparisions: Comparison for `AZURE_SKU` attributes
        :param Sequence['ServiceNamingConditionConditionAzureSkusArgs'] azure_skus: Comparison for `AZURE_SKU` attributes
        :param Sequence['ServiceNamingConditionConditionBaseComparisonBasicArgs'] base_comparison_basics: A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        :param Sequence['ServiceNamingConditionConditionBaseConditionKeyArgs'] base_condition_keys: Fallback for not yet known type
        :param Sequence['ServiceNamingConditionConditionBitnessComparisionArgs'] bitness_comparisions: Comparison for `BITNESS` attributes
        :param Sequence['ServiceNamingConditionConditionBitnessArgs'] bitnesses: Comparison for `BITNESS` attributes
        :param Sequence['ServiceNamingConditionConditionCloudTypeComparisonArgs'] cloud_type_comparisons: Comparison for `CLOUD_TYPE` attributes
        :param Sequence['ServiceNamingConditionConditionCloudTypeArgs'] cloud_types: Comparison for `CLOUD_TYPE` attributes
        :param Sequence['ServiceNamingConditionConditionComparisonArgs'] comparisons: A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        :param Sequence['ServiceNamingConditionConditionCustomApplicationTypeComparisonArgs'] custom_application_type_comparisons: Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        :param Sequence['ServiceNamingConditionConditionCustomApplicationTypeArgs'] custom_application_types: Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        :param Sequence['ServiceNamingConditionConditionCustomHostMetadataConditionKeyArgs'] custom_host_metadata_condition_keys: Key for Custom Host Metadata
        :param Sequence['ServiceNamingConditionConditionCustomHostMetadataArgs'] custom_host_metadatas: Key for Custom Host Metadata
        :param Sequence['ServiceNamingConditionConditionCustomProcessMetadataConditionKeyArgs'] custom_process_metadata_condition_keys: Key for Custom Process Metadata
        :param Sequence['ServiceNamingConditionConditionCustomProcessMetadataArgs'] custom_process_metadatas: Key for Custom Process Metadata
        :param Sequence['ServiceNamingConditionConditionDatabaseTopologyArgs'] database_topologies: Comparison for `DATABASE_TOPOLOGY` attributes
        :param Sequence['ServiceNamingConditionConditionDatabaseTopologyComparisonArgs'] database_topology_comparisons: Comparison for `DATABASE_TOPOLOGY` attributes
        :param Sequence['ServiceNamingConditionConditionDcrumDecoderComparisonArgs'] dcrum_decoder_comparisons: Comparison for `DCRUM_DECODER_TYPE` attributes
        :param Sequence['ServiceNamingConditionConditionDcrumDecoderArgs'] dcrum_decoders: Comparison for `DCRUM_DECODER_TYPE` attributes
        :param Sequence['ServiceNamingConditionConditionEntityArgs'] entities: Comparison for `ENTITY_ID` attributes
        :param Sequence['ServiceNamingConditionConditionEntityIdComparisonArgs'] entity_id_comparisons: Comparison for `ENTITY_ID` attributes
        :param Sequence['ServiceNamingConditionConditionHostTechArgs'] host_teches: Comparison for `SIMPLE_HOST_TECH` attributes
        :param Sequence['ServiceNamingConditionConditionHypervisorTypeComparisionArgs'] hypervisor_type_comparisions: `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
        :param Sequence['ServiceNamingConditionConditionHypervisorArgs'] hypervisors: Comparison for `HYPERVISOR_TYPE` attributes
        :param Sequence['ServiceNamingConditionConditionIndexedNameComparisonArgs'] indexed_name_comparisons: Comparison for `INDEXED_NAME` attributes
        :param Sequence['ServiceNamingConditionConditionIndexedNameArgs'] indexed_names: Comparison for `INDEXED_NAME` attributes
        :param Sequence['ServiceNamingConditionConditionIndexedStringComparisonArgs'] indexed_string_comparisons: Comparison for `INDEXED_STRING` attributes
        :param Sequence['ServiceNamingConditionConditionIndexedStringArgs'] indexed_strings: Comparison for `INDEXED_STRING` attributes
        :param Sequence['ServiceNamingConditionConditionIndexedTagComparisonArgs'] indexed_tag_comparisons: Comparison for `INDEXED_TAG` attributes
        :param Sequence['ServiceNamingConditionConditionIndexedTagArgs'] indexed_tags: Comparison for `INDEXED_TAG` attributes
        :param Sequence['ServiceNamingConditionConditionIntegerComparisonArgs'] integer_comparisons: Comparison for `INTEGER` attributes
        :param Sequence['ServiceNamingConditionConditionIntegerArgs'] integers: Comparison for `INTEGER` attributes
        :param Sequence['ServiceNamingConditionConditionIpaddressComparisonArgs'] ipaddress_comparisons: Comparison for `IP_ADDRESS` attributes
        :param Sequence['ServiceNamingConditionConditionIpaddressArgs'] ipaddresses: Comparison for `IP_ADDRESS` attributes
        :param Sequence['ServiceNamingConditionConditionKeyArgs'] keys: Fallback for not yet known type
        :param Sequence['ServiceNamingConditionConditionMobilePlatformComparisonArgs'] mobile_platform_comparisons: Comparison for `MOBILE_PLATFORM` attributes
        :param Sequence['ServiceNamingConditionConditionMobilePlatformArgs'] mobile_platforms: Comparison for `MOBILE_PLATFORM` attributes
        :param Sequence['ServiceNamingConditionConditionOsArchArgs'] os_arches: Comparison for `OS_ARCHITECTURE` attributes
        :param Sequence['ServiceNamingConditionConditionOsTypeArgs'] os_types: Comparison for `OS_TYPE` attributes
        :param Sequence['ServiceNamingConditionConditionOsarchitectureComparisonArgs'] osarchitecture_comparisons: Comparison for `OS_ARCHITECTURE` attributes
        :param Sequence['ServiceNamingConditionConditionOstypeComparisonArgs'] ostype_comparisons: Comparison for `OS_TYPE` attributes
        :param Sequence['ServiceNamingConditionConditionPaasTypeComparisonArgs'] paas_type_comparisons: Comparison for `PAAS_TYPE` attributes
        :param Sequence['ServiceNamingConditionConditionPaasTypeArgs'] paas_types: Comparison for `PAAS_TYPE` attributes
        :param Sequence['ServiceNamingConditionConditionProcessMetadataConditionKeyArgs'] process_metadata_condition_keys: The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        :param Sequence['ServiceNamingConditionConditionProcessMetadataArgs'] process_metadatas: The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        :param Sequence['ServiceNamingConditionConditionServiceTopologyArgs'] service_topologies: Comparison for `SERVICE_TOPOLOGY` attributes
        :param Sequence['ServiceNamingConditionConditionServiceTopologyComparisonArgs'] service_topology_comparisons: Comparison for `SERVICE_TOPOLOGY` attributes
        :param Sequence['ServiceNamingConditionConditionServiceTypeComparisonArgs'] service_type_comparisons: Comparison for `SERVICE_TYPE` attributes
        :param Sequence['ServiceNamingConditionConditionServiceTypeArgs'] service_types: Comparison for `SERVICE_TYPE` attributes
        :param Sequence['ServiceNamingConditionConditionSimpleHostTechComparisonArgs'] simple_host_tech_comparisons: Comparison for `SIMPLE_HOST_TECH` attributes
        :param Sequence['ServiceNamingConditionConditionSimpleTechComparisonArgs'] simple_tech_comparisons: Comparison for `SIMPLE_TECH` attributes
        :param Sequence['ServiceNamingConditionConditionStringComparisonArgs'] string_comparisons: Comparison for `STRING` attributes
        :param Sequence['ServiceNamingConditionConditionStringConditionKeyArgs'] string_condition_keys: The key for dynamic attributes of the `STRING` type
        :param Sequence['ServiceNamingConditionConditionStringKeyArgs'] string_keys: The key for dynamic attributes of the `STRING` type
        :param Sequence['ServiceNamingConditionConditionStringArgs'] strings: Comparison for `STRING` attributes
        :param Sequence['ServiceNamingConditionConditionSyntheticEngineTypeComparisonArgs'] synthetic_engine_type_comparisons: Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        :param Sequence['ServiceNamingConditionConditionSyntheticEngineArgs'] synthetic_engines: Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        :param Sequence['ServiceNamingConditionConditionTagComparisonArgs'] tag_comparisons: Comparison for `TAG` attributes
        :param Sequence['ServiceNamingConditionConditionTagArgs'] tags: Comparison for `TAG` attributes
        :param Sequence['ServiceNamingConditionConditionTechArgs'] teches: Comparison for `SIMPLE_TECH` attributes
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if application_type_comparisons is not None:
            pulumi.set(__self__, "application_type_comparisons", application_type_comparisons)
        if application_types is not None:
            pulumi.set(__self__, "application_types", application_types)
        if azure_compute_mode_comparisons is not None:
            pulumi.set(__self__, "azure_compute_mode_comparisons", azure_compute_mode_comparisons)
        if azure_compute_modes is not None:
            pulumi.set(__self__, "azure_compute_modes", azure_compute_modes)
        if azure_sku_comparisions is not None:
            pulumi.set(__self__, "azure_sku_comparisions", azure_sku_comparisions)
        if azure_skus is not None:
            pulumi.set(__self__, "azure_skus", azure_skus)
        if base_comparison_basics is not None:
            pulumi.set(__self__, "base_comparison_basics", base_comparison_basics)
        if base_condition_keys is not None:
            pulumi.set(__self__, "base_condition_keys", base_condition_keys)
        if bitness_comparisions is not None:
            pulumi.set(__self__, "bitness_comparisions", bitness_comparisions)
        if bitnesses is not None:
            pulumi.set(__self__, "bitnesses", bitnesses)
        if cloud_type_comparisons is not None:
            pulumi.set(__self__, "cloud_type_comparisons", cloud_type_comparisons)
        if cloud_types is not None:
            pulumi.set(__self__, "cloud_types", cloud_types)
        if comparisons is not None:
            pulumi.set(__self__, "comparisons", comparisons)
        if custom_application_type_comparisons is not None:
            pulumi.set(__self__, "custom_application_type_comparisons", custom_application_type_comparisons)
        if custom_application_types is not None:
            pulumi.set(__self__, "custom_application_types", custom_application_types)
        if custom_host_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_host_metadata_condition_keys", custom_host_metadata_condition_keys)
        if custom_host_metadatas is not None:
            pulumi.set(__self__, "custom_host_metadatas", custom_host_metadatas)
        if custom_process_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_process_metadata_condition_keys", custom_process_metadata_condition_keys)
        if custom_process_metadatas is not None:
            pulumi.set(__self__, "custom_process_metadatas", custom_process_metadatas)
        if database_topologies is not None:
            pulumi.set(__self__, "database_topologies", database_topologies)
        if database_topology_comparisons is not None:
            pulumi.set(__self__, "database_topology_comparisons", database_topology_comparisons)
        if dcrum_decoder_comparisons is not None:
            pulumi.set(__self__, "dcrum_decoder_comparisons", dcrum_decoder_comparisons)
        if dcrum_decoders is not None:
            pulumi.set(__self__, "dcrum_decoders", dcrum_decoders)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if entity_id_comparisons is not None:
            pulumi.set(__self__, "entity_id_comparisons", entity_id_comparisons)
        if host_teches is not None:
            pulumi.set(__self__, "host_teches", host_teches)
        if hypervisor_type_comparisions is not None:
            pulumi.set(__self__, "hypervisor_type_comparisions", hypervisor_type_comparisions)
        if hypervisors is not None:
            pulumi.set(__self__, "hypervisors", hypervisors)
        if indexed_name_comparisons is not None:
            pulumi.set(__self__, "indexed_name_comparisons", indexed_name_comparisons)
        if indexed_names is not None:
            pulumi.set(__self__, "indexed_names", indexed_names)
        if indexed_string_comparisons is not None:
            pulumi.set(__self__, "indexed_string_comparisons", indexed_string_comparisons)
        if indexed_strings is not None:
            pulumi.set(__self__, "indexed_strings", indexed_strings)
        if indexed_tag_comparisons is not None:
            pulumi.set(__self__, "indexed_tag_comparisons", indexed_tag_comparisons)
        if indexed_tags is not None:
            pulumi.set(__self__, "indexed_tags", indexed_tags)
        if integer_comparisons is not None:
            pulumi.set(__self__, "integer_comparisons", integer_comparisons)
        if integers is not None:
            pulumi.set(__self__, "integers", integers)
        if ipaddress_comparisons is not None:
            pulumi.set(__self__, "ipaddress_comparisons", ipaddress_comparisons)
        if ipaddresses is not None:
            pulumi.set(__self__, "ipaddresses", ipaddresses)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if mobile_platform_comparisons is not None:
            pulumi.set(__self__, "mobile_platform_comparisons", mobile_platform_comparisons)
        if mobile_platforms is not None:
            pulumi.set(__self__, "mobile_platforms", mobile_platforms)
        if os_arches is not None:
            pulumi.set(__self__, "os_arches", os_arches)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if osarchitecture_comparisons is not None:
            pulumi.set(__self__, "osarchitecture_comparisons", osarchitecture_comparisons)
        if ostype_comparisons is not None:
            pulumi.set(__self__, "ostype_comparisons", ostype_comparisons)
        if paas_type_comparisons is not None:
            pulumi.set(__self__, "paas_type_comparisons", paas_type_comparisons)
        if paas_types is not None:
            pulumi.set(__self__, "paas_types", paas_types)
        if process_metadata_condition_keys is not None:
            pulumi.set(__self__, "process_metadata_condition_keys", process_metadata_condition_keys)
        if process_metadatas is not None:
            pulumi.set(__self__, "process_metadatas", process_metadatas)
        if service_topologies is not None:
            pulumi.set(__self__, "service_topologies", service_topologies)
        if service_topology_comparisons is not None:
            pulumi.set(__self__, "service_topology_comparisons", service_topology_comparisons)
        if service_type_comparisons is not None:
            pulumi.set(__self__, "service_type_comparisons", service_type_comparisons)
        if service_types is not None:
            pulumi.set(__self__, "service_types", service_types)
        if simple_host_tech_comparisons is not None:
            pulumi.set(__self__, "simple_host_tech_comparisons", simple_host_tech_comparisons)
        if simple_tech_comparisons is not None:
            pulumi.set(__self__, "simple_tech_comparisons", simple_tech_comparisons)
        if string_comparisons is not None:
            pulumi.set(__self__, "string_comparisons", string_comparisons)
        if string_condition_keys is not None:
            pulumi.set(__self__, "string_condition_keys", string_condition_keys)
        if string_keys is not None:
            pulumi.set(__self__, "string_keys", string_keys)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)
        if synthetic_engine_type_comparisons is not None:
            pulumi.set(__self__, "synthetic_engine_type_comparisons", synthetic_engine_type_comparisons)
        if synthetic_engines is not None:
            pulumi.set(__self__, "synthetic_engines", synthetic_engines)
        if tag_comparisons is not None:
            pulumi.set(__self__, "tag_comparisons", tag_comparisons)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if teches is not None:
            pulumi.set(__self__, "teches", teches)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="applicationTypeComparisons")
    @_utilities.deprecated("""You should use 'application_type' instead of 'application_type_comparison'. This attribute still exists for backwards compatibility.""")
    def application_type_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionApplicationTypeComparison']]:
        """
        Comparison for `APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "application_type_comparisons")

    @property
    @pulumi.getter(name="applicationTypes")
    def application_types(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionApplicationType']]:
        """
        Comparison for `APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "application_types")

    @property
    @pulumi.getter(name="azureComputeModeComparisons")
    def azure_compute_mode_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionAzureComputeModeComparison']]:
        """
        Comparison for `AZURE_COMPUTE_MODE` attributes
        """
        return pulumi.get(self, "azure_compute_mode_comparisons")

    @property
    @pulumi.getter(name="azureComputeModes")
    @_utilities.deprecated("""You should use 'azure_compute_mode' instead of 'azure_compute_mode_comparison'. This attribute still exists for backwards compatibility.""")
    def azure_compute_modes(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionAzureComputeMode']]:
        """
        Comparison for `AZURE_COMPUTE_MODE` attributes
        """
        return pulumi.get(self, "azure_compute_modes")

    @property
    @pulumi.getter(name="azureSkuComparisions")
    @_utilities.deprecated("""You should use 'azure_sku' instead of 'azure_sku_comparision'. This attribute still exists for backwards compatibility.""")
    def azure_sku_comparisions(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionAzureSkuComparision']]:
        """
        Comparison for `AZURE_SKU` attributes
        """
        return pulumi.get(self, "azure_sku_comparisions")

    @property
    @pulumi.getter(name="azureSkus")
    def azure_skus(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionAzureSkus']]:
        """
        Comparison for `AZURE_SKU` attributes
        """
        return pulumi.get(self, "azure_skus")

    @property
    @pulumi.getter(name="baseComparisonBasics")
    @_utilities.deprecated("""You should use 'comparison' instead of 'base_comparison_basic'. This attribute still exists for backwards compatibility.""")
    def base_comparison_basics(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionBaseComparisonBasic']]:
        """
        A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        """
        return pulumi.get(self, "base_comparison_basics")

    @property
    @pulumi.getter(name="baseConditionKeys")
    @_utilities.deprecated("""'base_condition_key' is deprecated. You should use 'key'""")
    def base_condition_keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionBaseConditionKey']]:
        """
        Fallback for not yet known type
        """
        return pulumi.get(self, "base_condition_keys")

    @property
    @pulumi.getter(name="bitnessComparisions")
    @_utilities.deprecated("""You should use 'bitness' instead of 'bitness_comparision'. This attribute still exists for backwards compatibility.""")
    def bitness_comparisions(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionBitnessComparision']]:
        """
        Comparison for `BITNESS` attributes
        """
        return pulumi.get(self, "bitness_comparisions")

    @property
    @pulumi.getter
    def bitnesses(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionBitness']]:
        """
        Comparison for `BITNESS` attributes
        """
        return pulumi.get(self, "bitnesses")

    @property
    @pulumi.getter(name="cloudTypeComparisons")
    @_utilities.deprecated("""You should use 'cloud_type' instead of 'cloud_type_comparison'. This attribute still exists for backwards compatibility.""")
    def cloud_type_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCloudTypeComparison']]:
        """
        Comparison for `CLOUD_TYPE` attributes
        """
        return pulumi.get(self, "cloud_type_comparisons")

    @property
    @pulumi.getter(name="cloudTypes")
    def cloud_types(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCloudType']]:
        """
        Comparison for `CLOUD_TYPE` attributes
        """
        return pulumi.get(self, "cloud_types")

    @property
    @pulumi.getter
    def comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionComparison']]:
        """
        A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
        """
        return pulumi.get(self, "comparisons")

    @property
    @pulumi.getter(name="customApplicationTypeComparisons")
    @_utilities.deprecated("""You should use 'custom_application_type' instead of 'custom_application_type_comparison'. This attribute still exists for backwards compatibility.""")
    def custom_application_type_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCustomApplicationTypeComparison']]:
        """
        Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "custom_application_type_comparisons")

    @property
    @pulumi.getter(name="customApplicationTypes")
    def custom_application_types(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCustomApplicationType']]:
        """
        Comparison for `CUSTOM_APPLICATION_TYPE` attributes
        """
        return pulumi.get(self, "custom_application_types")

    @property
    @pulumi.getter(name="customHostMetadataConditionKeys")
    @_utilities.deprecated("""'custom_host_metadata_condition_key' is deprecated. You should use 'custom_host_metadata'""")
    def custom_host_metadata_condition_keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCustomHostMetadataConditionKey']]:
        """
        Key for Custom Host Metadata
        """
        return pulumi.get(self, "custom_host_metadata_condition_keys")

    @property
    @pulumi.getter(name="customHostMetadatas")
    def custom_host_metadatas(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCustomHostMetadata']]:
        """
        Key for Custom Host Metadata
        """
        return pulumi.get(self, "custom_host_metadatas")

    @property
    @pulumi.getter(name="customProcessMetadataConditionKeys")
    @_utilities.deprecated("""'custom_process_metadata_condition_key' is deprecated. You should use 'custom_process_metadata'""")
    def custom_process_metadata_condition_keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCustomProcessMetadataConditionKey']]:
        """
        Key for Custom Process Metadata
        """
        return pulumi.get(self, "custom_process_metadata_condition_keys")

    @property
    @pulumi.getter(name="customProcessMetadatas")
    def custom_process_metadatas(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCustomProcessMetadata']]:
        """
        Key for Custom Process Metadata
        """
        return pulumi.get(self, "custom_process_metadatas")

    @property
    @pulumi.getter(name="databaseTopologies")
    def database_topologies(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionDatabaseTopology']]:
        """
        Comparison for `DATABASE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "database_topologies")

    @property
    @pulumi.getter(name="databaseTopologyComparisons")
    @_utilities.deprecated("""You should use 'database_topology' instead of 'database_topology_comparison'. This attribute still exists for backwards compatibility.""")
    def database_topology_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionDatabaseTopologyComparison']]:
        """
        Comparison for `DATABASE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "database_topology_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoderComparisons")
    @_utilities.deprecated("""You should use 'dcrum_decoder' instead of 'dcrum_decoder_comparison'. This attribute still exists for backwards compatibility.""")
    def dcrum_decoder_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionDcrumDecoderComparison']]:
        """
        Comparison for `DCRUM_DECODER_TYPE` attributes
        """
        return pulumi.get(self, "dcrum_decoder_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoders")
    def dcrum_decoders(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionDcrumDecoder']]:
        """
        Comparison for `DCRUM_DECODER_TYPE` attributes
        """
        return pulumi.get(self, "dcrum_decoders")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionEntity']]:
        """
        Comparison for `ENTITY_ID` attributes
        """
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="entityIdComparisons")
    @_utilities.deprecated("""You should use 'entity' instead of 'entity_id_comparison'. This attribute still exists for backwards compatibility.""")
    def entity_id_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionEntityIdComparison']]:
        """
        Comparison for `ENTITY_ID` attributes
        """
        return pulumi.get(self, "entity_id_comparisons")

    @property
    @pulumi.getter(name="hostTeches")
    def host_teches(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionHostTech']]:
        """
        Comparison for `SIMPLE_HOST_TECH` attributes
        """
        return pulumi.get(self, "host_teches")

    @property
    @pulumi.getter(name="hypervisorTypeComparisions")
    @_utilities.deprecated("""`hypervisor_type_comparision` is deprecated. Use `hypervisor` instead""")
    def hypervisor_type_comparisions(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionHypervisorTypeComparision']]:
        """
        `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
        """
        return pulumi.get(self, "hypervisor_type_comparisions")

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionHypervisor']]:
        """
        Comparison for `HYPERVISOR_TYPE` attributes
        """
        return pulumi.get(self, "hypervisors")

    @property
    @pulumi.getter(name="indexedNameComparisons")
    @_utilities.deprecated("""You should use 'indexed_name' instead of 'indexed_name_comparison'. This attribute still exists for backwards compatibility.""")
    def indexed_name_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedNameComparison']]:
        """
        Comparison for `INDEXED_NAME` attributes
        """
        return pulumi.get(self, "indexed_name_comparisons")

    @property
    @pulumi.getter(name="indexedNames")
    def indexed_names(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedName']]:
        """
        Comparison for `INDEXED_NAME` attributes
        """
        return pulumi.get(self, "indexed_names")

    @property
    @pulumi.getter(name="indexedStringComparisons")
    @_utilities.deprecated("""You should use 'indexed_string' instead of 'indexed_string_comparison'. This attribute still exists for backwards compatibility.""")
    def indexed_string_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedStringComparison']]:
        """
        Comparison for `INDEXED_STRING` attributes
        """
        return pulumi.get(self, "indexed_string_comparisons")

    @property
    @pulumi.getter(name="indexedStrings")
    def indexed_strings(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedString']]:
        """
        Comparison for `INDEXED_STRING` attributes
        """
        return pulumi.get(self, "indexed_strings")

    @property
    @pulumi.getter(name="indexedTagComparisons")
    @_utilities.deprecated("""You should use 'indexed_tag' instead of 'indexed_tag_comparison'. This attribute still exists for backwards compatibility.""")
    def indexed_tag_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedTagComparison']]:
        """
        Comparison for `INDEXED_TAG` attributes
        """
        return pulumi.get(self, "indexed_tag_comparisons")

    @property
    @pulumi.getter(name="indexedTags")
    def indexed_tags(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedTag']]:
        """
        Comparison for `INDEXED_TAG` attributes
        """
        return pulumi.get(self, "indexed_tags")

    @property
    @pulumi.getter(name="integerComparisons")
    @_utilities.deprecated("""You should use 'integer' instead of 'integer_comparison'. This attribute still exists for backwards compatibility.""")
    def integer_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIntegerComparison']]:
        """
        Comparison for `INTEGER` attributes
        """
        return pulumi.get(self, "integer_comparisons")

    @property
    @pulumi.getter
    def integers(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionInteger']]:
        """
        Comparison for `INTEGER` attributes
        """
        return pulumi.get(self, "integers")

    @property
    @pulumi.getter(name="ipaddressComparisons")
    @_utilities.deprecated("""You should use 'ipaddress' instead of 'ipaddress_comparison'. This attribute still exists for backwards compatibility.""")
    def ipaddress_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIpaddressComparison']]:
        """
        Comparison for `IP_ADDRESS` attributes
        """
        return pulumi.get(self, "ipaddress_comparisons")

    @property
    @pulumi.getter
    def ipaddresses(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIpaddress']]:
        """
        Comparison for `IP_ADDRESS` attributes
        """
        return pulumi.get(self, "ipaddresses")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionKey']]:
        """
        Fallback for not yet known type
        """
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter(name="mobilePlatformComparisons")
    @_utilities.deprecated("""You should use 'mobile_platform' instead of 'mobile_platform_comparison'. This attribute still exists for backwards compatibility.""")
    def mobile_platform_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionMobilePlatformComparison']]:
        """
        Comparison for `MOBILE_PLATFORM` attributes
        """
        return pulumi.get(self, "mobile_platform_comparisons")

    @property
    @pulumi.getter(name="mobilePlatforms")
    def mobile_platforms(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionMobilePlatform']]:
        """
        Comparison for `MOBILE_PLATFORM` attributes
        """
        return pulumi.get(self, "mobile_platforms")

    @property
    @pulumi.getter(name="osArches")
    def os_arches(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionOsArch']]:
        """
        Comparison for `OS_ARCHITECTURE` attributes
        """
        return pulumi.get(self, "os_arches")

    @property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionOsType']]:
        """
        Comparison for `OS_TYPE` attributes
        """
        return pulumi.get(self, "os_types")

    @property
    @pulumi.getter(name="osarchitectureComparisons")
    @_utilities.deprecated("""You should use 'os_arch' instead of 'osarchitecture_comparison'. This attribute still exists for backwards compatibility.""")
    def osarchitecture_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionOsarchitectureComparison']]:
        """
        Comparison for `OS_ARCHITECTURE` attributes
        """
        return pulumi.get(self, "osarchitecture_comparisons")

    @property
    @pulumi.getter(name="ostypeComparisons")
    @_utilities.deprecated("""You should use 'os_type' instead of 'ostype_comparison'. This attribute still exists for backwards compatibility.""")
    def ostype_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionOstypeComparison']]:
        """
        Comparison for `OS_TYPE` attributes
        """
        return pulumi.get(self, "ostype_comparisons")

    @property
    @pulumi.getter(name="paasTypeComparisons")
    @_utilities.deprecated("""You should use 'paas_type' instead of 'paas_type_comparison'. This attribute still exists for backwards compatibility.""")
    def paas_type_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionPaasTypeComparison']]:
        """
        Comparison for `PAAS_TYPE` attributes
        """
        return pulumi.get(self, "paas_type_comparisons")

    @property
    @pulumi.getter(name="paasTypes")
    def paas_types(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionPaasType']]:
        """
        Comparison for `PAAS_TYPE` attributes
        """
        return pulumi.get(self, "paas_types")

    @property
    @pulumi.getter(name="processMetadataConditionKeys")
    @_utilities.deprecated("""'process_metadata_condition_key' is deprecated. You should use 'process_metadata'""")
    def process_metadata_condition_keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionProcessMetadataConditionKey']]:
        """
        The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        """
        return pulumi.get(self, "process_metadata_condition_keys")

    @property
    @pulumi.getter(name="processMetadatas")
    def process_metadatas(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionProcessMetadata']]:
        """
        The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
        """
        return pulumi.get(self, "process_metadatas")

    @property
    @pulumi.getter(name="serviceTopologies")
    def service_topologies(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionServiceTopology']]:
        """
        Comparison for `SERVICE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "service_topologies")

    @property
    @pulumi.getter(name="serviceTopologyComparisons")
    @_utilities.deprecated("""You should use 'service_topology' instead of 'service_topology_comparison'. This attribute still exists for backwards compatibility.""")
    def service_topology_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionServiceTopologyComparison']]:
        """
        Comparison for `SERVICE_TOPOLOGY` attributes
        """
        return pulumi.get(self, "service_topology_comparisons")

    @property
    @pulumi.getter(name="serviceTypeComparisons")
    @_utilities.deprecated("""You should use 'service_type' instead of 'service_type_comparison'. This attribute still exists for backwards compatibility.""")
    def service_type_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionServiceTypeComparison']]:
        """
        Comparison for `SERVICE_TYPE` attributes
        """
        return pulumi.get(self, "service_type_comparisons")

    @property
    @pulumi.getter(name="serviceTypes")
    def service_types(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionServiceType']]:
        """
        Comparison for `SERVICE_TYPE` attributes
        """
        return pulumi.get(self, "service_types")

    @property
    @pulumi.getter(name="simpleHostTechComparisons")
    @_utilities.deprecated("""You should use 'host_tech' instead of 'simple_host_tech_comparison'. This attribute still exists for backwards compatibility.""")
    def simple_host_tech_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionSimpleHostTechComparison']]:
        """
        Comparison for `SIMPLE_HOST_TECH` attributes
        """
        return pulumi.get(self, "simple_host_tech_comparisons")

    @property
    @pulumi.getter(name="simpleTechComparisons")
    @_utilities.deprecated("""You should use 'tech' instead of 'simple_tech_comparison'. This attribute still exists for backwards compatibility.""")
    def simple_tech_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionSimpleTechComparison']]:
        """
        Comparison for `SIMPLE_TECH` attributes
        """
        return pulumi.get(self, "simple_tech_comparisons")

    @property
    @pulumi.getter(name="stringComparisons")
    @_utilities.deprecated("""You should use 'string' instead of 'string_comparison'. This attribute still exists for backwards compatibility.""")
    def string_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionStringComparison']]:
        """
        Comparison for `STRING` attributes
        """
        return pulumi.get(self, "string_comparisons")

    @property
    @pulumi.getter(name="stringConditionKeys")
    @_utilities.deprecated("""'string_condition_key' is deprecated. You should use 'string_key'""")
    def string_condition_keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionStringConditionKey']]:
        """
        The key for dynamic attributes of the `STRING` type
        """
        return pulumi.get(self, "string_condition_keys")

    @property
    @pulumi.getter(name="stringKeys")
    def string_keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionStringKey']]:
        """
        The key for dynamic attributes of the `STRING` type
        """
        return pulumi.get(self, "string_keys")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionString']]:
        """
        Comparison for `STRING` attributes
        """
        return pulumi.get(self, "strings")

    @property
    @pulumi.getter(name="syntheticEngineTypeComparisons")
    @_utilities.deprecated("""You should use 'synthetic_engine' instead of 'synthetic_engine_type_comparison'. This attribute still exists for backwards compatibility.""")
    def synthetic_engine_type_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionSyntheticEngineTypeComparison']]:
        """
        Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        """
        return pulumi.get(self, "synthetic_engine_type_comparisons")

    @property
    @pulumi.getter(name="syntheticEngines")
    def synthetic_engines(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionSyntheticEngine']]:
        """
        Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
        """
        return pulumi.get(self, "synthetic_engines")

    @property
    @pulumi.getter(name="tagComparisons")
    @_utilities.deprecated("""You should use 'tag' instead of 'tag_comparison'. This attribute still exists for backwards compatibility.""")
    def tag_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionTagComparison']]:
        """
        Comparison for `TAG` attributes
        """
        return pulumi.get(self, "tag_comparisons")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionTag']]:
        """
        Comparison for `TAG` attributes
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def teches(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionTech']]:
        """
        Comparison for `SIMPLE_TECH` attributes
        """
        return pulumi.get(self, "teches")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be APPLICATION_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be APPLICATION_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionAzureComputeMode(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are DEDICATED or SHARED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are DEDICATED or SHARED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionAzureComputeModeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are DEDICATED or SHARED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are DEDICATED or SHARED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionAzureSkuComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be AZURE_SKU
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be AZURE_SKU
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionAzureSkus(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionBaseComparisonBasic(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str type: The type of comparison
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of comparison
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionBaseConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str type: Defines the actual set of fields depending on the value
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defines the actual set of fields depending on the value
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionBitness(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are 32 and 64.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are 32 and 64.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionBitnessComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be BITNESS
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are 32 and 64.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be BITNESS
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are 32 and 64.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionCloudType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionCloudTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be CLOUD_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be CLOUD_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionComparison(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str type: The type of comparison
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of comparison
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionCustomApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be CUSTOM_APPLICATION_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be CUSTOM_APPLICATION_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionCustomHostMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionCustomHostMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionCustomHostMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionCustomHostMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ServiceNamingConditionConditionCustomHostMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'ServiceNamingConditionConditionCustomHostMetadataDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ServiceNamingConditionConditionCustomHostMetadataDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomHostMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionCustomHostMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ServiceNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'ServiceNamingConditionConditionCustomHostMetadataConditionKeyDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str type: if specified, needs to be HOST_CUSTOM_METADATA_KEY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ServiceNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be HOST_CUSTOM_METADATA_KEY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomHostMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionCustomProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionCustomProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionCustomProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ServiceNamingConditionConditionCustomProcessMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'ServiceNamingConditionConditionCustomProcessMetadataDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ServiceNamingConditionConditionCustomProcessMetadataDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionCustomProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ServiceNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param 'ServiceNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKeyArgs' dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        :param str type: if specified, needs to be PROCESS_CUSTOM_METADATA_KEY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ServiceNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey':
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be PROCESS_CUSTOM_METADATA_KEY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomProcessMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        """
        :param str key: The actual key of the custom metadata
        :param str source: The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The actual key of the custom metadata
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionDatabaseTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionDatabaseTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be DATABASE_TOPOLOGY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be DATABASE_TOPOLOGY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionDcrumDecoder(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionDcrumDecoderComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be DCRUM_DECODER_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be DCRUM_DECODER_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionEntity(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionEntityIdComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be ENTITY_ID
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be ENTITY_ID
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionHostTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionHostTechValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'ServiceNamingConditionConditionHostTechValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionHostTechValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionHostTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionHostTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionHostTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionHostTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ServiceNamingConditionConditionHypervisor(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionHypervisorTypeComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be HYPERVISOR_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be HYPERVISOR_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedName(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedNameComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be INDEXED_NAME
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INDEXED_NAME
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedString(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedStringComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be INDEXED_STRING
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INDEXED_STRING
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionIndexedTagValue'] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param 'ServiceNamingConditionConditionIndexedTagValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionIndexedTagValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionIndexedTagComparisonValue'] = None):
        """
        :param str operator: Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        :param str type: if specified, needs to be INDEXED_TAG
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param 'ServiceNamingConditionConditionIndexedTagComparisonValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INDEXED_TAG
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionIndexedTagComparisonValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionInteger(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param int value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIntegerComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be INTEGER
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param int value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be INTEGER
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIpaddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionIpaddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionIpaddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionIpaddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIpaddressComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionIpaddressComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionIpaddressComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionIpaddressComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be IP_ADDRESS
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be IP_ADDRESS
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str type: Defines the actual set of fields depending on the value
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defines the actual set of fields depending on the value
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionMobilePlatform(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionMobilePlatformComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be MOBILE_PLATFORM
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be MOBILE_PLATFORM
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionOsArch(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionOsType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionOsarchitectureComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be OS_ARCHITECTURE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be OS_ARCHITECTURE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionOstypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be OS_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be OS_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionPaasType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionPaasTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be PAAS_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be PAAS_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        :param str type: if specified, needs to be PROCESS_PREDEFINED_METADATA_KEY
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be PROCESS_PREDEFINED_METADATA_KEY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionServiceTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionServiceTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SERVICE_TOPOLOGY
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SERVICE_TOPOLOGY
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionServiceType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionServiceTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SERVICE_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SERVICE_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionSimpleHostTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionSimpleHostTechComparisonValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SIMPLE_HOST_TECH
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'ServiceNamingConditionConditionSimpleHostTechComparisonValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SIMPLE_HOST_TECH
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionSimpleHostTechComparisonValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionSimpleHostTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionSimpleHostTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ServiceNamingConditionConditionSimpleTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionSimpleTechComparisonValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SIMPLE_TECH
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'ServiceNamingConditionConditionSimpleTechComparisonValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SIMPLE_TECH
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionSimpleTechComparisonValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionSimpleTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionSimpleTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionSimpleTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionSimpleTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ServiceNamingConditionConditionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionStringComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionStringComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionStringComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionStringComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        :param bool case_sensitive: The comparison is case-sensitive (`true`) or insensitive (`false`)
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be STRING
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The comparison is case-sensitive (`true`) or insensitive (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be STRING
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionStringConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionStringConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionStringConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionStringConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
                  - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
                  - `AMAZON_ECR_IMAGE_REGION`
                  - `AMAZON_LAMBDA_FUNCTION_NAME`
                  - `AMAZON_REGION`
                  - `APACHE_CONFIG_PATH`
                  - `APACHE_SPARK_MASTER_IP_ADDRESS`
                  - `ASP_DOT_NET_CORE_APPLICATION_PATH`
                  - `AWS_ECS_CLUSTER`
                  - `AWS_ECS_CONTAINERNAME`
                  - `AWS_ECS_FAMILY`
                  - `AWS_ECS_REVISION`
                  - `CASSANDRA_CLUSTER_NAME`
                  - `CATALINA_BASE`
                  - `CATALINA_HOME`
                  - `CLOUD_FOUNDRY_APP_ID`
                  - `CLOUD_FOUNDRY_APP_NAME`
                  - `CLOUD_FOUNDRY_INSTANCE_INDEX`
                  - `CLOUD_FOUNDRY_SPACE_ID`
                  - `CLOUD_FOUNDRY_SPACE_NAME`
                  - `COLDFUSION_JVM_CONFIG_FILE`
                  - `COLDFUSION_SERVICE_NAME`
                  - `COMMAND_LINE_ARGS`
                  - `DOTNET_COMMAND`
                  - `DOTNET_COMMAND_PATH`
                  - `DYNATRACE_CLUSTER_ID`
                  - `DYNATRACE_NODE_ID`
                  - `ELASTICSEARCH_CLUSTER_NAME`
                  - `ELASTICSEARCH_NODE_NAME`
                  - `EQUINOX_CONFIG_PATH`
                  - `EXE_NAME`
                  - `EXE_PATH`
                  - `GLASS_FISH_DOMAIN_NAME`
                  - `GLASS_FISH_INSTANCE_NAME`
                  - `GOOGLE_APP_ENGINE_INSTANCE`
                  - `GOOGLE_APP_ENGINE_SERVICE`
                  - `GOOGLE_CLOUD_PROJECT`
                  - `HYBRIS_BIN_DIRECTORY`
                  - `HYBRIS_CONFIG_DIRECTORY`
                  - `HYBRIS_DATA_DIRECTORY`
                  - `IBM_CICS_REGION`
                  - `IBM_CTG_NAME`
                  - `IBM_IMS_CONNECT_REGION`
                  - `IBM_IMS_CONTROL_REGION`
                  - `IBM_IMS_MESSAGE_PROCESSING_REGION`
                  - `IBM_IMS_SOAP_GW_NAME`
                  - `IBM_INTEGRATION_NODE_NAME`
                  - `IBM_INTEGRATION_SERVER_NAME`
                  - `IIS_APP_POOL`
                  - `IIS_ROLE_NAME`
                  - `JAVA_JAR_FILE`
                  - `JAVA_JAR_PATH`
                  - `JAVA_MAIN_CLASS`
                  - `JAVA_MAIN_MODULE`
                  - `JBOSS_HOME`
                  - `JBOSS_MODE`
                  - `JBOSS_SERVER_NAME`
                  - `KUBERNETES_BASE_POD_NAME`
                  - `KUBERNETES_CONTAINER_NAME`
                  - `KUBERNETES_FULL_POD_NAME`
                  - `KUBERNETES_NAMESPACE`
                  - `KUBERNETES_POD_UID`
                  - `MSSQL_INSTANCE_NAME`
                  - `NODE_JS_APP_BASE_DIRECTORY`
                  - `NODE_JS_APP_NAME`
                  - `NODE_JS_SCRIPT_NAME`
                  - `ORACLE_SID`
                  - `PG_ID_CALC_INPUT_KEY_LINKAGE`
                  - `PHP_SCRIPT_PATH`
                  - `PHP_WORKING_DIRECTORY`
                  - `RUBY_APP_ROOT_PATH`
                  - `RUBY_SCRIPT_PATH`
                  - `RULE_RESULT`
                  - `SOFTWAREAG_INSTALL_ROOT`
                  - `SOFTWAREAG_PRODUCTPROPNAME`
                  - `SPRINGBOOT_APP_NAME`
                  - `SPRINGBOOT_PROFILE_NAME`
                  - `SPRINGBOOT_STARTUP_CLASS`
                  - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
                  - `TIBCO_BUSINESSWORKS_CE_VERSION`
                  - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
                  - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
                  - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
                  - `TIBCO_BUSINESS_WORKS_HOME`
                  - `VARNISH_INSTANCE_NAME`
                  - `WEB_LOGIC_CLUSTER_NAME`
                  - `WEB_LOGIC_DOMAIN_NAME`
                  - `WEB_LOGIC_HOME`
                  - `WEB_LOGIC_NAME`
                  - `WEB_SPHERE_CELL_NAME`
                  - `WEB_SPHERE_CLUSTER_NAME`
                  - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        :param str type: if specified, needs to be `STRING`
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
           - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
           - `AMAZON_ECR_IMAGE_REGION`
           - `AMAZON_LAMBDA_FUNCTION_NAME`
           - `AMAZON_REGION`
           - `APACHE_CONFIG_PATH`
           - `APACHE_SPARK_MASTER_IP_ADDRESS`
           - `ASP_DOT_NET_CORE_APPLICATION_PATH`
           - `AWS_ECS_CLUSTER`
           - `AWS_ECS_CONTAINERNAME`
           - `AWS_ECS_FAMILY`
           - `AWS_ECS_REVISION`
           - `CASSANDRA_CLUSTER_NAME`
           - `CATALINA_BASE`
           - `CATALINA_HOME`
           - `CLOUD_FOUNDRY_APP_ID`
           - `CLOUD_FOUNDRY_APP_NAME`
           - `CLOUD_FOUNDRY_INSTANCE_INDEX`
           - `CLOUD_FOUNDRY_SPACE_ID`
           - `CLOUD_FOUNDRY_SPACE_NAME`
           - `COLDFUSION_JVM_CONFIG_FILE`
           - `COLDFUSION_SERVICE_NAME`
           - `COMMAND_LINE_ARGS`
           - `DOTNET_COMMAND`
           - `DOTNET_COMMAND_PATH`
           - `DYNATRACE_CLUSTER_ID`
           - `DYNATRACE_NODE_ID`
           - `ELASTICSEARCH_CLUSTER_NAME`
           - `ELASTICSEARCH_NODE_NAME`
           - `EQUINOX_CONFIG_PATH`
           - `EXE_NAME`
           - `EXE_PATH`
           - `GLASS_FISH_DOMAIN_NAME`
           - `GLASS_FISH_INSTANCE_NAME`
           - `GOOGLE_APP_ENGINE_INSTANCE`
           - `GOOGLE_APP_ENGINE_SERVICE`
           - `GOOGLE_CLOUD_PROJECT`
           - `HYBRIS_BIN_DIRECTORY`
           - `HYBRIS_CONFIG_DIRECTORY`
           - `HYBRIS_DATA_DIRECTORY`
           - `IBM_CICS_REGION`
           - `IBM_CTG_NAME`
           - `IBM_IMS_CONNECT_REGION`
           - `IBM_IMS_CONTROL_REGION`
           - `IBM_IMS_MESSAGE_PROCESSING_REGION`
           - `IBM_IMS_SOAP_GW_NAME`
           - `IBM_INTEGRATION_NODE_NAME`
           - `IBM_INTEGRATION_SERVER_NAME`
           - `IIS_APP_POOL`
           - `IIS_ROLE_NAME`
           - `JAVA_JAR_FILE`
           - `JAVA_JAR_PATH`
           - `JAVA_MAIN_CLASS`
           - `JAVA_MAIN_MODULE`
           - `JBOSS_HOME`
           - `JBOSS_MODE`
           - `JBOSS_SERVER_NAME`
           - `KUBERNETES_BASE_POD_NAME`
           - `KUBERNETES_CONTAINER_NAME`
           - `KUBERNETES_FULL_POD_NAME`
           - `KUBERNETES_NAMESPACE`
           - `KUBERNETES_POD_UID`
           - `MSSQL_INSTANCE_NAME`
           - `NODE_JS_APP_BASE_DIRECTORY`
           - `NODE_JS_APP_NAME`
           - `NODE_JS_SCRIPT_NAME`
           - `ORACLE_SID`
           - `PG_ID_CALC_INPUT_KEY_LINKAGE`
           - `PHP_SCRIPT_PATH`
           - `PHP_WORKING_DIRECTORY`
           - `RUBY_APP_ROOT_PATH`
           - `RUBY_SCRIPT_PATH`
           - `RULE_RESULT`
           - `SOFTWAREAG_INSTALL_ROOT`
           - `SOFTWAREAG_PRODUCTPROPNAME`
           - `SPRINGBOOT_APP_NAME`
           - `SPRINGBOOT_PROFILE_NAME`
           - `SPRINGBOOT_STARTUP_CLASS`
           - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
           - `TIBCO_BUSINESSWORKS_CE_VERSION`
           - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
           - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
           - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
           - `TIBCO_BUSINESS_WORKS_HOME`
           - `VARNISH_INSTANCE_NAME`
           - `WEB_LOGIC_CLUSTER_NAME`
           - `WEB_LOGIC_DOMAIN_NAME`
           - `WEB_LOGIC_HOME`
           - `WEB_LOGIC_NAME`
           - `WEB_SPHERE_CELL_NAME`
           - `WEB_SPHERE_CLUSTER_NAME`
           - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be `STRING`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionStringKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionStringKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionStringKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionStringKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        """
        :param str attribute: The attribute to be used for comparision
        :param str dynamic_key: The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
                  - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
                  - `AMAZON_ECR_IMAGE_REGION`
                  - `AMAZON_LAMBDA_FUNCTION_NAME`
                  - `AMAZON_REGION`
                  - `APACHE_CONFIG_PATH`
                  - `APACHE_SPARK_MASTER_IP_ADDRESS`
                  - `ASP_DOT_NET_CORE_APPLICATION_PATH`
                  - `AWS_ECS_CLUSTER`
                  - `AWS_ECS_CONTAINERNAME`
                  - `AWS_ECS_FAMILY`
                  - `AWS_ECS_REVISION`
                  - `CASSANDRA_CLUSTER_NAME`
                  - `CATALINA_BASE`
                  - `CATALINA_HOME`
                  - `CLOUD_FOUNDRY_APP_ID`
                  - `CLOUD_FOUNDRY_APP_NAME`
                  - `CLOUD_FOUNDRY_INSTANCE_INDEX`
                  - `CLOUD_FOUNDRY_SPACE_ID`
                  - `CLOUD_FOUNDRY_SPACE_NAME`
                  - `COLDFUSION_JVM_CONFIG_FILE`
                  - `COLDFUSION_SERVICE_NAME`
                  - `COMMAND_LINE_ARGS`
                  - `DOTNET_COMMAND`
                  - `DOTNET_COMMAND_PATH`
                  - `DYNATRACE_CLUSTER_ID`
                  - `DYNATRACE_NODE_ID`
                  - `ELASTICSEARCH_CLUSTER_NAME`
                  - `ELASTICSEARCH_NODE_NAME`
                  - `EQUINOX_CONFIG_PATH`
                  - `EXE_NAME`
                  - `EXE_PATH`
                  - `GLASS_FISH_DOMAIN_NAME`
                  - `GLASS_FISH_INSTANCE_NAME`
                  - `GOOGLE_APP_ENGINE_INSTANCE`
                  - `GOOGLE_APP_ENGINE_SERVICE`
                  - `GOOGLE_CLOUD_PROJECT`
                  - `HYBRIS_BIN_DIRECTORY`
                  - `HYBRIS_CONFIG_DIRECTORY`
                  - `HYBRIS_DATA_DIRECTORY`
                  - `IBM_CICS_REGION`
                  - `IBM_CTG_NAME`
                  - `IBM_IMS_CONNECT_REGION`
                  - `IBM_IMS_CONTROL_REGION`
                  - `IBM_IMS_MESSAGE_PROCESSING_REGION`
                  - `IBM_IMS_SOAP_GW_NAME`
                  - `IBM_INTEGRATION_NODE_NAME`
                  - `IBM_INTEGRATION_SERVER_NAME`
                  - `IIS_APP_POOL`
                  - `IIS_ROLE_NAME`
                  - `JAVA_JAR_FILE`
                  - `JAVA_JAR_PATH`
                  - `JAVA_MAIN_CLASS`
                  - `JAVA_MAIN_MODULE`
                  - `JBOSS_HOME`
                  - `JBOSS_MODE`
                  - `JBOSS_SERVER_NAME`
                  - `KUBERNETES_BASE_POD_NAME`
                  - `KUBERNETES_CONTAINER_NAME`
                  - `KUBERNETES_FULL_POD_NAME`
                  - `KUBERNETES_NAMESPACE`
                  - `KUBERNETES_POD_UID`
                  - `MSSQL_INSTANCE_NAME`
                  - `NODE_JS_APP_BASE_DIRECTORY`
                  - `NODE_JS_APP_NAME`
                  - `NODE_JS_SCRIPT_NAME`
                  - `ORACLE_SID`
                  - `PG_ID_CALC_INPUT_KEY_LINKAGE`
                  - `PHP_SCRIPT_PATH`
                  - `PHP_WORKING_DIRECTORY`
                  - `RUBY_APP_ROOT_PATH`
                  - `RUBY_SCRIPT_PATH`
                  - `RULE_RESULT`
                  - `SOFTWAREAG_INSTALL_ROOT`
                  - `SOFTWAREAG_PRODUCTPROPNAME`
                  - `SPRINGBOOT_APP_NAME`
                  - `SPRINGBOOT_PROFILE_NAME`
                  - `SPRINGBOOT_STARTUP_CLASS`
                  - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
                  - `TIBCO_BUSINESSWORKS_CE_VERSION`
                  - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
                  - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
                  - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
                  - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
                  - `TIBCO_BUSINESS_WORKS_HOME`
                  - `VARNISH_INSTANCE_NAME`
                  - `WEB_LOGIC_CLUSTER_NAME`
                  - `WEB_LOGIC_DOMAIN_NAME`
                  - `WEB_LOGIC_HOME`
                  - `WEB_LOGIC_NAME`
                  - `WEB_SPHERE_CELL_NAME`
                  - `WEB_SPHERE_CLUSTER_NAME`
                  - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to be used for comparision
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        """
        The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
           - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
           - `AMAZON_ECR_IMAGE_REGION`
           - `AMAZON_LAMBDA_FUNCTION_NAME`
           - `AMAZON_REGION`
           - `APACHE_CONFIG_PATH`
           - `APACHE_SPARK_MASTER_IP_ADDRESS`
           - `ASP_DOT_NET_CORE_APPLICATION_PATH`
           - `AWS_ECS_CLUSTER`
           - `AWS_ECS_CONTAINERNAME`
           - `AWS_ECS_FAMILY`
           - `AWS_ECS_REVISION`
           - `CASSANDRA_CLUSTER_NAME`
           - `CATALINA_BASE`
           - `CATALINA_HOME`
           - `CLOUD_FOUNDRY_APP_ID`
           - `CLOUD_FOUNDRY_APP_NAME`
           - `CLOUD_FOUNDRY_INSTANCE_INDEX`
           - `CLOUD_FOUNDRY_SPACE_ID`
           - `CLOUD_FOUNDRY_SPACE_NAME`
           - `COLDFUSION_JVM_CONFIG_FILE`
           - `COLDFUSION_SERVICE_NAME`
           - `COMMAND_LINE_ARGS`
           - `DOTNET_COMMAND`
           - `DOTNET_COMMAND_PATH`
           - `DYNATRACE_CLUSTER_ID`
           - `DYNATRACE_NODE_ID`
           - `ELASTICSEARCH_CLUSTER_NAME`
           - `ELASTICSEARCH_NODE_NAME`
           - `EQUINOX_CONFIG_PATH`
           - `EXE_NAME`
           - `EXE_PATH`
           - `GLASS_FISH_DOMAIN_NAME`
           - `GLASS_FISH_INSTANCE_NAME`
           - `GOOGLE_APP_ENGINE_INSTANCE`
           - `GOOGLE_APP_ENGINE_SERVICE`
           - `GOOGLE_CLOUD_PROJECT`
           - `HYBRIS_BIN_DIRECTORY`
           - `HYBRIS_CONFIG_DIRECTORY`
           - `HYBRIS_DATA_DIRECTORY`
           - `IBM_CICS_REGION`
           - `IBM_CTG_NAME`
           - `IBM_IMS_CONNECT_REGION`
           - `IBM_IMS_CONTROL_REGION`
           - `IBM_IMS_MESSAGE_PROCESSING_REGION`
           - `IBM_IMS_SOAP_GW_NAME`
           - `IBM_INTEGRATION_NODE_NAME`
           - `IBM_INTEGRATION_SERVER_NAME`
           - `IIS_APP_POOL`
           - `IIS_ROLE_NAME`
           - `JAVA_JAR_FILE`
           - `JAVA_JAR_PATH`
           - `JAVA_MAIN_CLASS`
           - `JAVA_MAIN_MODULE`
           - `JBOSS_HOME`
           - `JBOSS_MODE`
           - `JBOSS_SERVER_NAME`
           - `KUBERNETES_BASE_POD_NAME`
           - `KUBERNETES_CONTAINER_NAME`
           - `KUBERNETES_FULL_POD_NAME`
           - `KUBERNETES_NAMESPACE`
           - `KUBERNETES_POD_UID`
           - `MSSQL_INSTANCE_NAME`
           - `NODE_JS_APP_BASE_DIRECTORY`
           - `NODE_JS_APP_NAME`
           - `NODE_JS_SCRIPT_NAME`
           - `ORACLE_SID`
           - `PG_ID_CALC_INPUT_KEY_LINKAGE`
           - `PHP_SCRIPT_PATH`
           - `PHP_WORKING_DIRECTORY`
           - `RUBY_APP_ROOT_PATH`
           - `RUBY_SCRIPT_PATH`
           - `RULE_RESULT`
           - `SOFTWAREAG_INSTALL_ROOT`
           - `SOFTWAREAG_PRODUCTPROPNAME`
           - `SPRINGBOOT_APP_NAME`
           - `SPRINGBOOT_PROFILE_NAME`
           - `SPRINGBOOT_STARTUP_CLASS`
           - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
           - `TIBCO_BUSINESSWORKS_CE_VERSION`
           - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
           - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
           - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
           - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
           - `TIBCO_BUSINESS_WORKS_HOME`
           - `VARNISH_INSTANCE_NAME`
           - `WEB_LOGIC_CLUSTER_NAME`
           - `WEB_LOGIC_DOMAIN_NAME`
           - `WEB_LOGIC_HOME`
           - `WEB_LOGIC_NAME`
           - `WEB_SPHERE_CELL_NAME`
           - `WEB_SPHERE_CLUSTER_NAME`
           - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
        """
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionSyntheticEngine(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionSyntheticEngineTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str operator: Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be SYNTHETIC_ENGINE_TYPE
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be SYNTHETIC_ENGINE_TYPE
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare to. Possible values are CLASSIC and CUSTOM
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionTagValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'ServiceNamingConditionConditionTagValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionTagValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionTagComparisonValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str type: if specified, needs to be TAG
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'ServiceNamingConditionConditionTagComparisonValueArgs' value: Tag of a Dynatrace entity
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The value of the attribute type is implicit, therefore shouldn't get specified""")
    def type(self) -> Optional[str]:
        """
        if specified, needs to be TAG
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionTagComparisonValue']:
        """
        Tag of a Dynatrace entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str unknowns: Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionTechValue'] = None):
        """
        :param str operator: Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        :param bool negate: Reverses the operator. For example it turns the **begins with** into **does not begin with**
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param 'ServiceNamingConditionConditionTechValueArgs' value: The value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Reverses the operator. For example it turns the **begins with** into **does not begin with**
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionTechValue']:
        """
        The value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        """
        :param str type: Predefined technology, if technology is not predefined, then the verbatim type must be set.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str verbatim_type: Non-predefined technology, use for custom technologies
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Predefined technology, if technology is not predefined, then the verbatim type must be set.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        """
        Non-predefined technology, use for custom technologies
        """
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class SessionReplayWebPrivacyMaskingPresets(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "playbackMaskingPreset":
            suggest = "playback_masking_preset"
        elif key == "recordingMaskingPreset":
            suggest = "recording_masking_preset"
        elif key == "playbackMaskingAllowListRules":
            suggest = "playback_masking_allow_list_rules"
        elif key == "playbackMaskingBlockListRules":
            suggest = "playback_masking_block_list_rules"
        elif key == "recordingMaskingAllowListRules":
            suggest = "recording_masking_allow_list_rules"
        elif key == "recordingMaskingBlockListRules":
            suggest = "recording_masking_block_list_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionReplayWebPrivacyMaskingPresets. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionReplayWebPrivacyMaskingPresets.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionReplayWebPrivacyMaskingPresets.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 playback_masking_preset: str,
                 recording_masking_preset: str,
                 playback_masking_allow_list_rules: Optional['outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRules'] = None,
                 playback_masking_block_list_rules: Optional['outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRules'] = None,
                 recording_masking_allow_list_rules: Optional['outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRules'] = None,
                 recording_masking_block_list_rules: Optional['outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRules'] = None):
        """
        :param str playback_masking_preset: (Field has overlap with `ApplicationDataPrivacy`) Possible Values: `MASK_ALL`, `MASK_USER_INPUT`, `ALLOW_LIST`, `BLOCK_LIST`
        :param str recording_masking_preset: (Field has overlap with `ApplicationDataPrivacy`) Possible Values: `MASK_USER_INPUT`, `ALLOW_LIST`, `BLOCK_LIST`, `MASK_ALL`
        :param 'SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRulesArgs' playback_masking_allow_list_rules: (Field has overlap with `ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
        :param 'SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRulesArgs' playback_masking_block_list_rules: (Field has overlap with `ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
        :param 'SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRulesArgs' recording_masking_allow_list_rules: (Field has overlap with `ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
        :param 'SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRulesArgs' recording_masking_block_list_rules: (Field has overlap with `ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
        """
        pulumi.set(__self__, "playback_masking_preset", playback_masking_preset)
        pulumi.set(__self__, "recording_masking_preset", recording_masking_preset)
        if playback_masking_allow_list_rules is not None:
            pulumi.set(__self__, "playback_masking_allow_list_rules", playback_masking_allow_list_rules)
        if playback_masking_block_list_rules is not None:
            pulumi.set(__self__, "playback_masking_block_list_rules", playback_masking_block_list_rules)
        if recording_masking_allow_list_rules is not None:
            pulumi.set(__self__, "recording_masking_allow_list_rules", recording_masking_allow_list_rules)
        if recording_masking_block_list_rules is not None:
            pulumi.set(__self__, "recording_masking_block_list_rules", recording_masking_block_list_rules)

    @property
    @pulumi.getter(name="playbackMaskingPreset")
    def playback_masking_preset(self) -> str:
        """
        (Field has overlap with `ApplicationDataPrivacy`) Possible Values: `MASK_ALL`, `MASK_USER_INPUT`, `ALLOW_LIST`, `BLOCK_LIST`
        """
        return pulumi.get(self, "playback_masking_preset")

    @property
    @pulumi.getter(name="recordingMaskingPreset")
    def recording_masking_preset(self) -> str:
        """
        (Field has overlap with `ApplicationDataPrivacy`) Possible Values: `MASK_USER_INPUT`, `ALLOW_LIST`, `BLOCK_LIST`, `MASK_ALL`
        """
        return pulumi.get(self, "recording_masking_preset")

    @property
    @pulumi.getter(name="playbackMaskingAllowListRules")
    def playback_masking_allow_list_rules(self) -> Optional['outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRules']:
        """
        (Field has overlap with `ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
        """
        return pulumi.get(self, "playback_masking_allow_list_rules")

    @property
    @pulumi.getter(name="playbackMaskingBlockListRules")
    def playback_masking_block_list_rules(self) -> Optional['outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRules']:
        """
        (Field has overlap with `ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
        """
        return pulumi.get(self, "playback_masking_block_list_rules")

    @property
    @pulumi.getter(name="recordingMaskingAllowListRules")
    def recording_masking_allow_list_rules(self) -> Optional['outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRules']:
        """
        (Field has overlap with `ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
        """
        return pulumi.get(self, "recording_masking_allow_list_rules")

    @property
    @pulumi.getter(name="recordingMaskingBlockListRules")
    def recording_masking_block_list_rules(self) -> Optional['outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRules']:
        """
        (Field has overlap with `ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
        """
        return pulumi.get(self, "recording_masking_block_list_rules")


@pulumi.output_type
class SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowListRules":
            suggest = "allow_list_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_list_rules: Sequence['outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRulesAllowListRule']):
        pulumi.set(__self__, "allow_list_rules", allow_list_rules)

    @property
    @pulumi.getter(name="allowListRules")
    def allow_list_rules(self) -> Sequence['outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRulesAllowListRule']:
        return pulumi.get(self, "allow_list_rules")


@pulumi.output_type
class SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRulesAllowListRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeExpression":
            suggest = "attribute_expression"
        elif key == "cssExpression":
            suggest = "css_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRulesAllowListRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRulesAllowListRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRulesAllowListRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: str,
                 attribute_expression: Optional[str] = None,
                 css_expression: Optional[str] = None):
        """
        :param str target: Possible Values: `ATTRIBUTE`, `ELEMENT`
        :param str attribute_expression: Attribute masking can be applied to web applications that store data within attributes, typically data-NAME attributes in HTML5. When you define attributes, their values are masked while recording but not removed.
        :param str css_expression: Content masking can be applied to webpages where personal data is displayed. When content masking is applied to parent elements, all child elements are masked by default.
        """
        pulumi.set(__self__, "target", target)
        if attribute_expression is not None:
            pulumi.set(__self__, "attribute_expression", attribute_expression)
        if css_expression is not None:
            pulumi.set(__self__, "css_expression", css_expression)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Possible Values: `ATTRIBUTE`, `ELEMENT`
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="attributeExpression")
    def attribute_expression(self) -> Optional[str]:
        """
        Attribute masking can be applied to web applications that store data within attributes, typically data-NAME attributes in HTML5. When you define attributes, their values are masked while recording but not removed.
        """
        return pulumi.get(self, "attribute_expression")

    @property
    @pulumi.getter(name="cssExpression")
    def css_expression(self) -> Optional[str]:
        """
        Content masking can be applied to webpages where personal data is displayed. When content masking is applied to parent elements, all child elements are masked by default.
        """
        return pulumi.get(self, "css_expression")


@pulumi.output_type
class SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockListRules":
            suggest = "block_list_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_list_rules: Sequence['outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRulesBlockListRule']):
        pulumi.set(__self__, "block_list_rules", block_list_rules)

    @property
    @pulumi.getter(name="blockListRules")
    def block_list_rules(self) -> Sequence['outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRulesBlockListRule']:
        return pulumi.get(self, "block_list_rules")


@pulumi.output_type
class SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRulesBlockListRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeExpression":
            suggest = "attribute_expression"
        elif key == "cssExpression":
            suggest = "css_expression"
        elif key == "hideUserInteraction":
            suggest = "hide_user_interaction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRulesBlockListRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRulesBlockListRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRulesBlockListRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: str,
                 attribute_expression: Optional[str] = None,
                 css_expression: Optional[str] = None,
                 hide_user_interaction: Optional[bool] = None):
        """
        :param str target: Possible Values: `ELEMENT`, `ATTRIBUTE`
        :param str attribute_expression: Attribute masking can be applied to web applications that store data within attributes, typically data-NAME attributes in HTML5. When you define attributes, their values are masked while recording but not removed.
        :param str css_expression: Content masking can be applied to webpages where personal data is displayed. When content masking is applied to parent elements, all child elements are masked by default.
        :param bool hide_user_interaction: Hide user interactions with these elements, including clicks that expand elements, highlighting that results from hovering a cursor over an option, and selection of specific form options.
        """
        pulumi.set(__self__, "target", target)
        if attribute_expression is not None:
            pulumi.set(__self__, "attribute_expression", attribute_expression)
        if css_expression is not None:
            pulumi.set(__self__, "css_expression", css_expression)
        if hide_user_interaction is not None:
            pulumi.set(__self__, "hide_user_interaction", hide_user_interaction)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Possible Values: `ELEMENT`, `ATTRIBUTE`
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="attributeExpression")
    def attribute_expression(self) -> Optional[str]:
        """
        Attribute masking can be applied to web applications that store data within attributes, typically data-NAME attributes in HTML5. When you define attributes, their values are masked while recording but not removed.
        """
        return pulumi.get(self, "attribute_expression")

    @property
    @pulumi.getter(name="cssExpression")
    def css_expression(self) -> Optional[str]:
        """
        Content masking can be applied to webpages where personal data is displayed. When content masking is applied to parent elements, all child elements are masked by default.
        """
        return pulumi.get(self, "css_expression")

    @property
    @pulumi.getter(name="hideUserInteraction")
    def hide_user_interaction(self) -> Optional[bool]:
        """
        Hide user interactions with these elements, including clicks that expand elements, highlighting that results from hovering a cursor over an option, and selection of specific form options.
        """
        return pulumi.get(self, "hide_user_interaction")


@pulumi.output_type
class SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowListRules":
            suggest = "allow_list_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_list_rules: Sequence['outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRulesAllowListRule']):
        pulumi.set(__self__, "allow_list_rules", allow_list_rules)

    @property
    @pulumi.getter(name="allowListRules")
    def allow_list_rules(self) -> Sequence['outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRulesAllowListRule']:
        return pulumi.get(self, "allow_list_rules")


@pulumi.output_type
class SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRulesAllowListRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeExpression":
            suggest = "attribute_expression"
        elif key == "cssExpression":
            suggest = "css_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRulesAllowListRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRulesAllowListRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRulesAllowListRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: str,
                 attribute_expression: Optional[str] = None,
                 css_expression: Optional[str] = None):
        """
        :param str target: Possible Values: `ATTRIBUTE`, `ELEMENT`
        :param str attribute_expression: Attribute masking can be applied to web applications that store data within attributes, typically data-NAME attributes in HTML5. When you define attributes, their values are masked while recording but not removed.
        :param str css_expression: Content masking can be applied to webpages where personal data is displayed. When content masking is applied to parent elements, all child elements are masked by default.
        """
        pulumi.set(__self__, "target", target)
        if attribute_expression is not None:
            pulumi.set(__self__, "attribute_expression", attribute_expression)
        if css_expression is not None:
            pulumi.set(__self__, "css_expression", css_expression)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Possible Values: `ATTRIBUTE`, `ELEMENT`
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="attributeExpression")
    def attribute_expression(self) -> Optional[str]:
        """
        Attribute masking can be applied to web applications that store data within attributes, typically data-NAME attributes in HTML5. When you define attributes, their values are masked while recording but not removed.
        """
        return pulumi.get(self, "attribute_expression")

    @property
    @pulumi.getter(name="cssExpression")
    def css_expression(self) -> Optional[str]:
        """
        Content masking can be applied to webpages where personal data is displayed. When content masking is applied to parent elements, all child elements are masked by default.
        """
        return pulumi.get(self, "css_expression")


@pulumi.output_type
class SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockListRules":
            suggest = "block_list_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_list_rules: Sequence['outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRulesBlockListRule']):
        pulumi.set(__self__, "block_list_rules", block_list_rules)

    @property
    @pulumi.getter(name="blockListRules")
    def block_list_rules(self) -> Sequence['outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRulesBlockListRule']:
        return pulumi.get(self, "block_list_rules")


@pulumi.output_type
class SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRulesBlockListRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeExpression":
            suggest = "attribute_expression"
        elif key == "cssExpression":
            suggest = "css_expression"
        elif key == "hideUserInteraction":
            suggest = "hide_user_interaction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRulesBlockListRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRulesBlockListRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRulesBlockListRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: str,
                 attribute_expression: Optional[str] = None,
                 css_expression: Optional[str] = None,
                 hide_user_interaction: Optional[bool] = None):
        """
        :param str target: Possible Values: `ELEMENT`, `ATTRIBUTE`
        :param str attribute_expression: Attribute masking can be applied to web applications that store data within attributes, typically data-NAME attributes in HTML5. When you define attributes, their values are masked while recording but not removed.
        :param str css_expression: Content masking can be applied to webpages where personal data is displayed. When content masking is applied to parent elements, all child elements are masked by default.
        :param bool hide_user_interaction: Hide user interactions with these elements, including clicks that expand elements, highlighting that results from hovering a cursor over an option, and selection of specific form options.
        """
        pulumi.set(__self__, "target", target)
        if attribute_expression is not None:
            pulumi.set(__self__, "attribute_expression", attribute_expression)
        if css_expression is not None:
            pulumi.set(__self__, "css_expression", css_expression)
        if hide_user_interaction is not None:
            pulumi.set(__self__, "hide_user_interaction", hide_user_interaction)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Possible Values: `ELEMENT`, `ATTRIBUTE`
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="attributeExpression")
    def attribute_expression(self) -> Optional[str]:
        """
        Attribute masking can be applied to web applications that store data within attributes, typically data-NAME attributes in HTML5. When you define attributes, their values are masked while recording but not removed.
        """
        return pulumi.get(self, "attribute_expression")

    @property
    @pulumi.getter(name="cssExpression")
    def css_expression(self) -> Optional[str]:
        """
        Content masking can be applied to webpages where personal data is displayed. When content masking is applied to parent elements, all child elements are masked by default.
        """
        return pulumi.get(self, "css_expression")

    @property
    @pulumi.getter(name="hideUserInteraction")
    def hide_user_interaction(self) -> Optional[bool]:
        """
        Hide user interactions with these elements, including clicks that expand elements, highlighting that results from hovering a cursor over an option, and selection of specific form options.
        """
        return pulumi.get(self, "hide_user_interaction")


@pulumi.output_type
class SiteReliabilityGuardianObjectives(dict):
    def __init__(__self__, *,
                 objectives: Sequence['outputs.SiteReliabilityGuardianObjectivesObjective']):
        pulumi.set(__self__, "objectives", objectives)

    @property
    @pulumi.getter
    def objectives(self) -> Sequence['outputs.SiteReliabilityGuardianObjectivesObjective']:
        return pulumi.get(self, "objectives")


@pulumi.output_type
class SiteReliabilityGuardianObjectivesObjective(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "objectiveType":
            suggest = "objective_type"
        elif key == "autoAdaptiveThresholdEnabled":
            suggest = "auto_adaptive_threshold_enabled"
        elif key == "dqlQuery":
            suggest = "dql_query"
        elif key == "referenceSlo":
            suggest = "reference_slo"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SiteReliabilityGuardianObjectivesObjective. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SiteReliabilityGuardianObjectivesObjective.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SiteReliabilityGuardianObjectivesObjective.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: str,
                 name: str,
                 objective_type: str,
                 auto_adaptive_threshold_enabled: Optional[bool] = None,
                 description: Optional[str] = None,
                 dql_query: Optional[str] = None,
                 reference_slo: Optional[str] = None,
                 target: Optional[float] = None,
                 warning: Optional[float] = None):
        """
        :param str comparison_operator: Possible Values: `GREATER_THAN_OR_EQUAL`, `LESS_THAN_OR_EQUAL`
        :param str name: Objective name
        :param str objective_type: Possible Values: `DQL`, `REFERENCE_SLO`
        :param bool auto_adaptive_threshold_enabled: Enable auto adaptive threshold
        :param str description: no documentation available
        :param str dql_query: DQL query
        :param str reference_slo: Please enter the metric key of your desired SLO. SLO metric keys have to start with 'func:slo.'
        :param float target: no documentation available
        :param float warning: no documentation available
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "objective_type", objective_type)
        if auto_adaptive_threshold_enabled is not None:
            pulumi.set(__self__, "auto_adaptive_threshold_enabled", auto_adaptive_threshold_enabled)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dql_query is not None:
            pulumi.set(__self__, "dql_query", dql_query)
        if reference_slo is not None:
            pulumi.set(__self__, "reference_slo", reference_slo)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> str:
        """
        Possible Values: `GREATER_THAN_OR_EQUAL`, `LESS_THAN_OR_EQUAL`
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Objective name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="objectiveType")
    def objective_type(self) -> str:
        """
        Possible Values: `DQL`, `REFERENCE_SLO`
        """
        return pulumi.get(self, "objective_type")

    @property
    @pulumi.getter(name="autoAdaptiveThresholdEnabled")
    def auto_adaptive_threshold_enabled(self) -> Optional[bool]:
        """
        Enable auto adaptive threshold
        """
        return pulumi.get(self, "auto_adaptive_threshold_enabled")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dqlQuery")
    def dql_query(self) -> Optional[str]:
        """
        DQL query
        """
        return pulumi.get(self, "dql_query")

    @property
    @pulumi.getter(name="referenceSlo")
    def reference_slo(self) -> Optional[str]:
        """
        Please enter the metric key of your desired SLO. SLO metric keys have to start with 'func:slo.'
        """
        return pulumi.get(self, "reference_slo")

    @property
    @pulumi.getter
    def target(self) -> Optional[float]:
        """
        no documentation available
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def warning(self) -> Optional[float]:
        """
        no documentation available
        """
        return pulumi.get(self, "warning")


@pulumi.output_type
class SiteReliabilityGuardianVariables(dict):
    def __init__(__self__, *,
                 variables: Sequence['outputs.SiteReliabilityGuardianVariablesVariable']):
        pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def variables(self) -> Sequence['outputs.SiteReliabilityGuardianVariablesVariable']:
        return pulumi.get(self, "variables")


@pulumi.output_type
class SiteReliabilityGuardianVariablesVariable(dict):
    def __init__(__self__, *,
                 definition: str,
                 name: str):
        """
        :param str definition: Value
        :param str name: no documentation available
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Value
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SloErrorBudgetBurnRate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "burnRateVisualizationEnabled":
            suggest = "burn_rate_visualization_enabled"
        elif key == "fastBurnThreshold":
            suggest = "fast_burn_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloErrorBudgetBurnRate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloErrorBudgetBurnRate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloErrorBudgetBurnRate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 burn_rate_visualization_enabled: Optional[bool] = None,
                 fast_burn_threshold: Optional[float] = None):
        """
        :param bool burn_rate_visualization_enabled: The error budget burn rate calculation is enabled (true) or disabled (false).
        :param float fast_burn_threshold: The threshold between a slow and a fast burn rate.
        """
        if burn_rate_visualization_enabled is not None:
            pulumi.set(__self__, "burn_rate_visualization_enabled", burn_rate_visualization_enabled)
        if fast_burn_threshold is not None:
            pulumi.set(__self__, "fast_burn_threshold", fast_burn_threshold)

    @property
    @pulumi.getter(name="burnRateVisualizationEnabled")
    def burn_rate_visualization_enabled(self) -> Optional[bool]:
        """
        The error budget burn rate calculation is enabled (true) or disabled (false).
        """
        return pulumi.get(self, "burn_rate_visualization_enabled")

    @property
    @pulumi.getter(name="fastBurnThreshold")
    def fast_burn_threshold(self) -> Optional[float]:
        """
        The threshold between a slow and a fast burn rate.
        """
        return pulumi.get(self, "fast_burn_threshold")


@pulumi.output_type
class SloV2ErrorBudgetBurnRate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "burnRateVisualizationEnabled":
            suggest = "burn_rate_visualization_enabled"
        elif key == "fastBurnThreshold":
            suggest = "fast_burn_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloV2ErrorBudgetBurnRate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloV2ErrorBudgetBurnRate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloV2ErrorBudgetBurnRate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 burn_rate_visualization_enabled: bool,
                 fast_burn_threshold: Optional[float] = None):
        """
        :param bool burn_rate_visualization_enabled: Burn rate visualization enabled
        :param float fast_burn_threshold: The threshold defines when a burn rate is marked as fast-burning (high-emergency). Burn rates lower than this threshold (and greater than 1) are highlighted as slow-burn (low-emergency).
        """
        pulumi.set(__self__, "burn_rate_visualization_enabled", burn_rate_visualization_enabled)
        if fast_burn_threshold is not None:
            pulumi.set(__self__, "fast_burn_threshold", fast_burn_threshold)

    @property
    @pulumi.getter(name="burnRateVisualizationEnabled")
    def burn_rate_visualization_enabled(self) -> bool:
        """
        Burn rate visualization enabled
        """
        return pulumi.get(self, "burn_rate_visualization_enabled")

    @property
    @pulumi.getter(name="fastBurnThreshold")
    def fast_burn_threshold(self) -> Optional[float]:
        """
        The threshold defines when a burn rate is marked as fast-burning (high-emergency). Burn rates lower than this threshold (and greater than 1) are highlighted as slow-burn (low-emergency).
        """
        return pulumi.get(self, "fast_burn_threshold")


@pulumi.output_type
class SpanCaptureRuleMatches(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.SpanCaptureRuleMatchesMatch']):
        """
        :param Sequence['SpanCaptureRuleMatchesMatchArgs'] matches: Matching strategies for the Span
        """
        pulumi.set(__self__, "matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.SpanCaptureRuleMatchesMatch']:
        """
        Matching strategies for the Span
        """
        return pulumi.get(self, "matches")


@pulumi.output_type
class SpanCaptureRuleMatchesMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpanCaptureRuleMatchesMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpanCaptureRuleMatchesMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpanCaptureRuleMatchesMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison: str,
                 source: str,
                 case_sensitive: Optional[bool] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str comparison: Possible values are `EQUALS`, `CONTAINS`, `STARTS_WITH`, `ENDS_WITH`, `DOES_NOT_EQUAL`, `DOES_NOT_CONTAIN`, `DOES_NOT_START_WITH` and `DOES_NOT_END_WITH`.
        :param str source: What to match against. Possible values are `SPAN_NAME`, `SPAN_KIND`, `ATTRIBUTE`, `INSTRUMENTATION_LIBRARY_NAME` and `INSTRUMENTATION_LIBRARY_VERSION`
        :param bool case_sensitive: Whether to match strings case sensitively or not
        :param str key: The name of the attribute if `source` is `ATTRIBUTE`
        :param str value: The value to compare against. When `source` is `SPAN_KIND` the only allowed values are `INTERNAL`, `SERVER`, `CLIENT`, `PRODUCER` and `CONSUMER`
        """
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "source", source)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparison(self) -> str:
        """
        Possible values are `EQUALS`, `CONTAINS`, `STARTS_WITH`, `ENDS_WITH`, `DOES_NOT_EQUAL`, `DOES_NOT_CONTAIN`, `DOES_NOT_START_WITH` and `DOES_NOT_END_WITH`.
        """
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        What to match against. Possible values are `SPAN_NAME`, `SPAN_KIND`, `ATTRIBUTE`, `INSTRUMENTATION_LIBRARY_NAME` and `INSTRUMENTATION_LIBRARY_VERSION`
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        Whether to match strings case sensitively or not
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The name of the attribute if `source` is `ATTRIBUTE`
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare against. When `source` is `SPAN_KIND` the only allowed values are `INTERNAL`, `SERVER`, `CLIENT`, `PRODUCER` and `CONSUMER`
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SpanContextPropagationMatches(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.SpanContextPropagationMatchesMatch']):
        """
        :param Sequence['SpanContextPropagationMatchesMatchArgs'] matches: Matching strategies for the Span
        """
        pulumi.set(__self__, "matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.SpanContextPropagationMatchesMatch']:
        """
        Matching strategies for the Span
        """
        return pulumi.get(self, "matches")


@pulumi.output_type
class SpanContextPropagationMatchesMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpanContextPropagationMatchesMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpanContextPropagationMatchesMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpanContextPropagationMatchesMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison: str,
                 source: str,
                 case_sensitive: Optional[bool] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str comparison: Possible values are `EQUALS`, `CONTAINS`, `STARTS_WITH`, `ENDS_WITH`, `DOES_NOT_EQUAL`, `DOES_NOT_CONTAIN`, `DOES_NOT_START_WITH` and `DOES_NOT_END_WITH`.
        :param str source: What to match against. Possible values are `SPAN_NAME`, `SPAN_KIND`, `ATTRIBUTE`, `INSTRUMENTATION_LIBRARY_NAME` and `INSTRUMENTATION_LIBRARY_VERSION`
        :param bool case_sensitive: Whether to match strings case sensitively or not
        :param str key: The name of the attribute if `source` is `ATTRIBUTE`
        :param str value: The value to compare against. When `source` is `SPAN_KIND` the only allowed values are `INTERNAL`, `SERVER`, `CLIENT`, `PRODUCER` and `CONSUMER`
        """
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "source", source)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparison(self) -> str:
        """
        Possible values are `EQUALS`, `CONTAINS`, `STARTS_WITH`, `ENDS_WITH`, `DOES_NOT_EQUAL`, `DOES_NOT_CONTAIN`, `DOES_NOT_START_WITH` and `DOES_NOT_END_WITH`.
        """
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        What to match against. Possible values are `SPAN_NAME`, `SPAN_KIND`, `ATTRIBUTE`, `INSTRUMENTATION_LIBRARY_NAME` and `INSTRUMENTATION_LIBRARY_VERSION`
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        Whether to match strings case sensitively or not
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The name of the attribute if `source` is `ATTRIBUTE`
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare against. When `source` is `SPAN_KIND` the only allowed values are `INTERNAL`, `SERVER`, `CLIENT`, `PRODUCER` and `CONSUMER`
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SpanEntryPointMatches(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.SpanEntryPointMatchesMatch']):
        """
        :param Sequence['SpanEntryPointMatchesMatchArgs'] matches: Matching strategies for the Span
        """
        pulumi.set(__self__, "matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.SpanEntryPointMatchesMatch']:
        """
        Matching strategies for the Span
        """
        return pulumi.get(self, "matches")


@pulumi.output_type
class SpanEntryPointMatchesMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpanEntryPointMatchesMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpanEntryPointMatchesMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpanEntryPointMatchesMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison: str,
                 source: str,
                 case_sensitive: Optional[bool] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str comparison: Possible values are `EQUALS`, `CONTAINS`, `STARTS_WITH`, `ENDS_WITH`, `DOES_NOT_EQUAL`, `DOES_NOT_CONTAIN`, `DOES_NOT_START_WITH` and `DOES_NOT_END_WITH`.
        :param str source: What to match against. Possible values are `SPAN_NAME`, `SPAN_KIND`, `ATTRIBUTE`, `INSTRUMENTATION_LIBRARY_NAME` and `INSTRUMENTATION_LIBRARY_VERSION`
        :param bool case_sensitive: Whether to match strings case sensitively or not
        :param str key: The name of the attribute if `source` is `ATTRIBUTE`
        :param str value: The value to compare against. When `source` is `SPAN_KIND` the only allowed values are `INTERNAL`, `SERVER`, `CLIENT`, `PRODUCER` and `CONSUMER`
        """
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "source", source)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparison(self) -> str:
        """
        Possible values are `EQUALS`, `CONTAINS`, `STARTS_WITH`, `ENDS_WITH`, `DOES_NOT_EQUAL`, `DOES_NOT_CONTAIN`, `DOES_NOT_START_WITH` and `DOES_NOT_END_WITH`.
        """
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        What to match against. Possible values are `SPAN_NAME`, `SPAN_KIND`, `ATTRIBUTE`, `INSTRUMENTATION_LIBRARY_NAME` and `INSTRUMENTATION_LIBRARY_VERSION`
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        Whether to match strings case sensitively or not
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The name of the attribute if `source` is `ATTRIBUTE`
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to compare against. When `source` is `SPAN_KIND` the only allowed values are `INTERNAL`, `SERVER`, `CLIENT`, `PRODUCER` and `CONSUMER`
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class UpdateWindowsDailyRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurrenceRange":
            suggest = "recurrence_range"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateWindowsDailyRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateWindowsDailyRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateWindowsDailyRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 every: int,
                 recurrence_range: 'outputs.UpdateWindowsDailyRecurrenceRecurrenceRange',
                 update_time: 'outputs.UpdateWindowsDailyRecurrenceUpdateTime'):
        """
        :param int every: Every **X** days:
               * `1` = every day,
               * `2` = every two days,
               * `3` = every three days,
               * etc.
        :param 'UpdateWindowsDailyRecurrenceRecurrenceRangeArgs' recurrence_range: Recurrence range
        :param 'UpdateWindowsDailyRecurrenceUpdateTimeArgs' update_time: Update time
        """
        pulumi.set(__self__, "every", every)
        pulumi.set(__self__, "recurrence_range", recurrence_range)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def every(self) -> int:
        """
        Every **X** days:
        * `1` = every day,
        * `2` = every two days,
        * `3` = every three days,
        * etc.
        """
        return pulumi.get(self, "every")

    @property
    @pulumi.getter(name="recurrenceRange")
    def recurrence_range(self) -> 'outputs.UpdateWindowsDailyRecurrenceRecurrenceRange':
        """
        Recurrence range
        """
        return pulumi.get(self, "recurrence_range")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> 'outputs.UpdateWindowsDailyRecurrenceUpdateTime':
        """
        Update time
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class UpdateWindowsDailyRecurrenceRecurrenceRange(dict):
    def __init__(__self__, *,
                 end: str,
                 start: str):
        """
        :param str end: no documentation available
        :param str start: no documentation available
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class UpdateWindowsDailyRecurrenceUpdateTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateWindowsDailyRecurrenceUpdateTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateWindowsDailyRecurrenceUpdateTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateWindowsDailyRecurrenceUpdateTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: int,
                 start_time: str,
                 time_zone: str):
        """
        :param int duration: Duration (minutes)
        :param str start_time: Start time (24-hour clock)
        :param str time_zone: Possible Values: `GMT_06_00`, `GMT_12_00`, `GMT_10_00`, `GMT_07_00`, `GMT_00_00`, `GMT_11_00`, `GMT_03_00`, `GMT_01_00`, `GMT_05_00`, `GMT_09_00`, `GMT_02_00`, `GMT_04_00`, `GMT_08_00`
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def duration(self) -> int:
        """
        Duration (minutes)
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        Start time (24-hour clock)
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        Possible Values: `GMT_06_00`, `GMT_12_00`, `GMT_10_00`, `GMT_07_00`, `GMT_00_00`, `GMT_11_00`, `GMT_03_00`, `GMT_01_00`, `GMT_05_00`, `GMT_09_00`, `GMT_02_00`, `GMT_04_00`, `GMT_08_00`
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class UpdateWindowsMonthlyRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurrenceRange":
            suggest = "recurrence_range"
        elif key == "selectedMonthDay":
            suggest = "selected_month_day"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateWindowsMonthlyRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateWindowsMonthlyRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateWindowsMonthlyRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 every: int,
                 recurrence_range: 'outputs.UpdateWindowsMonthlyRecurrenceRecurrenceRange',
                 selected_month_day: int,
                 update_time: 'outputs.UpdateWindowsMonthlyRecurrenceUpdateTime'):
        """
        :param int every: Every **X** months:
               * `1` = every month,
               * `2` = every two months,
               * `3` = every three months,
               * etc.
        :param 'UpdateWindowsMonthlyRecurrenceRecurrenceRangeArgs' recurrence_range: Recurrence range
        :param int selected_month_day: Day of the month
        :param 'UpdateWindowsMonthlyRecurrenceUpdateTimeArgs' update_time: Update time
        """
        pulumi.set(__self__, "every", every)
        pulumi.set(__self__, "recurrence_range", recurrence_range)
        pulumi.set(__self__, "selected_month_day", selected_month_day)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def every(self) -> int:
        """
        Every **X** months:
        * `1` = every month,
        * `2` = every two months,
        * `3` = every three months,
        * etc.
        """
        return pulumi.get(self, "every")

    @property
    @pulumi.getter(name="recurrenceRange")
    def recurrence_range(self) -> 'outputs.UpdateWindowsMonthlyRecurrenceRecurrenceRange':
        """
        Recurrence range
        """
        return pulumi.get(self, "recurrence_range")

    @property
    @pulumi.getter(name="selectedMonthDay")
    def selected_month_day(self) -> int:
        """
        Day of the month
        """
        return pulumi.get(self, "selected_month_day")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> 'outputs.UpdateWindowsMonthlyRecurrenceUpdateTime':
        """
        Update time
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class UpdateWindowsMonthlyRecurrenceRecurrenceRange(dict):
    def __init__(__self__, *,
                 end: str,
                 start: str):
        """
        :param str end: no documentation available
        :param str start: no documentation available
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class UpdateWindowsMonthlyRecurrenceUpdateTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateWindowsMonthlyRecurrenceUpdateTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateWindowsMonthlyRecurrenceUpdateTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateWindowsMonthlyRecurrenceUpdateTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: int,
                 start_time: str,
                 time_zone: str):
        """
        :param int duration: Duration (minutes)
        :param str start_time: Start time (24-hour clock)
        :param str time_zone: Possible Values: `GMT_06_00`, `GMT_12_00`, `GMT_10_00`, `GMT_07_00`, `GMT_00_00`, `GMT_11_00`, `GMT_03_00`, `GMT_01_00`, `GMT_05_00`, `GMT_09_00`, `GMT_02_00`, `GMT_04_00`, `GMT_08_00`
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def duration(self) -> int:
        """
        Duration (minutes)
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        Start time (24-hour clock)
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        Possible Values: `GMT_06_00`, `GMT_12_00`, `GMT_10_00`, `GMT_07_00`, `GMT_00_00`, `GMT_11_00`, `GMT_03_00`, `GMT_01_00`, `GMT_05_00`, `GMT_09_00`, `GMT_02_00`, `GMT_04_00`, `GMT_08_00`
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class UpdateWindowsOnceRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurrenceRange":
            suggest = "recurrence_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateWindowsOnceRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateWindowsOnceRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateWindowsOnceRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recurrence_range: 'outputs.UpdateWindowsOnceRecurrenceRecurrenceRange'):
        """
        :param 'UpdateWindowsOnceRecurrenceRecurrenceRangeArgs' recurrence_range: Update time
        """
        pulumi.set(__self__, "recurrence_range", recurrence_range)

    @property
    @pulumi.getter(name="recurrenceRange")
    def recurrence_range(self) -> 'outputs.UpdateWindowsOnceRecurrenceRecurrenceRange':
        """
        Update time
        """
        return pulumi.get(self, "recurrence_range")


@pulumi.output_type
class UpdateWindowsOnceRecurrenceRecurrenceRange(dict):
    def __init__(__self__, *,
                 end: str,
                 start: str):
        """
        :param str end: no documentation available
        :param str start: no documentation available
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class UpdateWindowsWeeklyRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurrenceRange":
            suggest = "recurrence_range"
        elif key == "selectedWeekDays":
            suggest = "selected_week_days"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateWindowsWeeklyRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateWindowsWeeklyRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateWindowsWeeklyRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 every: int,
                 recurrence_range: 'outputs.UpdateWindowsWeeklyRecurrenceRecurrenceRange',
                 selected_week_days: 'outputs.UpdateWindowsWeeklyRecurrenceSelectedWeekDays',
                 update_time: 'outputs.UpdateWindowsWeeklyRecurrenceUpdateTime'):
        """
        :param int every: Every **X** weeks:
               * `1` = every week,
               * `2` = every two weeks,
               * `3` = every three weeks,
               * etc.
        :param 'UpdateWindowsWeeklyRecurrenceRecurrenceRangeArgs' recurrence_range: Recurrence range
        :param 'UpdateWindowsWeeklyRecurrenceSelectedWeekDaysArgs' selected_week_days: Day of the week
        :param 'UpdateWindowsWeeklyRecurrenceUpdateTimeArgs' update_time: Update time
        """
        pulumi.set(__self__, "every", every)
        pulumi.set(__self__, "recurrence_range", recurrence_range)
        pulumi.set(__self__, "selected_week_days", selected_week_days)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def every(self) -> int:
        """
        Every **X** weeks:
        * `1` = every week,
        * `2` = every two weeks,
        * `3` = every three weeks,
        * etc.
        """
        return pulumi.get(self, "every")

    @property
    @pulumi.getter(name="recurrenceRange")
    def recurrence_range(self) -> 'outputs.UpdateWindowsWeeklyRecurrenceRecurrenceRange':
        """
        Recurrence range
        """
        return pulumi.get(self, "recurrence_range")

    @property
    @pulumi.getter(name="selectedWeekDays")
    def selected_week_days(self) -> 'outputs.UpdateWindowsWeeklyRecurrenceSelectedWeekDays':
        """
        Day of the week
        """
        return pulumi.get(self, "selected_week_days")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> 'outputs.UpdateWindowsWeeklyRecurrenceUpdateTime':
        """
        Update time
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class UpdateWindowsWeeklyRecurrenceRecurrenceRange(dict):
    def __init__(__self__, *,
                 end: str,
                 start: str):
        """
        :param str end: no documentation available
        :param str start: no documentation available
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class UpdateWindowsWeeklyRecurrenceSelectedWeekDays(dict):
    def __init__(__self__, *,
                 friday: bool,
                 monday: bool,
                 saturday: bool,
                 sunday: bool,
                 thursday: bool,
                 tuesday: bool,
                 wednesday: bool):
        """
        :param bool friday: no documentation available
        :param bool monday: no documentation available
        :param bool saturday: no documentation available
        :param bool sunday: no documentation available
        :param bool thursday: no documentation available
        :param bool tuesday: no documentation available
        :param bool wednesday: no documentation available
        """
        pulumi.set(__self__, "friday", friday)
        pulumi.set(__self__, "monday", monday)
        pulumi.set(__self__, "saturday", saturday)
        pulumi.set(__self__, "sunday", sunday)
        pulumi.set(__self__, "thursday", thursday)
        pulumi.set(__self__, "tuesday", tuesday)
        pulumi.set(__self__, "wednesday", wednesday)

    @property
    @pulumi.getter
    def friday(self) -> bool:
        """
        no documentation available
        """
        return pulumi.get(self, "friday")

    @property
    @pulumi.getter
    def monday(self) -> bool:
        """
        no documentation available
        """
        return pulumi.get(self, "monday")

    @property
    @pulumi.getter
    def saturday(self) -> bool:
        """
        no documentation available
        """
        return pulumi.get(self, "saturday")

    @property
    @pulumi.getter
    def sunday(self) -> bool:
        """
        no documentation available
        """
        return pulumi.get(self, "sunday")

    @property
    @pulumi.getter
    def thursday(self) -> bool:
        """
        no documentation available
        """
        return pulumi.get(self, "thursday")

    @property
    @pulumi.getter
    def tuesday(self) -> bool:
        """
        no documentation available
        """
        return pulumi.get(self, "tuesday")

    @property
    @pulumi.getter
    def wednesday(self) -> bool:
        """
        no documentation available
        """
        return pulumi.get(self, "wednesday")


@pulumi.output_type
class UpdateWindowsWeeklyRecurrenceUpdateTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateWindowsWeeklyRecurrenceUpdateTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateWindowsWeeklyRecurrenceUpdateTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateWindowsWeeklyRecurrenceUpdateTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: int,
                 start_time: str,
                 time_zone: str):
        """
        :param int duration: Duration (minutes)
        :param str start_time: Start time (24-hour clock)
        :param str time_zone: Possible Values: `GMT_06_00`, `GMT_12_00`, `GMT_10_00`, `GMT_07_00`, `GMT_00_00`, `GMT_11_00`, `GMT_03_00`, `GMT_01_00`, `GMT_05_00`, `GMT_09_00`, `GMT_02_00`, `GMT_04_00`, `GMT_08_00`
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def duration(self) -> int:
        """
        Duration (minutes)
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        Start time (24-hour clock)
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        Possible Values: `GMT_06_00`, `GMT_12_00`, `GMT_10_00`, `GMT_07_00`, `GMT_00_00`, `GMT_11_00`, `GMT_03_00`, `GMT_01_00`, `GMT_05_00`, `GMT_09_00`, `GMT_02_00`, `GMT_04_00`, `GMT_08_00`
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class UrlBasedSamplingQueryParameters(dict):
    def __init__(__self__, *,
                 parameters: Sequence['outputs.UrlBasedSamplingQueryParametersParameter']):
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def parameters(self) -> Sequence['outputs.UrlBasedSamplingQueryParametersParameter']:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class UrlBasedSamplingQueryParametersParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueIsUndefined":
            suggest = "value_is_undefined"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlBasedSamplingQueryParametersParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlBasedSamplingQueryParametersParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlBasedSamplingQueryParametersParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_is_undefined: Optional[bool] = None):
        """
        :param str name: Query parameter name
        :param str value: Query parameter value
        :param bool value_is_undefined: Query parameter value is undefined
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_is_undefined is not None:
            pulumi.set(__self__, "value_is_undefined", value_is_undefined)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Query parameter name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Query parameter value
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueIsUndefined")
    def value_is_undefined(self) -> Optional[bool]:
        """
        Query parameter value is undefined
        """
        return pulumi.get(self, "value_is_undefined")


@pulumi.output_type
class UserActionMetricsFilters(dict):
    def __init__(__self__, *,
                 filters: Sequence['outputs.UserActionMetricsFiltersFilter']):
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.UserActionMetricsFiltersFilter']:
        return pulumi.get(self, "filters")


@pulumi.output_type
class UserActionMetricsFiltersFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "valueIns":
            suggest = "value_ins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserActionMetricsFiltersFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserActionMetricsFiltersFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserActionMetricsFiltersFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 operator: str,
                 value: Optional[str] = None,
                 value_ins: Optional[Sequence[str]] = None):
        """
        :param str field_name: Field name
        :param str operator: Possible Values: `EQUALS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL_TO`, `IN`, `IS_NOT_NULL`, `IS_NULL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL_TO`, `LIKE`, `NOT_EQUAL`, `NOT_LIKE`, `STARTS_WITH`
        :param str value: no documentation available
        :param Sequence[str] value_ins: Values
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_ins is not None:
            pulumi.set(__self__, "value_ins", value_ins)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Field name
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Possible Values: `EQUALS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL_TO`, `IN`, `IS_NOT_NULL`, `IS_NULL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL_TO`, `LIKE`, `NOT_EQUAL`, `NOT_LIKE`, `STARTS_WITH`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueIns")
    def value_ins(self) -> Optional[Sequence[str]]:
        """
        Values
        """
        return pulumi.get(self, "value_ins")


@pulumi.output_type
class UserActionMetricsValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserActionMetricsValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserActionMetricsValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserActionMetricsValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 field_name: Optional[str] = None):
        """
        :param str type: Possible Values: `COUNTER`, `FIELD`
        :param str field_name: Field name
        """
        pulumi.set(__self__, "type", type)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `COUNTER`, `FIELD`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[str]:
        """
        Field name
        """
        return pulumi.get(self, "field_name")


@pulumi.output_type
class UserGroupPermissions(dict):
    def __init__(__self__, *,
                 grants: Sequence['outputs.UserGroupPermissionsGrant']):
        """
        :param Sequence['UserGroupPermissionsGrantArgs'] grants: A permission granted to one or multiple environments
        """
        pulumi.set(__self__, "grants", grants)

    @property
    @pulumi.getter
    def grants(self) -> Sequence['outputs.UserGroupPermissionsGrant']:
        """
        A permission granted to one or multiple environments
        """
        return pulumi.get(self, "grants")


@pulumi.output_type
class UserGroupPermissionsGrant(dict):
    def __init__(__self__, *,
                 permission: str,
                 environments: Optional[Sequence[str]] = None):
        """
        :param str permission: The permission. Possible values are `VIEWER`, `MANAGE_SETTINGS`, `AGENT_INSTALL`, `LOG_VIEWER`, `VIEW_SENSITIVE_REQUEST_DATA`, `CONFIGURE_REQUEST_CAPTURE_DATA`, `REPLAY_SESSION_DATA`, `REPLAY_SESSION_DATA_WITHOUT_MASKING`, `MANAGE_SECURITY_PROBLEMS` and `MANAGE_SUPPORT_TICKETS`.
        :param Sequence[str] environments: The ids of the environments this permission grants the user access to.
        """
        pulumi.set(__self__, "permission", permission)
        if environments is not None:
            pulumi.set(__self__, "environments", environments)

    @property
    @pulumi.getter
    def permission(self) -> str:
        """
        The permission. Possible values are `VIEWER`, `MANAGE_SETTINGS`, `AGENT_INSTALL`, `LOG_VIEWER`, `VIEW_SENSITIVE_REQUEST_DATA`, `CONFIGURE_REQUEST_CAPTURE_DATA`, `REPLAY_SESSION_DATA`, `REPLAY_SESSION_DATA_WITHOUT_MASKING`, `MANAGE_SECURITY_PROBLEMS` and `MANAGE_SUPPORT_TICKETS`.
        """
        return pulumi.get(self, "permission")

    @property
    @pulumi.getter
    def environments(self) -> Optional[Sequence[str]]:
        """
        The ids of the environments this permission grants the user access to.
        """
        return pulumi.get(self, "environments")


@pulumi.output_type
class UserSessionMetricsFilters(dict):
    def __init__(__self__, *,
                 filters: Sequence['outputs.UserSessionMetricsFiltersFilter']):
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.UserSessionMetricsFiltersFilter']:
        return pulumi.get(self, "filters")


@pulumi.output_type
class UserSessionMetricsFiltersFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "valueIns":
            suggest = "value_ins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserSessionMetricsFiltersFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserSessionMetricsFiltersFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserSessionMetricsFiltersFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 operator: str,
                 value: Optional[str] = None,
                 value_ins: Optional[Sequence[str]] = None):
        """
        :param str field_name: Field name
        :param str operator: Possible Values: `EQUALS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL_TO`, `IN`, `IS_NOT_NULL`, `IS_NULL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL_TO`, `LIKE`, `NOT_EQUAL`, `NOT_LIKE`, `STARTS_WITH`
        :param str value: no documentation available
        :param Sequence[str] value_ins: Values
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_ins is not None:
            pulumi.set(__self__, "value_ins", value_ins)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Field name
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Possible Values: `EQUALS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL_TO`, `IN`, `IS_NOT_NULL`, `IS_NULL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL_TO`, `LIKE`, `NOT_EQUAL`, `NOT_LIKE`, `STARTS_WITH`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueIns")
    def value_ins(self) -> Optional[Sequence[str]]:
        """
        Values
        """
        return pulumi.get(self, "value_ins")


@pulumi.output_type
class UserSessionMetricsValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserSessionMetricsValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserSessionMetricsValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserSessionMetricsValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 field_name: Optional[str] = None):
        """
        :param str type: Possible Values: `COUNTER`, `FIELD`
        :param str field_name: Field name
        """
        pulumi.set(__self__, "type", type)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `COUNTER`, `FIELD`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[str]:
        """
        Field name
        """
        return pulumi.get(self, "field_name")


@pulumi.output_type
class VmwareAnomaliesDroppedPacketsDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesDroppedPacketsDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesDroppedPacketsDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesDroppedPacketsDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.VmwareAnomaliesDroppedPacketsDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'VmwareAnomaliesDroppedPacketsDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.VmwareAnomaliesDroppedPacketsDetectionCustomThresholds']:
        """
        Alert if the condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class VmwareAnomaliesDroppedPacketsDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "droppedPacketsPerSecond":
            suggest = "dropped_packets_per_second"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesDroppedPacketsDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesDroppedPacketsDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesDroppedPacketsDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dropped_packets_per_second: int):
        """
        :param int dropped_packets_per_second: Receive/transmit dropped packets rate on NIC is higher than
        """
        pulumi.set(__self__, "dropped_packets_per_second", dropped_packets_per_second)

    @property
    @pulumi.getter(name="droppedPacketsPerSecond")
    def dropped_packets_per_second(self) -> int:
        """
        Receive/transmit dropped packets rate on NIC is higher than
        """
        return pulumi.get(self, "dropped_packets_per_second")


@pulumi.output_type
class VmwareAnomaliesEsxiHighCpuDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesEsxiHighCpuDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesEsxiHighCpuDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesEsxiHighCpuDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.VmwareAnomaliesEsxiHighCpuDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'VmwareAnomaliesEsxiHighCpuDetectionCustomThresholdsArgs' custom_thresholds: Alert if **all three** conditions are met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.VmwareAnomaliesEsxiHighCpuDetectionCustomThresholds']:
        """
        Alert if **all three** conditions are met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class VmwareAnomaliesEsxiHighCpuDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuPeakPercentage":
            suggest = "cpu_peak_percentage"
        elif key == "cpuUsagePercentage":
            suggest = "cpu_usage_percentage"
        elif key == "vmCpuReadyPercentage":
            suggest = "vm_cpu_ready_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesEsxiHighCpuDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesEsxiHighCpuDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesEsxiHighCpuDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_peak_percentage: int,
                 cpu_usage_percentage: int,
                 vm_cpu_ready_percentage: int):
        """
        :param int cpu_peak_percentage: At least one peak occurred when Hypervisor CPU usage was higher than
        :param int cpu_usage_percentage: CPU usage is higher than
        :param int vm_cpu_ready_percentage: VM CPU ready is higher than
        """
        pulumi.set(__self__, "cpu_peak_percentage", cpu_peak_percentage)
        pulumi.set(__self__, "cpu_usage_percentage", cpu_usage_percentage)
        pulumi.set(__self__, "vm_cpu_ready_percentage", vm_cpu_ready_percentage)

    @property
    @pulumi.getter(name="cpuPeakPercentage")
    def cpu_peak_percentage(self) -> int:
        """
        At least one peak occurred when Hypervisor CPU usage was higher than
        """
        return pulumi.get(self, "cpu_peak_percentage")

    @property
    @pulumi.getter(name="cpuUsagePercentage")
    def cpu_usage_percentage(self) -> int:
        """
        CPU usage is higher than
        """
        return pulumi.get(self, "cpu_usage_percentage")

    @property
    @pulumi.getter(name="vmCpuReadyPercentage")
    def vm_cpu_ready_percentage(self) -> int:
        """
        VM CPU ready is higher than
        """
        return pulumi.get(self, "vm_cpu_ready_percentage")


@pulumi.output_type
class VmwareAnomaliesEsxiHighMemoryDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesEsxiHighMemoryDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesEsxiHighMemoryDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesEsxiHighMemoryDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.VmwareAnomaliesEsxiHighMemoryDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'VmwareAnomaliesEsxiHighMemoryDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.VmwareAnomaliesEsxiHighMemoryDetectionCustomThresholds']:
        """
        Alert if the condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class VmwareAnomaliesEsxiHighMemoryDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionDecompressionRate":
            suggest = "compression_decompression_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesEsxiHighMemoryDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesEsxiHighMemoryDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesEsxiHighMemoryDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_decompression_rate: float):
        """
        :param float compression_decompression_rate: ESXi host swap IN/OUT or compression/decompression rate is higher than
        """
        pulumi.set(__self__, "compression_decompression_rate", compression_decompression_rate)

    @property
    @pulumi.getter(name="compressionDecompressionRate")
    def compression_decompression_rate(self) -> float:
        """
        ESXi host swap IN/OUT or compression/decompression rate is higher than
        """
        return pulumi.get(self, "compression_decompression_rate")


@pulumi.output_type
class VmwareAnomaliesGuestCpuLimitDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesGuestCpuLimitDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesGuestCpuLimitDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesGuestCpuLimitDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.VmwareAnomaliesGuestCpuLimitDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'VmwareAnomaliesGuestCpuLimitDetectionCustomThresholdsArgs' custom_thresholds: Alert if **all three** conditions are met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.VmwareAnomaliesGuestCpuLimitDetectionCustomThresholds']:
        """
        Alert if **all three** conditions are met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class VmwareAnomaliesGuestCpuLimitDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostCpuUsagePercentage":
            suggest = "host_cpu_usage_percentage"
        elif key == "vmCpuReadyPercentage":
            suggest = "vm_cpu_ready_percentage"
        elif key == "vmCpuUsagePercentage":
            suggest = "vm_cpu_usage_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesGuestCpuLimitDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesGuestCpuLimitDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesGuestCpuLimitDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_cpu_usage_percentage: int,
                 vm_cpu_ready_percentage: int,
                 vm_cpu_usage_percentage: int):
        """
        :param int host_cpu_usage_percentage: Hypervisor CPU usage is higher than
        :param int vm_cpu_ready_percentage: VM CPU ready is higher than
        :param int vm_cpu_usage_percentage: VM CPU usage (VM CPU Usage Mhz / VM CPU limit in Mhz) is higher than
        """
        pulumi.set(__self__, "host_cpu_usage_percentage", host_cpu_usage_percentage)
        pulumi.set(__self__, "vm_cpu_ready_percentage", vm_cpu_ready_percentage)
        pulumi.set(__self__, "vm_cpu_usage_percentage", vm_cpu_usage_percentage)

    @property
    @pulumi.getter(name="hostCpuUsagePercentage")
    def host_cpu_usage_percentage(self) -> int:
        """
        Hypervisor CPU usage is higher than
        """
        return pulumi.get(self, "host_cpu_usage_percentage")

    @property
    @pulumi.getter(name="vmCpuReadyPercentage")
    def vm_cpu_ready_percentage(self) -> int:
        """
        VM CPU ready is higher than
        """
        return pulumi.get(self, "vm_cpu_ready_percentage")

    @property
    @pulumi.getter(name="vmCpuUsagePercentage")
    def vm_cpu_usage_percentage(self) -> int:
        """
        VM CPU usage (VM CPU Usage Mhz / VM CPU limit in Mhz) is higher than
        """
        return pulumi.get(self, "vm_cpu_usage_percentage")


@pulumi.output_type
class VmwareAnomaliesLowDatastoreSpaceDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesLowDatastoreSpaceDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesLowDatastoreSpaceDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesLowDatastoreSpaceDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.VmwareAnomaliesLowDatastoreSpaceDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'VmwareAnomaliesLowDatastoreSpaceDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 1 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.VmwareAnomaliesLowDatastoreSpaceDetectionCustomThresholds']:
        """
        Alert if the condition is met in 1 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class VmwareAnomaliesLowDatastoreSpaceDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeSpacePercentage":
            suggest = "free_space_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesLowDatastoreSpaceDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesLowDatastoreSpaceDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesLowDatastoreSpaceDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_space_percentage: int):
        """
        :param int free_space_percentage: Datastore free space is lower than
        """
        pulumi.set(__self__, "free_space_percentage", free_space_percentage)

    @property
    @pulumi.getter(name="freeSpacePercentage")
    def free_space_percentage(self) -> int:
        """
        Datastore free space is lower than
        """
        return pulumi.get(self, "free_space_percentage")


@pulumi.output_type
class VmwareAnomaliesOverloadedStorageDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesOverloadedStorageDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesOverloadedStorageDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesOverloadedStorageDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.VmwareAnomaliesOverloadedStorageDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'VmwareAnomaliesOverloadedStorageDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.VmwareAnomaliesOverloadedStorageDetectionCustomThresholds']:
        """
        Alert if the condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class VmwareAnomaliesOverloadedStorageDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commandAbortsNumber":
            suggest = "command_aborts_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesOverloadedStorageDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesOverloadedStorageDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesOverloadedStorageDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command_aborts_number: int):
        """
        :param int command_aborts_number: Number of command aborts is higher than
        """
        pulumi.set(__self__, "command_aborts_number", command_aborts_number)

    @property
    @pulumi.getter(name="commandAbortsNumber")
    def command_aborts_number(self) -> int:
        """
        Number of command aborts is higher than
        """
        return pulumi.get(self, "command_aborts_number")


@pulumi.output_type
class VmwareAnomaliesSlowPhysicalStorageDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesSlowPhysicalStorageDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesSlowPhysicalStorageDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesSlowPhysicalStorageDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.VmwareAnomaliesSlowPhysicalStorageDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'VmwareAnomaliesSlowPhysicalStorageDetectionCustomThresholdsArgs' custom_thresholds: Alert if **any** condition is met in 4 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.VmwareAnomaliesSlowPhysicalStorageDetectionCustomThresholds']:
        """
        Alert if **any** condition is met in 4 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class VmwareAnomaliesSlowPhysicalStorageDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avgReadWriteLatency":
            suggest = "avg_read_write_latency"
        elif key == "peakReadWriteLatency":
            suggest = "peak_read_write_latency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesSlowPhysicalStorageDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesSlowPhysicalStorageDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesSlowPhysicalStorageDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avg_read_write_latency: int,
                 peak_read_write_latency: int):
        """
        :param int avg_read_write_latency: Read/write latency is higher than
        :param int peak_read_write_latency: Peak value for read/write latency is higher than
        """
        pulumi.set(__self__, "avg_read_write_latency", avg_read_write_latency)
        pulumi.set(__self__, "peak_read_write_latency", peak_read_write_latency)

    @property
    @pulumi.getter(name="avgReadWriteLatency")
    def avg_read_write_latency(self) -> int:
        """
        Read/write latency is higher than
        """
        return pulumi.get(self, "avg_read_write_latency")

    @property
    @pulumi.getter(name="peakReadWriteLatency")
    def peak_read_write_latency(self) -> int:
        """
        Peak value for read/write latency is higher than
        """
        return pulumi.get(self, "peak_read_write_latency")


@pulumi.output_type
class VmwareAnomaliesUndersizedStorageDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesUndersizedStorageDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesUndersizedStorageDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesUndersizedStorageDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.VmwareAnomaliesUndersizedStorageDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'VmwareAnomaliesUndersizedStorageDetectionCustomThresholdsArgs' custom_thresholds: Alert if **any** condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.VmwareAnomaliesUndersizedStorageDetectionCustomThresholds']:
        """
        Alert if **any** condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class VmwareAnomaliesUndersizedStorageDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "averageQueueCommandLatency":
            suggest = "average_queue_command_latency"
        elif key == "peakQueueCommandLatency":
            suggest = "peak_queue_command_latency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesUndersizedStorageDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesUndersizedStorageDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesUndersizedStorageDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 average_queue_command_latency: int,
                 peak_queue_command_latency: int):
        """
        :param int average_queue_command_latency: Average queue command latency is higher than
        :param int peak_queue_command_latency: Peak queue command latency is higher than
        """
        pulumi.set(__self__, "average_queue_command_latency", average_queue_command_latency)
        pulumi.set(__self__, "peak_queue_command_latency", peak_queue_command_latency)

    @property
    @pulumi.getter(name="averageQueueCommandLatency")
    def average_queue_command_latency(self) -> int:
        """
        Average queue command latency is higher than
        """
        return pulumi.get(self, "average_queue_command_latency")

    @property
    @pulumi.getter(name="peakQueueCommandLatency")
    def peak_queue_command_latency(self) -> int:
        """
        Peak queue command latency is higher than
        """
        return pulumi.get(self, "peak_queue_command_latency")


@pulumi.output_type
class VulnerabilityCodeCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "processGroup":
            suggest = "process_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VulnerabilityCodeCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VulnerabilityCodeCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VulnerabilityCodeCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 process_group: Optional[str] = None):
        """
        :param str process_group: Process group
        """
        if process_group is not None:
            pulumi.set(__self__, "process_group", process_group)

    @property
    @pulumi.getter(name="processGroup")
    def process_group(self) -> Optional[str]:
        """
        Process group
        """
        return pulumi.get(self, "process_group")


@pulumi.output_type
class VulnerabilityCodeMetadata(dict):
    def __init__(__self__, *,
                 comment: str):
        """
        :param str comment: no documentation available
        """
        pulumi.set(__self__, "comment", comment)

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        no documentation available
        """
        return pulumi.get(self, "comment")


@pulumi.output_type
class VulnerabilityCodeResourceAttributeConditions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceAttributeConditions":
            suggest = "resource_attribute_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VulnerabilityCodeResourceAttributeConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VulnerabilityCodeResourceAttributeConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VulnerabilityCodeResourceAttributeConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_attribute_conditions: Sequence['outputs.VulnerabilityCodeResourceAttributeConditionsResourceAttributeCondition']):
        pulumi.set(__self__, "resource_attribute_conditions", resource_attribute_conditions)

    @property
    @pulumi.getter(name="resourceAttributeConditions")
    def resource_attribute_conditions(self) -> Sequence['outputs.VulnerabilityCodeResourceAttributeConditionsResourceAttributeCondition']:
        return pulumi.get(self, "resource_attribute_conditions")


@pulumi.output_type
class VulnerabilityCodeResourceAttributeConditionsResourceAttributeCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceAttributeKey":
            suggest = "resource_attribute_key"
        elif key == "resourceAttributeValue":
            suggest = "resource_attribute_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VulnerabilityCodeResourceAttributeConditionsResourceAttributeCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VulnerabilityCodeResourceAttributeConditionsResourceAttributeCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VulnerabilityCodeResourceAttributeConditionsResourceAttributeCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 matcher: str,
                 resource_attribute_key: str,
                 resource_attribute_value: Optional[str] = None):
        """
        :param str matcher: Possible Values: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_END_WITH`, `DOES_NOT_EXIST`, `DOES_NOT_START_WITH`, `ENDS_WITH`, `EQUALS`, `EXISTS`, `NOT_EQUALS`, `STARTS_WITH`
        :param str resource_attribute_key: Resource attribute key
        :param str resource_attribute_value: Resource attribute value
        """
        pulumi.set(__self__, "matcher", matcher)
        pulumi.set(__self__, "resource_attribute_key", resource_attribute_key)
        if resource_attribute_value is not None:
            pulumi.set(__self__, "resource_attribute_value", resource_attribute_value)

    @property
    @pulumi.getter
    def matcher(self) -> str:
        """
        Possible Values: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_END_WITH`, `DOES_NOT_EXIST`, `DOES_NOT_START_WITH`, `ENDS_WITH`, `EQUALS`, `EXISTS`, `NOT_EQUALS`, `STARTS_WITH`
        """
        return pulumi.get(self, "matcher")

    @property
    @pulumi.getter(name="resourceAttributeKey")
    def resource_attribute_key(self) -> str:
        """
        Resource attribute key
        """
        return pulumi.get(self, "resource_attribute_key")

    @property
    @pulumi.getter(name="resourceAttributeValue")
    def resource_attribute_value(self) -> Optional[str]:
        """
        Resource attribute value
        """
        return pulumi.get(self, "resource_attribute_value")


@pulumi.output_type
class VulnerabilityCodeVulnerabilityDetectionControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitoringMode":
            suggest = "monitoring_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VulnerabilityCodeVulnerabilityDetectionControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VulnerabilityCodeVulnerabilityDetectionControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VulnerabilityCodeVulnerabilityDetectionControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitoring_mode: str):
        """
        :param str monitoring_mode: Possible Values: `MONITORING_OFF`, `MONITORING_ON`
        """
        pulumi.set(__self__, "monitoring_mode", monitoring_mode)

    @property
    @pulumi.getter(name="monitoringMode")
    def monitoring_mode(self) -> str:
        """
        Possible Values: `MONITORING_OFF`, `MONITORING_ON`
        """
        return pulumi.get(self, "monitoring_mode")


@pulumi.output_type
class VulnerabilitySettingsTechnologies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableDotNet":
            suggest = "enable_dot_net"
        elif key == "enableGo":
            suggest = "enable_go"
        elif key == "enableJava":
            suggest = "enable_java"
        elif key == "enableKubernetes":
            suggest = "enable_kubernetes"
        elif key == "enableNodeJs":
            suggest = "enable_node_js"
        elif key == "enablePhp":
            suggest = "enable_php"
        elif key == "enableDotNetRuntime":
            suggest = "enable_dot_net_runtime"
        elif key == "enableJavaRuntime":
            suggest = "enable_java_runtime"
        elif key == "enableNodeJsRuntime":
            suggest = "enable_node_js_runtime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VulnerabilitySettingsTechnologies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VulnerabilitySettingsTechnologies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VulnerabilitySettingsTechnologies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_dot_net: bool,
                 enable_go: bool,
                 enable_java: bool,
                 enable_kubernetes: bool,
                 enable_node_js: bool,
                 enable_php: bool,
                 enable_dot_net_runtime: Optional[bool] = None,
                 enable_java_runtime: Optional[bool] = None,
                 enable_node_js_runtime: Optional[bool] = None):
        """
        :param bool enable_dot_net: NET
        :param bool enable_go: Go
        :param bool enable_java: Java
        :param bool enable_kubernetes: Kubernetes
        :param bool enable_node_js: Node.js
        :param bool enable_php: PHP
        :param bool enable_dot_net_runtime: NET runtimes
        :param bool enable_java_runtime: Java runtimes
        :param bool enable_node_js_runtime: Node.js runtimes
        """
        pulumi.set(__self__, "enable_dot_net", enable_dot_net)
        pulumi.set(__self__, "enable_go", enable_go)
        pulumi.set(__self__, "enable_java", enable_java)
        pulumi.set(__self__, "enable_kubernetes", enable_kubernetes)
        pulumi.set(__self__, "enable_node_js", enable_node_js)
        pulumi.set(__self__, "enable_php", enable_php)
        if enable_dot_net_runtime is not None:
            pulumi.set(__self__, "enable_dot_net_runtime", enable_dot_net_runtime)
        if enable_java_runtime is not None:
            pulumi.set(__self__, "enable_java_runtime", enable_java_runtime)
        if enable_node_js_runtime is not None:
            pulumi.set(__self__, "enable_node_js_runtime", enable_node_js_runtime)

    @property
    @pulumi.getter(name="enableDotNet")
    def enable_dot_net(self) -> bool:
        """
        NET
        """
        return pulumi.get(self, "enable_dot_net")

    @property
    @pulumi.getter(name="enableGo")
    def enable_go(self) -> bool:
        """
        Go
        """
        return pulumi.get(self, "enable_go")

    @property
    @pulumi.getter(name="enableJava")
    def enable_java(self) -> bool:
        """
        Java
        """
        return pulumi.get(self, "enable_java")

    @property
    @pulumi.getter(name="enableKubernetes")
    def enable_kubernetes(self) -> bool:
        """
        Kubernetes
        """
        return pulumi.get(self, "enable_kubernetes")

    @property
    @pulumi.getter(name="enableNodeJs")
    def enable_node_js(self) -> bool:
        """
        Node.js
        """
        return pulumi.get(self, "enable_node_js")

    @property
    @pulumi.getter(name="enablePhp")
    def enable_php(self) -> bool:
        """
        PHP
        """
        return pulumi.get(self, "enable_php")

    @property
    @pulumi.getter(name="enableDotNetRuntime")
    def enable_dot_net_runtime(self) -> Optional[bool]:
        """
        NET runtimes
        """
        return pulumi.get(self, "enable_dot_net_runtime")

    @property
    @pulumi.getter(name="enableJavaRuntime")
    def enable_java_runtime(self) -> Optional[bool]:
        """
        Java runtimes
        """
        return pulumi.get(self, "enable_java_runtime")

    @property
    @pulumi.getter(name="enableNodeJsRuntime")
    def enable_node_js_runtime(self) -> Optional[bool]:
        """
        Node.js runtimes
        """
        return pulumi.get(self, "enable_node_js_runtime")


@pulumi.output_type
class WebAppAnomaliesErrorRate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorRateAuto":
            suggest = "error_rate_auto"
        elif key == "errorRateDetectionMode":
            suggest = "error_rate_detection_mode"
        elif key == "errorRateFixed":
            suggest = "error_rate_fixed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesErrorRate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesErrorRate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesErrorRate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 error_rate_auto: Optional['outputs.WebAppAnomaliesErrorRateErrorRateAuto'] = None,
                 error_rate_detection_mode: Optional[str] = None,
                 error_rate_fixed: Optional['outputs.WebAppAnomaliesErrorRateErrorRateFixed'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'WebAppAnomaliesErrorRateErrorRateAutoArgs' error_rate_auto: Alert if the percentage of failing user actions increases by **both** the absolute and relative thresholds:
        :param str error_rate_detection_mode: Possible Values: `Auto`, `Fixed`
        :param 'WebAppAnomaliesErrorRateErrorRateFixedArgs' error_rate_fixed: no documentation available
        """
        pulumi.set(__self__, "enabled", enabled)
        if error_rate_auto is not None:
            pulumi.set(__self__, "error_rate_auto", error_rate_auto)
        if error_rate_detection_mode is not None:
            pulumi.set(__self__, "error_rate_detection_mode", error_rate_detection_mode)
        if error_rate_fixed is not None:
            pulumi.set(__self__, "error_rate_fixed", error_rate_fixed)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="errorRateAuto")
    def error_rate_auto(self) -> Optional['outputs.WebAppAnomaliesErrorRateErrorRateAuto']:
        """
        Alert if the percentage of failing user actions increases by **both** the absolute and relative thresholds:
        """
        return pulumi.get(self, "error_rate_auto")

    @property
    @pulumi.getter(name="errorRateDetectionMode")
    def error_rate_detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Fixed`
        """
        return pulumi.get(self, "error_rate_detection_mode")

    @property
    @pulumi.getter(name="errorRateFixed")
    def error_rate_fixed(self) -> Optional['outputs.WebAppAnomaliesErrorRateErrorRateFixed']:
        """
        no documentation available
        """
        return pulumi.get(self, "error_rate_fixed")


@pulumi.output_type
class WebAppAnomaliesErrorRateErrorRateAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "absoluteIncrease":
            suggest = "absolute_increase"
        elif key == "overAlertingProtection":
            suggest = "over_alerting_protection"
        elif key == "relativeIncrease":
            suggest = "relative_increase"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesErrorRateErrorRateAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesErrorRateErrorRateAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesErrorRateErrorRateAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 absolute_increase: float,
                 over_alerting_protection: 'outputs.WebAppAnomaliesErrorRateErrorRateAutoOverAlertingProtection',
                 relative_increase: float):
        """
        :param float absolute_increase: Absolute threshold
        :param 'WebAppAnomaliesErrorRateErrorRateAutoOverAlertingProtectionArgs' over_alerting_protection: Avoid over-alerting
        :param float relative_increase: Relative threshold
        """
        pulumi.set(__self__, "absolute_increase", absolute_increase)
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "relative_increase", relative_increase)

    @property
    @pulumi.getter(name="absoluteIncrease")
    def absolute_increase(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "absolute_increase")

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.WebAppAnomaliesErrorRateErrorRateAutoOverAlertingProtection':
        """
        Avoid over-alerting
        """
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter(name="relativeIncrease")
    def relative_increase(self) -> float:
        """
        Relative threshold
        """
        return pulumi.get(self, "relative_increase")


@pulumi.output_type
class WebAppAnomaliesErrorRateErrorRateAutoOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsPerMinute":
            suggest = "actions_per_minute"
        elif key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesErrorRateErrorRateAutoOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesErrorRateErrorRateAutoOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesErrorRateErrorRateAutoOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_per_minute: float,
                 minutes_abnormal_state: float):
        """
        :param float actions_per_minute: Only alert if there are at least
        :param float minutes_abnormal_state: Only alert if the abnormal state remains for at least
        """
        pulumi.set(__self__, "actions_per_minute", actions_per_minute)
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)

    @property
    @pulumi.getter(name="actionsPerMinute")
    def actions_per_minute(self) -> float:
        """
        Only alert if there are at least
        """
        return pulumi.get(self, "actions_per_minute")

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> float:
        """
        Only alert if the abnormal state remains for at least
        """
        return pulumi.get(self, "minutes_abnormal_state")


@pulumi.output_type
class WebAppAnomaliesErrorRateErrorRateFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorRateReqPerMin":
            suggest = "error_rate_req_per_min"
        elif key == "errorRateSensitivity":
            suggest = "error_rate_sensitivity"
        elif key == "maxFailureRateIncrease":
            suggest = "max_failure_rate_increase"
        elif key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesErrorRateErrorRateFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesErrorRateErrorRateFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesErrorRateErrorRateFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_rate_req_per_min: float,
                 error_rate_sensitivity: str,
                 max_failure_rate_increase: float,
                 minutes_abnormal_state: float):
        """
        :param float error_rate_req_per_min: To avoid over-alerting for low traffic applications
        :param str error_rate_sensitivity: Possible Values: `Low`, `Medium`, `High`
        :param float max_failure_rate_increase: Alert if this custom error rate threshold is exceeded during any 5-minute-period
        :param float minutes_abnormal_state: Amount of minutes the observed traffic has to stay in abnormal state before alert
        """
        pulumi.set(__self__, "error_rate_req_per_min", error_rate_req_per_min)
        pulumi.set(__self__, "error_rate_sensitivity", error_rate_sensitivity)
        pulumi.set(__self__, "max_failure_rate_increase", max_failure_rate_increase)
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)

    @property
    @pulumi.getter(name="errorRateReqPerMin")
    def error_rate_req_per_min(self) -> float:
        """
        To avoid over-alerting for low traffic applications
        """
        return pulumi.get(self, "error_rate_req_per_min")

    @property
    @pulumi.getter(name="errorRateSensitivity")
    def error_rate_sensitivity(self) -> str:
        """
        Possible Values: `Low`, `Medium`, `High`
        """
        return pulumi.get(self, "error_rate_sensitivity")

    @property
    @pulumi.getter(name="maxFailureRateIncrease")
    def max_failure_rate_increase(self) -> float:
        """
        Alert if this custom error rate threshold is exceeded during any 5-minute-period
        """
        return pulumi.get(self, "max_failure_rate_increase")

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> float:
        """
        Amount of minutes the observed traffic has to stay in abnormal state before alert
        """
        return pulumi.get(self, "minutes_abnormal_state")


@pulumi.output_type
class WebAppAnomaliesResponseTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectionMode":
            suggest = "detection_mode"
        elif key == "responseTimeAuto":
            suggest = "response_time_auto"
        elif key == "responseTimeFixed":
            suggest = "response_time_fixed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesResponseTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesResponseTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesResponseTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 detection_mode: Optional[str] = None,
                 response_time_auto: Optional['outputs.WebAppAnomaliesResponseTimeResponseTimeAuto'] = None,
                 response_time_fixed: Optional['outputs.WebAppAnomaliesResponseTimeResponseTimeFixed'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param str detection_mode: Possible Values: `Auto`, `Fixed`
        :param 'WebAppAnomaliesResponseTimeResponseTimeAutoArgs' response_time_auto: no documentation available
        :param 'WebAppAnomaliesResponseTimeResponseTimeFixedArgs' response_time_fixed: no documentation available
        """
        pulumi.set(__self__, "enabled", enabled)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if response_time_auto is not None:
            pulumi.set(__self__, "response_time_auto", response_time_auto)
        if response_time_fixed is not None:
            pulumi.set(__self__, "response_time_fixed", response_time_fixed)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Fixed`
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter(name="responseTimeAuto")
    def response_time_auto(self) -> Optional['outputs.WebAppAnomaliesResponseTimeResponseTimeAuto']:
        """
        no documentation available
        """
        return pulumi.get(self, "response_time_auto")

    @property
    @pulumi.getter(name="responseTimeFixed")
    def response_time_fixed(self) -> Optional['outputs.WebAppAnomaliesResponseTimeResponseTimeFixed']:
        """
        no documentation available
        """
        return pulumi.get(self, "response_time_fixed")


@pulumi.output_type
class WebAppAnomaliesResponseTimeResponseTimeAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overAlertingProtection":
            suggest = "over_alerting_protection"
        elif key == "responseTimeAll":
            suggest = "response_time_all"
        elif key == "responseTimeSlowest":
            suggest = "response_time_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesResponseTimeResponseTimeAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 over_alerting_protection: 'outputs.WebAppAnomaliesResponseTimeResponseTimeAutoOverAlertingProtection',
                 response_time_all: 'outputs.WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeAll',
                 response_time_slowest: 'outputs.WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeSlowest'):
        """
        :param 'WebAppAnomaliesResponseTimeResponseTimeAutoOverAlertingProtectionArgs' over_alerting_protection: Avoid over-alerting
        :param 'WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeAllArgs' response_time_all: Alert if the median response time of all user actions degrades beyond **both** the absolute and relative thresholds:
        :param 'WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeSlowestArgs' response_time_slowest: Alert if the response time of the slowest 10% of requests degrades beyond **both** the absolute and relative thresholds:
        """
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "response_time_all", response_time_all)
        pulumi.set(__self__, "response_time_slowest", response_time_slowest)

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.WebAppAnomaliesResponseTimeResponseTimeAutoOverAlertingProtection':
        """
        Avoid over-alerting
        """
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter(name="responseTimeAll")
    def response_time_all(self) -> 'outputs.WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeAll':
        """
        Alert if the median response time of all user actions degrades beyond **both** the absolute and relative thresholds:
        """
        return pulumi.get(self, "response_time_all")

    @property
    @pulumi.getter(name="responseTimeSlowest")
    def response_time_slowest(self) -> 'outputs.WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeSlowest':
        """
        Alert if the response time of the slowest 10% of requests degrades beyond **both** the absolute and relative thresholds:
        """
        return pulumi.get(self, "response_time_slowest")


@pulumi.output_type
class WebAppAnomaliesResponseTimeResponseTimeAutoOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsPerMinute":
            suggest = "actions_per_minute"
        elif key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesResponseTimeResponseTimeAutoOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeAutoOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeAutoOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_per_minute: float,
                 minutes_abnormal_state: float):
        """
        :param float actions_per_minute: Only alert if there are at least
        :param float minutes_abnormal_state: Only alert if the abnormal state remains for at least
        """
        pulumi.set(__self__, "actions_per_minute", actions_per_minute)
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)

    @property
    @pulumi.getter(name="actionsPerMinute")
    def actions_per_minute(self) -> float:
        """
        Only alert if there are at least
        """
        return pulumi.get(self, "actions_per_minute")

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> float:
        """
        Only alert if the abnormal state remains for at least
        """
        return pulumi.get(self, "minutes_abnormal_state")


@pulumi.output_type
class WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeAll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "degradationMilliseconds":
            suggest = "degradation_milliseconds"
        elif key == "degradationPercent":
            suggest = "degradation_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeAll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeAll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeAll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 degradation_milliseconds: float,
                 degradation_percent: float):
        """
        :param float degradation_milliseconds: Absolute threshold
        :param float degradation_percent: Relative threshold
        """
        pulumi.set(__self__, "degradation_milliseconds", degradation_milliseconds)
        pulumi.set(__self__, "degradation_percent", degradation_percent)

    @property
    @pulumi.getter(name="degradationMilliseconds")
    def degradation_milliseconds(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "degradation_milliseconds")

    @property
    @pulumi.getter(name="degradationPercent")
    def degradation_percent(self) -> float:
        """
        Relative threshold
        """
        return pulumi.get(self, "degradation_percent")


@pulumi.output_type
class WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestDegradationMilliseconds":
            suggest = "slowest_degradation_milliseconds"
        elif key == "slowestDegradationPercent":
            suggest = "slowest_degradation_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slowest_degradation_milliseconds: float,
                 slowest_degradation_percent: float):
        """
        :param float slowest_degradation_milliseconds: Absolute threshold
        :param float slowest_degradation_percent: Relative threshold
        """
        pulumi.set(__self__, "slowest_degradation_milliseconds", slowest_degradation_milliseconds)
        pulumi.set(__self__, "slowest_degradation_percent", slowest_degradation_percent)

    @property
    @pulumi.getter(name="slowestDegradationMilliseconds")
    def slowest_degradation_milliseconds(self) -> float:
        """
        Absolute threshold
        """
        return pulumi.get(self, "slowest_degradation_milliseconds")

    @property
    @pulumi.getter(name="slowestDegradationPercent")
    def slowest_degradation_percent(self) -> float:
        """
        Relative threshold
        """
        return pulumi.get(self, "slowest_degradation_percent")


@pulumi.output_type
class WebAppAnomaliesResponseTimeResponseTimeFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overAlertingProtection":
            suggest = "over_alerting_protection"
        elif key == "responseTimeAll":
            suggest = "response_time_all"
        elif key == "responseTimeSlowest":
            suggest = "response_time_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesResponseTimeResponseTimeFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 over_alerting_protection: 'outputs.WebAppAnomaliesResponseTimeResponseTimeFixedOverAlertingProtection',
                 response_time_all: 'outputs.WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeAll',
                 response_time_slowest: 'outputs.WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeSlowest',
                 sensitivity: str):
        """
        :param 'WebAppAnomaliesResponseTimeResponseTimeFixedOverAlertingProtectionArgs' over_alerting_protection: Avoid over-alerting
        :param 'WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeAllArgs' response_time_all: Alert if the key performance metric of all requests degrades beyond this threshold:
        :param 'WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeSlowestArgs' response_time_slowest: Alert if the key performance metric of the slowest 10% of requests degrades beyond this threshold:
        :param str sensitivity: Possible Values: `Medium`, `High`, `Low`
        """
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "response_time_all", response_time_all)
        pulumi.set(__self__, "response_time_slowest", response_time_slowest)
        pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.WebAppAnomaliesResponseTimeResponseTimeFixedOverAlertingProtection':
        """
        Avoid over-alerting
        """
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter(name="responseTimeAll")
    def response_time_all(self) -> 'outputs.WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeAll':
        """
        Alert if the key performance metric of all requests degrades beyond this threshold:
        """
        return pulumi.get(self, "response_time_all")

    @property
    @pulumi.getter(name="responseTimeSlowest")
    def response_time_slowest(self) -> 'outputs.WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeSlowest':
        """
        Alert if the key performance metric of the slowest 10% of requests degrades beyond this threshold:
        """
        return pulumi.get(self, "response_time_slowest")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        """
        Possible Values: `Medium`, `High`, `Low`
        """
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class WebAppAnomaliesResponseTimeResponseTimeFixedOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsPerMinute":
            suggest = "actions_per_minute"
        elif key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesResponseTimeResponseTimeFixedOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeFixedOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeFixedOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_per_minute: float,
                 minutes_abnormal_state: float):
        """
        :param float actions_per_minute: Only alert if there are at least
        :param float minutes_abnormal_state: Only alert if the abnormal state remains for at least
        """
        pulumi.set(__self__, "actions_per_minute", actions_per_minute)
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)

    @property
    @pulumi.getter(name="actionsPerMinute")
    def actions_per_minute(self) -> float:
        """
        Only alert if there are at least
        """
        return pulumi.get(self, "actions_per_minute")

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> float:
        """
        Only alert if the abnormal state remains for at least
        """
        return pulumi.get(self, "minutes_abnormal_state")


@pulumi.output_type
class WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeAll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "degradationMilliseconds":
            suggest = "degradation_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeAll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeAll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeAll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 degradation_milliseconds: float):
        """
        :param float degradation_milliseconds: Alert if the key performance metric degrades beyond this many ms within an observation period of 5 minutes
        """
        pulumi.set(__self__, "degradation_milliseconds", degradation_milliseconds)

    @property
    @pulumi.getter(name="degradationMilliseconds")
    def degradation_milliseconds(self) -> float:
        """
        Alert if the key performance metric degrades beyond this many ms within an observation period of 5 minutes
        """
        return pulumi.get(self, "degradation_milliseconds")


@pulumi.output_type
class WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestDegradationMilliseconds":
            suggest = "slowest_degradation_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slowest_degradation_milliseconds: float):
        """
        :param float slowest_degradation_milliseconds: Alert if the key performance metric of the slowest 10% degrades beyond this many ms within an observation period of 5 minutes
        """
        pulumi.set(__self__, "slowest_degradation_milliseconds", slowest_degradation_milliseconds)

    @property
    @pulumi.getter(name="slowestDegradationMilliseconds")
    def slowest_degradation_milliseconds(self) -> float:
        """
        Alert if the key performance metric of the slowest 10% degrades beyond this many ms within an observation period of 5 minutes
        """
        return pulumi.get(self, "slowest_degradation_milliseconds")


@pulumi.output_type
class WebAppAnomaliesTrafficDrops(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trafficDrops":
            suggest = "traffic_drops"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesTrafficDrops. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesTrafficDrops.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesTrafficDrops.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 traffic_drops: Optional['outputs.WebAppAnomaliesTrafficDropsTrafficDrops'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'WebAppAnomaliesTrafficDropsTrafficDropsArgs' traffic_drops: Dynatrace learns your typical application traffic over an observation period of one week.
        """
        pulumi.set(__self__, "enabled", enabled)
        if traffic_drops is not None:
            pulumi.set(__self__, "traffic_drops", traffic_drops)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="trafficDrops")
    def traffic_drops(self) -> Optional['outputs.WebAppAnomaliesTrafficDropsTrafficDrops']:
        """
        Dynatrace learns your typical application traffic over an observation period of one week.
        """
        return pulumi.get(self, "traffic_drops")


@pulumi.output_type
class WebAppAnomaliesTrafficDropsTrafficDrops(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "abnormalStateAbnormalState":
            suggest = "abnormal_state_abnormal_state"
        elif key == "trafficDropPercentage":
            suggest = "traffic_drop_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesTrafficDropsTrafficDrops. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesTrafficDropsTrafficDrops.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesTrafficDropsTrafficDrops.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 abnormal_state_abnormal_state: float,
                 traffic_drop_percentage: float):
        """
        :param float abnormal_state_abnormal_state: Minutes the observed traffic has to stay in abnormal state before alert
        :param float traffic_drop_percentage: Alert if the observed traffic is less than this percentage of the expected value
        """
        pulumi.set(__self__, "abnormal_state_abnormal_state", abnormal_state_abnormal_state)
        pulumi.set(__self__, "traffic_drop_percentage", traffic_drop_percentage)

    @property
    @pulumi.getter(name="abnormalStateAbnormalState")
    def abnormal_state_abnormal_state(self) -> float:
        """
        Minutes the observed traffic has to stay in abnormal state before alert
        """
        return pulumi.get(self, "abnormal_state_abnormal_state")

    @property
    @pulumi.getter(name="trafficDropPercentage")
    def traffic_drop_percentage(self) -> float:
        """
        Alert if the observed traffic is less than this percentage of the expected value
        """
        return pulumi.get(self, "traffic_drop_percentage")


@pulumi.output_type
class WebAppAnomaliesTrafficSpikes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trafficSpikes":
            suggest = "traffic_spikes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesTrafficSpikes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesTrafficSpikes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesTrafficSpikes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 traffic_spikes: Optional['outputs.WebAppAnomaliesTrafficSpikesTrafficSpikes'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'WebAppAnomaliesTrafficSpikesTrafficSpikesArgs' traffic_spikes: Dynatrace learns your typical application traffic over an observation period of one week.
        """
        pulumi.set(__self__, "enabled", enabled)
        if traffic_spikes is not None:
            pulumi.set(__self__, "traffic_spikes", traffic_spikes)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="trafficSpikes")
    def traffic_spikes(self) -> Optional['outputs.WebAppAnomaliesTrafficSpikesTrafficSpikes']:
        """
        Dynatrace learns your typical application traffic over an observation period of one week.
        """
        return pulumi.get(self, "traffic_spikes")


@pulumi.output_type
class WebAppAnomaliesTrafficSpikesTrafficSpikes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"
        elif key == "trafficSpikePercentage":
            suggest = "traffic_spike_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesTrafficSpikesTrafficSpikes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesTrafficSpikesTrafficSpikes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesTrafficSpikesTrafficSpikes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_abnormal_state: float,
                 traffic_spike_percentage: float):
        """
        :param float minutes_abnormal_state: Minutes an application has to stay in abnormal state before alert
        :param float traffic_spike_percentage: Alert if the observed traffic is more than this percentage of the expected value
        """
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)
        pulumi.set(__self__, "traffic_spike_percentage", traffic_spike_percentage)

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> float:
        """
        Minutes an application has to stay in abnormal state before alert
        """
        return pulumi.get(self, "minutes_abnormal_state")

    @property
    @pulumi.getter(name="trafficSpikePercentage")
    def traffic_spike_percentage(self) -> float:
        """
        Alert if the observed traffic is more than this percentage of the expected value
        """
        return pulumi.get(self, "traffic_spike_percentage")


@pulumi.output_type
class WebAppCustomErrorsErrorRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorRules":
            suggest = "error_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppCustomErrorsErrorRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppCustomErrorsErrorRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppCustomErrorsErrorRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_rules: Sequence['outputs.WebAppCustomErrorsErrorRulesErrorRule']):
        pulumi.set(__self__, "error_rules", error_rules)

    @property
    @pulumi.getter(name="errorRules")
    def error_rules(self) -> Sequence['outputs.WebAppCustomErrorsErrorRulesErrorRule']:
        return pulumi.get(self, "error_rules")


@pulumi.output_type
class WebAppCustomErrorsErrorRulesErrorRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "captureSettings":
            suggest = "capture_settings"
        elif key == "keyMatcher":
            suggest = "key_matcher"
        elif key == "valueMatcher":
            suggest = "value_matcher"
        elif key == "keyPattern":
            suggest = "key_pattern"
        elif key == "valuePattern":
            suggest = "value_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppCustomErrorsErrorRulesErrorRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppCustomErrorsErrorRulesErrorRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppCustomErrorsErrorRulesErrorRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture_settings: 'outputs.WebAppCustomErrorsErrorRulesErrorRuleCaptureSettings',
                 key_matcher: str,
                 value_matcher: str,
                 key_pattern: Optional[str] = None,
                 value_pattern: Optional[str] = None):
        """
        :param 'WebAppCustomErrorsErrorRulesErrorRuleCaptureSettingsArgs' capture_settings: Capture settings
        :param str key_matcher: Possible Values: `ALL`, `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`
        :param str value_matcher: Possible Values: `ALL`, `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`
        :param str key_pattern: A case-insensitive key pattern
        :param str value_pattern: A case-insensitive value pattern
        """
        pulumi.set(__self__, "capture_settings", capture_settings)
        pulumi.set(__self__, "key_matcher", key_matcher)
        pulumi.set(__self__, "value_matcher", value_matcher)
        if key_pattern is not None:
            pulumi.set(__self__, "key_pattern", key_pattern)
        if value_pattern is not None:
            pulumi.set(__self__, "value_pattern", value_pattern)

    @property
    @pulumi.getter(name="captureSettings")
    def capture_settings(self) -> 'outputs.WebAppCustomErrorsErrorRulesErrorRuleCaptureSettings':
        """
        Capture settings
        """
        return pulumi.get(self, "capture_settings")

    @property
    @pulumi.getter(name="keyMatcher")
    def key_matcher(self) -> str:
        """
        Possible Values: `ALL`, `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`
        """
        return pulumi.get(self, "key_matcher")

    @property
    @pulumi.getter(name="valueMatcher")
    def value_matcher(self) -> str:
        """
        Possible Values: `ALL`, `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`
        """
        return pulumi.get(self, "value_matcher")

    @property
    @pulumi.getter(name="keyPattern")
    def key_pattern(self) -> Optional[str]:
        """
        A case-insensitive key pattern
        """
        return pulumi.get(self, "key_pattern")

    @property
    @pulumi.getter(name="valuePattern")
    def value_pattern(self) -> Optional[str]:
        """
        A case-insensitive value pattern
        """
        return pulumi.get(self, "value_pattern")


@pulumi.output_type
class WebAppCustomErrorsErrorRulesErrorRuleCaptureSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "considerForAi":
            suggest = "consider_for_ai"
        elif key == "impactApdex":
            suggest = "impact_apdex"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppCustomErrorsErrorRulesErrorRuleCaptureSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppCustomErrorsErrorRulesErrorRuleCaptureSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppCustomErrorsErrorRulesErrorRuleCaptureSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture: bool,
                 consider_for_ai: Optional[bool] = None,
                 impact_apdex: Optional[bool] = None):
        """
        :param bool capture: Capture this error
        :param bool consider_for_ai: [View more details](https://dt-url.net/hd580p2k)
        :param bool impact_apdex: Include error in Apdex calculations
        """
        pulumi.set(__self__, "capture", capture)
        if consider_for_ai is not None:
            pulumi.set(__self__, "consider_for_ai", consider_for_ai)
        if impact_apdex is not None:
            pulumi.set(__self__, "impact_apdex", impact_apdex)

    @property
    @pulumi.getter
    def capture(self) -> bool:
        """
        Capture this error
        """
        return pulumi.get(self, "capture")

    @property
    @pulumi.getter(name="considerForAi")
    def consider_for_ai(self) -> Optional[bool]:
        """
        [View more details](https://dt-url.net/hd580p2k)
        """
        return pulumi.get(self, "consider_for_ai")

    @property
    @pulumi.getter(name="impactApdex")
    def impact_apdex(self) -> Optional[bool]:
        """
        Include error in Apdex calculations
        """
        return pulumi.get(self, "impact_apdex")


@pulumi.output_type
class WebAppEnablementRum(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costAndTrafficControl":
            suggest = "cost_and_traffic_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppEnablementRum. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppEnablementRum.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppEnablementRum.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_and_traffic_control: int,
                 enabled: bool):
        """
        :param int cost_and_traffic_control: (Field has overlap with `WebApplication`) Percentage of user sessions captured and analyzed
        :param bool enabled: (Field has overlap with `WebApplication`) This setting is enabled (`true`) or disabled (`false`)
        """
        pulumi.set(__self__, "cost_and_traffic_control", cost_and_traffic_control)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="costAndTrafficControl")
    def cost_and_traffic_control(self) -> int:
        """
        (Field has overlap with `WebApplication`) Percentage of user sessions captured and analyzed
        """
        return pulumi.get(self, "cost_and_traffic_control")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        (Field has overlap with `WebApplication`) This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WebAppEnablementSessionReplay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costAndTrafficControl":
            suggest = "cost_and_traffic_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppEnablementSessionReplay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppEnablementSessionReplay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppEnablementSessionReplay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_and_traffic_control: int,
                 enabled: bool):
        """
        :param int cost_and_traffic_control: (Field has overlap with `WebApplication`) [Percentage of user sessions recorded with Session Replay](https://dt-url.net/sr-cost-traffic-control). For example, if you have 50% for RUM and 50% for Session Replay, it results in 25% of sessions recorded with Session Replay.
        :param bool enabled: (Field has overlap with `WebApplication`) This setting is enabled (`true`) or disabled (`false`)
        """
        pulumi.set(__self__, "cost_and_traffic_control", cost_and_traffic_control)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="costAndTrafficControl")
    def cost_and_traffic_control(self) -> int:
        """
        (Field has overlap with `WebApplication`) [Percentage of user sessions recorded with Session Replay](https://dt-url.net/sr-cost-traffic-control). For example, if you have 50% for RUM and 50% for Session Replay, it results in 25% of sessions recorded with Session Replay.
        """
        return pulumi.get(self, "cost_and_traffic_control")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        (Field has overlap with `WebApplication`) This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WebAppKeyPerformanceCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frustratingThresholdSeconds":
            suggest = "frustrating_threshold_seconds"
        elif key == "toleratedThresholdSeconds":
            suggest = "tolerated_threshold_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppKeyPerformanceCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppKeyPerformanceCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppKeyPerformanceCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frustrating_threshold_seconds: float,
                 tolerated_threshold_seconds: float):
        """
        :param float frustrating_threshold_seconds: If **User action duration** is above this value, the action is assigned to the Frustrated performance zone.
        :param float tolerated_threshold_seconds: If **User action duration** is below this value, the action is assigned to the Satisfied performance zone.
        """
        pulumi.set(__self__, "frustrating_threshold_seconds", frustrating_threshold_seconds)
        pulumi.set(__self__, "tolerated_threshold_seconds", tolerated_threshold_seconds)

    @property
    @pulumi.getter(name="frustratingThresholdSeconds")
    def frustrating_threshold_seconds(self) -> float:
        """
        If **User action duration** is above this value, the action is assigned to the Frustrated performance zone.
        """
        return pulumi.get(self, "frustrating_threshold_seconds")

    @property
    @pulumi.getter(name="toleratedThresholdSeconds")
    def tolerated_threshold_seconds(self) -> float:
        """
        If **User action duration** is below this value, the action is assigned to the Satisfied performance zone.
        """
        return pulumi.get(self, "tolerated_threshold_seconds")


@pulumi.output_type
class WebAppKeyPerformanceLoadFallbackThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frustratingFallbackThresholdSeconds":
            suggest = "frustrating_fallback_threshold_seconds"
        elif key == "toleratedFallbackThresholdSeconds":
            suggest = "tolerated_fallback_threshold_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppKeyPerformanceLoadFallbackThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppKeyPerformanceLoadFallbackThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppKeyPerformanceLoadFallbackThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frustrating_fallback_threshold_seconds: float,
                 tolerated_fallback_threshold_seconds: float):
        """
        :param float frustrating_fallback_threshold_seconds: If **User action duration** is above this value, the action is assigned to the Frustrated performance zone.
        :param float tolerated_fallback_threshold_seconds: If **User action duration** is below this value, the action is assigned to the Satisfied performance zone.
        """
        pulumi.set(__self__, "frustrating_fallback_threshold_seconds", frustrating_fallback_threshold_seconds)
        pulumi.set(__self__, "tolerated_fallback_threshold_seconds", tolerated_fallback_threshold_seconds)

    @property
    @pulumi.getter(name="frustratingFallbackThresholdSeconds")
    def frustrating_fallback_threshold_seconds(self) -> float:
        """
        If **User action duration** is above this value, the action is assigned to the Frustrated performance zone.
        """
        return pulumi.get(self, "frustrating_fallback_threshold_seconds")

    @property
    @pulumi.getter(name="toleratedFallbackThresholdSeconds")
    def tolerated_fallback_threshold_seconds(self) -> float:
        """
        If **User action duration** is below this value, the action is assigned to the Satisfied performance zone.
        """
        return pulumi.get(self, "tolerated_fallback_threshold_seconds")


@pulumi.output_type
class WebAppKeyPerformanceLoadThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frustratingThresholdSeconds":
            suggest = "frustrating_threshold_seconds"
        elif key == "toleratedThresholdSeconds":
            suggest = "tolerated_threshold_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppKeyPerformanceLoadThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppKeyPerformanceLoadThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppKeyPerformanceLoadThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frustrating_threshold_seconds: float,
                 tolerated_threshold_seconds: float):
        """
        :param float frustrating_threshold_seconds: If the key performance metric is above this value, the action is assigned to the Frustrated performance zone.
        :param float tolerated_threshold_seconds: If the key performance metric is below this value, the action is assigned to the Satisfied performance zone.
        """
        pulumi.set(__self__, "frustrating_threshold_seconds", frustrating_threshold_seconds)
        pulumi.set(__self__, "tolerated_threshold_seconds", tolerated_threshold_seconds)

    @property
    @pulumi.getter(name="frustratingThresholdSeconds")
    def frustrating_threshold_seconds(self) -> float:
        """
        If the key performance metric is above this value, the action is assigned to the Frustrated performance zone.
        """
        return pulumi.get(self, "frustrating_threshold_seconds")

    @property
    @pulumi.getter(name="toleratedThresholdSeconds")
    def tolerated_threshold_seconds(self) -> float:
        """
        If the key performance metric is below this value, the action is assigned to the Satisfied performance zone.
        """
        return pulumi.get(self, "tolerated_threshold_seconds")


@pulumi.output_type
class WebAppKeyPerformanceXhrFallbackThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frustratingFallbackThresholdSeconds":
            suggest = "frustrating_fallback_threshold_seconds"
        elif key == "toleratedFallbackThresholdSeconds":
            suggest = "tolerated_fallback_threshold_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppKeyPerformanceXhrFallbackThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppKeyPerformanceXhrFallbackThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppKeyPerformanceXhrFallbackThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frustrating_fallback_threshold_seconds: float,
                 tolerated_fallback_threshold_seconds: float):
        """
        :param float frustrating_fallback_threshold_seconds: If **User action duration** is above this value, the action is assigned to the Frustrated performance zone.
        :param float tolerated_fallback_threshold_seconds: If **User action duration** is below this value, the action is assigned to the Satisfied performance zone.
        """
        pulumi.set(__self__, "frustrating_fallback_threshold_seconds", frustrating_fallback_threshold_seconds)
        pulumi.set(__self__, "tolerated_fallback_threshold_seconds", tolerated_fallback_threshold_seconds)

    @property
    @pulumi.getter(name="frustratingFallbackThresholdSeconds")
    def frustrating_fallback_threshold_seconds(self) -> float:
        """
        If **User action duration** is above this value, the action is assigned to the Frustrated performance zone.
        """
        return pulumi.get(self, "frustrating_fallback_threshold_seconds")

    @property
    @pulumi.getter(name="toleratedFallbackThresholdSeconds")
    def tolerated_fallback_threshold_seconds(self) -> float:
        """
        If **User action duration** is below this value, the action is assigned to the Satisfied performance zone.
        """
        return pulumi.get(self, "tolerated_fallback_threshold_seconds")


@pulumi.output_type
class WebAppKeyPerformanceXhrThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frustratingThresholdSeconds":
            suggest = "frustrating_threshold_seconds"
        elif key == "toleratedThresholdSeconds":
            suggest = "tolerated_threshold_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppKeyPerformanceXhrThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppKeyPerformanceXhrThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppKeyPerformanceXhrThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frustrating_threshold_seconds: float,
                 tolerated_threshold_seconds: float):
        """
        :param float frustrating_threshold_seconds: If the key performance metric is above this value, the action is assigned to the Frustrated performance zone.
        :param float tolerated_threshold_seconds: If the key performance metric is below this value, the action is assigned to the Satisfied performance zone.
        """
        pulumi.set(__self__, "frustrating_threshold_seconds", frustrating_threshold_seconds)
        pulumi.set(__self__, "tolerated_threshold_seconds", tolerated_threshold_seconds)

    @property
    @pulumi.getter(name="frustratingThresholdSeconds")
    def frustrating_threshold_seconds(self) -> float:
        """
        If the key performance metric is above this value, the action is assigned to the Frustrated performance zone.
        """
        return pulumi.get(self, "frustrating_threshold_seconds")

    @property
    @pulumi.getter(name="toleratedThresholdSeconds")
    def tolerated_threshold_seconds(self) -> float:
        """
        If the key performance metric is below this value, the action is assigned to the Satisfied performance zone.
        """
        return pulumi.get(self, "tolerated_threshold_seconds")


@pulumi.output_type
class WebAppRequestErrorsErrorRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorRules":
            suggest = "error_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppRequestErrorsErrorRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppRequestErrorsErrorRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppRequestErrorsErrorRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_rules: Sequence['outputs.WebAppRequestErrorsErrorRulesErrorRule']):
        pulumi.set(__self__, "error_rules", error_rules)

    @property
    @pulumi.getter(name="errorRules")
    def error_rules(self) -> Sequence['outputs.WebAppRequestErrorsErrorRulesErrorRule']:
        return pulumi.get(self, "error_rules")


@pulumi.output_type
class WebAppRequestErrorsErrorRulesErrorRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "captureSettings":
            suggest = "capture_settings"
        elif key == "considerCspViolations":
            suggest = "consider_csp_violations"
        elif key == "considerFailedImages":
            suggest = "consider_failed_images"
        elif key == "filterSettings":
            suggest = "filter_settings"
        elif key == "errorCodes":
            suggest = "error_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppRequestErrorsErrorRulesErrorRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppRequestErrorsErrorRulesErrorRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppRequestErrorsErrorRulesErrorRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture_settings: 'outputs.WebAppRequestErrorsErrorRulesErrorRuleCaptureSettings',
                 consider_csp_violations: bool,
                 consider_failed_images: bool,
                 filter_settings: 'outputs.WebAppRequestErrorsErrorRulesErrorRuleFilterSettings',
                 error_codes: Optional[str] = None):
        """
        :param 'WebAppRequestErrorsErrorRulesErrorRuleCaptureSettingsArgs' capture_settings: Capture settings
        :param bool consider_csp_violations: Match by errors that have CSP violations
        :param bool consider_failed_images: Match by errors that have failed image requests
        :param 'WebAppRequestErrorsErrorRulesErrorRuleFilterSettingsArgs' filter_settings: Filter settings
        :param str error_codes: Match by error code
        """
        pulumi.set(__self__, "capture_settings", capture_settings)
        pulumi.set(__self__, "consider_csp_violations", consider_csp_violations)
        pulumi.set(__self__, "consider_failed_images", consider_failed_images)
        pulumi.set(__self__, "filter_settings", filter_settings)
        if error_codes is not None:
            pulumi.set(__self__, "error_codes", error_codes)

    @property
    @pulumi.getter(name="captureSettings")
    def capture_settings(self) -> 'outputs.WebAppRequestErrorsErrorRulesErrorRuleCaptureSettings':
        """
        Capture settings
        """
        return pulumi.get(self, "capture_settings")

    @property
    @pulumi.getter(name="considerCspViolations")
    def consider_csp_violations(self) -> bool:
        """
        Match by errors that have CSP violations
        """
        return pulumi.get(self, "consider_csp_violations")

    @property
    @pulumi.getter(name="considerFailedImages")
    def consider_failed_images(self) -> bool:
        """
        Match by errors that have failed image requests
        """
        return pulumi.get(self, "consider_failed_images")

    @property
    @pulumi.getter(name="filterSettings")
    def filter_settings(self) -> 'outputs.WebAppRequestErrorsErrorRulesErrorRuleFilterSettings':
        """
        Filter settings
        """
        return pulumi.get(self, "filter_settings")

    @property
    @pulumi.getter(name="errorCodes")
    def error_codes(self) -> Optional[str]:
        """
        Match by error code
        """
        return pulumi.get(self, "error_codes")


@pulumi.output_type
class WebAppRequestErrorsErrorRulesErrorRuleCaptureSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "considerForAi":
            suggest = "consider_for_ai"
        elif key == "impactApdex":
            suggest = "impact_apdex"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppRequestErrorsErrorRulesErrorRuleCaptureSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppRequestErrorsErrorRulesErrorRuleCaptureSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppRequestErrorsErrorRulesErrorRuleCaptureSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture: bool,
                 consider_for_ai: Optional[bool] = None,
                 impact_apdex: Optional[bool] = None):
        """
        :param bool capture: Capture this error
        :param bool consider_for_ai: [View more details](https://dt-url.net/hd580p2k)
        :param bool impact_apdex: Include error in Apdex calculations
        """
        pulumi.set(__self__, "capture", capture)
        if consider_for_ai is not None:
            pulumi.set(__self__, "consider_for_ai", consider_for_ai)
        if impact_apdex is not None:
            pulumi.set(__self__, "impact_apdex", impact_apdex)

    @property
    @pulumi.getter
    def capture(self) -> bool:
        """
        Capture this error
        """
        return pulumi.get(self, "capture")

    @property
    @pulumi.getter(name="considerForAi")
    def consider_for_ai(self) -> Optional[bool]:
        """
        [View more details](https://dt-url.net/hd580p2k)
        """
        return pulumi.get(self, "consider_for_ai")

    @property
    @pulumi.getter(name="impactApdex")
    def impact_apdex(self) -> Optional[bool]:
        """
        Include error in Apdex calculations
        """
        return pulumi.get(self, "impact_apdex")


@pulumi.output_type
class WebAppRequestErrorsErrorRulesErrorRuleFilterSettings(dict):
    def __init__(__self__, *,
                 filter: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str filter: Possible Values: `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`
        :param str url: no documentation available
        """
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        Possible Values: `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        no documentation available
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class WebApplicationConversionGoals(dict):
    def __init__(__self__, *,
                 goals: Sequence['outputs.WebApplicationConversionGoalsGoal']):
        """
        :param Sequence['WebApplicationConversionGoalsGoalArgs'] goals: A conversion goal of the application
        """
        pulumi.set(__self__, "goals", goals)

    @property
    @pulumi.getter
    def goals(self) -> Sequence['outputs.WebApplicationConversionGoalsGoal']:
        """
        A conversion goal of the application
        """
        return pulumi.get(self, "goals")


@pulumi.output_type
class WebApplicationConversionGoalsGoal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userAction":
            suggest = "user_action"
        elif key == "visitDuration":
            suggest = "visit_duration"
        elif key == "visitNumAction":
            suggest = "visit_num_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationConversionGoalsGoal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationConversionGoalsGoal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationConversionGoalsGoal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 destination: Optional['outputs.WebApplicationConversionGoalsGoalDestination'] = None,
                 id: Optional[str] = None,
                 type: Optional[str] = None,
                 user_action: Optional['outputs.WebApplicationConversionGoalsGoalUserAction'] = None,
                 visit_duration: Optional['outputs.WebApplicationConversionGoalsGoalVisitDuration'] = None,
                 visit_num_action: Optional['outputs.WebApplicationConversionGoalsGoalVisitNumAction'] = None):
        """
        :param str name: The name of the conversion goal. Valid length within 1 and 50 characters.
        :param 'WebApplicationConversionGoalsGoalDestinationArgs' destination: Configuration of a destination-based conversion goal
        :param str id: The ID of conversion goal.
        :param str type: The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        :param 'WebApplicationConversionGoalsGoalUserActionArgs' user_action: Configuration of a destination-based conversion goal
        :param 'WebApplicationConversionGoalsGoalVisitDurationArgs' visit_duration: Configuration of a destination-based conversion goal
        :param 'WebApplicationConversionGoalsGoalVisitNumActionArgs' visit_num_action: Configuration of a destination-based conversion goal
        """
        pulumi.set(__self__, "name", name)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_action is not None:
            pulumi.set(__self__, "user_action", user_action)
        if visit_duration is not None:
            pulumi.set(__self__, "visit_duration", visit_duration)
        if visit_num_action is not None:
            pulumi.set(__self__, "visit_num_action", visit_num_action)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the conversion goal. Valid length within 1 and 50 characters.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.WebApplicationConversionGoalsGoalDestination']:
        """
        Configuration of a destination-based conversion goal
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of conversion goal.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAction")
    def user_action(self) -> Optional['outputs.WebApplicationConversionGoalsGoalUserAction']:
        """
        Configuration of a destination-based conversion goal
        """
        return pulumi.get(self, "user_action")

    @property
    @pulumi.getter(name="visitDuration")
    def visit_duration(self) -> Optional['outputs.WebApplicationConversionGoalsGoalVisitDuration']:
        """
        Configuration of a destination-based conversion goal
        """
        return pulumi.get(self, "visit_duration")

    @property
    @pulumi.getter(name="visitNumAction")
    def visit_num_action(self) -> Optional['outputs.WebApplicationConversionGoalsGoalVisitNumAction']:
        """
        Configuration of a destination-based conversion goal
        """
        return pulumi.get(self, "visit_num_action")


@pulumi.output_type
class WebApplicationConversionGoalsGoalDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlOrPath":
            suggest = "url_or_path"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchType":
            suggest = "match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationConversionGoalsGoalDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationConversionGoalsGoalDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationConversionGoalsGoalDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url_or_path: str,
                 case_sensitive: Optional[bool] = None,
                 match_type: Optional[str] = None):
        """
        :param str url_or_path: The path to be reached to hit the conversion goal
        :param bool case_sensitive: The match is case-sensitive (`true`) or (`false`)
        :param str match_type: The operator of the match. Possible values are `Begins`, `Contains` and `Ends`.
        """
        pulumi.set(__self__, "url_or_path", url_or_path)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)

    @property
    @pulumi.getter(name="urlOrPath")
    def url_or_path(self) -> str:
        """
        The path to be reached to hit the conversion goal
        """
        return pulumi.get(self, "url_or_path")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The match is case-sensitive (`true`) or (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        The operator of the match. Possible values are `Begins`, `Contains` and `Ends`.
        """
        return pulumi.get(self, "match_type")


@pulumi.output_type
class WebApplicationConversionGoalsGoalUserAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchEntity":
            suggest = "match_entity"
        elif key == "matchType":
            suggest = "match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationConversionGoalsGoalUserAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationConversionGoalsGoalUserAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationConversionGoalsGoalUserAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: Optional[str] = None,
                 case_sensitive: Optional[bool] = None,
                 match_entity: Optional[str] = None,
                 match_type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str action_type: Type of the action to which the rule applies. Possible values are `Custom`, `Load` and `Xhr`.
        :param bool case_sensitive: The match is case-sensitive (`true`) or (`false`)
        :param str match_entity: The type of the entity to which the rule applies. Possible values are `ActionName`, `CssSelector`, `JavaScriptVariable`, `MetaTag`, `PagePath`, `PageTitle`, `PageUrl`, `UrlAnchor` and `XhrUrl`.
        :param str match_type: The operator of the match. Possible values are `Begins`, `Contains` and `Ends`.
        :param str value: The value to be matched to hit the conversion goal
        """
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_entity is not None:
            pulumi.set(__self__, "match_entity", match_entity)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        """
        Type of the action to which the rule applies. Possible values are `Custom`, `Load` and `Xhr`.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        The match is case-sensitive (`true`) or (`false`)
        """
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchEntity")
    def match_entity(self) -> Optional[str]:
        """
        The type of the entity to which the rule applies. Possible values are `ActionName`, `CssSelector`, `JavaScriptVariable`, `MetaTag`, `PagePath`, `PageTitle`, `PageUrl`, `UrlAnchor` and `XhrUrl`.
        """
        return pulumi.get(self, "match_entity")

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        The operator of the match. Possible values are `Begins`, `Contains` and `Ends`.
        """
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to be matched to hit the conversion goal
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebApplicationConversionGoalsGoalVisitDuration(dict):
    def __init__(__self__, *,
                 duration: int):
        """
        :param int duration: The duration of session to hit the conversion goal, in milliseconds
        """
        pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter
    def duration(self) -> int:
        """
        The duration of session to hit the conversion goal, in milliseconds
        """
        return pulumi.get(self, "duration")


@pulumi.output_type
class WebApplicationConversionGoalsGoalVisitNumAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numUserActions":
            suggest = "num_user_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationConversionGoalsGoalVisitNumAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationConversionGoalsGoalVisitNumAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationConversionGoalsGoalVisitNumAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_user_actions: Optional[int] = None):
        """
        :param int num_user_actions: The number of user actions to hit the conversion goal
        """
        if num_user_actions is not None:
            pulumi.set(__self__, "num_user_actions", num_user_actions)

    @property
    @pulumi.getter(name="numUserActions")
    def num_user_actions(self) -> Optional[int]:
        """
        The number of user actions to hit the conversion goal
        """
        return pulumi.get(self, "num_user_actions")


@pulumi.output_type
class WebApplicationCustomActionApdexSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frustratingFallbackThreshold":
            suggest = "frustrating_fallback_threshold"
        elif key == "frustratingThreshold":
            suggest = "frustrating_threshold"
        elif key == "toleratedFallbackThreshold":
            suggest = "tolerated_fallback_threshold"
        elif key == "toleratedThreshold":
            suggest = "tolerated_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationCustomActionApdexSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationCustomActionApdexSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationCustomActionApdexSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frustrating_fallback_threshold: int,
                 frustrating_threshold: int,
                 tolerated_fallback_threshold: int,
                 tolerated_threshold: int,
                 threshold: Optional[int] = None):
        """
        :param int frustrating_fallback_threshold: Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
        :param int frustrating_threshold: Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
        :param int tolerated_fallback_threshold: Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
        :param int tolerated_threshold: Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
        :param int threshold: no documentation available
        """
        pulumi.set(__self__, "frustrating_fallback_threshold", frustrating_fallback_threshold)
        pulumi.set(__self__, "frustrating_threshold", frustrating_threshold)
        pulumi.set(__self__, "tolerated_fallback_threshold", tolerated_fallback_threshold)
        pulumi.set(__self__, "tolerated_threshold", tolerated_threshold)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="frustratingFallbackThreshold")
    def frustrating_fallback_threshold(self) -> int:
        """
        Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
        """
        return pulumi.get(self, "frustrating_fallback_threshold")

    @property
    @pulumi.getter(name="frustratingThreshold")
    def frustrating_threshold(self) -> int:
        """
        Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
        """
        return pulumi.get(self, "frustrating_threshold")

    @property
    @pulumi.getter(name="toleratedFallbackThreshold")
    def tolerated_fallback_threshold(self) -> int:
        """
        Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
        """
        return pulumi.get(self, "tolerated_fallback_threshold")

    @property
    @pulumi.getter(name="toleratedThreshold")
    def tolerated_threshold(self) -> int:
        """
        Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
        """
        return pulumi.get(self, "tolerated_threshold")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The attribute `threshold` no longer exists in the API schema, please use `tolerated_threshold`, `frustrating_threshold`, `tolerated_fallback_threshold`, and `frustrating_fallback_threshold` instead""")
    def threshold(self) -> Optional[int]:
        """
        no documentation available
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class WebApplicationKeyUserAction(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.WebApplicationKeyUserActionAction']):
        """
        :param Sequence['WebApplicationKeyUserActionActionArgs'] actions: Configuration of the key user action
        """
        pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.WebApplicationKeyUserActionAction']:
        """
        Configuration of the key user action
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class WebApplicationKeyUserActionAction(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 domain: Optional[str] = None):
        """
        :param str name: The name of the action
        :param str type: The type of the action. Possible values are `Custom`, `Load` and `Xhr`.
        :param str domain: The domain where the action is performed.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the action
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the action. Possible values are `Custom`, `Load` and `Xhr`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        The domain where the action is performed.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class WebApplicationLoadActionApdexSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frustratingFallbackThreshold":
            suggest = "frustrating_fallback_threshold"
        elif key == "frustratingThreshold":
            suggest = "frustrating_threshold"
        elif key == "toleratedFallbackThreshold":
            suggest = "tolerated_fallback_threshold"
        elif key == "toleratedThreshold":
            suggest = "tolerated_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationLoadActionApdexSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationLoadActionApdexSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationLoadActionApdexSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frustrating_fallback_threshold: int,
                 frustrating_threshold: int,
                 tolerated_fallback_threshold: int,
                 tolerated_threshold: int,
                 threshold: Optional[int] = None):
        """
        :param int frustrating_fallback_threshold: Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
        :param int frustrating_threshold: Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
        :param int tolerated_fallback_threshold: Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
        :param int tolerated_threshold: Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
        :param int threshold: no documentation available
        """
        pulumi.set(__self__, "frustrating_fallback_threshold", frustrating_fallback_threshold)
        pulumi.set(__self__, "frustrating_threshold", frustrating_threshold)
        pulumi.set(__self__, "tolerated_fallback_threshold", tolerated_fallback_threshold)
        pulumi.set(__self__, "tolerated_threshold", tolerated_threshold)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="frustratingFallbackThreshold")
    def frustrating_fallback_threshold(self) -> int:
        """
        Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
        """
        return pulumi.get(self, "frustrating_fallback_threshold")

    @property
    @pulumi.getter(name="frustratingThreshold")
    def frustrating_threshold(self) -> int:
        """
        Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
        """
        return pulumi.get(self, "frustrating_threshold")

    @property
    @pulumi.getter(name="toleratedFallbackThreshold")
    def tolerated_fallback_threshold(self) -> int:
        """
        Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
        """
        return pulumi.get(self, "tolerated_fallback_threshold")

    @property
    @pulumi.getter(name="toleratedThreshold")
    def tolerated_threshold(self) -> int:
        """
        Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
        """
        return pulumi.get(self, "tolerated_threshold")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The attribute `threshold` no longer exists in the API schema, please use `tolerated_threshold`, `frustrating_threshold`, `tolerated_fallback_threshold`, and `frustrating_fallback_threshold` instead""")
    def threshold(self) -> Optional[int]:
        """
        no documentation available
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class WebApplicationMetaDataCaptureSettings(dict):
    def __init__(__self__, *,
                 captures: Optional[Sequence['outputs.WebApplicationMetaDataCaptureSettingsCapture']] = None):
        """
        :param Sequence['WebApplicationMetaDataCaptureSettingsCaptureArgs'] captures: Java script agent meta data capture settings
        """
        if captures is not None:
            pulumi.set(__self__, "captures", captures)

    @property
    @pulumi.getter
    def captures(self) -> Optional[Sequence['outputs.WebApplicationMetaDataCaptureSettingsCapture']]:
        """
        Java script agent meta data capture settings
        """
        return pulumi.get(self, "captures")


@pulumi.output_type
class WebApplicationMetaDataCaptureSettingsCapture(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capturingName":
            suggest = "capturing_name"
        elif key == "publicMetadata":
            suggest = "public_metadata"
        elif key == "uniqueId":
            suggest = "unique_id"
        elif key == "useLastValue":
            suggest = "use_last_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMetaDataCaptureSettingsCapture. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMetaDataCaptureSettingsCapture.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMetaDataCaptureSettingsCapture.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capturing_name: str,
                 name: str,
                 type: str,
                 public_metadata: Optional[bool] = None,
                 unique_id: Optional[int] = None,
                 use_last_value: Optional[bool] = None):
        """
        :param str capturing_name: The name of the meta data to capture
        :param str name: Name for displaying the captured values in Dynatrace
        :param str type: The type of the meta data to capture. Possible values are `COOKIE`, `CSS_SELECTOR`, `JAVA_SCRIPT_FUNCTION`, `JAVA_SCRIPT_VARIABLE`, `META_TAG` and `QUERY_STRING`.
        :param bool public_metadata: `true` if this metadata should be captured regardless of the privacy settings, `false` otherwise
        :param int unique_id: The unique ID of the meta data to capture
        :param bool use_last_value: `true` if the last captured value should be used for this metadata. By default the first value will be used.
        """
        pulumi.set(__self__, "capturing_name", capturing_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if public_metadata is not None:
            pulumi.set(__self__, "public_metadata", public_metadata)
        if unique_id is not None:
            pulumi.set(__self__, "unique_id", unique_id)
        if use_last_value is not None:
            pulumi.set(__self__, "use_last_value", use_last_value)

    @property
    @pulumi.getter(name="capturingName")
    def capturing_name(self) -> str:
        """
        The name of the meta data to capture
        """
        return pulumi.get(self, "capturing_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name for displaying the captured values in Dynatrace
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the meta data to capture. Possible values are `COOKIE`, `CSS_SELECTOR`, `JAVA_SCRIPT_FUNCTION`, `JAVA_SCRIPT_VARIABLE`, `META_TAG` and `QUERY_STRING`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="publicMetadata")
    def public_metadata(self) -> Optional[bool]:
        """
        `true` if this metadata should be captured regardless of the privacy settings, `false` otherwise
        """
        return pulumi.get(self, "public_metadata")

    @property
    @pulumi.getter(name="uniqueId")
    def unique_id(self) -> Optional[int]:
        """
        The unique ID of the meta data to capture
        """
        return pulumi.get(self, "unique_id")

    @property
    @pulumi.getter(name="useLastValue")
    def use_last_value(self) -> Optional[bool]:
        """
        `true` if the last captured value should be used for this metadata. By default the first value will be used.
        """
        return pulumi.get(self, "use_last_value")


@pulumi.output_type
class WebApplicationMonitoringSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedJavascriptTagSettings":
            suggest = "advanced_javascript_tag_settings"
        elif key == "contentCapture":
            suggest = "content_capture"
        elif key == "injectionMode":
            suggest = "injection_mode"
        elif key == "addCrossOriginAnonymousAttribute":
            suggest = "add_cross_origin_anonymous_attribute"
        elif key == "angularPackageName":
            suggest = "angular_package_name"
        elif key == "browserRestrictionSettings":
            suggest = "browser_restriction_settings"
        elif key == "cacheControlHeaderOptimizations":
            suggest = "cache_control_header_optimizations"
        elif key == "cookiePlacementDomain":
            suggest = "cookie_placement_domain"
        elif key == "correlationHeaderInclusionRegex":
            suggest = "correlation_header_inclusion_regex"
        elif key == "customConfigurationProperties":
            suggest = "custom_configuration_properties"
        elif key == "excludeXhrRegex":
            suggest = "exclude_xhr_regex"
        elif key == "fetchRequests":
            suggest = "fetch_requests"
        elif key == "instrumentedWebServer":
            suggest = "instrumented_web_server"
        elif key == "ipAddressRestrictionSettings":
            suggest = "ip_address_restriction_settings"
        elif key == "javascriptFrameworkSupport":
            suggest = "javascript_framework_support"
        elif key == "javascriptInjectionRules":
            suggest = "javascript_injection_rules"
        elif key == "libraryFileLocation":
            suggest = "library_file_location"
        elif key == "monitoringDataPath":
            suggest = "monitoring_data_path"
        elif key == "sameSiteCookieAttribute":
            suggest = "same_site_cookie_attribute"
        elif key == "scriptTagCacheDurationInHours":
            suggest = "script_tag_cache_duration_in_hours"
        elif key == "secureCookieAttribute":
            suggest = "secure_cookie_attribute"
        elif key == "serverRequestPathId":
            suggest = "server_request_path_id"
        elif key == "useCors":
            suggest = "use_cors"
        elif key == "xmlHttpRequest":
            suggest = "xml_http_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_javascript_tag_settings: 'outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings',
                 content_capture: 'outputs.WebApplicationMonitoringSettingsContentCapture',
                 injection_mode: str,
                 add_cross_origin_anonymous_attribute: Optional[bool] = None,
                 angular_package_name: Optional[str] = None,
                 browser_restriction_settings: Optional['outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettings'] = None,
                 cache_control_header_optimizations: Optional[bool] = None,
                 cookie_placement_domain: Optional[str] = None,
                 correlation_header_inclusion_regex: Optional[str] = None,
                 custom_configuration_properties: Optional[str] = None,
                 exclude_xhr_regex: Optional[str] = None,
                 fetch_requests: Optional[bool] = None,
                 instrumented_web_server: Optional[bool] = None,
                 ip_address_restriction_settings: Optional['outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettings'] = None,
                 javascript_framework_support: Optional['outputs.WebApplicationMonitoringSettingsJavascriptFrameworkSupport'] = None,
                 javascript_injection_rules: Optional['outputs.WebApplicationMonitoringSettingsJavascriptInjectionRules'] = None,
                 library_file_location: Optional[str] = None,
                 monitoring_data_path: Optional[str] = None,
                 same_site_cookie_attribute: Optional[str] = None,
                 script_tag_cache_duration_in_hours: Optional[int] = None,
                 secure_cookie_attribute: Optional[bool] = None,
                 server_request_path_id: Optional[str] = None,
                 use_cors: Optional[bool] = None,
                 xml_http_request: Optional[bool] = None):
        """
        :param 'WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsArgs' advanced_javascript_tag_settings: Advanced JavaScript tag settings
        :param 'WebApplicationMonitoringSettingsContentCaptureArgs' content_capture: Settings for content capture
        :param str injection_mode: Possible valures are `CODE_SNIPPET`, `CODE_SNIPPET_ASYNC`, `INLINE_CODE` and `JAVASCRIPT_TAG`.
        :param bool add_cross_origin_anonymous_attribute: Add the cross origin = anonymous attribute to capture JavaScript error messages and W3C resource timings
        :param str angular_package_name: The name of the angular package
        :param 'WebApplicationMonitoringSettingsBrowserRestrictionSettingsArgs' browser_restriction_settings: Settings for restricting certain browser type, version, platform and, comparator. It also restricts the mode
        :param bool cache_control_header_optimizations: Optimize the value of cache control headers for use with Dynatrace real user monitoring enabled/disabled
        :param str cookie_placement_domain: Domain for cookie placement. Maximum 150 characters.
        :param str correlation_header_inclusion_regex: To enable RUM for XHR calls to AWS Lambda, define a regular expression matching these calls, Dynatrace can then automatically add a custom header (`x-dtc`) to each such request to the respective endpoints in AWS.
        :param str custom_configuration_properties: The location to send monitoring data from the JavaScript tag.
               
                Specify either a relative or an absolute URL. If you use an absolute URL, data will be sent using CORS. 
               
                **Required** for auto-injected applications, optional for agentless applications. Maximum 512 characters.
        :param str exclude_xhr_regex: You can exclude some actions from becoming XHR actions.
               
               Put a regular expression, matching all the required URLs, here.
               
               If noting specified the feature is disabled
        :param bool fetch_requests: `fetch()` request capture enabled/disabled
        :param bool instrumented_web_server: Instrumented web or app server.
        :param 'WebApplicationMonitoringSettingsIpAddressRestrictionSettingsArgs' ip_address_restriction_settings: Settings for restricting certain ip addresses and for introducing subnet mask. It also restricts the mode
        :param 'WebApplicationMonitoringSettingsJavascriptFrameworkSupportArgs' javascript_framework_support: Support of various JavaScript frameworks
        :param 'WebApplicationMonitoringSettingsJavascriptInjectionRulesArgs' javascript_injection_rules: Java script injection rules
        :param str library_file_location: The location of your application’s custom JavaScript library file. 
               
                If nothing specified the root directory of your web server is used. 
               
                **Required** for auto-injected applications, not supported by agentless applications. Maximum 512 characters.
        :param str monitoring_data_path: The location to send monitoring data from the JavaScript tag.
               
                Specify either a relative or an absolute URL. If you use an absolute URL, data will be sent using CORS. 
               
                **Required** for auto-injected applications, optional for agentless applications. Maximum 512 characters.
        :param str same_site_cookie_attribute: Same site cookie attribute
        :param int script_tag_cache_duration_in_hours: Time duration for the cache settings
        :param bool secure_cookie_attribute: Secure attribute usage for Dynatrace cookies enabled/disabled
        :param str server_request_path_id: Path to identify the server’s request ID. Maximum 150 characters.
        :param bool use_cors: Send beacon data via CORS.
        :param bool xml_http_request: `XmlHttpRequest` support enabled/disabled
        """
        pulumi.set(__self__, "advanced_javascript_tag_settings", advanced_javascript_tag_settings)
        pulumi.set(__self__, "content_capture", content_capture)
        pulumi.set(__self__, "injection_mode", injection_mode)
        if add_cross_origin_anonymous_attribute is not None:
            pulumi.set(__self__, "add_cross_origin_anonymous_attribute", add_cross_origin_anonymous_attribute)
        if angular_package_name is not None:
            pulumi.set(__self__, "angular_package_name", angular_package_name)
        if browser_restriction_settings is not None:
            pulumi.set(__self__, "browser_restriction_settings", browser_restriction_settings)
        if cache_control_header_optimizations is not None:
            pulumi.set(__self__, "cache_control_header_optimizations", cache_control_header_optimizations)
        if cookie_placement_domain is not None:
            pulumi.set(__self__, "cookie_placement_domain", cookie_placement_domain)
        if correlation_header_inclusion_regex is not None:
            pulumi.set(__self__, "correlation_header_inclusion_regex", correlation_header_inclusion_regex)
        if custom_configuration_properties is not None:
            pulumi.set(__self__, "custom_configuration_properties", custom_configuration_properties)
        if exclude_xhr_regex is not None:
            pulumi.set(__self__, "exclude_xhr_regex", exclude_xhr_regex)
        if fetch_requests is not None:
            pulumi.set(__self__, "fetch_requests", fetch_requests)
        if instrumented_web_server is not None:
            pulumi.set(__self__, "instrumented_web_server", instrumented_web_server)
        if ip_address_restriction_settings is not None:
            pulumi.set(__self__, "ip_address_restriction_settings", ip_address_restriction_settings)
        if javascript_framework_support is not None:
            pulumi.set(__self__, "javascript_framework_support", javascript_framework_support)
        if javascript_injection_rules is not None:
            pulumi.set(__self__, "javascript_injection_rules", javascript_injection_rules)
        if library_file_location is not None:
            pulumi.set(__self__, "library_file_location", library_file_location)
        if monitoring_data_path is not None:
            pulumi.set(__self__, "monitoring_data_path", monitoring_data_path)
        if same_site_cookie_attribute is not None:
            pulumi.set(__self__, "same_site_cookie_attribute", same_site_cookie_attribute)
        if script_tag_cache_duration_in_hours is not None:
            pulumi.set(__self__, "script_tag_cache_duration_in_hours", script_tag_cache_duration_in_hours)
        if secure_cookie_attribute is not None:
            pulumi.set(__self__, "secure_cookie_attribute", secure_cookie_attribute)
        if server_request_path_id is not None:
            pulumi.set(__self__, "server_request_path_id", server_request_path_id)
        if use_cors is not None:
            pulumi.set(__self__, "use_cors", use_cors)
        if xml_http_request is not None:
            pulumi.set(__self__, "xml_http_request", xml_http_request)

    @property
    @pulumi.getter(name="advancedJavascriptTagSettings")
    def advanced_javascript_tag_settings(self) -> 'outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings':
        """
        Advanced JavaScript tag settings
        """
        return pulumi.get(self, "advanced_javascript_tag_settings")

    @property
    @pulumi.getter(name="contentCapture")
    def content_capture(self) -> 'outputs.WebApplicationMonitoringSettingsContentCapture':
        """
        Settings for content capture
        """
        return pulumi.get(self, "content_capture")

    @property
    @pulumi.getter(name="injectionMode")
    def injection_mode(self) -> str:
        """
        Possible valures are `CODE_SNIPPET`, `CODE_SNIPPET_ASYNC`, `INLINE_CODE` and `JAVASCRIPT_TAG`.
        """
        return pulumi.get(self, "injection_mode")

    @property
    @pulumi.getter(name="addCrossOriginAnonymousAttribute")
    def add_cross_origin_anonymous_attribute(self) -> Optional[bool]:
        """
        Add the cross origin = anonymous attribute to capture JavaScript error messages and W3C resource timings
        """
        return pulumi.get(self, "add_cross_origin_anonymous_attribute")

    @property
    @pulumi.getter(name="angularPackageName")
    def angular_package_name(self) -> Optional[str]:
        """
        The name of the angular package
        """
        return pulumi.get(self, "angular_package_name")

    @property
    @pulumi.getter(name="browserRestrictionSettings")
    def browser_restriction_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettings']:
        """
        Settings for restricting certain browser type, version, platform and, comparator. It also restricts the mode
        """
        return pulumi.get(self, "browser_restriction_settings")

    @property
    @pulumi.getter(name="cacheControlHeaderOptimizations")
    def cache_control_header_optimizations(self) -> Optional[bool]:
        """
        Optimize the value of cache control headers for use with Dynatrace real user monitoring enabled/disabled
        """
        return pulumi.get(self, "cache_control_header_optimizations")

    @property
    @pulumi.getter(name="cookiePlacementDomain")
    def cookie_placement_domain(self) -> Optional[str]:
        """
        Domain for cookie placement. Maximum 150 characters.
        """
        return pulumi.get(self, "cookie_placement_domain")

    @property
    @pulumi.getter(name="correlationHeaderInclusionRegex")
    def correlation_header_inclusion_regex(self) -> Optional[str]:
        """
        To enable RUM for XHR calls to AWS Lambda, define a regular expression matching these calls, Dynatrace can then automatically add a custom header (`x-dtc`) to each such request to the respective endpoints in AWS.
        """
        return pulumi.get(self, "correlation_header_inclusion_regex")

    @property
    @pulumi.getter(name="customConfigurationProperties")
    def custom_configuration_properties(self) -> Optional[str]:
        """
        The location to send monitoring data from the JavaScript tag.

         Specify either a relative or an absolute URL. If you use an absolute URL, data will be sent using CORS. 

         **Required** for auto-injected applications, optional for agentless applications. Maximum 512 characters.
        """
        return pulumi.get(self, "custom_configuration_properties")

    @property
    @pulumi.getter(name="excludeXhrRegex")
    def exclude_xhr_regex(self) -> Optional[str]:
        """
        You can exclude some actions from becoming XHR actions.

        Put a regular expression, matching all the required URLs, here.

        If noting specified the feature is disabled
        """
        return pulumi.get(self, "exclude_xhr_regex")

    @property
    @pulumi.getter(name="fetchRequests")
    def fetch_requests(self) -> Optional[bool]:
        """
        `fetch()` request capture enabled/disabled
        """
        return pulumi.get(self, "fetch_requests")

    @property
    @pulumi.getter(name="instrumentedWebServer")
    def instrumented_web_server(self) -> Optional[bool]:
        """
        Instrumented web or app server.
        """
        return pulumi.get(self, "instrumented_web_server")

    @property
    @pulumi.getter(name="ipAddressRestrictionSettings")
    def ip_address_restriction_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettings']:
        """
        Settings for restricting certain ip addresses and for introducing subnet mask. It also restricts the mode
        """
        return pulumi.get(self, "ip_address_restriction_settings")

    @property
    @pulumi.getter(name="javascriptFrameworkSupport")
    def javascript_framework_support(self) -> Optional['outputs.WebApplicationMonitoringSettingsJavascriptFrameworkSupport']:
        """
        Support of various JavaScript frameworks
        """
        return pulumi.get(self, "javascript_framework_support")

    @property
    @pulumi.getter(name="javascriptInjectionRules")
    def javascript_injection_rules(self) -> Optional['outputs.WebApplicationMonitoringSettingsJavascriptInjectionRules']:
        """
        Java script injection rules
        """
        return pulumi.get(self, "javascript_injection_rules")

    @property
    @pulumi.getter(name="libraryFileLocation")
    def library_file_location(self) -> Optional[str]:
        """
        The location of your application’s custom JavaScript library file. 

         If nothing specified the root directory of your web server is used. 

         **Required** for auto-injected applications, not supported by agentless applications. Maximum 512 characters.
        """
        return pulumi.get(self, "library_file_location")

    @property
    @pulumi.getter(name="monitoringDataPath")
    def monitoring_data_path(self) -> Optional[str]:
        """
        The location to send monitoring data from the JavaScript tag.

         Specify either a relative or an absolute URL. If you use an absolute URL, data will be sent using CORS. 

         **Required** for auto-injected applications, optional for agentless applications. Maximum 512 characters.
        """
        return pulumi.get(self, "monitoring_data_path")

    @property
    @pulumi.getter(name="sameSiteCookieAttribute")
    def same_site_cookie_attribute(self) -> Optional[str]:
        """
        Same site cookie attribute
        """
        return pulumi.get(self, "same_site_cookie_attribute")

    @property
    @pulumi.getter(name="scriptTagCacheDurationInHours")
    def script_tag_cache_duration_in_hours(self) -> Optional[int]:
        """
        Time duration for the cache settings
        """
        return pulumi.get(self, "script_tag_cache_duration_in_hours")

    @property
    @pulumi.getter(name="secureCookieAttribute")
    def secure_cookie_attribute(self) -> Optional[bool]:
        """
        Secure attribute usage for Dynatrace cookies enabled/disabled
        """
        return pulumi.get(self, "secure_cookie_attribute")

    @property
    @pulumi.getter(name="serverRequestPathId")
    def server_request_path_id(self) -> Optional[str]:
        """
        Path to identify the server’s request ID. Maximum 150 characters.
        """
        return pulumi.get(self, "server_request_path_id")

    @property
    @pulumi.getter(name="useCors")
    def use_cors(self) -> Optional[bool]:
        """
        Send beacon data via CORS.
        """
        return pulumi.get(self, "use_cors")

    @property
    @pulumi.getter(name="xmlHttpRequest")
    def xml_http_request(self) -> Optional[bool]:
        """
        `XmlHttpRequest` support enabled/disabled
        """
        return pulumi.get(self, "xml_http_request")


@pulumi.output_type
class WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalEventHandlers":
            suggest = "additional_event_handlers"
        elif key == "maxActionNameLength":
            suggest = "max_action_name_length"
        elif key == "maxErrorsToCapture":
            suggest = "max_errors_to_capture"
        elif key == "eventWrapperSettings":
            suggest = "event_wrapper_settings"
        elif key == "globalEventCaptureSettings":
            suggest = "global_event_capture_settings"
        elif key == "instrumentUnsupportedAjaxFrameworks":
            suggest = "instrument_unsupported_ajax_frameworks"
        elif key == "specialCharactersToEscape":
            suggest = "special_characters_to_escape"
        elif key == "syncBeaconFirefox":
            suggest = "sync_beacon_firefox"
        elif key == "syncBeaconInternetExplorer":
            suggest = "sync_beacon_internet_explorer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_event_handlers: 'outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers',
                 max_action_name_length: int,
                 max_errors_to_capture: int,
                 event_wrapper_settings: Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings'] = None,
                 global_event_capture_settings: Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings'] = None,
                 instrument_unsupported_ajax_frameworks: Optional[bool] = None,
                 special_characters_to_escape: Optional[str] = None,
                 sync_beacon_firefox: Optional[bool] = None,
                 sync_beacon_internet_explorer: Optional[bool] = None):
        """
        :param 'WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlersArgs' additional_event_handlers: Additional event handlers and wrappers
        :param int max_action_name_length: Maximum character length for action names. Valid values range from 5 to 10000.
        :param int max_errors_to_capture: Maximum number of errors to be captured per page. Valid values range from 0 to 50.
        :param 'WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettingsArgs' event_wrapper_settings: In addition to the event handlers, events called using `addEventListener` or `attachEvent` can be captured. Be careful with this option! Event wrappers can conflict with the JavaScript code on a web page
        :param 'WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettingsArgs' global_event_capture_settings: Global event capture settings
        :param bool instrument_unsupported_ajax_frameworks: Instrumentation of unsupported Ajax frameworks enabled/disabled
        :param str special_characters_to_escape: Additional special characters that are to be escaped using non-alphanumeric characters in HTML escape format. Maximum length 30 character. Allowed characters are `^`, `\\`, `<` and `>`.
        :param bool sync_beacon_firefox: Send the beacon signal as a synchronous XMLHttpRequest using Firefox enabled/disabled
        :param bool sync_beacon_internet_explorer: Send the beacon signal as a synchronous XMLHttpRequest using Internet Explorer enabled/disabled
        """
        pulumi.set(__self__, "additional_event_handlers", additional_event_handlers)
        pulumi.set(__self__, "max_action_name_length", max_action_name_length)
        pulumi.set(__self__, "max_errors_to_capture", max_errors_to_capture)
        if event_wrapper_settings is not None:
            pulumi.set(__self__, "event_wrapper_settings", event_wrapper_settings)
        if global_event_capture_settings is not None:
            pulumi.set(__self__, "global_event_capture_settings", global_event_capture_settings)
        if instrument_unsupported_ajax_frameworks is not None:
            pulumi.set(__self__, "instrument_unsupported_ajax_frameworks", instrument_unsupported_ajax_frameworks)
        if special_characters_to_escape is not None:
            pulumi.set(__self__, "special_characters_to_escape", special_characters_to_escape)
        if sync_beacon_firefox is not None:
            pulumi.set(__self__, "sync_beacon_firefox", sync_beacon_firefox)
        if sync_beacon_internet_explorer is not None:
            pulumi.set(__self__, "sync_beacon_internet_explorer", sync_beacon_internet_explorer)

    @property
    @pulumi.getter(name="additionalEventHandlers")
    def additional_event_handlers(self) -> 'outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers':
        """
        Additional event handlers and wrappers
        """
        return pulumi.get(self, "additional_event_handlers")

    @property
    @pulumi.getter(name="maxActionNameLength")
    def max_action_name_length(self) -> int:
        """
        Maximum character length for action names. Valid values range from 5 to 10000.
        """
        return pulumi.get(self, "max_action_name_length")

    @property
    @pulumi.getter(name="maxErrorsToCapture")
    def max_errors_to_capture(self) -> int:
        """
        Maximum number of errors to be captured per page. Valid values range from 0 to 50.
        """
        return pulumi.get(self, "max_errors_to_capture")

    @property
    @pulumi.getter(name="eventWrapperSettings")
    def event_wrapper_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings']:
        """
        In addition to the event handlers, events called using `addEventListener` or `attachEvent` can be captured. Be careful with this option! Event wrappers can conflict with the JavaScript code on a web page
        """
        return pulumi.get(self, "event_wrapper_settings")

    @property
    @pulumi.getter(name="globalEventCaptureSettings")
    def global_event_capture_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings']:
        """
        Global event capture settings
        """
        return pulumi.get(self, "global_event_capture_settings")

    @property
    @pulumi.getter(name="instrumentUnsupportedAjaxFrameworks")
    def instrument_unsupported_ajax_frameworks(self) -> Optional[bool]:
        """
        Instrumentation of unsupported Ajax frameworks enabled/disabled
        """
        return pulumi.get(self, "instrument_unsupported_ajax_frameworks")

    @property
    @pulumi.getter(name="specialCharactersToEscape")
    def special_characters_to_escape(self) -> Optional[str]:
        """
        Additional special characters that are to be escaped using non-alphanumeric characters in HTML escape format. Maximum length 30 character. Allowed characters are `^`, `\\`, `<` and `>`.
        """
        return pulumi.get(self, "special_characters_to_escape")

    @property
    @pulumi.getter(name="syncBeaconFirefox")
    def sync_beacon_firefox(self) -> Optional[bool]:
        """
        Send the beacon signal as a synchronous XMLHttpRequest using Firefox enabled/disabled
        """
        return pulumi.get(self, "sync_beacon_firefox")

    @property
    @pulumi.getter(name="syncBeaconInternetExplorer")
    def sync_beacon_internet_explorer(self) -> Optional[bool]:
        """
        Send the beacon signal as a synchronous XMLHttpRequest using Internet Explorer enabled/disabled
        """
        return pulumi.get(self, "sync_beacon_internet_explorer")


@pulumi.output_type
class WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxDomNodes":
            suggest = "max_dom_nodes"
        elif key == "toStringMethod":
            suggest = "to_string_method"
        elif key == "useMouseUpEventForClicks":
            suggest = "use_mouse_up_event_for_clicks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_dom_nodes: int,
                 blur: Optional[bool] = None,
                 change: Optional[bool] = None,
                 click: Optional[bool] = None,
                 mouseup: Optional[bool] = None,
                 to_string_method: Optional[bool] = None,
                 use_mouse_up_event_for_clicks: Optional[bool] = None):
        """
        :param int max_dom_nodes: Max. number of DOM nodes to instrument. Valid values range from 0 to 100000.
        :param bool blur: Blur event handler enabled/disabled
        :param bool change: Change event handler enabled/disabled
        :param bool click: Click event handler enabled/disabled
        :param bool mouseup: Mouseup event handler enabled/disabled
        :param bool to_string_method: toString method enabled/disabled
        :param bool use_mouse_up_event_for_clicks: Use mouseup event for clicks enabled/disabled
        """
        pulumi.set(__self__, "max_dom_nodes", max_dom_nodes)
        if blur is not None:
            pulumi.set(__self__, "blur", blur)
        if change is not None:
            pulumi.set(__self__, "change", change)
        if click is not None:
            pulumi.set(__self__, "click", click)
        if mouseup is not None:
            pulumi.set(__self__, "mouseup", mouseup)
        if to_string_method is not None:
            pulumi.set(__self__, "to_string_method", to_string_method)
        if use_mouse_up_event_for_clicks is not None:
            pulumi.set(__self__, "use_mouse_up_event_for_clicks", use_mouse_up_event_for_clicks)

    @property
    @pulumi.getter(name="maxDomNodes")
    def max_dom_nodes(self) -> int:
        """
        Max. number of DOM nodes to instrument. Valid values range from 0 to 100000.
        """
        return pulumi.get(self, "max_dom_nodes")

    @property
    @pulumi.getter
    def blur(self) -> Optional[bool]:
        """
        Blur event handler enabled/disabled
        """
        return pulumi.get(self, "blur")

    @property
    @pulumi.getter
    def change(self) -> Optional[bool]:
        """
        Change event handler enabled/disabled
        """
        return pulumi.get(self, "change")

    @property
    @pulumi.getter
    def click(self) -> Optional[bool]:
        """
        Click event handler enabled/disabled
        """
        return pulumi.get(self, "click")

    @property
    @pulumi.getter
    def mouseup(self) -> Optional[bool]:
        """
        Mouseup event handler enabled/disabled
        """
        return pulumi.get(self, "mouseup")

    @property
    @pulumi.getter(name="toStringMethod")
    def to_string_method(self) -> Optional[bool]:
        """
        toString method enabled/disabled
        """
        return pulumi.get(self, "to_string_method")

    @property
    @pulumi.getter(name="useMouseUpEventForClicks")
    def use_mouse_up_event_for_clicks(self) -> Optional[bool]:
        """
        Use mouseup event for clicks enabled/disabled
        """
        return pulumi.get(self, "use_mouse_up_event_for_clicks")


@pulumi.output_type
class WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "touchEnd":
            suggest = "touch_end"
        elif key == "touchStart":
            suggest = "touch_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blur: Optional[bool] = None,
                 change: Optional[bool] = None,
                 click: Optional[bool] = None,
                 mouseup: Optional[bool] = None,
                 touch_end: Optional[bool] = None,
                 touch_start: Optional[bool] = None):
        """
        :param bool blur: Blur enabled/disabled
        :param bool change: Change enabled/disabled
        :param bool click: Click enabled/disabled
        :param bool mouseup: MouseUp enabled/disabled
        :param bool touch_end: TouchEnd enabled/disabled
        :param bool touch_start: TouchStart enabled/disabled
        """
        if blur is not None:
            pulumi.set(__self__, "blur", blur)
        if change is not None:
            pulumi.set(__self__, "change", change)
        if click is not None:
            pulumi.set(__self__, "click", click)
        if mouseup is not None:
            pulumi.set(__self__, "mouseup", mouseup)
        if touch_end is not None:
            pulumi.set(__self__, "touch_end", touch_end)
        if touch_start is not None:
            pulumi.set(__self__, "touch_start", touch_start)

    @property
    @pulumi.getter
    def blur(self) -> Optional[bool]:
        """
        Blur enabled/disabled
        """
        return pulumi.get(self, "blur")

    @property
    @pulumi.getter
    def change(self) -> Optional[bool]:
        """
        Change enabled/disabled
        """
        return pulumi.get(self, "change")

    @property
    @pulumi.getter
    def click(self) -> Optional[bool]:
        """
        Click enabled/disabled
        """
        return pulumi.get(self, "click")

    @property
    @pulumi.getter
    def mouseup(self) -> Optional[bool]:
        """
        MouseUp enabled/disabled
        """
        return pulumi.get(self, "mouseup")

    @property
    @pulumi.getter(name="touchEnd")
    def touch_end(self) -> Optional[bool]:
        """
        TouchEnd enabled/disabled
        """
        return pulumi.get(self, "touch_end")

    @property
    @pulumi.getter(name="touchStart")
    def touch_start(self) -> Optional[bool]:
        """
        TouchStart enabled/disabled
        """
        return pulumi.get(self, "touch_start")


@pulumi.output_type
class WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalEventCapturedAsUserInput":
            suggest = "additional_event_captured_as_user_input"
        elif key == "touchEnd":
            suggest = "touch_end"
        elif key == "touchStart":
            suggest = "touch_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_event_captured_as_user_input: Optional[str] = None,
                 change: Optional[bool] = None,
                 click: Optional[bool] = None,
                 doubleclick: Optional[bool] = None,
                 keydown: Optional[bool] = None,
                 keyup: Optional[bool] = None,
                 mousedown: Optional[bool] = None,
                 mouseup: Optional[bool] = None,
                 scroll: Optional[bool] = None,
                 touch_end: Optional[bool] = None,
                 touch_start: Optional[bool] = None):
        """
        :param str additional_event_captured_as_user_input: Additional events to be captured globally as user input.
        :param bool change: Change enabled/disabled
        :param bool click: Click enabled/disabled
        :param bool doubleclick: DoubleClick enabled/disabled
        :param bool keydown: KeyDown enabled/disabled
        :param bool keyup: KeyUp enabled/disabled
        :param bool mousedown: MouseDown enabled/disabled
        :param bool mouseup: MouseUp enabled/disabled
        :param bool scroll: Scroll enabled/disabled
        :param bool touch_end: TouchEnd enabled/disabled
        :param bool touch_start: TouchStart enabled/disabled
        """
        if additional_event_captured_as_user_input is not None:
            pulumi.set(__self__, "additional_event_captured_as_user_input", additional_event_captured_as_user_input)
        if change is not None:
            pulumi.set(__self__, "change", change)
        if click is not None:
            pulumi.set(__self__, "click", click)
        if doubleclick is not None:
            pulumi.set(__self__, "doubleclick", doubleclick)
        if keydown is not None:
            pulumi.set(__self__, "keydown", keydown)
        if keyup is not None:
            pulumi.set(__self__, "keyup", keyup)
        if mousedown is not None:
            pulumi.set(__self__, "mousedown", mousedown)
        if mouseup is not None:
            pulumi.set(__self__, "mouseup", mouseup)
        if scroll is not None:
            pulumi.set(__self__, "scroll", scroll)
        if touch_end is not None:
            pulumi.set(__self__, "touch_end", touch_end)
        if touch_start is not None:
            pulumi.set(__self__, "touch_start", touch_start)

    @property
    @pulumi.getter(name="additionalEventCapturedAsUserInput")
    def additional_event_captured_as_user_input(self) -> Optional[str]:
        """
        Additional events to be captured globally as user input.
        """
        return pulumi.get(self, "additional_event_captured_as_user_input")

    @property
    @pulumi.getter
    def change(self) -> Optional[bool]:
        """
        Change enabled/disabled
        """
        return pulumi.get(self, "change")

    @property
    @pulumi.getter
    def click(self) -> Optional[bool]:
        """
        Click enabled/disabled
        """
        return pulumi.get(self, "click")

    @property
    @pulumi.getter
    def doubleclick(self) -> Optional[bool]:
        """
        DoubleClick enabled/disabled
        """
        return pulumi.get(self, "doubleclick")

    @property
    @pulumi.getter
    def keydown(self) -> Optional[bool]:
        """
        KeyDown enabled/disabled
        """
        return pulumi.get(self, "keydown")

    @property
    @pulumi.getter
    def keyup(self) -> Optional[bool]:
        """
        KeyUp enabled/disabled
        """
        return pulumi.get(self, "keyup")

    @property
    @pulumi.getter
    def mousedown(self) -> Optional[bool]:
        """
        MouseDown enabled/disabled
        """
        return pulumi.get(self, "mousedown")

    @property
    @pulumi.getter
    def mouseup(self) -> Optional[bool]:
        """
        MouseUp enabled/disabled
        """
        return pulumi.get(self, "mouseup")

    @property
    @pulumi.getter
    def scroll(self) -> Optional[bool]:
        """
        Scroll enabled/disabled
        """
        return pulumi.get(self, "scroll")

    @property
    @pulumi.getter(name="touchEnd")
    def touch_end(self) -> Optional[bool]:
        """
        TouchEnd enabled/disabled
        """
        return pulumi.get(self, "touch_end")

    @property
    @pulumi.getter(name="touchStart")
    def touch_start(self) -> Optional[bool]:
        """
        TouchStart enabled/disabled
        """
        return pulumi.get(self, "touch_start")


@pulumi.output_type
class WebApplicationMonitoringSettingsBrowserRestrictionSettings(dict):
    def __init__(__self__, *,
                 mode: str,
                 restrictions: Optional['outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictions'] = None):
        """
        :param str mode: The mode of the list of browser restrictions. Possible values area `EXCLUDE` and `INCLUDE`.
        :param 'WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsArgs' restrictions: A list of browser restrictions
        """
        pulumi.set(__self__, "mode", mode)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The mode of the list of browser restrictions. Possible values area `EXCLUDE` and `INCLUDE`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional['outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictions']:
        """
        A list of browser restrictions
        """
        return pulumi.get(self, "restrictions")


@pulumi.output_type
class WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictions(dict):
    def __init__(__self__, *,
                 restrictions: Sequence['outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction']):
        """
        :param Sequence['WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestrictionArgs'] restrictions: Browser exclusion rules for the browsers that are to be excluded
        """
        pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def restrictions(self) -> Sequence['outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction']:
        """
        Browser exclusion rules for the browsers that are to be excluded
        """
        return pulumi.get(self, "restrictions")


@pulumi.output_type
class WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "browserType":
            suggest = "browser_type"
        elif key == "browserVersion":
            suggest = "browser_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 browser_type: str,
                 browser_version: Optional[str] = None,
                 comparator: Optional[str] = None,
                 platform: Optional[str] = None):
        """
        :param str browser_type: The type of the browser that is used. Possible values are `ANDROID_WEBKIT`, `BOTS_SPIDERS`, `CHROME`, `EDGE`, `FIREFOX`, `INTERNET_EXPLORER,`OPERA`and`SAFARI`
        :param str browser_version: The version of the browser that is used
        :param str comparator: No documentation available. Possible values are `EQUALS`, `GREATER_THAN_OR_EQUAL` and `LOWER_THAN_OR_EQUAL`.
        :param str platform: The platform on which the browser is being used. Possible values are `ALL`, `DESKTOP` and `MOBILE`
        """
        pulumi.set(__self__, "browser_type", browser_type)
        if browser_version is not None:
            pulumi.set(__self__, "browser_version", browser_version)
        if comparator is not None:
            pulumi.set(__self__, "comparator", comparator)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @property
    @pulumi.getter(name="browserType")
    def browser_type(self) -> str:
        """
        The type of the browser that is used. Possible values are `ANDROID_WEBKIT`, `BOTS_SPIDERS`, `CHROME`, `EDGE`, `FIREFOX`, `INTERNET_EXPLORER,`OPERA`and`SAFARI`
        """
        return pulumi.get(self, "browser_type")

    @property
    @pulumi.getter(name="browserVersion")
    def browser_version(self) -> Optional[str]:
        """
        The version of the browser that is used
        """
        return pulumi.get(self, "browser_version")

    @property
    @pulumi.getter
    def comparator(self) -> Optional[str]:
        """
        No documentation available. Possible values are `EQUALS`, `GREATER_THAN_OR_EQUAL` and `LOWER_THAN_OR_EQUAL`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def platform(self) -> Optional[str]:
        """
        The platform on which the browser is being used. Possible values are `ALL`, `DESKTOP` and `MOBILE`
        """
        return pulumi.get(self, "platform")


@pulumi.output_type
class WebApplicationMonitoringSettingsContentCapture(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceTimingSettings":
            suggest = "resource_timing_settings"
        elif key == "timeoutSettings":
            suggest = "timeout_settings"
        elif key == "javascriptErrors":
            suggest = "javascript_errors"
        elif key == "visuallyCompleteAndSpeedIndex":
            suggest = "visually_complete_and_speed_index"
        elif key == "visuallyCompleteSettings":
            suggest = "visually_complete_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsContentCapture. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsContentCapture.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsContentCapture.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_timing_settings: 'outputs.WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings',
                 timeout_settings: 'outputs.WebApplicationMonitoringSettingsContentCaptureTimeoutSettings',
                 javascript_errors: Optional[bool] = None,
                 visually_complete_and_speed_index: Optional[bool] = None,
                 visually_complete_settings: Optional['outputs.WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings'] = None):
        """
        :param 'WebApplicationMonitoringSettingsContentCaptureResourceTimingSettingsArgs' resource_timing_settings: Settings for resource timings capture
        :param 'WebApplicationMonitoringSettingsContentCaptureTimeoutSettingsArgs' timeout_settings: Settings for timed action capture
        :param bool javascript_errors: JavaScript errors monitoring enabled/disabled
        :param bool visually_complete_and_speed_index: Visually complete and Speed index support enabled/disabled
        :param 'WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettingsArgs' visually_complete_settings: Settings for VisuallyComplete
        """
        pulumi.set(__self__, "resource_timing_settings", resource_timing_settings)
        pulumi.set(__self__, "timeout_settings", timeout_settings)
        if javascript_errors is not None:
            pulumi.set(__self__, "javascript_errors", javascript_errors)
        if visually_complete_and_speed_index is not None:
            pulumi.set(__self__, "visually_complete_and_speed_index", visually_complete_and_speed_index)
        if visually_complete_settings is not None:
            pulumi.set(__self__, "visually_complete_settings", visually_complete_settings)

    @property
    @pulumi.getter(name="resourceTimingSettings")
    def resource_timing_settings(self) -> 'outputs.WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings':
        """
        Settings for resource timings capture
        """
        return pulumi.get(self, "resource_timing_settings")

    @property
    @pulumi.getter(name="timeoutSettings")
    def timeout_settings(self) -> 'outputs.WebApplicationMonitoringSettingsContentCaptureTimeoutSettings':
        """
        Settings for timed action capture
        """
        return pulumi.get(self, "timeout_settings")

    @property
    @pulumi.getter(name="javascriptErrors")
    def javascript_errors(self) -> Optional[bool]:
        """
        JavaScript errors monitoring enabled/disabled
        """
        return pulumi.get(self, "javascript_errors")

    @property
    @pulumi.getter(name="visuallyCompleteAndSpeedIndex")
    def visually_complete_and_speed_index(self) -> Optional[bool]:
        """
        Visually complete and Speed index support enabled/disabled
        """
        return pulumi.get(self, "visually_complete_and_speed_index")

    @property
    @pulumi.getter(name="visuallyCompleteSettings")
    def visually_complete_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings']:
        """
        Settings for VisuallyComplete
        """
        return pulumi.get(self, "visually_complete_settings")


@pulumi.output_type
class WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instrumentationDelay":
            suggest = "instrumentation_delay"
        elif key == "nonW3cResourceTimings":
            suggest = "non_w3c_resource_timings"
        elif key == "resourceTimingCaptureType":
            suggest = "resource_timing_capture_type"
        elif key == "resourceTimingsDomainLimit":
            suggest = "resource_timings_domain_limit"
        elif key == "w3cResourceTimings":
            suggest = "w3c_resource_timings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instrumentation_delay: int,
                 non_w3c_resource_timings: Optional[bool] = None,
                 resource_timing_capture_type: Optional[str] = None,
                 resource_timings_domain_limit: Optional[int] = None,
                 w3c_resource_timings: Optional[bool] = None):
        """
        :param int instrumentation_delay: Instrumentation delay for monitoring resource and image resource impact in browsers that don't offer W3C resource timings.
        :param bool non_w3c_resource_timings: Timing for JavaScript files and images on non-W3C supported browsers enabled/disabled
        :param str resource_timing_capture_type: Defines how detailed resource timings are captured.
               
               Only effective if **w3cResourceTimings** or **nonW3cResourceTimings** is enabled. Possible values are `CAPTURE_ALL_SUMMARIES`, `CAPTURE_FULL_DETAILS` and `CAPTURE_LIMITED_SUMMARIES`
        :param int resource_timings_domain_limit: Limits the number of domains for which W3C resource timings are captured.
               
               Only effective if **resourceTimingCaptureType** is `CAPTURE_LIMITED_SUMMARIES`. Valid values range from 0 to 50.
        :param bool w3c_resource_timings: W3C resource timings for third party/CDN enabled/disabled
        """
        pulumi.set(__self__, "instrumentation_delay", instrumentation_delay)
        if non_w3c_resource_timings is not None:
            pulumi.set(__self__, "non_w3c_resource_timings", non_w3c_resource_timings)
        if resource_timing_capture_type is not None:
            pulumi.set(__self__, "resource_timing_capture_type", resource_timing_capture_type)
        if resource_timings_domain_limit is not None:
            pulumi.set(__self__, "resource_timings_domain_limit", resource_timings_domain_limit)
        if w3c_resource_timings is not None:
            pulumi.set(__self__, "w3c_resource_timings", w3c_resource_timings)

    @property
    @pulumi.getter(name="instrumentationDelay")
    def instrumentation_delay(self) -> int:
        """
        Instrumentation delay for monitoring resource and image resource impact in browsers that don't offer W3C resource timings.
        """
        return pulumi.get(self, "instrumentation_delay")

    @property
    @pulumi.getter(name="nonW3cResourceTimings")
    def non_w3c_resource_timings(self) -> Optional[bool]:
        """
        Timing for JavaScript files and images on non-W3C supported browsers enabled/disabled
        """
        return pulumi.get(self, "non_w3c_resource_timings")

    @property
    @pulumi.getter(name="resourceTimingCaptureType")
    def resource_timing_capture_type(self) -> Optional[str]:
        """
        Defines how detailed resource timings are captured.

        Only effective if **w3cResourceTimings** or **nonW3cResourceTimings** is enabled. Possible values are `CAPTURE_ALL_SUMMARIES`, `CAPTURE_FULL_DETAILS` and `CAPTURE_LIMITED_SUMMARIES`
        """
        return pulumi.get(self, "resource_timing_capture_type")

    @property
    @pulumi.getter(name="resourceTimingsDomainLimit")
    def resource_timings_domain_limit(self) -> Optional[int]:
        """
        Limits the number of domains for which W3C resource timings are captured.

        Only effective if **resourceTimingCaptureType** is `CAPTURE_LIMITED_SUMMARIES`. Valid values range from 0 to 50.
        """
        return pulumi.get(self, "resource_timings_domain_limit")

    @property
    @pulumi.getter(name="w3cResourceTimings")
    def w3c_resource_timings(self) -> Optional[bool]:
        """
        W3C resource timings for third party/CDN enabled/disabled
        """
        return pulumi.get(self, "w3c_resource_timings")


@pulumi.output_type
class WebApplicationMonitoringSettingsContentCaptureTimeoutSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "temporaryActionLimit":
            suggest = "temporary_action_limit"
        elif key == "temporaryActionTotalTimeout":
            suggest = "temporary_action_total_timeout"
        elif key == "timedActionSupport":
            suggest = "timed_action_support"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsContentCaptureTimeoutSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsContentCaptureTimeoutSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsContentCaptureTimeoutSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 temporary_action_limit: int,
                 temporary_action_total_timeout: int,
                 timed_action_support: Optional[bool] = None):
        """
        :param int temporary_action_limit: Defines how deep temporary actions may cascade. 0 disables temporary actions completely. Recommended value if enabled is 3
        :param int temporary_action_total_timeout: The total timeout of all cascaded timeouts that should still be able to create a temporary action
        :param bool timed_action_support: Timed action support enabled/disabled.
        """
        pulumi.set(__self__, "temporary_action_limit", temporary_action_limit)
        pulumi.set(__self__, "temporary_action_total_timeout", temporary_action_total_timeout)
        if timed_action_support is not None:
            pulumi.set(__self__, "timed_action_support", timed_action_support)

    @property
    @pulumi.getter(name="temporaryActionLimit")
    def temporary_action_limit(self) -> int:
        """
        Defines how deep temporary actions may cascade. 0 disables temporary actions completely. Recommended value if enabled is 3
        """
        return pulumi.get(self, "temporary_action_limit")

    @property
    @pulumi.getter(name="temporaryActionTotalTimeout")
    def temporary_action_total_timeout(self) -> int:
        """
        The total timeout of all cascaded timeouts that should still be able to create a temporary action
        """
        return pulumi.get(self, "temporary_action_total_timeout")

    @property
    @pulumi.getter(name="timedActionSupport")
    def timed_action_support(self) -> Optional[bool]:
        """
        Timed action support enabled/disabled.
        """
        return pulumi.get(self, "timed_action_support")


@pulumi.output_type
class WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeUrlRegex":
            suggest = "exclude_url_regex"
        elif key == "ignoredMutationsList":
            suggest = "ignored_mutations_list"
        elif key == "inactivityTimeout":
            suggest = "inactivity_timeout"
        elif key == "mutationTimeout":
            suggest = "mutation_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_url_regex: Optional[str] = None,
                 ignored_mutations_list: Optional[str] = None,
                 inactivity_timeout: Optional[int] = None,
                 mutation_timeout: Optional[int] = None,
                 threshold: Optional[int] = None):
        """
        :param str exclude_url_regex: A RegularExpression used to exclude images and iframes from being detected by the VC module
        :param str ignored_mutations_list: Query selector for mutation nodes to ignore in VC and SI calculation
        :param int inactivity_timeout: The time in ms the VC module waits for no mutations happening on the page after the load action. Defaults to 1000. Valid values range from 0 to 30000.
        :param int mutation_timeout: Determines the time in ms VC waits after an action closes to start calculation. Defaults to 50. Valid values range from 0 to 5000.
        :param int threshold: Minimum visible area in pixels of elements to be counted towards VC and SI. Defaults to 50. Valid values range from 0 to 10000.
        """
        if exclude_url_regex is not None:
            pulumi.set(__self__, "exclude_url_regex", exclude_url_regex)
        if ignored_mutations_list is not None:
            pulumi.set(__self__, "ignored_mutations_list", ignored_mutations_list)
        if inactivity_timeout is not None:
            pulumi.set(__self__, "inactivity_timeout", inactivity_timeout)
        if mutation_timeout is not None:
            pulumi.set(__self__, "mutation_timeout", mutation_timeout)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="excludeUrlRegex")
    def exclude_url_regex(self) -> Optional[str]:
        """
        A RegularExpression used to exclude images and iframes from being detected by the VC module
        """
        return pulumi.get(self, "exclude_url_regex")

    @property
    @pulumi.getter(name="ignoredMutationsList")
    def ignored_mutations_list(self) -> Optional[str]:
        """
        Query selector for mutation nodes to ignore in VC and SI calculation
        """
        return pulumi.get(self, "ignored_mutations_list")

    @property
    @pulumi.getter(name="inactivityTimeout")
    def inactivity_timeout(self) -> Optional[int]:
        """
        The time in ms the VC module waits for no mutations happening on the page after the load action. Defaults to 1000. Valid values range from 0 to 30000.
        """
        return pulumi.get(self, "inactivity_timeout")

    @property
    @pulumi.getter(name="mutationTimeout")
    def mutation_timeout(self) -> Optional[int]:
        """
        Determines the time in ms VC waits after an action closes to start calculation. Defaults to 50. Valid values range from 0 to 5000.
        """
        return pulumi.get(self, "mutation_timeout")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[int]:
        """
        Minimum visible area in pixels of elements to be counted towards VC and SI. Defaults to 50. Valid values range from 0 to 10000.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class WebApplicationMonitoringSettingsIpAddressRestrictionSettings(dict):
    def __init__(__self__, *,
                 mode: str,
                 restrictions: Optional['outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictions'] = None):
        """
        :param str mode: The mode of the list of ip address restrictions. Possible values area `EXCLUDE` and `INCLUDE`.
        :param 'WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsArgs' restrictions: The IP addresses or the IP address ranges to be mapped to the location
        """
        pulumi.set(__self__, "mode", mode)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The mode of the list of ip address restrictions. Possible values area `EXCLUDE` and `INCLUDE`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional['outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictions']:
        """
        The IP addresses or the IP address ranges to be mapped to the location
        """
        return pulumi.get(self, "restrictions")


@pulumi.output_type
class WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictions(dict):
    def __init__(__self__, *,
                 ranges: Sequence['outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange']):
        """
        :param Sequence['WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRangeArgs'] ranges: The IP address or the IP address range to be mapped to the location
        """
        pulumi.set(__self__, "ranges", ranges)

    @property
    @pulumi.getter
    def ranges(self) -> Sequence['outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange']:
        """
        The IP address or the IP address range to be mapped to the location
        """
        return pulumi.get(self, "ranges")


@pulumi.output_type
class WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressTo":
            suggest = "address_to"
        elif key == "subnetMask":
            suggest = "subnet_mask"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 address_to: Optional[str] = None,
                 subnet_mask: Optional[int] = None):
        """
        :param str address: The IP address to be mapped.
        :param str address_to: The **to** address of the IP address range.
        :param int subnet_mask: The subnet mask of the IP address range. Valid values range from 0 to 128.
        """
        pulumi.set(__self__, "address", address)
        if address_to is not None:
            pulumi.set(__self__, "address_to", address_to)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The IP address to be mapped.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="addressTo")
    def address_to(self) -> Optional[str]:
        """
        The **to** address of the IP address range.
        """
        return pulumi.get(self, "address_to")

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[int]:
        """
        The subnet mask of the IP address range. Valid values range from 0 to 128.
        """
        return pulumi.get(self, "subnet_mask")


@pulumi.output_type
class WebApplicationMonitoringSettingsJavascriptFrameworkSupport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeXObject":
            suggest = "active_x_object"
        elif key == "mooTools":
            suggest = "moo_tools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsJavascriptFrameworkSupport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsJavascriptFrameworkSupport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsJavascriptFrameworkSupport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_x_object: Optional[bool] = None,
                 angular: Optional[bool] = None,
                 dojo: Optional[bool] = None,
                 extjs: Optional[bool] = None,
                 icefaces: Optional[bool] = None,
                 jquery: Optional[bool] = None,
                 moo_tools: Optional[bool] = None,
                 prototype: Optional[bool] = None):
        """
        :param bool active_x_object: ActiveXObject support enabled/disabled
        :param bool angular: AngularJS and Angular support enabled/disabled
        :param bool dojo: Dojo support enabled/disabled
        :param bool extjs: ExtJS, Sencha Touch support enabled/disabled
        :param bool icefaces: ICEfaces support enabled/disabled
        :param bool jquery: jQuery, Backbone.js support enabled/disabled
        :param bool moo_tools: MooTools support enabled/disabled
        :param bool prototype: Prototype support enabled/disabled
        """
        if active_x_object is not None:
            pulumi.set(__self__, "active_x_object", active_x_object)
        if angular is not None:
            pulumi.set(__self__, "angular", angular)
        if dojo is not None:
            pulumi.set(__self__, "dojo", dojo)
        if extjs is not None:
            pulumi.set(__self__, "extjs", extjs)
        if icefaces is not None:
            pulumi.set(__self__, "icefaces", icefaces)
        if jquery is not None:
            pulumi.set(__self__, "jquery", jquery)
        if moo_tools is not None:
            pulumi.set(__self__, "moo_tools", moo_tools)
        if prototype is not None:
            pulumi.set(__self__, "prototype", prototype)

    @property
    @pulumi.getter(name="activeXObject")
    def active_x_object(self) -> Optional[bool]:
        """
        ActiveXObject support enabled/disabled
        """
        return pulumi.get(self, "active_x_object")

    @property
    @pulumi.getter
    def angular(self) -> Optional[bool]:
        """
        AngularJS and Angular support enabled/disabled
        """
        return pulumi.get(self, "angular")

    @property
    @pulumi.getter
    def dojo(self) -> Optional[bool]:
        """
        Dojo support enabled/disabled
        """
        return pulumi.get(self, "dojo")

    @property
    @pulumi.getter
    def extjs(self) -> Optional[bool]:
        """
        ExtJS, Sencha Touch support enabled/disabled
        """
        return pulumi.get(self, "extjs")

    @property
    @pulumi.getter
    def icefaces(self) -> Optional[bool]:
        """
        ICEfaces support enabled/disabled
        """
        return pulumi.get(self, "icefaces")

    @property
    @pulumi.getter
    def jquery(self) -> Optional[bool]:
        """
        jQuery, Backbone.js support enabled/disabled
        """
        return pulumi.get(self, "jquery")

    @property
    @pulumi.getter(name="mooTools")
    def moo_tools(self) -> Optional[bool]:
        """
        MooTools support enabled/disabled
        """
        return pulumi.get(self, "moo_tools")

    @property
    @pulumi.getter
    def prototype(self) -> Optional[bool]:
        """
        Prototype support enabled/disabled
        """
        return pulumi.get(self, "prototype")


@pulumi.output_type
class WebApplicationMonitoringSettingsJavascriptInjectionRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.WebApplicationMonitoringSettingsJavascriptInjectionRulesRule']):
        """
        :param Sequence['WebApplicationMonitoringSettingsJavascriptInjectionRulesRuleArgs'] rules: Java script injection rule
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.WebApplicationMonitoringSettingsJavascriptInjectionRulesRule']:
        """
        Java script injection rule
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class WebApplicationMonitoringSettingsJavascriptInjectionRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlOperator":
            suggest = "url_operator"
        elif key == "htmlPattern":
            suggest = "html_pattern"
        elif key == "urlPattern":
            suggest = "url_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsJavascriptInjectionRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsJavascriptInjectionRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsJavascriptInjectionRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule: str,
                 url_operator: str,
                 enabled: Optional[bool] = None,
                 html_pattern: Optional[str] = None,
                 target: Optional[str] = None,
                 url_pattern: Optional[str] = None):
        """
        :param str rule: The url rule of the java script injection. Possible values are `AFTER_SPECIFIC_HTML`, `AUTOMATIC_INJECTION`, `BEFORE_SPECIFIC_HTML` and `DO_NOT_INJECT`.
        :param str url_operator: The url operator of the java script injection. Possible values are `ALL_PAGES`, `CONTAINS`, `ENDS_WITH`, `EQUALS` and `STARTS_WITH`.
        :param bool enabled: `fetch()` request capture enabled/disabled
        :param str html_pattern: The HTML pattern of the java script injection
        :param str target: The target against which the rule of the java script injection should be matched. Possible values are `PAGE_QUERY` and `URL`.
        :param str url_pattern: The url pattern of the java script injection
        """
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "url_operator", url_operator)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if html_pattern is not None:
            pulumi.set(__self__, "html_pattern", html_pattern)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if url_pattern is not None:
            pulumi.set(__self__, "url_pattern", url_pattern)

    @property
    @pulumi.getter
    def rule(self) -> str:
        """
        The url rule of the java script injection. Possible values are `AFTER_SPECIFIC_HTML`, `AUTOMATIC_INJECTION`, `BEFORE_SPECIFIC_HTML` and `DO_NOT_INJECT`.
        """
        return pulumi.get(self, "rule")

    @property
    @pulumi.getter(name="urlOperator")
    def url_operator(self) -> str:
        """
        The url operator of the java script injection. Possible values are `ALL_PAGES`, `CONTAINS`, `ENDS_WITH`, `EQUALS` and `STARTS_WITH`.
        """
        return pulumi.get(self, "url_operator")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        `fetch()` request capture enabled/disabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="htmlPattern")
    def html_pattern(self) -> Optional[str]:
        """
        The HTML pattern of the java script injection
        """
        return pulumi.get(self, "html_pattern")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        The target against which the rule of the java script injection should be matched. Possible values are `PAGE_QUERY` and `URL`.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="urlPattern")
    def url_pattern(self) -> Optional[str]:
        """
        The url pattern of the java script injection
        """
        return pulumi.get(self, "url_pattern")


@pulumi.output_type
class WebApplicationSessionReplayConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costControlPercentage":
            suggest = "cost_control_percentage"
        elif key == "cssResourceCapturingExclusionRules":
            suggest = "css_resource_capturing_exclusion_rules"
        elif key == "enableCssResourceCapturing":
            suggest = "enable_css_resource_capturing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationSessionReplayConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationSessionReplayConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationSessionReplayConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_control_percentage: int,
                 css_resource_capturing_exclusion_rules: Optional[Sequence[str]] = None,
                 enable_css_resource_capturing: Optional[bool] = None,
                 enabled: Optional[bool] = None):
        """
        :param int cost_control_percentage: (Field has overlap with `WebAppEnablement`) Session replay sampling rating in percent
        :param Sequence[str] css_resource_capturing_exclusion_rules: (Field has overlap with `SessionReplayResourceCapture`) A list of URLs to be excluded from CSS resource capturing
        :param bool enable_css_resource_capturing: (Field has overlap with `SessionReplayResourceCapture`) Capture (`true`) or don't capture (`false`) CSS resources from the session
        :param bool enabled: (Field has overlap with `WebAppEnablement`) SessionReplay Enabled/Disabled
        """
        pulumi.set(__self__, "cost_control_percentage", cost_control_percentage)
        if css_resource_capturing_exclusion_rules is not None:
            pulumi.set(__self__, "css_resource_capturing_exclusion_rules", css_resource_capturing_exclusion_rules)
        if enable_css_resource_capturing is not None:
            pulumi.set(__self__, "enable_css_resource_capturing", enable_css_resource_capturing)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="costControlPercentage")
    def cost_control_percentage(self) -> int:
        """
        (Field has overlap with `WebAppEnablement`) Session replay sampling rating in percent
        """
        return pulumi.get(self, "cost_control_percentage")

    @property
    @pulumi.getter(name="cssResourceCapturingExclusionRules")
    def css_resource_capturing_exclusion_rules(self) -> Optional[Sequence[str]]:
        """
        (Field has overlap with `SessionReplayResourceCapture`) A list of URLs to be excluded from CSS resource capturing
        """
        return pulumi.get(self, "css_resource_capturing_exclusion_rules")

    @property
    @pulumi.getter(name="enableCssResourceCapturing")
    def enable_css_resource_capturing(self) -> Optional[bool]:
        """
        (Field has overlap with `SessionReplayResourceCapture`) Capture (`true`) or don't capture (`false`) CSS resources from the session
        """
        return pulumi.get(self, "enable_css_resource_capturing")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        (Field has overlap with `WebAppEnablement`) SessionReplay Enabled/Disabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WebApplicationUserActionAndSessionProperties(dict):
    def __init__(__self__, *,
                 properties: Optional[Sequence['outputs.WebApplicationUserActionAndSessionPropertiesProperty']] = None):
        """
        :param Sequence['WebApplicationUserActionAndSessionPropertiesPropertyArgs'] properties: User action and session properties settings
        """
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def properties(self) -> Optional[Sequence['outputs.WebApplicationUserActionAndSessionPropertiesProperty']]:
        """
        User action and session properties settings
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class WebApplicationUserActionAndSessionPropertiesProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupRule":
            suggest = "cleanup_rule"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "longStringLength":
            suggest = "long_string_length"
        elif key == "metadataId":
            suggest = "metadata_id"
        elif key == "serverSideRequestAttribute":
            suggest = "server_side_request_attribute"
        elif key == "storeAsSessionProperty":
            suggest = "store_as_session_property"
        elif key == "storeAsUserActionProperty":
            suggest = "store_as_user_action_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionAndSessionPropertiesProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionAndSessionPropertiesProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionAndSessionPropertiesProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: int,
                 key: str,
                 origin: str,
                 type: str,
                 aggregation: Optional[str] = None,
                 cleanup_rule: Optional[str] = None,
                 display_name: Optional[str] = None,
                 ignore_case: Optional[bool] = None,
                 long_string_length: Optional[int] = None,
                 metadata_id: Optional[int] = None,
                 server_side_request_attribute: Optional[str] = None,
                 store_as_session_property: Optional[bool] = None,
                 store_as_user_action_property: Optional[bool] = None):
        """
        :param int id: Unique id among all userTags and properties of this application
        :param str key: Key of the property
        :param str origin: The origin of the property. Possible values are `JAVASCRIPT_API`, `META_DATA` and `SERVER_SIDE_REQUEST_ATTRIBUTE`.
        :param str type: The data type of the property. Possible values are `DATE`, `DOUBLE`, `LONG`, `LONG_STRING` and `STRING`.
        :param str aggregation: The aggregation type of the property.
        :param str cleanup_rule: The cleanup rule of the property. 
               
               Defines how to extract the data you need from a string value. Specify the [regular expression](https://dt-url.net/k9e0iaq) for the data you need there
        :param str display_name: The display name of the property
        :param bool ignore_case: If `true`, the value of this property will always be stored in lower case. Defaults to `false`.
        :param int long_string_length: If the `type` is `LONG_STRING`, the max length for this property. Must be a multiple of `100`. Defaults to `200`. Maximum is `1000`.
        :param int metadata_id: If the origin is `META_DATA`, metaData id of the property
        :param str server_side_request_attribute: The ID of the request attribute. 
               
               Only applicable when the **origin** is set to `SERVER_SIDE_REQUEST_ATTRIBUTE`
        :param bool store_as_session_property: If `true`, the property is stored as a session property
        :param bool store_as_user_action_property: If `true`, the property is stored as a user action property
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "type", type)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if cleanup_rule is not None:
            pulumi.set(__self__, "cleanup_rule", cleanup_rule)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if long_string_length is not None:
            pulumi.set(__self__, "long_string_length", long_string_length)
        if metadata_id is not None:
            pulumi.set(__self__, "metadata_id", metadata_id)
        if server_side_request_attribute is not None:
            pulumi.set(__self__, "server_side_request_attribute", server_side_request_attribute)
        if store_as_session_property is not None:
            pulumi.set(__self__, "store_as_session_property", store_as_session_property)
        if store_as_user_action_property is not None:
            pulumi.set(__self__, "store_as_user_action_property", store_as_user_action_property)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Unique id among all userTags and properties of this application
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of the property
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def origin(self) -> str:
        """
        The origin of the property. Possible values are `JAVASCRIPT_API`, `META_DATA` and `SERVER_SIDE_REQUEST_ATTRIBUTE`.
        """
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The data type of the property. Possible values are `DATE`, `DOUBLE`, `LONG`, `LONG_STRING` and `STRING`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        The aggregation type of the property.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="cleanupRule")
    def cleanup_rule(self) -> Optional[str]:
        """
        The cleanup rule of the property. 

        Defines how to extract the data you need from a string value. Specify the [regular expression](https://dt-url.net/k9e0iaq) for the data you need there
        """
        return pulumi.get(self, "cleanup_rule")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The display name of the property
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        If `true`, the value of this property will always be stored in lower case. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="longStringLength")
    def long_string_length(self) -> Optional[int]:
        """
        If the `type` is `LONG_STRING`, the max length for this property. Must be a multiple of `100`. Defaults to `200`. Maximum is `1000`.
        """
        return pulumi.get(self, "long_string_length")

    @property
    @pulumi.getter(name="metadataId")
    def metadata_id(self) -> Optional[int]:
        """
        If the origin is `META_DATA`, metaData id of the property
        """
        return pulumi.get(self, "metadata_id")

    @property
    @pulumi.getter(name="serverSideRequestAttribute")
    def server_side_request_attribute(self) -> Optional[str]:
        """
        The ID of the request attribute. 

        Only applicable when the **origin** is set to `SERVER_SIDE_REQUEST_ATTRIBUTE`
        """
        return pulumi.get(self, "server_side_request_attribute")

    @property
    @pulumi.getter(name="storeAsSessionProperty")
    def store_as_session_property(self) -> Optional[bool]:
        """
        If `true`, the property is stored as a session property
        """
        return pulumi.get(self, "store_as_session_property")

    @property
    @pulumi.getter(name="storeAsUserActionProperty")
    def store_as_user_action_property(self) -> Optional[bool]:
        """
        If `true`, the property is stored as a user action property
        """
        return pulumi.get(self, "store_as_user_action_property")


@pulumi.output_type
class WebApplicationUserActionNamingSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionNamingRules":
            suggest = "custom_action_naming_rules"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "loadActionNamingRules":
            suggest = "load_action_naming_rules"
        elif key == "queryParameterCleanups":
            suggest = "query_parameter_cleanups"
        elif key == "splitUserActionsByDomain":
            suggest = "split_user_actions_by_domain"
        elif key == "useFirstDetectedLoadAction":
            suggest = "use_first_detected_load_action"
        elif key == "xhrActionNamingRules":
            suggest = "xhr_action_naming_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionNamingSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionNamingSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionNamingSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_naming_rules: Optional['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRules'] = None,
                 ignore_case: Optional[bool] = None,
                 load_action_naming_rules: Optional['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRules'] = None,
                 placeholders: Optional['outputs.WebApplicationUserActionNamingSettingsPlaceholders'] = None,
                 query_parameter_cleanups: Optional[Sequence[str]] = None,
                 split_user_actions_by_domain: Optional[bool] = None,
                 use_first_detected_load_action: Optional[bool] = None,
                 xhr_action_naming_rules: Optional['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRules'] = None):
        """
        :param 'WebApplicationUserActionNamingSettingsCustomActionNamingRulesArgs' custom_action_naming_rules: User action naming rules for custom actions
        :param bool ignore_case: Case insensitive naming
        :param 'WebApplicationUserActionNamingSettingsLoadActionNamingRulesArgs' load_action_naming_rules: User action naming rules for loading actions
        :param 'WebApplicationUserActionNamingSettingsPlaceholdersArgs' placeholders: User action placeholders
        :param Sequence[str] query_parameter_cleanups: User action naming rules for custom actions. If not specified Dynatrace assumes `__sid`, `cfid`, `cftoken`, `phpsessid` and `sid`.
        :param bool split_user_actions_by_domain: Deactivate this setting if different domains should not result in separate user actions
        :param bool use_first_detected_load_action: First load action found under an XHR action should be used when true. Else the deepest one under the xhr action is used
        :param 'WebApplicationUserActionNamingSettingsXhrActionNamingRulesArgs' xhr_action_naming_rules: User action naming rules for XHR actions
        """
        if custom_action_naming_rules is not None:
            pulumi.set(__self__, "custom_action_naming_rules", custom_action_naming_rules)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if load_action_naming_rules is not None:
            pulumi.set(__self__, "load_action_naming_rules", load_action_naming_rules)
        if placeholders is not None:
            pulumi.set(__self__, "placeholders", placeholders)
        if query_parameter_cleanups is not None:
            pulumi.set(__self__, "query_parameter_cleanups", query_parameter_cleanups)
        if split_user_actions_by_domain is not None:
            pulumi.set(__self__, "split_user_actions_by_domain", split_user_actions_by_domain)
        if use_first_detected_load_action is not None:
            pulumi.set(__self__, "use_first_detected_load_action", use_first_detected_load_action)
        if xhr_action_naming_rules is not None:
            pulumi.set(__self__, "xhr_action_naming_rules", xhr_action_naming_rules)

    @property
    @pulumi.getter(name="customActionNamingRules")
    def custom_action_naming_rules(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRules']:
        """
        User action naming rules for custom actions
        """
        return pulumi.get(self, "custom_action_naming_rules")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Case insensitive naming
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="loadActionNamingRules")
    def load_action_naming_rules(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRules']:
        """
        User action naming rules for loading actions
        """
        return pulumi.get(self, "load_action_naming_rules")

    @property
    @pulumi.getter
    def placeholders(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsPlaceholders']:
        """
        User action placeholders
        """
        return pulumi.get(self, "placeholders")

    @property
    @pulumi.getter(name="queryParameterCleanups")
    def query_parameter_cleanups(self) -> Optional[Sequence[str]]:
        """
        User action naming rules for custom actions. If not specified Dynatrace assumes `__sid`, `cfid`, `cftoken`, `phpsessid` and `sid`.
        """
        return pulumi.get(self, "query_parameter_cleanups")

    @property
    @pulumi.getter(name="splitUserActionsByDomain")
    def split_user_actions_by_domain(self) -> Optional[bool]:
        """
        Deactivate this setting if different domains should not result in separate user actions
        """
        return pulumi.get(self, "split_user_actions_by_domain")

    @property
    @pulumi.getter(name="useFirstDetectedLoadAction")
    def use_first_detected_load_action(self) -> Optional[bool]:
        """
        First load action found under an XHR action should be used when true. Else the deepest one under the xhr action is used
        """
        return pulumi.get(self, "use_first_detected_load_action")

    @property
    @pulumi.getter(name="xhrActionNamingRules")
    def xhr_action_naming_rules(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRules']:
        """
        User action naming rules for XHR actions
        """
        return pulumi.get(self, "xhr_action_naming_rules")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsCustomActionNamingRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule']):
        """
        :param Sequence['WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleArgs'] rules: The settings of naming rule
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule']:
        """
        The settings of naming rule
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useOrConditions":
            suggest = "use_or_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template: str,
                 conditions: Optional['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditions'] = None,
                 use_or_conditions: Optional[bool] = None):
        """
        :param str template: Naming pattern. Use Curly brackets `{}` to select placeholders
        :param 'WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditionsArgs' conditions: Defines the conditions when the naming rule should apply
        :param bool use_or_conditions: If set to `true` the conditions will be connected by logical OR instead of logical AND
        """
        pulumi.set(__self__, "template", template)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if use_or_conditions is not None:
            pulumi.set(__self__, "use_or_conditions", use_or_conditions)

    @property
    @pulumi.getter
    def template(self) -> str:
        """
        Naming pattern. Use Curly brackets `{}` to select placeholders
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def conditions(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditions']:
        """
        Defines the conditions when the naming rule should apply
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="useOrConditions")
    def use_or_conditions(self) -> Optional[bool]:
        """
        If set to `true` the conditions will be connected by logical OR instead of logical AND
        """
        return pulumi.get(self, "use_or_conditions")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCondition']):
        """
        :param Sequence['WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditionsConditionArgs'] conditions: Defines the conditions when the naming rule should apply
        """
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCondition']:
        """
        Defines the conditions when the naming rule should apply
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCondition(dict):
    def __init__(__self__, *,
                 operand1: str,
                 operator: str,
                 operand2: Optional[str] = None):
        """
        :param str operand1: Must be a defined placeholder wrapped in curly braces
        :param str operator: The operator of the condition. Possible values are `CONTAINS`, `ENDS_WITH`, `EQUALS`, `IS_EMPTY`, `IS_NOT_EMPTY`, `MATCHES_REGULAR_EXPRESSION`, `NOT_CONTAINS`, `NOT_ENDS_WITH`, `NOT_EQUALS`, `NOT_MATCHES_REGULAR_EXPRESSION`, `NOT_STARTS_WITH` and `STARTS_WITH`.
        :param str operand2: Must be null if operator is `IS_EMPTY`, a regex if operator is `MATCHES_REGULAR_ERPRESSION`. In all other cases the value can be a freetext or a placeholder wrapped in curly braces
        """
        pulumi.set(__self__, "operand1", operand1)
        pulumi.set(__self__, "operator", operator)
        if operand2 is not None:
            pulumi.set(__self__, "operand2", operand2)

    @property
    @pulumi.getter
    def operand1(self) -> str:
        """
        Must be a defined placeholder wrapped in curly braces
        """
        return pulumi.get(self, "operand1")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator of the condition. Possible values are `CONTAINS`, `ENDS_WITH`, `EQUALS`, `IS_EMPTY`, `IS_NOT_EMPTY`, `MATCHES_REGULAR_EXPRESSION`, `NOT_CONTAINS`, `NOT_ENDS_WITH`, `NOT_EQUALS`, `NOT_MATCHES_REGULAR_EXPRESSION`, `NOT_STARTS_WITH` and `STARTS_WITH`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def operand2(self) -> Optional[str]:
        """
        Must be null if operator is `IS_EMPTY`, a regex if operator is `MATCHES_REGULAR_ERPRESSION`. In all other cases the value can be a freetext or a placeholder wrapped in curly braces
        """
        return pulumi.get(self, "operand2")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsLoadActionNamingRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule']):
        """
        :param Sequence['WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleArgs'] rules: The settings of naming rule
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule']:
        """
        The settings of naming rule
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useOrConditions":
            suggest = "use_or_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template: str,
                 conditions: Optional['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditions'] = None,
                 use_or_conditions: Optional[bool] = None):
        """
        :param str template: Naming pattern. Use Curly brackets `{}` to select placeholders
        :param 'WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditionsArgs' conditions: Defines the conditions when the naming rule should apply
        :param bool use_or_conditions: If set to `true` the conditions will be connected by logical OR instead of logical AND
        """
        pulumi.set(__self__, "template", template)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if use_or_conditions is not None:
            pulumi.set(__self__, "use_or_conditions", use_or_conditions)

    @property
    @pulumi.getter
    def template(self) -> str:
        """
        Naming pattern. Use Curly brackets `{}` to select placeholders
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def conditions(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditions']:
        """
        Defines the conditions when the naming rule should apply
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="useOrConditions")
    def use_or_conditions(self) -> Optional[bool]:
        """
        If set to `true` the conditions will be connected by logical OR instead of logical AND
        """
        return pulumi.get(self, "use_or_conditions")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCondition']):
        """
        :param Sequence['WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditionsConditionArgs'] conditions: Defines the conditions when the naming rule should apply
        """
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCondition']:
        """
        Defines the conditions when the naming rule should apply
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCondition(dict):
    def __init__(__self__, *,
                 operand1: str,
                 operator: str,
                 operand2: Optional[str] = None):
        """
        :param str operand1: Must be a defined placeholder wrapped in curly braces
        :param str operator: The operator of the condition. Possible values are `CONTAINS`, `ENDS_WITH`, `EQUALS`, `IS_EMPTY`, `IS_NOT_EMPTY`, `MATCHES_REGULAR_EXPRESSION`, `NOT_CONTAINS`, `NOT_ENDS_WITH`, `NOT_EQUALS`, `NOT_MATCHES_REGULAR_EXPRESSION`, `NOT_STARTS_WITH` and `STARTS_WITH`.
        :param str operand2: Must be null if operator is `IS_EMPTY`, a regex if operator is `MATCHES_REGULAR_ERPRESSION`. In all other cases the value can be a freetext or a placeholder wrapped in curly braces
        """
        pulumi.set(__self__, "operand1", operand1)
        pulumi.set(__self__, "operator", operator)
        if operand2 is not None:
            pulumi.set(__self__, "operand2", operand2)

    @property
    @pulumi.getter
    def operand1(self) -> str:
        """
        Must be a defined placeholder wrapped in curly braces
        """
        return pulumi.get(self, "operand1")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator of the condition. Possible values are `CONTAINS`, `ENDS_WITH`, `EQUALS`, `IS_EMPTY`, `IS_NOT_EMPTY`, `MATCHES_REGULAR_EXPRESSION`, `NOT_CONTAINS`, `NOT_ENDS_WITH`, `NOT_EQUALS`, `NOT_MATCHES_REGULAR_EXPRESSION`, `NOT_STARTS_WITH` and `STARTS_WITH`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def operand2(self) -> Optional[str]:
        """
        Must be null if operator is `IS_EMPTY`, a regex if operator is `MATCHES_REGULAR_ERPRESSION`. In all other cases the value can be a freetext or a placeholder wrapped in curly braces
        """
        return pulumi.get(self, "operand2")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsPlaceholders(dict):
    def __init__(__self__, *,
                 placeholders: Sequence['outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder']):
        """
        :param Sequence['WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderArgs'] placeholders: User action placeholders
        """
        pulumi.set(__self__, "placeholders", placeholders)

    @property
    @pulumi.getter
    def placeholders(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder']:
        """
        User action placeholders
        """
        return pulumi.get(self, "placeholders")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "processingPart":
            suggest = "processing_part"
        elif key == "metadataId":
            suggest = "metadata_id"
        elif key == "processingSteps":
            suggest = "processing_steps"
        elif key == "useGuessedElementIdentifier":
            suggest = "use_guessed_element_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input: str,
                 name: str,
                 processing_part: str,
                 metadata_id: Optional[int] = None,
                 processing_steps: Optional['outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps'] = None,
                 use_guessed_element_identifier: Optional[bool] = None):
        """
        :param str input: The input for the place holder. Possible values are `ELEMENT_IDENTIFIER`, `INPUT_TYPE`, `METADATA`, `PAGE_TITLE`, `PAGE_URL`, `SOURCE_URL`, `TOP_XHR_URL` and `XHR_URL`
        :param str name: Placeholder name. Valid length needs to be between 1 and 50 characters
        :param str processing_part: The part to process. Possible values are `ALL`, `ANCHOR` and `PATH`
        :param int metadata_id: The ID of the metadata
        :param 'WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsArgs' processing_steps: The processing step settings
        :param bool use_guessed_element_identifier: Use the element identifier that was selected by Dynatrace
        """
        pulumi.set(__self__, "input", input)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "processing_part", processing_part)
        if metadata_id is not None:
            pulumi.set(__self__, "metadata_id", metadata_id)
        if processing_steps is not None:
            pulumi.set(__self__, "processing_steps", processing_steps)
        if use_guessed_element_identifier is not None:
            pulumi.set(__self__, "use_guessed_element_identifier", use_guessed_element_identifier)

    @property
    @pulumi.getter
    def input(self) -> str:
        """
        The input for the place holder. Possible values are `ELEMENT_IDENTIFIER`, `INPUT_TYPE`, `METADATA`, `PAGE_TITLE`, `PAGE_URL`, `SOURCE_URL`, `TOP_XHR_URL` and `XHR_URL`
        """
        return pulumi.get(self, "input")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Placeholder name. Valid length needs to be between 1 and 50 characters
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="processingPart")
    def processing_part(self) -> str:
        """
        The part to process. Possible values are `ALL`, `ANCHOR` and `PATH`
        """
        return pulumi.get(self, "processing_part")

    @property
    @pulumi.getter(name="metadataId")
    def metadata_id(self) -> Optional[int]:
        """
        The ID of the metadata
        """
        return pulumi.get(self, "metadata_id")

    @property
    @pulumi.getter(name="processingSteps")
    def processing_steps(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps']:
        """
        The processing step settings
        """
        return pulumi.get(self, "processing_steps")

    @property
    @pulumi.getter(name="useGuessedElementIdentifier")
    def use_guessed_element_identifier(self) -> Optional[bool]:
        """
        Use the element identifier that was selected by Dynatrace
        """
        return pulumi.get(self, "use_guessed_element_identifier")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps(dict):
    def __init__(__self__, *,
                 steps: Sequence['outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep']):
        """
        :param Sequence['WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStepArgs'] steps: The processing step
        """
        pulumi.set(__self__, "steps", steps)

    @property
    @pulumi.getter
    def steps(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep']:
        """
        The processing step
        """
        return pulumi.get(self, "steps")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackToInput":
            suggest = "fallback_to_input"
        elif key == "patternAfter":
            suggest = "pattern_after"
        elif key == "patternAfterSearchType":
            suggest = "pattern_after_search_type"
        elif key == "patternBefore":
            suggest = "pattern_before"
        elif key == "patternBeforeSearchType":
            suggest = "pattern_before_search_type"
        elif key == "patternToReplace":
            suggest = "pattern_to_replace"
        elif key == "regularExpression":
            suggest = "regular_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fallback_to_input: Optional[bool] = None,
                 pattern_after: Optional[str] = None,
                 pattern_after_search_type: Optional[str] = None,
                 pattern_before: Optional[str] = None,
                 pattern_before_search_type: Optional[str] = None,
                 pattern_to_replace: Optional[str] = None,
                 regular_expression: Optional[str] = None,
                 replacement: Optional[str] = None):
        """
        :param str type: An action to be taken by the processing:
        :param bool fallback_to_input: If set to `true`: Returns the input if `patternBefore` or `patternAfter` cannot be found and the `type` is `SUBSTRING`. Returns the input if `regularExpression` doesn't match and `type` is `EXTRACT_BY_REGULAR_EXPRESSION`.
        :param str pattern_after: The pattern after the required value. It will be removed.
        :param str pattern_after_search_type: The required occurrence of **patternAfter**. Possible values are `FIRST` and `LAST`.
        :param str pattern_before: The pattern before the required value. It will be removed.
        :param str pattern_before_search_type: The required occurrence of **patternBefore**. Possible values are `FIRST` and `LAST`.
        :param str pattern_to_replace: The pattern to be replaced. 
               
                Only applicable if the `type` is `REPLACE_WITH_PATTERN`.
        :param str regular_expression: A regular expression for the string to be extracted or replaced. Only applicable if the `type` is `EXTRACT_BY_REGULAR_EXPRESSION` or `REPLACE_WITH_REGULAR_EXPRESSION`.
        :param str replacement: Replacement for the original value
        """
        pulumi.set(__self__, "type", type)
        if fallback_to_input is not None:
            pulumi.set(__self__, "fallback_to_input", fallback_to_input)
        if pattern_after is not None:
            pulumi.set(__self__, "pattern_after", pattern_after)
        if pattern_after_search_type is not None:
            pulumi.set(__self__, "pattern_after_search_type", pattern_after_search_type)
        if pattern_before is not None:
            pulumi.set(__self__, "pattern_before", pattern_before)
        if pattern_before_search_type is not None:
            pulumi.set(__self__, "pattern_before_search_type", pattern_before_search_type)
        if pattern_to_replace is not None:
            pulumi.set(__self__, "pattern_to_replace", pattern_to_replace)
        if regular_expression is not None:
            pulumi.set(__self__, "regular_expression", regular_expression)
        if replacement is not None:
            pulumi.set(__self__, "replacement", replacement)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        An action to be taken by the processing:
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="fallbackToInput")
    def fallback_to_input(self) -> Optional[bool]:
        """
        If set to `true`: Returns the input if `patternBefore` or `patternAfter` cannot be found and the `type` is `SUBSTRING`. Returns the input if `regularExpression` doesn't match and `type` is `EXTRACT_BY_REGULAR_EXPRESSION`.
        """
        return pulumi.get(self, "fallback_to_input")

    @property
    @pulumi.getter(name="patternAfter")
    def pattern_after(self) -> Optional[str]:
        """
        The pattern after the required value. It will be removed.
        """
        return pulumi.get(self, "pattern_after")

    @property
    @pulumi.getter(name="patternAfterSearchType")
    def pattern_after_search_type(self) -> Optional[str]:
        """
        The required occurrence of **patternAfter**. Possible values are `FIRST` and `LAST`.
        """
        return pulumi.get(self, "pattern_after_search_type")

    @property
    @pulumi.getter(name="patternBefore")
    def pattern_before(self) -> Optional[str]:
        """
        The pattern before the required value. It will be removed.
        """
        return pulumi.get(self, "pattern_before")

    @property
    @pulumi.getter(name="patternBeforeSearchType")
    def pattern_before_search_type(self) -> Optional[str]:
        """
        The required occurrence of **patternBefore**. Possible values are `FIRST` and `LAST`.
        """
        return pulumi.get(self, "pattern_before_search_type")

    @property
    @pulumi.getter(name="patternToReplace")
    def pattern_to_replace(self) -> Optional[str]:
        """
        The pattern to be replaced. 

         Only applicable if the `type` is `REPLACE_WITH_PATTERN`.
        """
        return pulumi.get(self, "pattern_to_replace")

    @property
    @pulumi.getter(name="regularExpression")
    def regular_expression(self) -> Optional[str]:
        """
        A regular expression for the string to be extracted or replaced. Only applicable if the `type` is `EXTRACT_BY_REGULAR_EXPRESSION` or `REPLACE_WITH_REGULAR_EXPRESSION`.
        """
        return pulumi.get(self, "regular_expression")

    @property
    @pulumi.getter
    def replacement(self) -> Optional[str]:
        """
        Replacement for the original value
        """
        return pulumi.get(self, "replacement")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsXhrActionNamingRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule']):
        """
        :param Sequence['WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleArgs'] rules: The settings of naming rule
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule']:
        """
        The settings of naming rule
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useOrConditions":
            suggest = "use_or_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template: str,
                 conditions: Optional['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditions'] = None,
                 use_or_conditions: Optional[bool] = None):
        """
        :param str template: Naming pattern. Use Curly brackets `{}` to select placeholders
        :param 'WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditionsArgs' conditions: Defines the conditions when the naming rule should apply
        :param bool use_or_conditions: If set to `true` the conditions will be connected by logical OR instead of logical AND
        """
        pulumi.set(__self__, "template", template)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if use_or_conditions is not None:
            pulumi.set(__self__, "use_or_conditions", use_or_conditions)

    @property
    @pulumi.getter
    def template(self) -> str:
        """
        Naming pattern. Use Curly brackets `{}` to select placeholders
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def conditions(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditions']:
        """
        Defines the conditions when the naming rule should apply
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="useOrConditions")
    def use_or_conditions(self) -> Optional[bool]:
        """
        If set to `true` the conditions will be connected by logical OR instead of logical AND
        """
        return pulumi.get(self, "use_or_conditions")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCondition']):
        """
        :param Sequence['WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditionsConditionArgs'] conditions: Defines the conditions when the naming rule should apply
        """
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCondition']:
        """
        Defines the conditions when the naming rule should apply
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCondition(dict):
    def __init__(__self__, *,
                 operand1: str,
                 operator: str,
                 operand2: Optional[str] = None):
        """
        :param str operand1: Must be a defined placeholder wrapped in curly braces
        :param str operator: The operator of the condition. Possible values are `CONTAINS`, `ENDS_WITH`, `EQUALS`, `IS_EMPTY`, `IS_NOT_EMPTY`, `MATCHES_REGULAR_EXPRESSION`, `NOT_CONTAINS`, `NOT_ENDS_WITH`, `NOT_EQUALS`, `NOT_MATCHES_REGULAR_EXPRESSION`, `NOT_STARTS_WITH` and `STARTS_WITH`.
        :param str operand2: Must be null if operator is `IS_EMPTY`, a regex if operator is `MATCHES_REGULAR_ERPRESSION`. In all other cases the value can be a freetext or a placeholder wrapped in curly braces
        """
        pulumi.set(__self__, "operand1", operand1)
        pulumi.set(__self__, "operator", operator)
        if operand2 is not None:
            pulumi.set(__self__, "operand2", operand2)

    @property
    @pulumi.getter
    def operand1(self) -> str:
        """
        Must be a defined placeholder wrapped in curly braces
        """
        return pulumi.get(self, "operand1")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator of the condition. Possible values are `CONTAINS`, `ENDS_WITH`, `EQUALS`, `IS_EMPTY`, `IS_NOT_EMPTY`, `MATCHES_REGULAR_EXPRESSION`, `NOT_CONTAINS`, `NOT_ENDS_WITH`, `NOT_EQUALS`, `NOT_MATCHES_REGULAR_EXPRESSION`, `NOT_STARTS_WITH` and `STARTS_WITH`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def operand2(self) -> Optional[str]:
        """
        Must be null if operator is `IS_EMPTY`, a regex if operator is `MATCHES_REGULAR_ERPRESSION`. In all other cases the value can be a freetext or a placeholder wrapped in curly braces
        """
        return pulumi.get(self, "operand2")


@pulumi.output_type
class WebApplicationUserTags(dict):
    def __init__(__self__, *,
                 tags: Sequence['outputs.WebApplicationUserTagsTag']):
        """
        :param Sequence['WebApplicationUserTagsTagArgs'] tags: User tag settings
        """
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.WebApplicationUserTagsTag']:
        """
        User tag settings
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class WebApplicationUserTagsTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupRule":
            suggest = "cleanup_rule"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "metadataId":
            suggest = "metadata_id"
        elif key == "serverSideRequestAttribute":
            suggest = "server_side_request_attribute"
        elif key == "uniqueId":
            suggest = "unique_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserTagsTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserTagsTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserTagsTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cleanup_rule: Optional[str] = None,
                 id: Optional[int] = None,
                 ignore_case: Optional[bool] = None,
                 metadata_id: Optional[int] = None,
                 server_side_request_attribute: Optional[str] = None,
                 unique_id: Optional[int] = None):
        """
        :param str cleanup_rule: Cleanup rule expression of the userTag
        :param bool ignore_case: If `true`, the value of this tag will always be stored in lower case. Defaults to `false`.
        :param int metadata_id: If it's of type metaData, metaData id of the userTag
        :param str server_side_request_attribute: The ID of the RrequestAttribute for the userTag
        :param int unique_id: A unique ID among all userTags and properties of this application. Minimum value is 1.
        """
        if cleanup_rule is not None:
            pulumi.set(__self__, "cleanup_rule", cleanup_rule)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if metadata_id is not None:
            pulumi.set(__self__, "metadata_id", metadata_id)
        if server_side_request_attribute is not None:
            pulumi.set(__self__, "server_side_request_attribute", server_side_request_attribute)
        if unique_id is not None:
            pulumi.set(__self__, "unique_id", unique_id)

    @property
    @pulumi.getter(name="cleanupRule")
    def cleanup_rule(self) -> Optional[str]:
        """
        Cleanup rule expression of the userTag
        """
        return pulumi.get(self, "cleanup_rule")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        If `true`, the value of this tag will always be stored in lower case. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="metadataId")
    def metadata_id(self) -> Optional[int]:
        """
        If it's of type metaData, metaData id of the userTag
        """
        return pulumi.get(self, "metadata_id")

    @property
    @pulumi.getter(name="serverSideRequestAttribute")
    def server_side_request_attribute(self) -> Optional[str]:
        """
        The ID of the RrequestAttribute for the userTag
        """
        return pulumi.get(self, "server_side_request_attribute")

    @property
    @pulumi.getter(name="uniqueId")
    def unique_id(self) -> Optional[int]:
        """
        A unique ID among all userTags and properties of this application. Minimum value is 1.
        """
        return pulumi.get(self, "unique_id")


@pulumi.output_type
class WebApplicationWaterfallSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceBrowserCachingThreshold":
            suggest = "resource_browser_caching_threshold"
        elif key == "resourcesThreshold":
            suggest = "resources_threshold"
        elif key == "slowCndResourcesThreshold":
            suggest = "slow_cnd_resources_threshold"
        elif key == "slowFirstPartyResourcesThreshold":
            suggest = "slow_first_party_resources_threshold"
        elif key == "slowThirdPartyResourcesThreshold":
            suggest = "slow_third_party_resources_threshold"
        elif key == "speedIndexVisuallyCompleteRatioThreshold":
            suggest = "speed_index_visually_complete_ratio_threshold"
        elif key == "uncompressedResourcesThreshold":
            suggest = "uncompressed_resources_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationWaterfallSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationWaterfallSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationWaterfallSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_browser_caching_threshold: int,
                 resources_threshold: int,
                 slow_cnd_resources_threshold: int,
                 slow_first_party_resources_threshold: int,
                 slow_third_party_resources_threshold: int,
                 speed_index_visually_complete_ratio_threshold: int,
                 uncompressed_resources_threshold: int):
        """
        :param int resource_browser_caching_threshold: Warn about resources with a lower browser cache rate above *X*%. Values between 1 and 100 are allowed.
        :param int resources_threshold: Warn about resources larger than *X* bytes. Values between 0 and 99999000 are allowed.
        :param int slow_cnd_resources_threshold: Warn about slow CDN resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
        :param int slow_first_party_resources_threshold: Warn about slow 1st party resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
        :param int slow_third_party_resources_threshold: Warn about slow 3rd party resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
        :param int speed_index_visually_complete_ratio_threshold: Warn if Speed index exceeds *X* % of Visually complete. Values between 1 and 99 are allowed.
        :param int uncompressed_resources_threshold: Warn about uncompressed resources larger than *X* bytes. Values between 0 and 99999 are allowed.
        """
        pulumi.set(__self__, "resource_browser_caching_threshold", resource_browser_caching_threshold)
        pulumi.set(__self__, "resources_threshold", resources_threshold)
        pulumi.set(__self__, "slow_cnd_resources_threshold", slow_cnd_resources_threshold)
        pulumi.set(__self__, "slow_first_party_resources_threshold", slow_first_party_resources_threshold)
        pulumi.set(__self__, "slow_third_party_resources_threshold", slow_third_party_resources_threshold)
        pulumi.set(__self__, "speed_index_visually_complete_ratio_threshold", speed_index_visually_complete_ratio_threshold)
        pulumi.set(__self__, "uncompressed_resources_threshold", uncompressed_resources_threshold)

    @property
    @pulumi.getter(name="resourceBrowserCachingThreshold")
    def resource_browser_caching_threshold(self) -> int:
        """
        Warn about resources with a lower browser cache rate above *X*%. Values between 1 and 100 are allowed.
        """
        return pulumi.get(self, "resource_browser_caching_threshold")

    @property
    @pulumi.getter(name="resourcesThreshold")
    def resources_threshold(self) -> int:
        """
        Warn about resources larger than *X* bytes. Values between 0 and 99999000 are allowed.
        """
        return pulumi.get(self, "resources_threshold")

    @property
    @pulumi.getter(name="slowCndResourcesThreshold")
    def slow_cnd_resources_threshold(self) -> int:
        """
        Warn about slow CDN resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
        """
        return pulumi.get(self, "slow_cnd_resources_threshold")

    @property
    @pulumi.getter(name="slowFirstPartyResourcesThreshold")
    def slow_first_party_resources_threshold(self) -> int:
        """
        Warn about slow 1st party resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
        """
        return pulumi.get(self, "slow_first_party_resources_threshold")

    @property
    @pulumi.getter(name="slowThirdPartyResourcesThreshold")
    def slow_third_party_resources_threshold(self) -> int:
        """
        Warn about slow 3rd party resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
        """
        return pulumi.get(self, "slow_third_party_resources_threshold")

    @property
    @pulumi.getter(name="speedIndexVisuallyCompleteRatioThreshold")
    def speed_index_visually_complete_ratio_threshold(self) -> int:
        """
        Warn if Speed index exceeds *X* % of Visually complete. Values between 1 and 99 are allowed.
        """
        return pulumi.get(self, "speed_index_visually_complete_ratio_threshold")

    @property
    @pulumi.getter(name="uncompressedResourcesThreshold")
    def uncompressed_resources_threshold(self) -> int:
        """
        Warn about uncompressed resources larger than *X* bytes. Values between 0 and 99999 are allowed.
        """
        return pulumi.get(self, "uncompressed_resources_threshold")


@pulumi.output_type
class WebApplicationXhrActionApdexSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frustratingFallbackThreshold":
            suggest = "frustrating_fallback_threshold"
        elif key == "frustratingThreshold":
            suggest = "frustrating_threshold"
        elif key == "toleratedFallbackThreshold":
            suggest = "tolerated_fallback_threshold"
        elif key == "toleratedThreshold":
            suggest = "tolerated_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationXhrActionApdexSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationXhrActionApdexSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationXhrActionApdexSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frustrating_fallback_threshold: int,
                 frustrating_threshold: int,
                 tolerated_fallback_threshold: int,
                 tolerated_threshold: int,
                 threshold: Optional[int] = None):
        """
        :param int frustrating_fallback_threshold: Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
        :param int frustrating_threshold: Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
        :param int tolerated_fallback_threshold: Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
        :param int tolerated_threshold: Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
        :param int threshold: no documentation available
        """
        pulumi.set(__self__, "frustrating_fallback_threshold", frustrating_fallback_threshold)
        pulumi.set(__self__, "frustrating_threshold", frustrating_threshold)
        pulumi.set(__self__, "tolerated_fallback_threshold", tolerated_fallback_threshold)
        pulumi.set(__self__, "tolerated_threshold", tolerated_threshold)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="frustratingFallbackThreshold")
    def frustrating_fallback_threshold(self) -> int:
        """
        Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
        """
        return pulumi.get(self, "frustrating_fallback_threshold")

    @property
    @pulumi.getter(name="frustratingThreshold")
    def frustrating_threshold(self) -> int:
        """
        Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
        """
        return pulumi.get(self, "frustrating_threshold")

    @property
    @pulumi.getter(name="toleratedFallbackThreshold")
    def tolerated_fallback_threshold(self) -> int:
        """
        Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
        """
        return pulumi.get(self, "tolerated_fallback_threshold")

    @property
    @pulumi.getter(name="toleratedThreshold")
    def tolerated_threshold(self) -> int:
        """
        Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
        """
        return pulumi.get(self, "tolerated_threshold")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The attribute `threshold` no longer exists in the API schema, please use `tolerated_threshold`, `frustrating_threshold`, `tolerated_fallback_threshold`, and `frustrating_fallback_threshold` instead""")
    def threshold(self) -> Optional[int]:
        """
        no documentation available
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class WebhookNotificationHeaders(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.WebhookNotificationHeadersHeader']):
        """
        :param Sequence['WebhookNotificationHeadersHeaderArgs'] headers: An additional HTTP Header to include when sending requests
        """
        pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.WebhookNotificationHeadersHeader']:
        """
        An additional HTTP Header to include when sending requests
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class WebhookNotificationHeadersHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretValue":
            suggest = "secret_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhookNotificationHeadersHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhookNotificationHeadersHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhookNotificationHeadersHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 secret_value: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the HTTP header
        :param str secret_value: The value of the HTTP header as a sensitive property. May contain an empty value. `secret_value` and `value` are mutually exclusive. Only one of those two is allowed to be specified.
        :param str value: The value of the HTTP header. May contain an empty value. `secret_value` and `value` are mutually exclusive. Only one of those two is allowed to be specified.
        """
        pulumi.set(__self__, "name", name)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the HTTP header
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[str]:
        """
        The value of the HTTP header as a sensitive property. May contain an empty value. `secret_value` and `value` are mutually exclusive. Only one of those two is allowed to be specified.
        """
        return pulumi.get(self, "secret_value")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the HTTP header. May contain an empty value. `secret_value` and `value` are mutually exclusive. Only one of those two is allowed to be specified.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebhookNotificationOauth2Credentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessTokenUrl":
            suggest = "access_token_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "authenticateViaRequestHeader":
            suggest = "authenticate_via_request_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhookNotificationOauth2Credentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhookNotificationOauth2Credentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhookNotificationOauth2Credentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token_url: str,
                 client_id: str,
                 client_secret: str,
                 authenticate_via_request_header: Optional[bool] = None,
                 scope: Optional[str] = None):
        """
        :param str access_token_url: Access token URL
        :param str client_id: Client ID
        :param str client_secret: Client secret
        :param bool authenticate_via_request_header: If false, the client credentials are included in the HTTP request body.
        :param str scope: The scope of access you are requesting
        """
        pulumi.set(__self__, "access_token_url", access_token_url)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if authenticate_via_request_header is not None:
            pulumi.set(__self__, "authenticate_via_request_header", authenticate_via_request_header)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="accessTokenUrl")
    def access_token_url(self) -> str:
        """
        Access token URL
        """
        return pulumi.get(self, "access_token_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        Client secret
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="authenticateViaRequestHeader")
    def authenticate_via_request_header(self) -> Optional[bool]:
        """
        If false, the client credentials are included in the HTTP request body.
        """
        return pulumi.get(self, "authenticate_via_request_header")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The scope of access you are requesting
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class XmattersNotificationHeaders(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.XmattersNotificationHeadersHeader']):
        """
        :param Sequence['XmattersNotificationHeadersHeaderArgs'] headers: An additional HTTP Header to include when sending requests
        """
        pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.XmattersNotificationHeadersHeader']:
        """
        An additional HTTP Header to include when sending requests
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class XmattersNotificationHeadersHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretValue":
            suggest = "secret_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in XmattersNotificationHeadersHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        XmattersNotificationHeadersHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        XmattersNotificationHeadersHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 secret_value: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the HTTP header
        :param str secret_value: The value of the HTTP header as a sensitive property. May contain an empty value. `secret_value` and `value` are mutually exclusive. Only one of those two is allowed to be specified.
        :param str value: The value of the HTTP header. May contain an empty value. `secret_value` and `value` are mutually exclusive. Only one of those two is allowed to be specified.
        """
        pulumi.set(__self__, "name", name)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the HTTP header
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[str]:
        """
        The value of the HTTP header as a sensitive property. May contain an empty value. `secret_value` and `value` are mutually exclusive. Only one of those two is allowed to be specified.
        """
        return pulumi.get(self, "secret_value")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the HTTP header. May contain an empty value. `secret_value` and `value` are mutually exclusive. Only one of those two is allowed to be specified.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAlertingProfilesValueResult(dict):
    def __init__(__self__, *,
                 id: str,
                 legacy_id: str,
                 management_zone_id: str,
                 management_zone_legacy_id: str,
                 name: str):
        """
        :param str id: The ID of the Alerting Profile when referred to as a Settings 2.0 resource (e.g. from within `SlackNotification`)
        :param str legacy_id: The ID of the Alerting Profile when referred to as a Configuration API resource (e.g. from within `Notification`)
        :param str management_zone_id: The ID of the management zone to which the alerting profile applies (Settings 2.0)
        :param str management_zone_legacy_id: The ID of the management zone to which the alerting profile applies (Configuration API)
        :param str name: The name of the Alerting Profile
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "legacy_id", legacy_id)
        pulumi.set(__self__, "management_zone_id", management_zone_id)
        pulumi.set(__self__, "management_zone_legacy_id", management_zone_legacy_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Alerting Profile when referred to as a Settings 2.0 resource (e.g. from within `SlackNotification`)
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="legacyId")
    def legacy_id(self) -> str:
        """
        The ID of the Alerting Profile when referred to as a Configuration API resource (e.g. from within `Notification`)
        """
        return pulumi.get(self, "legacy_id")

    @property
    @pulumi.getter(name="managementZoneId")
    def management_zone_id(self) -> str:
        """
        The ID of the management zone to which the alerting profile applies (Settings 2.0)
        """
        return pulumi.get(self, "management_zone_id")

    @property
    @pulumi.getter(name="managementZoneLegacyId")
    def management_zone_legacy_id(self) -> str:
        """
        The ID of the management zone to which the alerting profile applies (Configuration API)
        """
        return pulumi.get(self, "management_zone_legacy_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Alerting Profile
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetApiTokensApiTokenResult(dict):
    def __init__(__self__, *,
                 creation_date: str,
                 last_used_date: str,
                 last_used_ip_address: str,
                 modified_date: str,
                 name: str,
                 owner: str,
                 scopes: Sequence[str],
                 token: str,
                 enabled: Optional[bool] = None,
                 expiration_date: Optional[str] = None,
                 personal_access_token: Optional[bool] = None):
        """
        :param str creation_date: Token creation date in ISO 8601 format (yyyy-MM-dd'T'HH:mm:ss.SSS'Z')
        :param str last_used_date: Token last used date in ISO 8601 format (yyyy-MM-dd'T'HH:mm:ss.SSS'Z')
        :param str last_used_ip_address: Token last used IP address.
        :param str modified_date: Token last modified date in ISO 8601 format (yyyy-MM-dd'T'HH:mm:ss.SSS'Z').
        :param str name: The name of the token.
        :param str owner: The owner of the token
        :param Sequence[str] scopes: A list of the scopes to be assigned to the token.
        :param str token: The secret of the token.
        :param bool enabled: The token is enabled (true) or disabled (false), default disabled (false).
        :param str expiration_date: The expiration date of the token.
        :param bool personal_access_token: The token is a personal access token (true) or an API token (false).
        """
        pulumi.set(__self__, "creation_date", creation_date)
        pulumi.set(__self__, "last_used_date", last_used_date)
        pulumi.set(__self__, "last_used_ip_address", last_used_ip_address)
        pulumi.set(__self__, "modified_date", modified_date)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "token", token)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expiration_date is not None:
            pulumi.set(__self__, "expiration_date", expiration_date)
        if personal_access_token is not None:
            pulumi.set(__self__, "personal_access_token", personal_access_token)

    @property
    @pulumi.getter(name="creationDate")
    def creation_date(self) -> str:
        """
        Token creation date in ISO 8601 format (yyyy-MM-dd'T'HH:mm:ss.SSS'Z')
        """
        return pulumi.get(self, "creation_date")

    @property
    @pulumi.getter(name="lastUsedDate")
    def last_used_date(self) -> str:
        """
        Token last used date in ISO 8601 format (yyyy-MM-dd'T'HH:mm:ss.SSS'Z')
        """
        return pulumi.get(self, "last_used_date")

    @property
    @pulumi.getter(name="lastUsedIpAddress")
    def last_used_ip_address(self) -> str:
        """
        Token last used IP address.
        """
        return pulumi.get(self, "last_used_ip_address")

    @property
    @pulumi.getter(name="modifiedDate")
    def modified_date(self) -> str:
        """
        Token last modified date in ISO 8601 format (yyyy-MM-dd'T'HH:mm:ss.SSS'Z').
        """
        return pulumi.get(self, "modified_date")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the token.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def owner(self) -> str:
        """
        The owner of the token
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        A list of the scopes to be assigned to the token.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        The secret of the token.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        The token is enabled (true) or disabled (false), default disabled (false).
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> Optional[str]:
        """
        The expiration date of the token.
        """
        return pulumi.get(self, "expiration_date")

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> Optional[bool]:
        """
        The token is a personal access token (true) or an API token (false).
        """
        return pulumi.get(self, "personal_access_token")


@pulumi.output_type
class GetDocumentsValueResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 owner: str,
                 type: str):
        """
        :param str id: The unique identifier of the document.
        :param str name: The name of the document.
        :param str owner: The owner of the document. This could be a user or a group that has ownership rights over the document.
        :param str type: The type of the document. This could be a specific format or category the document belongs to.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the document.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the document.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def owner(self) -> str:
        """
        The owner of the document. This could be a user or a group that has ownership rights over the document.
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the document. This could be a specific format or category the document belongs to.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEntitiesEntityResult(dict):
    def __init__(__self__, *,
                 properties: Mapping[str, str],
                 display_name: Optional[str] = None,
                 entity_id: Optional[str] = None,
                 last_seen_tms: Optional[int] = None,
                 tags: Optional[Sequence['outputs.GetEntitiesEntityTagResult']] = None,
                 type: Optional[str] = None):
        """
        :param Mapping[str, str] properties: Properties defining the entity.
        :param str display_name: The name of the entity, displayed in the UI.
        :param str entity_id: The ID of the entity.
        :param int last_seen_tms: The timestamp at which the entity was last seen, in UTC milliseconds.
        :param Sequence['GetEntitiesEntityTagArgs'] tags: A set of tags assigned to the entity.
        :param str type: The type of the entity.
        """
        pulumi.set(__self__, "properties", properties)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if last_seen_tms is not None:
            pulumi.set(__self__, "last_seen_tms", last_seen_tms)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def properties(self) -> Mapping[str, str]:
        """
        Properties defining the entity.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The name of the entity, displayed in the UI.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[str]:
        """
        The ID of the entity.
        """
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter(name="lastSeenTms")
    def last_seen_tms(self) -> Optional[int]:
        """
        The timestamp at which the entity was last seen, in UTC milliseconds.
        """
        return pulumi.get(self, "last_seen_tms")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.GetEntitiesEntityTagResult']]:
        """
        A set of tags assigned to the entity.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the entity.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEntitiesEntityTagResult(dict):
    def __init__(__self__, *,
                 tags: Optional[Sequence['outputs.GetEntitiesEntityTagTagResult']] = None):
        """
        :param Sequence['GetEntitiesEntityTagTagArgs'] tags: A tag assigned to the entity
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.GetEntitiesEntityTagTagResult']]:
        """
        A tag assigned to the entity
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetEntitiesEntityTagTagResult(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 string_representation: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str context: The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value
        :param str key: The key of the tag. Custom tags have the tag value here
        :param str string_representation: The string representation of the tag
        :param str value: The value of the tag. Not applicable to custom tags
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if string_representation is not None:
            pulumi.set(__self__, "string_representation", string_representation)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        """
        The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag. Custom tags have the tag value here
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="stringRepresentation")
    def string_representation(self) -> Optional[str]:
        """
        The string representation of the tag
        """
        return pulumi.get(self, "string_representation")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Not applicable to custom tags
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGenericSettingsValueResult(dict):
    def __init__(__self__, *,
                 local_storage: str,
                 schema: str,
                 scope: str,
                 value: str):
        pulumi.set(__self__, "local_storage", local_storage)
        pulumi.set(__self__, "schema", schema)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> str:
        return pulumi.get(self, "local_storage")

    @property
    @pulumi.getter
    def schema(self) -> str:
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def scope(self) -> str:
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetHubItemsItemResult(dict):
    def __init__(__self__, *,
                 activation_link: str,
                 artifact_id: str,
                 author_logo: str,
                 author_name: str,
                 cluster_compatible: bool,
                 coming_soon: bool,
                 description: str,
                 documentation_link: str,
                 has_description_blocks: bool,
                 item_id: str,
                 logo: str,
                 marketing_link: str,
                 name: str,
                 not_compatible_reason: str,
                 tags: Sequence[str],
                 type: str):
        """
        :param str activation_link: The activation link for a technology
        :param str artifact_id: The unique ID used by the artifacts contained in releases
        :param str author_logo: URL for the author's logo
        :param str author_name: Name of the author of the item
        :param bool cluster_compatible: Checks if the item is compatible with the cluster version
        :param bool coming_soon: Whether or not the item is planned to be released soon
        :param str description: Description of the item
        :param str documentation_link: An absolute link to the documentation page of this item
        :param bool has_description_blocks: Whether or not the details call will contain description blocks
        :param str item_id: Unique Id of the item
        :param str logo: The logo of the item. Can be a URL or Base64 encoded. Intended for HTML tags
        :param str marketing_link: An absolute link to the marketing page of this item
        :param str name: Name of the item
        :param str not_compatible_reason: The reason why the item is not compatible with the cluster version
        :param Sequence[str] tags: Grouping of items with keywords
        :param str type: Represents the type of item. It can be `TECHNOLOGY`, `EXTENSION1` or `EXTENSION2`
        """
        pulumi.set(__self__, "activation_link", activation_link)
        pulumi.set(__self__, "artifact_id", artifact_id)
        pulumi.set(__self__, "author_logo", author_logo)
        pulumi.set(__self__, "author_name", author_name)
        pulumi.set(__self__, "cluster_compatible", cluster_compatible)
        pulumi.set(__self__, "coming_soon", coming_soon)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "documentation_link", documentation_link)
        pulumi.set(__self__, "has_description_blocks", has_description_blocks)
        pulumi.set(__self__, "item_id", item_id)
        pulumi.set(__self__, "logo", logo)
        pulumi.set(__self__, "marketing_link", marketing_link)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "not_compatible_reason", not_compatible_reason)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="activationLink")
    def activation_link(self) -> str:
        """
        The activation link for a technology
        """
        return pulumi.get(self, "activation_link")

    @property
    @pulumi.getter(name="artifactId")
    def artifact_id(self) -> str:
        """
        The unique ID used by the artifacts contained in releases
        """
        return pulumi.get(self, "artifact_id")

    @property
    @pulumi.getter(name="authorLogo")
    def author_logo(self) -> str:
        """
        URL for the author's logo
        """
        return pulumi.get(self, "author_logo")

    @property
    @pulumi.getter(name="authorName")
    def author_name(self) -> str:
        """
        Name of the author of the item
        """
        return pulumi.get(self, "author_name")

    @property
    @pulumi.getter(name="clusterCompatible")
    def cluster_compatible(self) -> bool:
        """
        Checks if the item is compatible with the cluster version
        """
        return pulumi.get(self, "cluster_compatible")

    @property
    @pulumi.getter(name="comingSoon")
    def coming_soon(self) -> bool:
        """
        Whether or not the item is planned to be released soon
        """
        return pulumi.get(self, "coming_soon")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the item
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="documentationLink")
    def documentation_link(self) -> str:
        """
        An absolute link to the documentation page of this item
        """
        return pulumi.get(self, "documentation_link")

    @property
    @pulumi.getter(name="hasDescriptionBlocks")
    def has_description_blocks(self) -> bool:
        """
        Whether or not the details call will contain description blocks
        """
        return pulumi.get(self, "has_description_blocks")

    @property
    @pulumi.getter(name="itemId")
    def item_id(self) -> str:
        """
        Unique Id of the item
        """
        return pulumi.get(self, "item_id")

    @property
    @pulumi.getter
    def logo(self) -> str:
        """
        The logo of the item. Can be a URL or Base64 encoded. Intended for HTML tags
        """
        return pulumi.get(self, "logo")

    @property
    @pulumi.getter(name="marketingLink")
    def marketing_link(self) -> str:
        """
        An absolute link to the marketing page of this item
        """
        return pulumi.get(self, "marketing_link")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the item
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="notCompatibleReason")
    def not_compatible_reason(self) -> str:
        """
        The reason why the item is not compatible with the cluster version
        """
        return pulumi.get(self, "not_compatible_reason")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        Grouping of items with keywords
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Represents the type of item. It can be `TECHNOLOGY`, `EXTENSION1` or `EXTENSION2`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetIamPoliciesPolicyResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 uuid: str,
                 account: Optional[str] = None,
                 environment: Optional[str] = None,
                 global_: Optional[bool] = None):
        """
        :param str name: The name of the policy
        :param str uuid: The UUID of the policy
        :param str account: The account UUID the policy is defined for
        :param str environment: The environment ID the policy is defined for
        :param bool global_: `true` if this is a global policy`
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "uuid", uuid)
        if account is not None:
            pulumi.set(__self__, "account", account)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if global_ is not None:
            pulumi.set(__self__, "global_", global_)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the policy
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uuid(self) -> str:
        """
        The UUID of the policy
        """
        return pulumi.get(self, "uuid")

    @property
    @pulumi.getter
    def account(self) -> Optional[str]:
        """
        The account UUID the policy is defined for
        """
        return pulumi.get(self, "account")

    @property
    @pulumi.getter
    def environment(self) -> Optional[str]:
        """
        The environment ID the policy is defined for
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="global")
    def global_(self) -> Optional[bool]:
        """
        `true` if this is a global policy`
        """
        return pulumi.get(self, "global_")


@pulumi.output_type
class GetManagementZonesValueResult(dict):
    def __init__(__self__, *,
                 description: str,
                 id: str,
                 legacy_id: str,
                 name: str):
        """
        :param str description: The description of the Management Zone
        :param str id: The ID of the Management Zone when referred to as a Settings 2.0 resource (e.g. from within `SlackNotification`)
        :param str legacy_id: The ID of the Management Zone when referred to as a Configuration API resource (e.g. from within `Notification`)
        :param str name: The name of the Management Zone
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "legacy_id", legacy_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the Management Zone
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Management Zone when referred to as a Settings 2.0 resource (e.g. from within `SlackNotification`)
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="legacyId")
    def legacy_id(self) -> str:
        """
        The ID of the Management Zone when referred to as a Configuration API resource (e.g. from within `Notification`)
        """
        return pulumi.get(self, "legacy_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Management Zone
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRemoteEnvironmentsRemoteEnvironmentResult(dict):
    def __init__(__self__, *,
                 name: str,
                 network_scope: str,
                 token: str,
                 uri: str):
        """
        :param str name: Name
        :param str network_scope: Possible Values: `CLUSTER`, `EXTERNAL`, `INTERNAL`
        :param str token: Provide a valid token created on the remote environment.
        :param str uri: Specify the full URI to the remote environment. Your local environment will have to be able to connect this URI on a network level.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_scope", network_scope)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkScope")
    def network_scope(self) -> str:
        """
        Possible Values: `CLUSTER`, `EXTERNAL`, `INTERNAL`
        """
        return pulumi.get(self, "network_scope")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        Provide a valid token created on the remote environment.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Specify the full URI to the remote environment. Your local environment will have to be able to connect this URI on a network level.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetSyntheticLocationsLocationsResult(dict):
    def __init__(__self__, *,
                 cloud_platform: str,
                 ips: Sequence[str],
                 stage: str,
                 status: str,
                 entity_id: Optional[str] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str cloud_platform: The cloud provider where the location is hosted.
        :param Sequence[str] ips: The list of IP addresses assigned to the location. 
               
                Only applicable to `PUBLIC` locations
        :param str stage: The release stage of the location
        :param str status: The status of the location: 
               
               * `ENABLED`: The location is displayed as active in the UI. You can assign monitors to the location. 
               * `DISABLED`: The location is displayed as inactive in the UI. You can't assign monitors to the location. Monitors already assigned to the location will stay there and will be executed from the location. 
               * `HIDDEN`: The location is not displayed in the UI. You can't assign monitors to the location. You can only set location as `HIDDEN` when no monitor is assigned to it
        :param str entity_id: The unique ID of the location
        :param str name: The name of the location
        :param str type: The type of the location. Supported values are `PUBLIC`, `PRIVATE` and `CLUSTER`
        """
        pulumi.set(__self__, "cloud_platform", cloud_platform)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "stage", stage)
        pulumi.set(__self__, "status", status)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="cloudPlatform")
    def cloud_platform(self) -> str:
        """
        The cloud provider where the location is hosted.
        """
        return pulumi.get(self, "cloud_platform")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        """
        The list of IP addresses assigned to the location. 

         Only applicable to `PUBLIC` locations
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def stage(self) -> str:
        """
        The release stage of the location
        """
        return pulumi.get(self, "stage")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the location: 

        * `ENABLED`: The location is displayed as active in the UI. You can assign monitors to the location. 
        * `DISABLED`: The location is displayed as inactive in the UI. You can't assign monitors to the location. Monitors already assigned to the location will stay there and will be executed from the location. 
        * `HIDDEN`: The location is not displayed in the UI. You can't assign monitors to the location. You can only set location as `HIDDEN` when no monitor is assigned to it
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[str]:
        """
        The unique ID of the location
        """
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the location
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the location. Supported values are `PUBLIC`, `PRIVATE` and `CLUSTER`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSyntheticNodesNodeResult(dict):
    def __init__(__self__, *,
                 active_gate_version: str,
                 auto_update: bool,
                 browser_monitors: bool,
                 health_check_status: str,
                 hostname: str,
                 id: str,
                 ips: Sequence[str],
                 one_agent_routing: bool,
                 operating_system: str,
                 player_version: str,
                 status: str,
                 version: str):
        """
        :param str active_gate_version: The version of the Active Gate
        :param bool auto_update: Specifies whether the Active Gate  has the Auto update option enabled
        :param bool browser_monitors: Specifies whether Browser Monitors are enabled or not
        :param str health_check_status: The health check status of the synthetic node
        :param str hostname: The hostname of a node
        :param str id: The ID of a node for usage within `SyntheticLocation`
        :param Sequence[str] ips: The known IP addresses of the node
        :param bool one_agent_routing: Specifies whether the Active Gate has the One Agent routing enabled
        :param str operating_system: The Active Gate's host operating system
        :param str player_version: The version of the synthetic player
        :param str status: The status of the synthetic node
        :param str version: The version of a node
        """
        pulumi.set(__self__, "active_gate_version", active_gate_version)
        pulumi.set(__self__, "auto_update", auto_update)
        pulumi.set(__self__, "browser_monitors", browser_monitors)
        pulumi.set(__self__, "health_check_status", health_check_status)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "one_agent_routing", one_agent_routing)
        pulumi.set(__self__, "operating_system", operating_system)
        pulumi.set(__self__, "player_version", player_version)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="activeGateVersion")
    def active_gate_version(self) -> str:
        """
        The version of the Active Gate
        """
        return pulumi.get(self, "active_gate_version")

    @property
    @pulumi.getter(name="autoUpdate")
    def auto_update(self) -> bool:
        """
        Specifies whether the Active Gate  has the Auto update option enabled
        """
        return pulumi.get(self, "auto_update")

    @property
    @pulumi.getter(name="browserMonitors")
    def browser_monitors(self) -> bool:
        """
        Specifies whether Browser Monitors are enabled or not
        """
        return pulumi.get(self, "browser_monitors")

    @property
    @pulumi.getter(name="healthCheckStatus")
    def health_check_status(self) -> str:
        """
        The health check status of the synthetic node
        """
        return pulumi.get(self, "health_check_status")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The hostname of a node
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of a node for usage within `SyntheticLocation`
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        """
        The known IP addresses of the node
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="oneAgentRouting")
    def one_agent_routing(self) -> bool:
        """
        Specifies whether the Active Gate has the One Agent routing enabled
        """
        return pulumi.get(self, "one_agent_routing")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> str:
        """
        The Active Gate's host operating system
        """
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter(name="playerVersion")
    def player_version(self) -> str:
        """
        The version of the synthetic player
        """
        return pulumi.get(self, "player_version")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the synthetic node
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version of a node
        """
        return pulumi.get(self, "version")


