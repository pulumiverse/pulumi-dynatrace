# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AlertingFilters',
    'AlertingFiltersFilter',
    'AlertingFiltersFilterCustom',
    'AlertingFiltersFilterCustomDescription',
    'AlertingFiltersFilterCustomMetadata',
    'AlertingFiltersFilterCustomMetadataItems',
    'AlertingFiltersFilterCustomMetadataItemsFilter',
    'AlertingFiltersFilterCustomTitle',
    'AlertingFiltersFilterPredefined',
    'AlertingProfileEventTypeFilter',
    'AlertingProfileEventTypeFilterCustomEventFilter',
    'AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter',
    'AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter',
    'AlertingProfileEventTypeFilterPredefinedEventFilter',
    'AlertingProfileMetadata',
    'AlertingProfileRule',
    'AlertingProfileRuleTagFilter',
    'AlertingProfileRuleTagFilterTagFilter',
    'AlertingRules',
    'AlertingRulesRule',
    'ApiDetectionConditions',
    'ApiDetectionConditionsCondition',
    'ApplicationAnomaliesFailureRate',
    'ApplicationAnomaliesFailureRateAuto',
    'ApplicationAnomaliesFailureRateThresholds',
    'ApplicationAnomaliesResponseTime',
    'ApplicationAnomaliesResponseTimeAuto',
    'ApplicationAnomaliesResponseTimeThresholds',
    'ApplicationAnomaliesTraffic',
    'ApplicationAnomaliesTrafficDrops',
    'ApplicationAnomaliesTrafficSpikes',
    'ApplicationDataPrivacySessionReplayDataPrivacy',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettings',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlayback',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRules',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecording',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRules',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule',
    'ApplicationDetectionRuleFilterConfig',
    'ApplicationErrorRulesCustomErrors',
    'ApplicationErrorRulesCustomErrorsRule',
    'ApplicationErrorRulesHttpErrors',
    'ApplicationErrorRulesHttpErrorsRule',
    'AutotagEntitySelectorBasedRule',
    'AutotagRule',
    'AutotagRuleCondition',
    'AutotagRuleConditionApplicationType',
    'AutotagRuleConditionApplicationTypeComparison',
    'AutotagRuleConditionAzureComputeMode',
    'AutotagRuleConditionAzureComputeModeComparison',
    'AutotagRuleConditionAzureSkuComparision',
    'AutotagRuleConditionAzureSkus',
    'AutotagRuleConditionBaseComparisonBasic',
    'AutotagRuleConditionBaseConditionKey',
    'AutotagRuleConditionBitness',
    'AutotagRuleConditionBitnessComparision',
    'AutotagRuleConditionCloudType',
    'AutotagRuleConditionCloudTypeComparison',
    'AutotagRuleConditionComparison',
    'AutotagRuleConditionCustomApplicationType',
    'AutotagRuleConditionCustomApplicationTypeComparison',
    'AutotagRuleConditionCustomHostMetadata',
    'AutotagRuleConditionCustomHostMetadataConditionKey',
    'AutotagRuleConditionCustomHostMetadataConditionKeyDynamicKey',
    'AutotagRuleConditionCustomHostMetadataDynamicKey',
    'AutotagRuleConditionCustomProcessMetadata',
    'AutotagRuleConditionCustomProcessMetadataConditionKey',
    'AutotagRuleConditionCustomProcessMetadataConditionKeyDynamicKey',
    'AutotagRuleConditionCustomProcessMetadataDynamicKey',
    'AutotagRuleConditionDatabaseTopology',
    'AutotagRuleConditionDatabaseTopologyComparison',
    'AutotagRuleConditionDcrumDecoder',
    'AutotagRuleConditionDcrumDecoderComparison',
    'AutotagRuleConditionEntity',
    'AutotagRuleConditionEntityIdComparison',
    'AutotagRuleConditionHostTech',
    'AutotagRuleConditionHostTechValue',
    'AutotagRuleConditionHypervisor',
    'AutotagRuleConditionHypervisorTypeComparision',
    'AutotagRuleConditionIndexedName',
    'AutotagRuleConditionIndexedNameComparison',
    'AutotagRuleConditionIndexedString',
    'AutotagRuleConditionIndexedStringComparison',
    'AutotagRuleConditionIndexedTag',
    'AutotagRuleConditionIndexedTagComparison',
    'AutotagRuleConditionIndexedTagComparisonValue',
    'AutotagRuleConditionIndexedTagValue',
    'AutotagRuleConditionInteger',
    'AutotagRuleConditionIntegerComparison',
    'AutotagRuleConditionIpaddress',
    'AutotagRuleConditionIpaddressComparison',
    'AutotagRuleConditionKey',
    'AutotagRuleConditionMobilePlatform',
    'AutotagRuleConditionMobilePlatformComparison',
    'AutotagRuleConditionOsArch',
    'AutotagRuleConditionOsType',
    'AutotagRuleConditionOsarchitectureComparison',
    'AutotagRuleConditionOstypeComparison',
    'AutotagRuleConditionPaasType',
    'AutotagRuleConditionPaasTypeComparison',
    'AutotagRuleConditionProcessMetadata',
    'AutotagRuleConditionProcessMetadataConditionKey',
    'AutotagRuleConditionServiceTopology',
    'AutotagRuleConditionServiceTopologyComparison',
    'AutotagRuleConditionServiceType',
    'AutotagRuleConditionServiceTypeComparison',
    'AutotagRuleConditionSimpleHostTechComparison',
    'AutotagRuleConditionSimpleHostTechComparisonValue',
    'AutotagRuleConditionSimpleTechComparison',
    'AutotagRuleConditionSimpleTechComparisonValue',
    'AutotagRuleConditionString',
    'AutotagRuleConditionStringComparison',
    'AutotagRuleConditionStringConditionKey',
    'AutotagRuleConditionStringKey',
    'AutotagRuleConditionSyntheticEngine',
    'AutotagRuleConditionSyntheticEngineTypeComparison',
    'AutotagRuleConditionTag',
    'AutotagRuleConditionTagComparison',
    'AutotagRuleConditionTagComparisonValue',
    'AutotagRuleConditionTagValue',
    'AutotagRuleConditionTech',
    'AutotagRuleConditionTechValue',
    'AutotagV2Rules',
    'AutotagV2RulesRule',
    'AutotagV2RulesRuleAttributeRule',
    'AutotagV2RulesRuleAttributeRuleConditions',
    'AutotagV2RulesRuleAttributeRuleConditionsCondition',
    'AwsAnomaliesEc2CandidateHighCpuDetection',
    'AwsAnomaliesEc2CandidateHighCpuDetectionCustomThresholds',
    'AwsAnomaliesElbHighConnectionErrorsDetection',
    'AwsAnomaliesElbHighConnectionErrorsDetectionCustomThresholds',
    'AwsAnomaliesLambdaHighErrorRateDetection',
    'AwsAnomaliesLambdaHighErrorRateDetectionCustomThresholds',
    'AwsAnomaliesRdsHighCpuDetection',
    'AwsAnomaliesRdsHighCpuDetectionCustomThresholds',
    'AwsAnomaliesRdsHighMemoryDetection',
    'AwsAnomaliesRdsHighMemoryDetectionCustomThresholds',
    'AwsAnomaliesRdsHighWriteReadLatencyDetection',
    'AwsAnomaliesRdsHighWriteReadLatencyDetectionCustomThresholds',
    'AwsAnomaliesRdsLowStorageDetection',
    'AwsAnomaliesRdsLowStorageDetectionCustomThresholds',
    'AwsAnomaliesRdsRestartsSequenceDetection',
    'AwsAnomaliesRdsRestartsSequenceDetectionCustomThresholds',
    'AwsCredentialsAuthenticationData',
    'AwsCredentialsSupportingServicesToMonitor',
    'AwsCredentialsSupportingServicesToMonitorMonitoredMetric',
    'AwsCredentialsTagsToMonitor',
    'AzureCredentialsMonitorOnlyExcludingTagPair',
    'AzureCredentialsMonitorOnlyTagPair',
    'AzureCredentialsSupportingService',
    'AzureCredentialsSupportingServiceMonitoredMetric',
    'BrowserMonitorAnomalyDetection',
    'BrowserMonitorAnomalyDetectionLoadingTimeThreshold',
    'BrowserMonitorAnomalyDetectionLoadingTimeThresholdThreshold',
    'BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold',
    'BrowserMonitorAnomalyDetectionOutageHandling',
    'BrowserMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy',
    'BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy',
    'BrowserMonitorKeyPerformanceMetrics',
    'BrowserMonitorPerformanceThresholds',
    'BrowserMonitorPerformanceThresholdsThreshold',
    'BrowserMonitorScript',
    'BrowserMonitorScriptConfiguration',
    'BrowserMonitorScriptConfigurationBandwidth',
    'BrowserMonitorScriptConfigurationCookies',
    'BrowserMonitorScriptConfigurationCookiesCookie',
    'BrowserMonitorScriptConfigurationDevice',
    'BrowserMonitorScriptConfigurationHeaders',
    'BrowserMonitorScriptConfigurationHeadersHeader',
    'BrowserMonitorScriptConfigurationIgnoredErrorCodes',
    'BrowserMonitorScriptConfigurationJavascriptSetttings',
    'BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings',
    'BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions',
    'BrowserMonitorScriptEvents',
    'BrowserMonitorScriptEventsEvent',
    'BrowserMonitorScriptEventsEventClick',
    'BrowserMonitorScriptEventsEventClickTarget',
    'BrowserMonitorScriptEventsEventClickTargetLocator',
    'BrowserMonitorScriptEventsEventClickTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventClickValidate',
    'BrowserMonitorScriptEventsEventClickValidateValidation',
    'BrowserMonitorScriptEventsEventClickValidateValidationTarget',
    'BrowserMonitorScriptEventsEventClickValidateValidationTargetLocator',
    'BrowserMonitorScriptEventsEventClickValidateValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventClickWait',
    'BrowserMonitorScriptEventsEventClickWaitValidation',
    'BrowserMonitorScriptEventsEventClickWaitValidationTarget',
    'BrowserMonitorScriptEventsEventClickWaitValidationTargetLocator',
    'BrowserMonitorScriptEventsEventClickWaitValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventCookie',
    'BrowserMonitorScriptEventsEventCookieCookies',
    'BrowserMonitorScriptEventsEventCookieCookiesCookie',
    'BrowserMonitorScriptEventsEventJavascript',
    'BrowserMonitorScriptEventsEventJavascriptTarget',
    'BrowserMonitorScriptEventsEventJavascriptTargetLocator',
    'BrowserMonitorScriptEventsEventJavascriptTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventJavascriptWait',
    'BrowserMonitorScriptEventsEventJavascriptWaitValidation',
    'BrowserMonitorScriptEventsEventJavascriptWaitValidationTarget',
    'BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocator',
    'BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventKeystrokes',
    'BrowserMonitorScriptEventsEventKeystrokesCredential',
    'BrowserMonitorScriptEventsEventKeystrokesTarget',
    'BrowserMonitorScriptEventsEventKeystrokesTargetLocator',
    'BrowserMonitorScriptEventsEventKeystrokesTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventKeystrokesValidate',
    'BrowserMonitorScriptEventsEventKeystrokesValidateValidation',
    'BrowserMonitorScriptEventsEventKeystrokesValidateValidationTarget',
    'BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocator',
    'BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventKeystrokesWait',
    'BrowserMonitorScriptEventsEventKeystrokesWaitValidation',
    'BrowserMonitorScriptEventsEventKeystrokesWaitValidationTarget',
    'BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocator',
    'BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventNavigate',
    'BrowserMonitorScriptEventsEventNavigateAuthentication',
    'BrowserMonitorScriptEventsEventNavigateTarget',
    'BrowserMonitorScriptEventsEventNavigateTargetLocator',
    'BrowserMonitorScriptEventsEventNavigateTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventNavigateValidate',
    'BrowserMonitorScriptEventsEventNavigateValidateValidation',
    'BrowserMonitorScriptEventsEventNavigateValidateValidationTarget',
    'BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocator',
    'BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventNavigateWait',
    'BrowserMonitorScriptEventsEventNavigateWaitValidation',
    'BrowserMonitorScriptEventsEventNavigateWaitValidationTarget',
    'BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocator',
    'BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventSelect',
    'BrowserMonitorScriptEventsEventSelectSelections',
    'BrowserMonitorScriptEventsEventSelectSelectionsOption',
    'BrowserMonitorScriptEventsEventSelectTarget',
    'BrowserMonitorScriptEventsEventSelectTargetLocator',
    'BrowserMonitorScriptEventsEventSelectTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventSelectValidate',
    'BrowserMonitorScriptEventsEventSelectValidateValidation',
    'BrowserMonitorScriptEventsEventSelectValidateValidationTarget',
    'BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocator',
    'BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventSelectWait',
    'BrowserMonitorScriptEventsEventSelectWaitValidation',
    'BrowserMonitorScriptEventsEventSelectWaitValidationTarget',
    'BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocator',
    'BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventTap',
    'BrowserMonitorScriptEventsEventTapTarget',
    'BrowserMonitorScriptEventsEventTapTargetLocator',
    'BrowserMonitorScriptEventsEventTapTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventTapValidate',
    'BrowserMonitorScriptEventsEventTapValidateValidation',
    'BrowserMonitorScriptEventsEventTapValidateValidationTarget',
    'BrowserMonitorScriptEventsEventTapValidateValidationTargetLocator',
    'BrowserMonitorScriptEventsEventTapValidateValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventTapWait',
    'BrowserMonitorScriptEventsEventTapWaitValidation',
    'BrowserMonitorScriptEventsEventTapWaitValidationTarget',
    'BrowserMonitorScriptEventsEventTapWaitValidationTargetLocator',
    'BrowserMonitorScriptEventsEventTapWaitValidationTargetLocatorLocator',
    'BrowserMonitorTag',
    'BrowserMonitorTagTag',
    'BusinessEventsOneagentEvent',
    'BusinessEventsOneagentEventCategory',
    'BusinessEventsOneagentEventData',
    'BusinessEventsOneagentEventDataEventDataFieldComplex',
    'BusinessEventsOneagentEventDataEventDataFieldComplexSource',
    'BusinessEventsOneagentEventProvider',
    'BusinessEventsOneagentEventType',
    'BusinessEventsOneagentTriggers',
    'BusinessEventsOneagentTriggersTrigger',
    'BusinessEventsOneagentTriggersTriggerSource',
    'BusinessEventsProcessingRuleTesting',
    'BusinessEventsProcessingTransformationFields',
    'BusinessEventsProcessingTransformationFieldsTransformationField',
    'CalculatedServiceMetricCondition',
    'CalculatedServiceMetricConditionCondition',
    'CalculatedServiceMetricConditionConditionComparison',
    'CalculatedServiceMetricConditionConditionComparisonBoolean',
    'CalculatedServiceMetricConditionConditionComparisonEsbInputNodeType',
    'CalculatedServiceMetricConditionConditionComparisonFailedState',
    'CalculatedServiceMetricConditionConditionComparisonFailureReason',
    'CalculatedServiceMetricConditionConditionComparisonFastString',
    'CalculatedServiceMetricConditionConditionComparisonFlawState',
    'CalculatedServiceMetricConditionConditionComparisonGeneric',
    'CalculatedServiceMetricConditionConditionComparisonHttpMethod',
    'CalculatedServiceMetricConditionConditionComparisonHttpStatusClass',
    'CalculatedServiceMetricConditionConditionComparisonIibInputNodeType',
    'CalculatedServiceMetricConditionConditionComparisonNumber',
    'CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute',
    'CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource',
    'CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag',
    'CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTagTagKey',
    'CalculatedServiceMetricConditionConditionComparisonServiceType',
    'CalculatedServiceMetricConditionConditionComparisonString',
    'CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute',
    'CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource',
    'CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag',
    'CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTagTagKey',
    'CalculatedServiceMetricConditionConditionComparisonTag',
    'CalculatedServiceMetricConditionConditionComparisonTagValue',
    'CalculatedServiceMetricConditionConditionComparisonTagValues',
    'CalculatedServiceMetricConditionConditionComparisonTagValuesValue',
    'CalculatedServiceMetricConditionConditionComparisonZosCallType',
    'CalculatedServiceMetricDimensionDefinition',
    'CalculatedServiceMetricDimensionDefinitionPlaceholders',
    'CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder',
    'CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource',
    'CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag',
    'CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKey',
    'CalculatedServiceMetricMetricDefinition',
    'CloudappWorkloaddetectionCloudFoundry',
    'CloudappWorkloaddetectionDocker',
    'CloudappWorkloaddetectionKubernetes',
    'CloudappWorkloaddetectionKubernetesFilters',
    'CloudappWorkloaddetectionKubernetesFiltersFilter',
    'CloudappWorkloaddetectionKubernetesFiltersFilterInclusionToggles',
    'CloudappWorkloaddetectionKubernetesFiltersFilterMatchFilter',
    'CredentialsCredentialUsageSummary',
    'CredentialsExternal',
    'CustomAnomaliesDimension',
    'CustomAnomaliesDimensionDimension',
    'CustomAnomaliesDimensionEntity',
    'CustomAnomaliesDimensionEntityFilter',
    'CustomAnomaliesDimensionString',
    'CustomAnomaliesDimensionStringFilter',
    'CustomAnomaliesScope',
    'CustomAnomaliesScopeCustomDeviceGroupName',
    'CustomAnomaliesScopeCustomDeviceGroupNameFilter',
    'CustomAnomaliesScopeEntity',
    'CustomAnomaliesScopeHostGroupName',
    'CustomAnomaliesScopeHostGroupNameFilter',
    'CustomAnomaliesScopeHostName',
    'CustomAnomaliesScopeHostNameFilter',
    'CustomAnomaliesScopeManagementZone',
    'CustomAnomaliesScopeName',
    'CustomAnomaliesScopeNameFilter',
    'CustomAnomaliesScopeProcessGroupId',
    'CustomAnomaliesScopeProcessGroupName',
    'CustomAnomaliesScopeProcessGroupNameFilter',
    'CustomAnomaliesScopeScope',
    'CustomAnomaliesScopeTag',
    'CustomAnomaliesScopeTagFilter',
    'CustomAnomaliesStrategy',
    'CustomAnomaliesStrategyAuto',
    'CustomAnomaliesStrategyGeneric',
    'CustomAnomaliesStrategyStatic',
    'CustomAppAnomaliesErrorRateIncrease',
    'CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto',
    'CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed',
    'CustomAppAnomaliesSlowUserActions',
    'CustomAppAnomaliesSlowUserActionsSlowUserActionsAuto',
    'CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting',
    'CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll',
    'CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest',
    'CustomAppAnomaliesSlowUserActionsSlowUserActionsFixed',
    'CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting',
    'CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed',
    'CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest',
    'CustomAppAnomaliesUnexpectedHighLoad',
    'CustomAppAnomaliesUnexpectedLowLoad',
    'CustomAppCrashRateCrashRateIncrease',
    'CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto',
    'CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed',
    'CustomAppEnablementRum',
    'CustomServiceRule',
    'CustomServiceRuleClass',
    'CustomServiceRuleFile',
    'CustomServiceRuleMethod',
    'CustomTagsTags',
    'CustomTagsTagsFilter',
    'DashboardDashboardMetadata',
    'DashboardDashboardMetadataDynamicFilters',
    'DashboardDashboardMetadataDynamicFiltersGenericTagFilters',
    'DashboardDashboardMetadataDynamicFiltersGenericTagFiltersFilter',
    'DashboardDashboardMetadataFilter',
    'DashboardDashboardMetadataFilterManagementZone',
    'DashboardDashboardMetadataSharingDetails',
    'DashboardMetadata',
    'DashboardSharingPermissions',
    'DashboardSharingPermissionsPermission',
    'DashboardSharingPublic',
    'DashboardTile',
    'DashboardTileBounds',
    'DashboardTileFilter',
    'DashboardTileFilterConfig',
    'DashboardTileFilterConfigChartConfig',
    'DashboardTileFilterConfigChartConfigResultMetadata',
    'DashboardTileFilterConfigChartConfigResultMetadataConfig',
    'DashboardTileFilterConfigChartConfigSeries',
    'DashboardTileFilterConfigChartConfigSeriesDimension',
    'DashboardTileFilterConfigFilters',
    'DashboardTileFilterConfigFiltersFilter',
    'DashboardTileFilterConfigFiltersFilterMatch',
    'DashboardTileFilterManagementZone',
    'DashboardTileVisualizationConfig',
    'DashboardsAllowlistAllowlist',
    'DashboardsAllowlistAllowlistUrlpattern',
    'DashboardsGeneralDefaultDashboardList',
    'DashboardsGeneralDefaultDashboardListDefaultDashboard',
    'DashboardsPresetsDashboardPresetsList',
    'DashboardsPresetsDashboardPresetsListDashboardPreset',
    'DataPrivacyDataCollection',
    'DataPrivacyDoNotTrack',
    'DataPrivacyMasking',
    'DataPrivacyUserTracking',
    'DatabaseAnomaliesDbConnectFailures',
    'DatabaseAnomaliesFailureRate',
    'DatabaseAnomaliesFailureRateAuto',
    'DatabaseAnomaliesFailureRateThresholds',
    'DatabaseAnomaliesLoad',
    'DatabaseAnomaliesLoadDrops',
    'DatabaseAnomaliesLoadSpikes',
    'DatabaseAnomaliesResponseTime',
    'DatabaseAnomaliesResponseTimeAuto',
    'DatabaseAnomaliesResponseTimeThresholds',
    'DatabaseAnomaliesV2DatabaseConnections',
    'DatabaseAnomaliesV2FailureRate',
    'DatabaseAnomaliesV2FailureRateAutoDetection',
    'DatabaseAnomaliesV2FailureRateAutoDetectionOverAlertingProtection',
    'DatabaseAnomaliesV2FailureRateFixedDetection',
    'DatabaseAnomaliesV2FailureRateFixedDetectionOverAlertingProtection',
    'DatabaseAnomaliesV2LoadDrops',
    'DatabaseAnomaliesV2LoadSpikes',
    'DatabaseAnomaliesV2ResponseTime',
    'DatabaseAnomaliesV2ResponseTimeAutoDetection',
    'DatabaseAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection',
    'DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll',
    'DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest',
    'DatabaseAnomaliesV2ResponseTimeFixedDetection',
    'DatabaseAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection',
    'DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll',
    'DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest',
    'DduPoolEvents',
    'DduPoolLogMonitoring',
    'DduPoolMetrics',
    'DduPoolServerless',
    'DduPoolTraces',
    'DeclarativeGroupingDetection',
    'DeclarativeGroupingDetectionProcessDefinition',
    'DeclarativeGroupingDetectionProcessDefinitionRules',
    'DeclarativeGroupingDetectionProcessDefinitionRulesRule',
    'DiskAnomaliesDiskName',
    'DiskAnomaliesTags',
    'DiskAnomaliesTagsFilter',
    'DiskAnomaliesV2Disk',
    'DiskAnomaliesV2DiskDiskLowInodesDetection',
    'DiskAnomaliesV2DiskDiskLowInodesDetectionCustomThresholds',
    'DiskAnomaliesV2DiskDiskLowSpaceDetection',
    'DiskAnomaliesV2DiskDiskLowSpaceDetectionCustomThresholds',
    'DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetection',
    'DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionCustomThresholds',
    'DiskAnomalyRulesDiskNameFilter',
    'DiskAnomalyRulesSampleLimit',
    'DiskOptionsExclusions',
    'DiskOptionsExclusionsExclusion',
    'DiskSpecificAnomaliesV2DiskLowInodesDetection',
    'DiskSpecificAnomaliesV2DiskLowInodesDetectionCustomThresholds',
    'DiskSpecificAnomaliesV2DiskLowSpaceDetection',
    'DiskSpecificAnomaliesV2DiskLowSpaceDetectionCustomThresholds',
    'DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetection',
    'DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetectionCustomThresholds',
    'EnvironmentQuotas',
    'EnvironmentQuotasDdus',
    'EnvironmentQuotasDemUnits',
    'EnvironmentQuotasLogs',
    'EnvironmentQuotasSynthetic',
    'EnvironmentQuotasUserSessions',
    'EnvironmentStorage',
    'EnvironmentStorageLimits',
    'EnvironmentStorageRetention',
    'FailureDetectionParametersBrokenLinks',
    'FailureDetectionParametersExceptionRules',
    'FailureDetectionParametersExceptionRulesCustomErrorRules',
    'FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRule',
    'FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRuleCondition',
    'FailureDetectionParametersExceptionRulesCustomHandledExceptions',
    'FailureDetectionParametersExceptionRulesCustomHandledExceptionsCustomHandledException',
    'FailureDetectionParametersExceptionRulesIgnoredExceptions',
    'FailureDetectionParametersExceptionRulesIgnoredExceptionsCustomHandledException',
    'FailureDetectionParametersExceptionRulesSuccessForcingExceptions',
    'FailureDetectionParametersExceptionRulesSuccessForcingExceptionsCustomHandledException',
    'FailureDetectionParametersHttpResponseCodes',
    'FailureDetectionRulesConditions',
    'FailureDetectionRulesConditionsCondition',
    'FailureDetectionRulesConditionsConditionPredicate',
    'GenericRelationshipsSources',
    'GenericRelationshipsSourcesSource',
    'GenericRelationshipsSourcesSourceMappingRules',
    'GenericRelationshipsSourcesSourceMappingRulesMappingRule',
    'GenericTypesRules',
    'GenericTypesRulesRule',
    'GenericTypesRulesRuleAttributes',
    'GenericTypesRulesRuleAttributesAttribute',
    'GenericTypesRulesRuleRequiredDimensions',
    'GenericTypesRulesRuleRequiredDimensionsRequiredDimension',
    'GenericTypesRulesRuleSources',
    'GenericTypesRulesRuleSourcesSource',
    'HostAnomaliesConnections',
    'HostAnomaliesCpu',
    'HostAnomaliesCpuThresholds',
    'HostAnomaliesDisks',
    'HostAnomaliesDisksInodes',
    'HostAnomaliesDisksInodesThresholds',
    'HostAnomaliesDisksSpace',
    'HostAnomaliesDisksSpaceThresholds',
    'HostAnomaliesDisksSpeed',
    'HostAnomaliesDisksSpeedThresholds',
    'HostAnomaliesGc',
    'HostAnomaliesGcThresholds',
    'HostAnomaliesJava',
    'HostAnomaliesJavaOutOfMemory',
    'HostAnomaliesJavaOutOfMemoryThresholds',
    'HostAnomaliesJavaOutOfThreads',
    'HostAnomaliesJavaOutOfThreadsThresholds',
    'HostAnomaliesMemory',
    'HostAnomaliesMemoryThresholds',
    'HostAnomaliesMemoryThresholdsLinux',
    'HostAnomaliesMemoryThresholdsWindows',
    'HostAnomaliesNetwork',
    'HostAnomaliesNetworkConnectivity',
    'HostAnomaliesNetworkConnectivityThresholds',
    'HostAnomaliesNetworkDroppedPackets',
    'HostAnomaliesNetworkDroppedPacketsThresholds',
    'HostAnomaliesNetworkErrors',
    'HostAnomaliesNetworkErrorsThresholds',
    'HostAnomaliesNetworkRetransmission',
    'HostAnomaliesNetworkRetransmissionThresholds',
    'HostAnomaliesNetworkUtilization',
    'HostAnomaliesNetworkUtilizationThresholds',
    'HostAnomaliesV2Host',
    'HostAnomaliesV2HostConnectionLostDetection',
    'HostAnomaliesV2HostHighCpuSaturationDetection',
    'HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholds',
    'HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2HostHighGcActivityDetection',
    'HostAnomaliesV2HostHighGcActivityDetectionCustomThresholds',
    'HostAnomaliesV2HostHighGcActivityDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2HostHighMemoryDetection',
    'HostAnomaliesV2HostHighMemoryDetectionCustomThresholds',
    'HostAnomaliesV2HostHighMemoryDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2HostHighSystemLoadDetection',
    'HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholds',
    'HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2HostOutOfMemoryDetection',
    'HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholds',
    'HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2HostOutOfThreadsDetection',
    'HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholds',
    'HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2Network',
    'HostAnomaliesV2NetworkHighNetworkDetection',
    'HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholds',
    'HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2NetworkNetworkDroppedPacketsDetection',
    'HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholds',
    'HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2NetworkNetworkErrorsDetection',
    'HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholds',
    'HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2NetworkNetworkHighRetransmissionDetection',
    'HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholds',
    'HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholdsEventThresholds',
    'HostAnomaliesV2NetworkNetworkTcpProblemsDetection',
    'HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholds',
    'HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholdsEventThresholds',
    'HostNamingCondition',
    'HostNamingConditionCondition',
    'HostNamingConditionConditionApplicationType',
    'HostNamingConditionConditionApplicationTypeComparison',
    'HostNamingConditionConditionAzureComputeMode',
    'HostNamingConditionConditionAzureComputeModeComparison',
    'HostNamingConditionConditionAzureSkuComparision',
    'HostNamingConditionConditionAzureSkus',
    'HostNamingConditionConditionBaseComparisonBasic',
    'HostNamingConditionConditionBaseConditionKey',
    'HostNamingConditionConditionBitness',
    'HostNamingConditionConditionBitnessComparision',
    'HostNamingConditionConditionCloudType',
    'HostNamingConditionConditionCloudTypeComparison',
    'HostNamingConditionConditionComparison',
    'HostNamingConditionConditionCustomApplicationType',
    'HostNamingConditionConditionCustomApplicationTypeComparison',
    'HostNamingConditionConditionCustomHostMetadata',
    'HostNamingConditionConditionCustomHostMetadataConditionKey',
    'HostNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey',
    'HostNamingConditionConditionCustomHostMetadataDynamicKey',
    'HostNamingConditionConditionCustomProcessMetadata',
    'HostNamingConditionConditionCustomProcessMetadataConditionKey',
    'HostNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey',
    'HostNamingConditionConditionCustomProcessMetadataDynamicKey',
    'HostNamingConditionConditionDatabaseTopology',
    'HostNamingConditionConditionDatabaseTopologyComparison',
    'HostNamingConditionConditionDcrumDecoder',
    'HostNamingConditionConditionDcrumDecoderComparison',
    'HostNamingConditionConditionEntity',
    'HostNamingConditionConditionEntityIdComparison',
    'HostNamingConditionConditionHostTech',
    'HostNamingConditionConditionHostTechValue',
    'HostNamingConditionConditionHypervisor',
    'HostNamingConditionConditionHypervisorTypeComparision',
    'HostNamingConditionConditionIndexedName',
    'HostNamingConditionConditionIndexedNameComparison',
    'HostNamingConditionConditionIndexedString',
    'HostNamingConditionConditionIndexedStringComparison',
    'HostNamingConditionConditionIndexedTag',
    'HostNamingConditionConditionIndexedTagComparison',
    'HostNamingConditionConditionIndexedTagComparisonValue',
    'HostNamingConditionConditionIndexedTagValue',
    'HostNamingConditionConditionInteger',
    'HostNamingConditionConditionIntegerComparison',
    'HostNamingConditionConditionIpaddress',
    'HostNamingConditionConditionIpaddressComparison',
    'HostNamingConditionConditionKey',
    'HostNamingConditionConditionMobilePlatform',
    'HostNamingConditionConditionMobilePlatformComparison',
    'HostNamingConditionConditionOsArch',
    'HostNamingConditionConditionOsType',
    'HostNamingConditionConditionOsarchitectureComparison',
    'HostNamingConditionConditionOstypeComparison',
    'HostNamingConditionConditionPaasType',
    'HostNamingConditionConditionPaasTypeComparison',
    'HostNamingConditionConditionProcessMetadata',
    'HostNamingConditionConditionProcessMetadataConditionKey',
    'HostNamingConditionConditionServiceTopology',
    'HostNamingConditionConditionServiceTopologyComparison',
    'HostNamingConditionConditionServiceType',
    'HostNamingConditionConditionServiceTypeComparison',
    'HostNamingConditionConditionSimpleHostTechComparison',
    'HostNamingConditionConditionSimpleHostTechComparisonValue',
    'HostNamingConditionConditionSimpleTechComparison',
    'HostNamingConditionConditionSimpleTechComparisonValue',
    'HostNamingConditionConditionString',
    'HostNamingConditionConditionStringComparison',
    'HostNamingConditionConditionStringConditionKey',
    'HostNamingConditionConditionStringKey',
    'HostNamingConditionConditionSyntheticEngine',
    'HostNamingConditionConditionSyntheticEngineTypeComparison',
    'HostNamingConditionConditionTag',
    'HostNamingConditionConditionTagComparison',
    'HostNamingConditionConditionTagComparisonValue',
    'HostNamingConditionConditionTagValue',
    'HostNamingConditionConditionTech',
    'HostNamingConditionConditionTechValue',
    'HttpMonitorAnomalyDetection',
    'HttpMonitorAnomalyDetectionLoadingTimeThreshold',
    'HttpMonitorAnomalyDetectionLoadingTimeThresholdThreshold',
    'HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold',
    'HttpMonitorAnomalyDetectionOutageHandling',
    'HttpMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy',
    'HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy',
    'HttpMonitorCookiesCookies',
    'HttpMonitorCookiesCookiesCookie',
    'HttpMonitorPerformanceThresholds',
    'HttpMonitorPerformanceThresholdsThreshold',
    'HttpMonitorScript',
    'HttpMonitorScriptRequest',
    'HttpMonitorScriptRequestAuthentication',
    'HttpMonitorScriptRequestConfiguration',
    'HttpMonitorScriptRequestConfigurationHeaders',
    'HttpMonitorScriptRequestConfigurationHeadersHeader',
    'HttpMonitorScriptRequestValidation',
    'HttpMonitorScriptRequestValidationRule',
    'HttpMonitorTag',
    'HttpMonitorTagTag',
    'IamGroupPermissions',
    'IamGroupPermissionsPermission',
    'ImsBridgesQueueManager',
    'ImsBridgesQueueManagerQueueManager',
    'K8sClusterAnomaliesCpuRequestsSaturation',
    'K8sClusterAnomaliesCpuRequestsSaturationConfiguration',
    'K8sClusterAnomaliesMemoryRequestsSaturation',
    'K8sClusterAnomaliesMemoryRequestsSaturationConfiguration',
    'K8sClusterAnomaliesMonitoringIssues',
    'K8sClusterAnomaliesMonitoringIssuesConfiguration',
    'K8sClusterAnomaliesPodsSaturation',
    'K8sClusterAnomaliesPodsSaturationConfiguration',
    'K8sClusterAnomaliesReadinessIssues',
    'K8sClusterAnomaliesReadinessIssuesConfiguration',
    'K8sCredentialsEventsFieldSelector',
    'K8sNamespaceAnomaliesCpuLimitsQuotaSaturation',
    'K8sNamespaceAnomaliesCpuLimitsQuotaSaturationConfiguration',
    'K8sNamespaceAnomaliesCpuRequestsQuotaSaturation',
    'K8sNamespaceAnomaliesCpuRequestsQuotaSaturationConfiguration',
    'K8sNamespaceAnomaliesMemoryLimitsQuotaSaturation',
    'K8sNamespaceAnomaliesMemoryLimitsQuotaSaturationConfiguration',
    'K8sNamespaceAnomaliesMemoryRequestsQuotaSaturation',
    'K8sNamespaceAnomaliesMemoryRequestsQuotaSaturationConfiguration',
    'K8sNamespaceAnomaliesPodsQuotaSaturation',
    'K8sNamespaceAnomaliesPodsQuotaSaturationConfiguration',
    'K8sNodeAnomaliesCpuRequestsSaturation',
    'K8sNodeAnomaliesCpuRequestsSaturationConfiguration',
    'K8sNodeAnomaliesMemoryRequestsSaturation',
    'K8sNodeAnomaliesMemoryRequestsSaturationConfiguration',
    'K8sNodeAnomaliesNodeProblematicCondition',
    'K8sNodeAnomaliesNodeProblematicConditionConfiguration',
    'K8sNodeAnomaliesPodsSaturation',
    'K8sNodeAnomaliesPodsSaturationConfiguration',
    'K8sNodeAnomaliesReadinessIssues',
    'K8sNodeAnomaliesReadinessIssuesConfiguration',
    'K8sPvcAnomaliesLowDiskSpaceCritical',
    'K8sPvcAnomaliesLowDiskSpaceCriticalConfiguration',
    'K8sPvcAnomaliesLowDiskSpaceCriticalPercentage',
    'K8sPvcAnomaliesLowDiskSpaceCriticalPercentageConfiguration',
    'K8sWorkloadAnomaliesContainerRestarts',
    'K8sWorkloadAnomaliesContainerRestartsConfiguration',
    'K8sWorkloadAnomaliesDeploymentStuck',
    'K8sWorkloadAnomaliesDeploymentStuckConfiguration',
    'K8sWorkloadAnomaliesHighCpuThrottling',
    'K8sWorkloadAnomaliesHighCpuThrottlingConfiguration',
    'K8sWorkloadAnomaliesHighCpuUsage',
    'K8sWorkloadAnomaliesHighCpuUsageConfiguration',
    'K8sWorkloadAnomaliesHighMemoryUsage',
    'K8sWorkloadAnomaliesHighMemoryUsageConfiguration',
    'K8sWorkloadAnomaliesNotAllPodsReady',
    'K8sWorkloadAnomaliesNotAllPodsReadyConfiguration',
    'K8sWorkloadAnomaliesPendingPods',
    'K8sWorkloadAnomaliesPendingPodsConfiguration',
    'K8sWorkloadAnomaliesPodStuckInTerminating',
    'K8sWorkloadAnomaliesPodStuckInTerminatingConfiguration',
    'K8sWorkloadAnomaliesWorkloadWithoutReadyPods',
    'K8sWorkloadAnomaliesWorkloadWithoutReadyPodsConfiguration',
    'KubernetesEventPatterns',
    'KubernetesEventPatternsEventPattern',
    'LogCustomSourceContext',
    'LogCustomSourceContextContext',
    'LogCustomSourceCustomLogSource',
    'LogEventsEventTemplate',
    'LogEventsEventTemplateMetadata',
    'LogEventsEventTemplateMetadataItem',
    'LogProcessingProcessorDefinition',
    'LogProcessingRuleTesting',
    'LogSensitiveDataMaskingMasking',
    'LogSensitiveDataMaskingMatchers',
    'LogSensitiveDataMaskingMatchersMatcher',
    'LogStorageMatchers',
    'LogStorageMatchersMatcher',
    'LogTimestampMatchers',
    'LogTimestampMatchersMatcher',
    'MaintenanceFilter',
    'MaintenanceFilterFilter',
    'MaintenanceGeneralProperties',
    'MaintenanceSchedule',
    'MaintenanceScheduleDailyRecurrence',
    'MaintenanceScheduleDailyRecurrenceRecurrenceRange',
    'MaintenanceScheduleDailyRecurrenceTimeWindow',
    'MaintenanceScheduleMonthlyRecurrence',
    'MaintenanceScheduleMonthlyRecurrenceRecurrenceRange',
    'MaintenanceScheduleMonthlyRecurrenceTimeWindow',
    'MaintenanceScheduleOnceRecurrence',
    'MaintenanceScheduleWeeklyRecurrence',
    'MaintenanceScheduleWeeklyRecurrenceRecurrenceRange',
    'MaintenanceScheduleWeeklyRecurrenceTimeWindow',
    'MaintenanceWindowSchedule',
    'MaintenanceWindowScheduleRecurrence',
    'MaintenanceWindowScope',
    'MaintenanceWindowScopeMatch',
    'MaintenanceWindowScopeMatchTag',
    'ManagementZoneDimensionalRule',
    'ManagementZoneDimensionalRuleCondition',
    'ManagementZoneEntitySelectorBasedRule',
    'ManagementZoneRule',
    'ManagementZoneRuleCondition',
    'ManagementZoneRuleConditionApplicationType',
    'ManagementZoneRuleConditionApplicationTypeComparison',
    'ManagementZoneRuleConditionAzureComputeMode',
    'ManagementZoneRuleConditionAzureComputeModeComparison',
    'ManagementZoneRuleConditionAzureSkuComparision',
    'ManagementZoneRuleConditionAzureSkus',
    'ManagementZoneRuleConditionBaseComparisonBasic',
    'ManagementZoneRuleConditionBaseConditionKey',
    'ManagementZoneRuleConditionBitness',
    'ManagementZoneRuleConditionBitnessComparision',
    'ManagementZoneRuleConditionCloudType',
    'ManagementZoneRuleConditionCloudTypeComparison',
    'ManagementZoneRuleConditionComparison',
    'ManagementZoneRuleConditionCustomApplicationType',
    'ManagementZoneRuleConditionCustomApplicationTypeComparison',
    'ManagementZoneRuleConditionCustomHostMetadata',
    'ManagementZoneRuleConditionCustomHostMetadataConditionKey',
    'ManagementZoneRuleConditionCustomHostMetadataConditionKeyDynamicKey',
    'ManagementZoneRuleConditionCustomHostMetadataDynamicKey',
    'ManagementZoneRuleConditionCustomProcessMetadata',
    'ManagementZoneRuleConditionCustomProcessMetadataConditionKey',
    'ManagementZoneRuleConditionCustomProcessMetadataConditionKeyDynamicKey',
    'ManagementZoneRuleConditionCustomProcessMetadataDynamicKey',
    'ManagementZoneRuleConditionDatabaseTopology',
    'ManagementZoneRuleConditionDatabaseTopologyComparison',
    'ManagementZoneRuleConditionDcrumDecoder',
    'ManagementZoneRuleConditionDcrumDecoderComparison',
    'ManagementZoneRuleConditionEntity',
    'ManagementZoneRuleConditionEntityIdComparison',
    'ManagementZoneRuleConditionHostTech',
    'ManagementZoneRuleConditionHostTechValue',
    'ManagementZoneRuleConditionHypervisor',
    'ManagementZoneRuleConditionHypervisorTypeComparision',
    'ManagementZoneRuleConditionIndexedName',
    'ManagementZoneRuleConditionIndexedNameComparison',
    'ManagementZoneRuleConditionIndexedString',
    'ManagementZoneRuleConditionIndexedStringComparison',
    'ManagementZoneRuleConditionIndexedTag',
    'ManagementZoneRuleConditionIndexedTagComparison',
    'ManagementZoneRuleConditionIndexedTagComparisonValue',
    'ManagementZoneRuleConditionIndexedTagValue',
    'ManagementZoneRuleConditionInteger',
    'ManagementZoneRuleConditionIntegerComparison',
    'ManagementZoneRuleConditionIpaddress',
    'ManagementZoneRuleConditionIpaddressComparison',
    'ManagementZoneRuleConditionKey',
    'ManagementZoneRuleConditionMobilePlatform',
    'ManagementZoneRuleConditionMobilePlatformComparison',
    'ManagementZoneRuleConditionOsArch',
    'ManagementZoneRuleConditionOsType',
    'ManagementZoneRuleConditionOsarchitectureComparison',
    'ManagementZoneRuleConditionOstypeComparison',
    'ManagementZoneRuleConditionPaasType',
    'ManagementZoneRuleConditionPaasTypeComparison',
    'ManagementZoneRuleConditionProcessMetadata',
    'ManagementZoneRuleConditionProcessMetadataConditionKey',
    'ManagementZoneRuleConditionServiceTopology',
    'ManagementZoneRuleConditionServiceTopologyComparison',
    'ManagementZoneRuleConditionServiceType',
    'ManagementZoneRuleConditionServiceTypeComparison',
    'ManagementZoneRuleConditionSimpleHostTechComparison',
    'ManagementZoneRuleConditionSimpleHostTechComparisonValue',
    'ManagementZoneRuleConditionSimpleTechComparison',
    'ManagementZoneRuleConditionSimpleTechComparisonValue',
    'ManagementZoneRuleConditionString',
    'ManagementZoneRuleConditionStringComparison',
    'ManagementZoneRuleConditionStringConditionKey',
    'ManagementZoneRuleConditionStringKey',
    'ManagementZoneRuleConditionSyntheticEngine',
    'ManagementZoneRuleConditionSyntheticEngineTypeComparison',
    'ManagementZoneRuleConditionTag',
    'ManagementZoneRuleConditionTagComparison',
    'ManagementZoneRuleConditionTagComparisonValue',
    'ManagementZoneRuleConditionTagValue',
    'ManagementZoneRuleConditionTech',
    'ManagementZoneRuleConditionTechValue',
    'ManagementZoneV2Rules',
    'ManagementZoneV2RulesRule',
    'ManagementZoneV2RulesRuleAttributeRule',
    'ManagementZoneV2RulesRuleAttributeRuleAttributeConditions',
    'ManagementZoneV2RulesRuleAttributeRuleAttributeConditionsCondition',
    'ManagementZoneV2RulesRuleDimensionRule',
    'ManagementZoneV2RulesRuleDimensionRuleDimensionConditions',
    'ManagementZoneV2RulesRuleDimensionRuleDimensionConditionsCondition',
    'MetricEventsEventTemplate',
    'MetricEventsEventTemplateMetadata',
    'MetricEventsModelProperties',
    'MetricEventsQueryDefinition',
    'MetricEventsQueryDefinitionDimensionFilter',
    'MetricEventsQueryDefinitionDimensionFilterFilter',
    'MetricEventsQueryDefinitionEntityFilter',
    'MetricEventsQueryDefinitionEntityFilterCondition',
    'MetricEventsQueryDefinitionEntityFilterConditionCondition',
    'MetricMetadataDimensions',
    'MetricMetadataDimensionsDimension',
    'MetricMetadataMetricProperties',
    'MobileAppAnomaliesErrorRateIncrease',
    'MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto',
    'MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed',
    'MobileAppAnomaliesSlowUserActions',
    'MobileAppAnomaliesSlowUserActionsSlowUserActionsAuto',
    'MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting',
    'MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll',
    'MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest',
    'MobileAppAnomaliesSlowUserActionsSlowUserActionsFixed',
    'MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting',
    'MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed',
    'MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest',
    'MobileAppAnomaliesUnexpectedHighLoad',
    'MobileAppAnomaliesUnexpectedLowLoad',
    'MobileAppCrashRateCrashRateIncrease',
    'MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto',
    'MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed',
    'MobileAppEnablementRum',
    'MobileAppEnablementSessionReplay',
    'MobileAppRequestErrorsErrorRules',
    'MobileAppRequestErrorsErrorRulesErrorRule',
    'MobileApplicationApdex',
    'MobileApplicationProperties',
    'MobileApplicationPropertiesApiValue',
    'MobileApplicationPropertiesRequestAttribute',
    'NetworkTrafficExcludeIp',
    'NetworkTrafficExcludeIpIpAddressForm',
    'NetworkTrafficExcludeNic',
    'NetworkTrafficExcludeNicNicForm',
    'NotificationAnsibleTower',
    'NotificationConfig',
    'NotificationEmail',
    'NotificationJira',
    'NotificationOpsGenie',
    'NotificationPagerDuty',
    'NotificationServiceNow',
    'NotificationSlack',
    'NotificationTrello',
    'NotificationVictorOps',
    'NotificationWebHook',
    'NotificationWebHookHeader',
    'NotificationXmatters',
    'NotificationXmattersHeader',
    'OneagentUpdatesMaintenanceWindows',
    'OneagentUpdatesMaintenanceWindowsMaintenanceWindow',
    'OpentelemetryMetricsAdditionalAttributes',
    'OpentelemetryMetricsAdditionalAttributesAdditionalAttribute',
    'OpentelemetryMetricsToDropAttributes',
    'OpentelemetryMetricsToDropAttributesToDropAttribute',
    'OsServicesDetectionConditionsLinux',
    'OsServicesDetectionConditionsLinuxLinuxDetectionCondition',
    'OsServicesDetectionConditionsWindows',
    'OsServicesDetectionConditionsWindowsDetectionConditionsWindow',
    'OsServicesMetadata',
    'OsServicesMetadataItem',
    'OwnershipConfigOwnershipIdentifiers',
    'OwnershipConfigOwnershipIdentifiersOwnershipIdentifier',
    'OwnershipTeamsAdditionalInformation',
    'OwnershipTeamsAdditionalInformationAdditionalInformation',
    'OwnershipTeamsContactDetails',
    'OwnershipTeamsContactDetailsContactDetail',
    'OwnershipTeamsContactDetailsContactDetailJira',
    'OwnershipTeamsLinks',
    'OwnershipTeamsLinksLink',
    'OwnershipTeamsResponsibilities',
    'OwnershipTeamsSupplementaryIdentifiers',
    'OwnershipTeamsSupplementaryIdentifiersSupplementaryIdentifier',
    'PgAnomaliesAvailability',
    'ProcessAvailabilityMetadata',
    'ProcessAvailabilityMetadataItem',
    'ProcessAvailabilityRules',
    'ProcessAvailabilityRulesRule',
    'ProcessGroupDetectionGroupExtraction',
    'ProcessGroupDetectionGroupExtractionDelimiter',
    'ProcessGroupDetectionInstanceExtraction',
    'ProcessGroupDetectionInstanceExtractionDelimiter',
    'ProcessGroupDetectionProcessDetection',
    'ProcessMonitoringRuleCondition',
    'ProcessgroupNamingCondition',
    'ProcessgroupNamingConditionCondition',
    'ProcessgroupNamingConditionConditionApplicationType',
    'ProcessgroupNamingConditionConditionApplicationTypeComparison',
    'ProcessgroupNamingConditionConditionAzureComputeMode',
    'ProcessgroupNamingConditionConditionAzureComputeModeComparison',
    'ProcessgroupNamingConditionConditionAzureSkuComparision',
    'ProcessgroupNamingConditionConditionAzureSkus',
    'ProcessgroupNamingConditionConditionBaseComparisonBasic',
    'ProcessgroupNamingConditionConditionBaseConditionKey',
    'ProcessgroupNamingConditionConditionBitness',
    'ProcessgroupNamingConditionConditionBitnessComparision',
    'ProcessgroupNamingConditionConditionCloudType',
    'ProcessgroupNamingConditionConditionCloudTypeComparison',
    'ProcessgroupNamingConditionConditionComparison',
    'ProcessgroupNamingConditionConditionCustomApplicationType',
    'ProcessgroupNamingConditionConditionCustomApplicationTypeComparison',
    'ProcessgroupNamingConditionConditionCustomHostMetadata',
    'ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey',
    'ProcessgroupNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey',
    'ProcessgroupNamingConditionConditionCustomHostMetadataDynamicKey',
    'ProcessgroupNamingConditionConditionCustomProcessMetadata',
    'ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey',
    'ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey',
    'ProcessgroupNamingConditionConditionCustomProcessMetadataDynamicKey',
    'ProcessgroupNamingConditionConditionDatabaseTopology',
    'ProcessgroupNamingConditionConditionDatabaseTopologyComparison',
    'ProcessgroupNamingConditionConditionDcrumDecoder',
    'ProcessgroupNamingConditionConditionDcrumDecoderComparison',
    'ProcessgroupNamingConditionConditionEntity',
    'ProcessgroupNamingConditionConditionEntityIdComparison',
    'ProcessgroupNamingConditionConditionHostTech',
    'ProcessgroupNamingConditionConditionHostTechValue',
    'ProcessgroupNamingConditionConditionHypervisor',
    'ProcessgroupNamingConditionConditionHypervisorTypeComparision',
    'ProcessgroupNamingConditionConditionIndexedName',
    'ProcessgroupNamingConditionConditionIndexedNameComparison',
    'ProcessgroupNamingConditionConditionIndexedString',
    'ProcessgroupNamingConditionConditionIndexedStringComparison',
    'ProcessgroupNamingConditionConditionIndexedTag',
    'ProcessgroupNamingConditionConditionIndexedTagComparison',
    'ProcessgroupNamingConditionConditionIndexedTagComparisonValue',
    'ProcessgroupNamingConditionConditionIndexedTagValue',
    'ProcessgroupNamingConditionConditionInteger',
    'ProcessgroupNamingConditionConditionIntegerComparison',
    'ProcessgroupNamingConditionConditionIpaddress',
    'ProcessgroupNamingConditionConditionIpaddressComparison',
    'ProcessgroupNamingConditionConditionKey',
    'ProcessgroupNamingConditionConditionMobilePlatform',
    'ProcessgroupNamingConditionConditionMobilePlatformComparison',
    'ProcessgroupNamingConditionConditionOsArch',
    'ProcessgroupNamingConditionConditionOsType',
    'ProcessgroupNamingConditionConditionOsarchitectureComparison',
    'ProcessgroupNamingConditionConditionOstypeComparison',
    'ProcessgroupNamingConditionConditionPaasType',
    'ProcessgroupNamingConditionConditionPaasTypeComparison',
    'ProcessgroupNamingConditionConditionProcessMetadata',
    'ProcessgroupNamingConditionConditionProcessMetadataConditionKey',
    'ProcessgroupNamingConditionConditionServiceTopology',
    'ProcessgroupNamingConditionConditionServiceTopologyComparison',
    'ProcessgroupNamingConditionConditionServiceType',
    'ProcessgroupNamingConditionConditionServiceTypeComparison',
    'ProcessgroupNamingConditionConditionSimpleHostTechComparison',
    'ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue',
    'ProcessgroupNamingConditionConditionSimpleTechComparison',
    'ProcessgroupNamingConditionConditionSimpleTechComparisonValue',
    'ProcessgroupNamingConditionConditionString',
    'ProcessgroupNamingConditionConditionStringComparison',
    'ProcessgroupNamingConditionConditionStringConditionKey',
    'ProcessgroupNamingConditionConditionStringKey',
    'ProcessgroupNamingConditionConditionSyntheticEngine',
    'ProcessgroupNamingConditionConditionSyntheticEngineTypeComparison',
    'ProcessgroupNamingConditionConditionTag',
    'ProcessgroupNamingConditionConditionTagComparison',
    'ProcessgroupNamingConditionConditionTagComparisonValue',
    'ProcessgroupNamingConditionConditionTagValue',
    'ProcessgroupNamingConditionConditionTech',
    'ProcessgroupNamingConditionConditionTechValue',
    'QueueManagerAliasQueue',
    'QueueManagerAliasQueueAliasQueue',
    'QueueManagerClusterQueue',
    'QueueManagerClusterQueueClusterQueue',
    'QueueManagerRemoteQueue',
    'QueueManagerRemoteQueueRemoteQueue',
    'RequestAttributeDataSource',
    'RequestAttributeDataSourceCicsSdkMethodNodeCondition',
    'RequestAttributeDataSourceIibLabelMethodNodeCondition',
    'RequestAttributeDataSourceIibMethodNodeCondition',
    'RequestAttributeDataSourceMethod',
    'RequestAttributeDataSourceMethodMethod',
    'RequestAttributeDataSourceScope',
    'RequestAttributeDataSourceValueProcessing',
    'RequestAttributeDataSourceValueProcessingExtractSubstring',
    'RequestAttributeDataSourceValueProcessingValueCondition',
    'RequestNamingConditions',
    'RequestNamingConditionsCondition',
    'RequestNamingConditionsConditionComparison',
    'RequestNamingConditionsConditionComparisonBoolean',
    'RequestNamingConditionsConditionComparisonEsbInputNodeType',
    'RequestNamingConditionsConditionComparisonFailedState',
    'RequestNamingConditionsConditionComparisonFailureReason',
    'RequestNamingConditionsConditionComparisonFastString',
    'RequestNamingConditionsConditionComparisonFlawState',
    'RequestNamingConditionsConditionComparisonGeneric',
    'RequestNamingConditionsConditionComparisonHttpMethod',
    'RequestNamingConditionsConditionComparisonHttpStatusClass',
    'RequestNamingConditionsConditionComparisonIibInputNodeType',
    'RequestNamingConditionsConditionComparisonNumber',
    'RequestNamingConditionsConditionComparisonNumberRequestAttribute',
    'RequestNamingConditionsConditionComparisonNumberRequestAttributeSource',
    'RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag',
    'RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey',
    'RequestNamingConditionsConditionComparisonServiceType',
    'RequestNamingConditionsConditionComparisonString',
    'RequestNamingConditionsConditionComparisonStringRequestAttribute',
    'RequestNamingConditionsConditionComparisonStringRequestAttributeSource',
    'RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag',
    'RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey',
    'RequestNamingConditionsConditionComparisonTag',
    'RequestNamingConditionsConditionComparisonTagValue',
    'RequestNamingConditionsConditionComparisonTagValues',
    'RequestNamingConditionsConditionComparisonTagValuesValue',
    'RequestNamingConditionsConditionComparisonZosCallType',
    'RequestNamingPlaceholders',
    'RequestNamingPlaceholdersPlaceholder',
    'RequestNamingPlaceholdersPlaceholderSource',
    'RequestNamingPlaceholdersPlaceholderSourceServiceTag',
    'RequestNamingPlaceholdersPlaceholderSourceServiceTagTagKey',
    'ResourceAttributesKeys',
    'ResourceAttributesKeysRule',
    'RumProviderBreakdownDomainNamePatternList',
    'RumProviderBreakdownDomainNamePatternListDomainNamePattern',
    'ServiceAnomaliesFailureRates',
    'ServiceAnomaliesFailureRatesAuto',
    'ServiceAnomaliesFailureRatesThresholds',
    'ServiceAnomaliesLoad',
    'ServiceAnomaliesLoadDrops',
    'ServiceAnomaliesLoadSpikes',
    'ServiceAnomaliesResponseTimes',
    'ServiceAnomaliesResponseTimesAuto',
    'ServiceAnomaliesResponseTimesThresholds',
    'ServiceAnomaliesV2FailureRate',
    'ServiceAnomaliesV2FailureRateAutoDetection',
    'ServiceAnomaliesV2FailureRateAutoDetectionOverAlertingProtection',
    'ServiceAnomaliesV2FailureRateFixedDetection',
    'ServiceAnomaliesV2FailureRateFixedDetectionOverAlertingProtection',
    'ServiceAnomaliesV2LoadDrops',
    'ServiceAnomaliesV2LoadSpikes',
    'ServiceAnomaliesV2ResponseTime',
    'ServiceAnomaliesV2ResponseTimeAutoDetection',
    'ServiceAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection',
    'ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll',
    'ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest',
    'ServiceAnomaliesV2ResponseTimeFixedDetection',
    'ServiceAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection',
    'ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll',
    'ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest',
    'ServiceExternalWebRequestConditions',
    'ServiceExternalWebRequestConditionsCondition',
    'ServiceExternalWebRequestIdContributors',
    'ServiceExternalWebRequestIdContributorsApplicationId',
    'ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributor',
    'ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformations',
    'ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation',
    'ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride',
    'ServiceExternalWebRequestIdContributorsContextRoot',
    'ServiceExternalWebRequestIdContributorsContextRootServiceIdContributor',
    'ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformations',
    'ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation',
    'ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorValueOverride',
    'ServiceExternalWebRequestIdContributorsPublicDomainName',
    'ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributor',
    'ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformations',
    'ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformationsTransformation',
    'ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorValueOverride',
    'ServiceExternalWebServiceConditions',
    'ServiceExternalWebServiceConditionsCondition',
    'ServiceExternalWebServiceIdContributors',
    'ServiceExternalWebServiceIdContributorsUrlPath',
    'ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributor',
    'ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformations',
    'ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformationsTransformation',
    'ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorValueOverride',
    'ServiceFailureExceptionRules',
    'ServiceFailureExceptionRulesCustomErrorRules',
    'ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRule',
    'ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRuleCondition',
    'ServiceFailureExceptionRulesCustomHandledExceptions',
    'ServiceFailureExceptionRulesCustomHandledExceptionsCustomHandledException',
    'ServiceFailureExceptionRulesIgnoredExceptions',
    'ServiceFailureExceptionRulesIgnoredExceptionsCustomHandledException',
    'ServiceFailureExceptionRulesSuccessForcingExceptions',
    'ServiceFailureExceptionRulesSuccessForcingExceptionsCustomHandledException',
    'ServiceFullWebRequestConditions',
    'ServiceFullWebRequestConditionsCondition',
    'ServiceFullWebRequestIdContributors',
    'ServiceFullWebRequestIdContributorsApplicationId',
    'ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributor',
    'ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformations',
    'ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation',
    'ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride',
    'ServiceFullWebRequestIdContributorsContextRoot',
    'ServiceFullWebRequestIdContributorsContextRootServiceIdContributor',
    'ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformations',
    'ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation',
    'ServiceFullWebRequestIdContributorsContextRootServiceIdContributorValueOverride',
    'ServiceFullWebRequestIdContributorsServerName',
    'ServiceFullWebRequestIdContributorsServerNameServiceIdContributor',
    'ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformations',
    'ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformationsTransformation',
    'ServiceFullWebRequestIdContributorsServerNameServiceIdContributorValueOverride',
    'ServiceFullWebServiceConditions',
    'ServiceFullWebServiceConditionsCondition',
    'ServiceFullWebServiceIdContributors',
    'ServiceFullWebServiceIdContributorsApplicationId',
    'ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributor',
    'ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformations',
    'ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformationsTransformation',
    'ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorValueOverride',
    'ServiceFullWebServiceIdContributorsContextRoot',
    'ServiceFullWebServiceIdContributorsContextRootServiceIdContributor',
    'ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformations',
    'ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformationsTransformation',
    'ServiceFullWebServiceIdContributorsContextRootServiceIdContributorValueOverride',
    'ServiceFullWebServiceIdContributorsServerName',
    'ServiceFullWebServiceIdContributorsServerNameServiceIdContributor',
    'ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformations',
    'ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformationsTransformation',
    'ServiceFullWebServiceIdContributorsServerNameServiceIdContributorValueOverride',
    'ServiceFullWebServiceIdContributorsWebServiceName',
    'ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributor',
    'ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformations',
    'ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformationsTransformation',
    'ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorValueOverride',
    'ServiceFullWebServiceIdContributorsWebServiceNamespace',
    'ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributor',
    'ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformations',
    'ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformationsTransformation',
    'ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorValueOverride',
    'ServiceHttpFailureBrokenLinks',
    'ServiceHttpFailureHttpResponseCodes',
    'ServiceNamingCondition',
    'ServiceNamingConditionCondition',
    'ServiceNamingConditionConditionApplicationType',
    'ServiceNamingConditionConditionApplicationTypeComparison',
    'ServiceNamingConditionConditionAzureComputeMode',
    'ServiceNamingConditionConditionAzureComputeModeComparison',
    'ServiceNamingConditionConditionAzureSkuComparision',
    'ServiceNamingConditionConditionAzureSkus',
    'ServiceNamingConditionConditionBaseComparisonBasic',
    'ServiceNamingConditionConditionBaseConditionKey',
    'ServiceNamingConditionConditionBitness',
    'ServiceNamingConditionConditionBitnessComparision',
    'ServiceNamingConditionConditionCloudType',
    'ServiceNamingConditionConditionCloudTypeComparison',
    'ServiceNamingConditionConditionComparison',
    'ServiceNamingConditionConditionCustomApplicationType',
    'ServiceNamingConditionConditionCustomApplicationTypeComparison',
    'ServiceNamingConditionConditionCustomHostMetadata',
    'ServiceNamingConditionConditionCustomHostMetadataConditionKey',
    'ServiceNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey',
    'ServiceNamingConditionConditionCustomHostMetadataDynamicKey',
    'ServiceNamingConditionConditionCustomProcessMetadata',
    'ServiceNamingConditionConditionCustomProcessMetadataConditionKey',
    'ServiceNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey',
    'ServiceNamingConditionConditionCustomProcessMetadataDynamicKey',
    'ServiceNamingConditionConditionDatabaseTopology',
    'ServiceNamingConditionConditionDatabaseTopologyComparison',
    'ServiceNamingConditionConditionDcrumDecoder',
    'ServiceNamingConditionConditionDcrumDecoderComparison',
    'ServiceNamingConditionConditionEntity',
    'ServiceNamingConditionConditionEntityIdComparison',
    'ServiceNamingConditionConditionHostTech',
    'ServiceNamingConditionConditionHostTechValue',
    'ServiceNamingConditionConditionHypervisor',
    'ServiceNamingConditionConditionHypervisorTypeComparision',
    'ServiceNamingConditionConditionIndexedName',
    'ServiceNamingConditionConditionIndexedNameComparison',
    'ServiceNamingConditionConditionIndexedString',
    'ServiceNamingConditionConditionIndexedStringComparison',
    'ServiceNamingConditionConditionIndexedTag',
    'ServiceNamingConditionConditionIndexedTagComparison',
    'ServiceNamingConditionConditionIndexedTagComparisonValue',
    'ServiceNamingConditionConditionIndexedTagValue',
    'ServiceNamingConditionConditionInteger',
    'ServiceNamingConditionConditionIntegerComparison',
    'ServiceNamingConditionConditionIpaddress',
    'ServiceNamingConditionConditionIpaddressComparison',
    'ServiceNamingConditionConditionKey',
    'ServiceNamingConditionConditionMobilePlatform',
    'ServiceNamingConditionConditionMobilePlatformComparison',
    'ServiceNamingConditionConditionOsArch',
    'ServiceNamingConditionConditionOsType',
    'ServiceNamingConditionConditionOsarchitectureComparison',
    'ServiceNamingConditionConditionOstypeComparison',
    'ServiceNamingConditionConditionPaasType',
    'ServiceNamingConditionConditionPaasTypeComparison',
    'ServiceNamingConditionConditionProcessMetadata',
    'ServiceNamingConditionConditionProcessMetadataConditionKey',
    'ServiceNamingConditionConditionServiceTopology',
    'ServiceNamingConditionConditionServiceTopologyComparison',
    'ServiceNamingConditionConditionServiceType',
    'ServiceNamingConditionConditionServiceTypeComparison',
    'ServiceNamingConditionConditionSimpleHostTechComparison',
    'ServiceNamingConditionConditionSimpleHostTechComparisonValue',
    'ServiceNamingConditionConditionSimpleTechComparison',
    'ServiceNamingConditionConditionSimpleTechComparisonValue',
    'ServiceNamingConditionConditionString',
    'ServiceNamingConditionConditionStringComparison',
    'ServiceNamingConditionConditionStringConditionKey',
    'ServiceNamingConditionConditionStringKey',
    'ServiceNamingConditionConditionSyntheticEngine',
    'ServiceNamingConditionConditionSyntheticEngineTypeComparison',
    'ServiceNamingConditionConditionTag',
    'ServiceNamingConditionConditionTagComparison',
    'ServiceNamingConditionConditionTagComparisonValue',
    'ServiceNamingConditionConditionTagValue',
    'ServiceNamingConditionConditionTech',
    'ServiceNamingConditionConditionTechValue',
    'SessionReplayWebPrivacyMaskingPresets',
    'SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRules',
    'SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRulesAllowListRule',
    'SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRules',
    'SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRulesBlockListRule',
    'SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRules',
    'SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRulesAllowListRule',
    'SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRules',
    'SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRulesBlockListRule',
    'SloV2ErrorBudgetBurnRate',
    'SpanCaptureRuleMatches',
    'SpanCaptureRuleMatchesMatch',
    'SpanContextPropagationMatches',
    'SpanContextPropagationMatchesMatch',
    'SpanEntryPointMatches',
    'SpanEntryPointMatchesMatch',
    'UpdateWindowsDailyRecurrence',
    'UpdateWindowsDailyRecurrenceRecurrenceRange',
    'UpdateWindowsDailyRecurrenceUpdateTime',
    'UpdateWindowsMonthlyRecurrence',
    'UpdateWindowsMonthlyRecurrenceRecurrenceRange',
    'UpdateWindowsMonthlyRecurrenceUpdateTime',
    'UpdateWindowsOnceRecurrence',
    'UpdateWindowsOnceRecurrenceRecurrenceRange',
    'UpdateWindowsWeeklyRecurrence',
    'UpdateWindowsWeeklyRecurrenceRecurrenceRange',
    'UpdateWindowsWeeklyRecurrenceSelectedWeekDays',
    'UpdateWindowsWeeklyRecurrenceUpdateTime',
    'UserActionMetricsFilters',
    'UserActionMetricsFiltersFilter',
    'UserActionMetricsValue',
    'UserGroupPermissions',
    'UserGroupPermissionsGrant',
    'UserSessionMetricsFilters',
    'UserSessionMetricsFiltersFilter',
    'UserSessionMetricsValue',
    'VmwareAnomaliesDroppedPacketsDetection',
    'VmwareAnomaliesDroppedPacketsDetectionCustomThresholds',
    'VmwareAnomaliesEsxiHighCpuDetection',
    'VmwareAnomaliesEsxiHighCpuDetectionCustomThresholds',
    'VmwareAnomaliesEsxiHighMemoryDetection',
    'VmwareAnomaliesEsxiHighMemoryDetectionCustomThresholds',
    'VmwareAnomaliesGuestCpuLimitDetection',
    'VmwareAnomaliesGuestCpuLimitDetectionCustomThresholds',
    'VmwareAnomaliesLowDatastoreSpaceDetection',
    'VmwareAnomaliesLowDatastoreSpaceDetectionCustomThresholds',
    'VmwareAnomaliesOverloadedStorageDetection',
    'VmwareAnomaliesOverloadedStorageDetectionCustomThresholds',
    'VmwareAnomaliesSlowPhysicalStorageDetection',
    'VmwareAnomaliesSlowPhysicalStorageDetectionCustomThresholds',
    'VmwareAnomaliesUndersizedStorageDetection',
    'VmwareAnomaliesUndersizedStorageDetectionCustomThresholds',
    'WebAppAnomaliesErrorRate',
    'WebAppAnomaliesErrorRateErrorRateAuto',
    'WebAppAnomaliesErrorRateErrorRateAutoOverAlertingProtection',
    'WebAppAnomaliesErrorRateErrorRateFixed',
    'WebAppAnomaliesResponseTime',
    'WebAppAnomaliesResponseTimeResponseTimeAuto',
    'WebAppAnomaliesResponseTimeResponseTimeAutoOverAlertingProtection',
    'WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeAll',
    'WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeSlowest',
    'WebAppAnomaliesResponseTimeResponseTimeFixed',
    'WebAppAnomaliesResponseTimeResponseTimeFixedOverAlertingProtection',
    'WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeAll',
    'WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeSlowest',
    'WebAppAnomaliesTrafficDrops',
    'WebAppAnomaliesTrafficDropsTrafficDrops',
    'WebAppAnomaliesTrafficSpikes',
    'WebAppAnomaliesTrafficSpikesTrafficSpikes',
    'WebAppCustomErrorsErrorRules',
    'WebAppCustomErrorsErrorRulesErrorRule',
    'WebAppCustomErrorsErrorRulesErrorRuleCaptureSettings',
    'WebAppEnablementRum',
    'WebAppEnablementSessionReplay',
    'WebAppRequestErrorsErrorRules',
    'WebAppRequestErrorsErrorRulesErrorRule',
    'WebAppRequestErrorsErrorRulesErrorRuleCaptureSettings',
    'WebAppRequestErrorsErrorRulesErrorRuleFilterSettings',
    'WebApplicationConversionGoals',
    'WebApplicationConversionGoalsGoal',
    'WebApplicationConversionGoalsGoalDestination',
    'WebApplicationConversionGoalsGoalUserAction',
    'WebApplicationConversionGoalsGoalVisitDuration',
    'WebApplicationConversionGoalsGoalVisitNumAction',
    'WebApplicationCustomActionApdexSettings',
    'WebApplicationKeyUserAction',
    'WebApplicationKeyUserActionAction',
    'WebApplicationLoadActionApdexSettings',
    'WebApplicationMetaDataCaptureSettings',
    'WebApplicationMetaDataCaptureSettingsCapture',
    'WebApplicationMonitoringSettings',
    'WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings',
    'WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers',
    'WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings',
    'WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings',
    'WebApplicationMonitoringSettingsBrowserRestrictionSettings',
    'WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictions',
    'WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction',
    'WebApplicationMonitoringSettingsContentCapture',
    'WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings',
    'WebApplicationMonitoringSettingsContentCaptureTimeoutSettings',
    'WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings',
    'WebApplicationMonitoringSettingsIpAddressRestrictionSettings',
    'WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictions',
    'WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange',
    'WebApplicationMonitoringSettingsJavascriptFrameworkSupport',
    'WebApplicationMonitoringSettingsJavascriptInjectionRules',
    'WebApplicationMonitoringSettingsJavascriptInjectionRulesRule',
    'WebApplicationSessionReplayConfig',
    'WebApplicationUserActionAndSessionProperties',
    'WebApplicationUserActionAndSessionPropertiesProperty',
    'WebApplicationUserActionNamingSettings',
    'WebApplicationUserActionNamingSettingsCustomActionNamingRules',
    'WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule',
    'WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditions',
    'WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCondition',
    'WebApplicationUserActionNamingSettingsLoadActionNamingRules',
    'WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule',
    'WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditions',
    'WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCondition',
    'WebApplicationUserActionNamingSettingsPlaceholders',
    'WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder',
    'WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps',
    'WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep',
    'WebApplicationUserActionNamingSettingsXhrActionNamingRules',
    'WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule',
    'WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditions',
    'WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCondition',
    'WebApplicationUserTags',
    'WebApplicationUserTagsTag',
    'WebApplicationWaterfallSettings',
    'WebApplicationXhrActionApdexSettings',
    'WebhookNotificationHeaders',
    'WebhookNotificationHeadersHeader',
    'XmattersNotificationHeaders',
    'XmattersNotificationHeadersHeader',
    'GetAlertingProfilesValueResult',
    'GetEntitiesEntitiesResult',
    'GetEntitiesEntitiesEntityResult',
    'GetEntitiesEntitiesEntityTagResult',
    'GetEntitiesEntitiesEntityTagTagResult',
    'GetManagementZonesValueResult',
    'GetSyntheticLocationsLocationsResult',
]

@pulumi.output_type
class AlertingFilters(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.AlertingFiltersFilter']] = None):
        """
        :param Sequence['AlertingFiltersFilterArgs'] filters: A conditions for the metric usage
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.AlertingFiltersFilter']]:
        """
        A conditions for the metric usage
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class AlertingFiltersFilter(dict):
    def __init__(__self__, *,
                 custom: Optional['outputs.AlertingFiltersFilterCustom'] = None,
                 predefined: Optional['outputs.AlertingFiltersFilterPredefined'] = None):
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if predefined is not None:
            pulumi.set(__self__, "predefined", predefined)

    @property
    @pulumi.getter
    def custom(self) -> Optional['outputs.AlertingFiltersFilterCustom']:
        return pulumi.get(self, "custom")

    @property
    @pulumi.getter
    def predefined(self) -> Optional['outputs.AlertingFiltersFilterPredefined']:
        return pulumi.get(self, "predefined")


@pulumi.output_type
class AlertingFiltersFilterCustom(dict):
    def __init__(__self__, *,
                 description: Optional['outputs.AlertingFiltersFilterCustomDescription'] = None,
                 metadata: Optional['outputs.AlertingFiltersFilterCustomMetadata'] = None,
                 title: Optional['outputs.AlertingFiltersFilterCustomTitle'] = None):
        if description is not None:
            pulumi.set(__self__, "description", description)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> Optional['outputs.AlertingFiltersFilterCustomDescription']:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.AlertingFiltersFilterCustomMetadata']:
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AlertingFiltersFilterCustomTitle']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AlertingFiltersFilterCustomDescription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingFiltersFilterCustomDescription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingFiltersFilterCustomDescription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingFiltersFilterCustomDescription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 case_sensitive: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 negate: Optional[bool] = None):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")


@pulumi.output_type
class AlertingFiltersFilterCustomMetadata(dict):
    def __init__(__self__, *,
                 items: 'outputs.AlertingFiltersFilterCustomMetadataItems'):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> 'outputs.AlertingFiltersFilterCustomMetadataItems':
        return pulumi.get(self, "items")


@pulumi.output_type
class AlertingFiltersFilterCustomMetadataItems(dict):
    def __init__(__self__, *,
                 filters: Sequence['outputs.AlertingFiltersFilterCustomMetadataItemsFilter']):
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.AlertingFiltersFilterCustomMetadataItemsFilter']:
        return pulumi.get(self, "filters")


@pulumi.output_type
class AlertingFiltersFilterCustomMetadataItemsFilter(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AlertingFiltersFilterCustomTitle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingFiltersFilterCustomTitle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingFiltersFilterCustomTitle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingFiltersFilterCustomTitle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 case_sensitive: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 negate: Optional[bool] = None):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")


@pulumi.output_type
class AlertingFiltersFilterPredefined(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")


@pulumi.output_type
class AlertingProfileEventTypeFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customEventFilters":
            suggest = "custom_event_filters"
        elif key == "predefinedEventFilters":
            suggest = "predefined_event_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileEventTypeFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileEventTypeFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileEventTypeFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_event_filters: Optional[Sequence['outputs.AlertingProfileEventTypeFilterCustomEventFilter']] = None,
                 predefined_event_filters: Optional[Sequence['outputs.AlertingProfileEventTypeFilterPredefinedEventFilter']] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence['AlertingProfileEventTypeFilterCustomEventFilterArgs'] custom_event_filters: Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
        :param Sequence['AlertingProfileEventTypeFilterPredefinedEventFilterArgs'] predefined_event_filters: Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if custom_event_filters is not None:
            pulumi.set(__self__, "custom_event_filters", custom_event_filters)
        if predefined_event_filters is not None:
            pulumi.set(__self__, "predefined_event_filters", predefined_event_filters)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="customEventFilters")
    def custom_event_filters(self) -> Optional[Sequence['outputs.AlertingProfileEventTypeFilterCustomEventFilter']]:
        """
        Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
        """
        return pulumi.get(self, "custom_event_filters")

    @property
    @pulumi.getter(name="predefinedEventFilters")
    def predefined_event_filters(self) -> Optional[Sequence['outputs.AlertingProfileEventTypeFilterPredefinedEventFilter']]:
        """
        Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
        """
        return pulumi.get(self, "predefined_event_filters")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileEventTypeFilterCustomEventFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDescriptionFilters":
            suggest = "custom_description_filters"
        elif key == "customTitleFilters":
            suggest = "custom_title_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileEventTypeFilterCustomEventFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileEventTypeFilterCustomEventFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileEventTypeFilterCustomEventFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_description_filters: Optional[Sequence['outputs.AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter']] = None,
                 custom_title_filters: Optional[Sequence['outputs.AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter']] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if custom_description_filters is not None:
            pulumi.set(__self__, "custom_description_filters", custom_description_filters)
        if custom_title_filters is not None:
            pulumi.set(__self__, "custom_title_filters", custom_title_filters)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="customDescriptionFilters")
    def custom_description_filters(self) -> Optional[Sequence['outputs.AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter']]:
        return pulumi.get(self, "custom_description_filters")

    @property
    @pulumi.getter(name="customTitleFilters")
    def custom_title_filters(self) -> Optional[Sequence['outputs.AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter']]:
        return pulumi.get(self, "custom_title_filters")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseInsensitive":
            suggest = "case_insensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 case_insensitive: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if case_insensitive is not None:
            pulumi.set(__self__, "case_insensitive", case_insensitive)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseInsensitive")
    def case_insensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_insensitive")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseInsensitive":
            suggest = "case_insensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 case_insensitive: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if case_insensitive is not None:
            pulumi.set(__self__, "case_insensitive", case_insensitive)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseInsensitive")
    def case_insensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_insensitive")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileEventTypeFilterPredefinedEventFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileEventTypeFilterPredefinedEventFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileEventTypeFilterPredefinedEventFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileEventTypeFilterPredefinedEventFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "event_type", event_type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> str:
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "configurationVersions":
            suggest = "configuration_versions"
        elif key == "currentConfigurationVersions":
            suggest = "current_configuration_versions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_version: Optional[str] = None,
                 configuration_versions: Optional[Sequence[int]] = None,
                 current_configuration_versions: Optional[Sequence[str]] = None):
        """
        :param str cluster_version: Dynatrace server version
        :param Sequence[int] configuration_versions: A Sorted list of the version numbers of the configuration
        :param Sequence[str] current_configuration_versions: A Sorted list of the version numbers of the configuration
        """
        if cluster_version is not None:
            pulumi.set(__self__, "cluster_version", cluster_version)
        if configuration_versions is not None:
            pulumi.set(__self__, "configuration_versions", configuration_versions)
        if current_configuration_versions is not None:
            pulumi.set(__self__, "current_configuration_versions", current_configuration_versions)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> Optional[str]:
        """
        Dynatrace server version
        """
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter(name="configurationVersions")
    def configuration_versions(self) -> Optional[Sequence[int]]:
        """
        A Sorted list of the version numbers of the configuration
        """
        return pulumi.get(self, "configuration_versions")

    @property
    @pulumi.getter(name="currentConfigurationVersions")
    def current_configuration_versions(self) -> Optional[Sequence[str]]:
        """
        A Sorted list of the version numbers of the configuration
        """
        return pulumi.get(self, "current_configuration_versions")


@pulumi.output_type
class AlertingProfileRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayInMinutes":
            suggest = "delay_in_minutes"
        elif key == "severityLevel":
            suggest = "severity_level"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_in_minutes: int,
                 severity_level: str,
                 tag_filters: Sequence['outputs.AlertingProfileRuleTagFilter'],
                 unknowns: Optional[str] = None):
        """
        :param int delay_in_minutes: Send a notification if a problem remains open longer than *X* minutes
        :param str severity_level: The severity level to trigger the alert. Possible values are `AVAILABILITY`,	`CUSTOM_ALERT`,	`ERROR`,`MONITORING_UNAVAILABLE`,`PERFORMANCE` and `RESOURCE_CONTENTION`.
        :param Sequence['AlertingProfileRuleTagFilterArgs'] tag_filters: Configuration of the tag filtering of the alerting profile
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "delay_in_minutes", delay_in_minutes)
        pulumi.set(__self__, "severity_level", severity_level)
        pulumi.set(__self__, "tag_filters", tag_filters)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="delayInMinutes")
    def delay_in_minutes(self) -> int:
        """
        Send a notification if a problem remains open longer than *X* minutes
        """
        return pulumi.get(self, "delay_in_minutes")

    @property
    @pulumi.getter(name="severityLevel")
    def severity_level(self) -> str:
        """
        The severity level to trigger the alert. Possible values are `AVAILABILITY`,	`CUSTOM_ALERT`,	`ERROR`,`MONITORING_UNAVAILABLE`,`PERFORMANCE` and `RESOURCE_CONTENTION`.
        """
        return pulumi.get(self, "severity_level")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Sequence['outputs.AlertingProfileRuleTagFilter']:
        """
        Configuration of the tag filtering of the alerting profile
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileRuleTagFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeMode":
            suggest = "include_mode"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileRuleTagFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileRuleTagFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileRuleTagFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_mode: str,
                 tag_filters: Optional[Sequence['outputs.AlertingProfileRuleTagFilterTagFilter']] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "include_mode", include_mode)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="includeMode")
    def include_mode(self) -> str:
        return pulumi.get(self, "include_mode")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.AlertingProfileRuleTagFilterTagFilter']]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileRuleTagFilterTagFilter(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AlertingRules(dict):
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.AlertingRulesRule']] = None):
        """
        :param Sequence['AlertingRulesRuleArgs'] rules: A conditions for the metric usage
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.AlertingRulesRule']]:
        """
        A conditions for the metric usage
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class AlertingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayInMinutes":
            suggest = "delay_in_minutes"
        elif key == "includeMode":
            suggest = "include_mode"
        elif key == "severityLevel":
            suggest = "severity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_in_minutes: int,
                 include_mode: str,
                 severity_level: str,
                 tags: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "delay_in_minutes", delay_in_minutes)
        pulumi.set(__self__, "include_mode", include_mode)
        pulumi.set(__self__, "severity_level", severity_level)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="delayInMinutes")
    def delay_in_minutes(self) -> int:
        return pulumi.get(self, "delay_in_minutes")

    @property
    @pulumi.getter(name="includeMode")
    def include_mode(self) -> str:
        return pulumi.get(self, "include_mode")

    @property
    @pulumi.getter(name="severityLevel")
    def severity_level(self) -> str:
        return pulumi.get(self, "severity_level")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class ApiDetectionConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.ApiDetectionConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.ApiDetectionConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ApiDetectionConditionsCondition(dict):
    def __init__(__self__, *,
                 base: str,
                 matcher: str,
                 pattern: str):
        pulumi.set(__self__, "base", base)
        pulumi.set(__self__, "matcher", matcher)
        pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def base(self) -> str:
        return pulumi.get(self, "base")

    @property
    @pulumi.getter
    def matcher(self) -> str:
        return pulumi.get(self, "matcher")

    @property
    @pulumi.getter
    def pattern(self) -> str:
        return pulumi.get(self, "pattern")


@pulumi.output_type
class ApplicationAnomaliesFailureRate(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.ApplicationAnomaliesFailureRateAuto'] = None,
                 thresholds: Optional['outputs.ApplicationAnomaliesFailureRateThresholds'] = None):
        """
        :param 'ApplicationAnomaliesFailureRateAutoArgs' auto: Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
        :param 'ApplicationAnomaliesFailureRateThresholdsArgs' thresholds: Fixed thresholds for failure rate increase detection
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.ApplicationAnomaliesFailureRateAuto']:
        """
        Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.ApplicationAnomaliesFailureRateThresholds']:
        """
        Fixed thresholds for failure rate increase detection
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class ApplicationAnomaliesFailureRateAuto(dict):
    def __init__(__self__, *,
                 absolute: int,
                 relative: int,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "absolute", absolute)
        pulumi.set(__self__, "relative", relative)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def absolute(self) -> int:
        return pulumi.get(self, "absolute")

    @property
    @pulumi.getter
    def relative(self) -> int:
        return pulumi.get(self, "relative")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ApplicationAnomaliesFailureRateThresholds(dict):
    def __init__(__self__, *,
                 sensitivity: str,
                 threshold: int,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold", threshold)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ApplicationAnomaliesResponseTime(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.ApplicationAnomaliesResponseTimeAuto'] = None,
                 thresholds: Optional['outputs.ApplicationAnomaliesResponseTimeThresholds'] = None):
        """
        :param 'ApplicationAnomaliesResponseTimeAutoArgs' auto: Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
        :param 'ApplicationAnomaliesResponseTimeThresholdsArgs' thresholds: Fixed thresholds for response time degradation detection
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.ApplicationAnomaliesResponseTimeAuto']:
        """
        Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.ApplicationAnomaliesResponseTimeThresholds']:
        """
        Fixed thresholds for response time degradation detection
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class ApplicationAnomaliesResponseTimeAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestMilliseconds":
            suggest = "slowest_milliseconds"
        elif key == "slowestPercent":
            suggest = "slowest_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAnomaliesResponseTimeAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAnomaliesResponseTimeAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAnomaliesResponseTimeAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load: str,
                 milliseconds: int,
                 percent: int,
                 slowest_milliseconds: int,
                 slowest_percent: int,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "load", load)
        pulumi.set(__self__, "milliseconds", milliseconds)
        pulumi.set(__self__, "percent", percent)
        pulumi.set(__self__, "slowest_milliseconds", slowest_milliseconds)
        pulumi.set(__self__, "slowest_percent", slowest_percent)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def load(self) -> str:
        return pulumi.get(self, "load")

    @property
    @pulumi.getter
    def milliseconds(self) -> int:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def percent(self) -> int:
        return pulumi.get(self, "percent")

    @property
    @pulumi.getter(name="slowestMilliseconds")
    def slowest_milliseconds(self) -> int:
        return pulumi.get(self, "slowest_milliseconds")

    @property
    @pulumi.getter(name="slowestPercent")
    def slowest_percent(self) -> int:
        return pulumi.get(self, "slowest_percent")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ApplicationAnomaliesResponseTimeThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestMilliseconds":
            suggest = "slowest_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAnomaliesResponseTimeThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAnomaliesResponseTimeThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAnomaliesResponseTimeThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load: str,
                 milliseconds: int,
                 sensitivity: str,
                 slowest_milliseconds: int,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "load", load)
        pulumi.set(__self__, "milliseconds", milliseconds)
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "slowest_milliseconds", slowest_milliseconds)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def load(self) -> str:
        return pulumi.get(self, "load")

    @property
    @pulumi.getter
    def milliseconds(self) -> int:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter(name="slowestMilliseconds")
    def slowest_milliseconds(self) -> int:
        return pulumi.get(self, "slowest_milliseconds")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ApplicationAnomaliesTraffic(dict):
    def __init__(__self__, *,
                 drops: Optional['outputs.ApplicationAnomaliesTrafficDrops'] = None,
                 spikes: Optional['outputs.ApplicationAnomaliesTrafficSpikes'] = None):
        """
        :param 'ApplicationAnomaliesTrafficDropsArgs' drops: The configuration of traffic drops detection
        :param 'ApplicationAnomaliesTrafficSpikesArgs' spikes: The configuration of traffic spikes detection
        """
        if drops is not None:
            pulumi.set(__self__, "drops", drops)
        if spikes is not None:
            pulumi.set(__self__, "spikes", spikes)

    @property
    @pulumi.getter
    def drops(self) -> Optional['outputs.ApplicationAnomaliesTrafficDrops']:
        """
        The configuration of traffic drops detection
        """
        return pulumi.get(self, "drops")

    @property
    @pulumi.getter
    def spikes(self) -> Optional['outputs.ApplicationAnomaliesTrafficSpikes']:
        """
        The configuration of traffic spikes detection
        """
        return pulumi.get(self, "spikes")


@pulumi.output_type
class ApplicationAnomaliesTrafficDrops(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 percent: Optional[int] = None):
        pulumi.set(__self__, "enabled", enabled)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        return pulumi.get(self, "percent")


@pulumi.output_type
class ApplicationAnomaliesTrafficSpikes(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 percent: Optional[int] = None):
        pulumi.set(__self__, "enabled", enabled)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        return pulumi.get(self, "percent")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentMaskingSettings":
            suggest = "content_masking_settings"
        elif key == "optIn":
            suggest = "opt_in"
        elif key == "urlExclusionRules":
            suggest = "url_exclusion_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationDataPrivacySessionReplayDataPrivacy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationDataPrivacySessionReplayDataPrivacy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationDataPrivacySessionReplayDataPrivacy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_masking_settings: 'outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettings',
                 opt_in: Optional[bool] = None,
                 url_exclusion_rules: Optional[Sequence[str]] = None):
        """
        :param 'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsArgs' content_masking_settings: (Field has overlap with `SessionReplayWebPrivacy`) Content masking settings for Session Replay.
        """
        pulumi.set(__self__, "content_masking_settings", content_masking_settings)
        if opt_in is not None:
            pulumi.set(__self__, "opt_in", opt_in)
        if url_exclusion_rules is not None:
            pulumi.set(__self__, "url_exclusion_rules", url_exclusion_rules)

    @property
    @pulumi.getter(name="contentMaskingSettings")
    def content_masking_settings(self) -> 'outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettings':
        """
        (Field has overlap with `SessionReplayWebPrivacy`) Content masking settings for Session Replay.
        """
        return pulumi.get(self, "content_masking_settings")

    @property
    @pulumi.getter(name="optIn")
    def opt_in(self) -> Optional[bool]:
        return pulumi.get(self, "opt_in")

    @property
    @pulumi.getter(name="urlExclusionRules")
    def url_exclusion_rules(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "url_exclusion_rules")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettings(dict):
    def __init__(__self__, *,
                 playback: 'outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlayback',
                 recording: 'outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecording'):
        pulumi.set(__self__, "playback", playback)
        pulumi.set(__self__, "recording", recording)

    @property
    @pulumi.getter
    def playback(self) -> 'outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlayback':
        return pulumi.get(self, "playback")

    @property
    @pulumi.getter
    def recording(self) -> 'outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecording':
        return pulumi.get(self, "recording")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlayback(dict):
    def __init__(__self__, *,
                 preset: str,
                 rules: Optional['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRules'] = None):
        pulumi.set(__self__, "preset", preset)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def preset(self) -> str:
        return pulumi.get(self, "preset")

    @property
    @pulumi.getter
    def rules(self) -> Optional['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRules']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userInteractionHidden":
            suggest = "user_interaction_hidden"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selector: str,
                 type: str,
                 user_interaction_hidden: Optional[bool] = None):
        pulumi.set(__self__, "selector", selector)
        pulumi.set(__self__, "type", type)
        if user_interaction_hidden is not None:
            pulumi.set(__self__, "user_interaction_hidden", user_interaction_hidden)

    @property
    @pulumi.getter
    def selector(self) -> str:
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userInteractionHidden")
    def user_interaction_hidden(self) -> Optional[bool]:
        return pulumi.get(self, "user_interaction_hidden")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecording(dict):
    def __init__(__self__, *,
                 preset: str,
                 rules: Optional['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRules'] = None):
        pulumi.set(__self__, "preset", preset)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def preset(self) -> str:
        return pulumi.get(self, "preset")

    @property
    @pulumi.getter
    def rules(self) -> Optional['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRules']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userInteractionHidden":
            suggest = "user_interaction_hidden"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selector: str,
                 type: str,
                 user_interaction_hidden: Optional[bool] = None):
        pulumi.set(__self__, "selector", selector)
        pulumi.set(__self__, "type", type)
        if user_interaction_hidden is not None:
            pulumi.set(__self__, "user_interaction_hidden", user_interaction_hidden)

    @property
    @pulumi.getter
    def selector(self) -> str:
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userInteractionHidden")
    def user_interaction_hidden(self) -> Optional[bool]:
        return pulumi.get(self, "user_interaction_hidden")


@pulumi.output_type
class ApplicationDetectionRuleFilterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationMatchTarget":
            suggest = "application_match_target"
        elif key == "applicationMatchType":
            suggest = "application_match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationDetectionRuleFilterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationDetectionRuleFilterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationDetectionRuleFilterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_match_target: str,
                 application_match_type: str,
                 pattern: str):
        """
        :param str application_match_target: Where to look for the pattern value, possible values are `DOMAIN` or `URL`
        :param str application_match_type: The operator used for matching the application detection rule, possible values are `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`, `MATCHES`
        :param str pattern: The value to look for with the application detection rule
        """
        pulumi.set(__self__, "application_match_target", application_match_target)
        pulumi.set(__self__, "application_match_type", application_match_type)
        pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter(name="applicationMatchTarget")
    def application_match_target(self) -> str:
        """
        Where to look for the pattern value, possible values are `DOMAIN` or `URL`
        """
        return pulumi.get(self, "application_match_target")

    @property
    @pulumi.getter(name="applicationMatchType")
    def application_match_type(self) -> str:
        """
        The operator used for matching the application detection rule, possible values are `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`, `MATCHES`
        """
        return pulumi.get(self, "application_match_type")

    @property
    @pulumi.getter
    def pattern(self) -> str:
        """
        The value to look for with the application detection rule
        """
        return pulumi.get(self, "pattern")


@pulumi.output_type
class ApplicationErrorRulesCustomErrors(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.ApplicationErrorRulesCustomErrorsRule']):
        """
        :param Sequence['ApplicationErrorRulesCustomErrorsRuleArgs'] rules: Configuration of the custom error in the web application
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.ApplicationErrorRulesCustomErrorsRule']:
        """
        Configuration of the custom error in the web application
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationErrorRulesCustomErrorsRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customAlerting":
            suggest = "custom_alerting"
        elif key == "impactApdex":
            suggest = "impact_apdex"
        elif key == "keyMatcher":
            suggest = "key_matcher"
        elif key == "keyPattern":
            suggest = "key_pattern"
        elif key == "valueMatcher":
            suggest = "value_matcher"
        elif key == "valuePattern":
            suggest = "value_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationErrorRulesCustomErrorsRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationErrorRulesCustomErrorsRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationErrorRulesCustomErrorsRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture: Optional[bool] = None,
                 custom_alerting: Optional[bool] = None,
                 impact_apdex: Optional[bool] = None,
                 key_matcher: Optional[str] = None,
                 key_pattern: Optional[str] = None,
                 value_matcher: Optional[str] = None,
                 value_pattern: Optional[str] = None):
        if capture is not None:
            pulumi.set(__self__, "capture", capture)
        if custom_alerting is not None:
            pulumi.set(__self__, "custom_alerting", custom_alerting)
        if impact_apdex is not None:
            pulumi.set(__self__, "impact_apdex", impact_apdex)
        if key_matcher is not None:
            pulumi.set(__self__, "key_matcher", key_matcher)
        if key_pattern is not None:
            pulumi.set(__self__, "key_pattern", key_pattern)
        if value_matcher is not None:
            pulumi.set(__self__, "value_matcher", value_matcher)
        if value_pattern is not None:
            pulumi.set(__self__, "value_pattern", value_pattern)

    @property
    @pulumi.getter
    def capture(self) -> Optional[bool]:
        return pulumi.get(self, "capture")

    @property
    @pulumi.getter(name="customAlerting")
    def custom_alerting(self) -> Optional[bool]:
        return pulumi.get(self, "custom_alerting")

    @property
    @pulumi.getter(name="impactApdex")
    def impact_apdex(self) -> Optional[bool]:
        return pulumi.get(self, "impact_apdex")

    @property
    @pulumi.getter(name="keyMatcher")
    def key_matcher(self) -> Optional[str]:
        return pulumi.get(self, "key_matcher")

    @property
    @pulumi.getter(name="keyPattern")
    def key_pattern(self) -> Optional[str]:
        return pulumi.get(self, "key_pattern")

    @property
    @pulumi.getter(name="valueMatcher")
    def value_matcher(self) -> Optional[str]:
        return pulumi.get(self, "value_matcher")

    @property
    @pulumi.getter(name="valuePattern")
    def value_pattern(self) -> Optional[str]:
        return pulumi.get(self, "value_pattern")


@pulumi.output_type
class ApplicationErrorRulesHttpErrors(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.ApplicationErrorRulesHttpErrorsRule']):
        """
        :param Sequence['ApplicationErrorRulesHttpErrorsRuleArgs'] rules: Configuration of the HTTP error in the web application
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.ApplicationErrorRulesHttpErrorsRule']:
        """
        Configuration of the HTTP error in the web application
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationErrorRulesHttpErrorsRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "considerBlockedRequests":
            suggest = "consider_blocked_requests"
        elif key == "considerForAi":
            suggest = "consider_for_ai"
        elif key == "considerUnknownErrorCode":
            suggest = "consider_unknown_error_code"
        elif key == "errorCodes":
            suggest = "error_codes"
        elif key == "filterByUrl":
            suggest = "filter_by_url"
        elif key == "impactApdex":
            suggest = "impact_apdex"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationErrorRulesHttpErrorsRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationErrorRulesHttpErrorsRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationErrorRulesHttpErrorsRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture: Optional[bool] = None,
                 consider_blocked_requests: Optional[bool] = None,
                 consider_for_ai: Optional[bool] = None,
                 consider_unknown_error_code: Optional[bool] = None,
                 error_codes: Optional[str] = None,
                 filter: Optional[str] = None,
                 filter_by_url: Optional[bool] = None,
                 impact_apdex: Optional[bool] = None,
                 url: Optional[str] = None):
        if capture is not None:
            pulumi.set(__self__, "capture", capture)
        if consider_blocked_requests is not None:
            pulumi.set(__self__, "consider_blocked_requests", consider_blocked_requests)
        if consider_for_ai is not None:
            pulumi.set(__self__, "consider_for_ai", consider_for_ai)
        if consider_unknown_error_code is not None:
            pulumi.set(__self__, "consider_unknown_error_code", consider_unknown_error_code)
        if error_codes is not None:
            pulumi.set(__self__, "error_codes", error_codes)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if filter_by_url is not None:
            pulumi.set(__self__, "filter_by_url", filter_by_url)
        if impact_apdex is not None:
            pulumi.set(__self__, "impact_apdex", impact_apdex)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def capture(self) -> Optional[bool]:
        return pulumi.get(self, "capture")

    @property
    @pulumi.getter(name="considerBlockedRequests")
    def consider_blocked_requests(self) -> Optional[bool]:
        return pulumi.get(self, "consider_blocked_requests")

    @property
    @pulumi.getter(name="considerForAi")
    def consider_for_ai(self) -> Optional[bool]:
        return pulumi.get(self, "consider_for_ai")

    @property
    @pulumi.getter(name="considerUnknownErrorCode")
    def consider_unknown_error_code(self) -> Optional[bool]:
        return pulumi.get(self, "consider_unknown_error_code")

    @property
    @pulumi.getter(name="errorCodes")
    def error_codes(self) -> Optional[str]:
        return pulumi.get(self, "error_codes")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="filterByUrl")
    def filter_by_url(self) -> Optional[bool]:
        return pulumi.get(self, "filter_by_url")

    @property
    @pulumi.getter(name="impactApdex")
    def impact_apdex(self) -> Optional[bool]:
        return pulumi.get(self, "impact_apdex")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class AutotagEntitySelectorBasedRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagEntitySelectorBasedRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagEntitySelectorBasedRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagEntitySelectorBasedRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 normalization: Optional[str] = None,
                 selector: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value_format: Optional[str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if normalization is not None:
            pulumi.set(__self__, "normalization", normalization)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def normalization(self) -> Optional[str]:
        return pulumi.get(self, "normalization")

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[str]:
        return pulumi.get(self, "value_format")


@pulumi.output_type
class AutotagRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propagationTypes":
            suggest = "propagation_types"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.AutotagRuleCondition']] = None,
                 enabled: Optional[bool] = None,
                 normalization: Optional[str] = None,
                 propagation_types: Optional[Sequence[str]] = None,
                 unknowns: Optional[str] = None,
                 value_format: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if normalization is not None:
            pulumi.set(__self__, "normalization", normalization)
        if propagation_types is not None:
            pulumi.set(__self__, "propagation_types", propagation_types)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.AutotagRuleCondition']]:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def normalization(self) -> Optional[str]:
        return pulumi.get(self, "normalization")

    @property
    @pulumi.getter(name="propagationTypes")
    def propagation_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "propagation_types")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[str]:
        return pulumi.get(self, "value_format")


@pulumi.output_type
class AutotagRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationTypeComparisons":
            suggest = "application_type_comparisons"
        elif key == "applicationTypes":
            suggest = "application_types"
        elif key == "azureComputeModeComparisons":
            suggest = "azure_compute_mode_comparisons"
        elif key == "azureComputeModes":
            suggest = "azure_compute_modes"
        elif key == "azureSkuComparisions":
            suggest = "azure_sku_comparisions"
        elif key == "azureSkus":
            suggest = "azure_skus"
        elif key == "baseComparisonBasics":
            suggest = "base_comparison_basics"
        elif key == "baseConditionKeys":
            suggest = "base_condition_keys"
        elif key == "bitnessComparisions":
            suggest = "bitness_comparisions"
        elif key == "cloudTypeComparisons":
            suggest = "cloud_type_comparisons"
        elif key == "cloudTypes":
            suggest = "cloud_types"
        elif key == "customApplicationTypeComparisons":
            suggest = "custom_application_type_comparisons"
        elif key == "customApplicationTypes":
            suggest = "custom_application_types"
        elif key == "customHostMetadataConditionKeys":
            suggest = "custom_host_metadata_condition_keys"
        elif key == "customHostMetadatas":
            suggest = "custom_host_metadatas"
        elif key == "customProcessMetadataConditionKeys":
            suggest = "custom_process_metadata_condition_keys"
        elif key == "customProcessMetadatas":
            suggest = "custom_process_metadatas"
        elif key == "databaseTopologies":
            suggest = "database_topologies"
        elif key == "databaseTopologyComparisons":
            suggest = "database_topology_comparisons"
        elif key == "dcrumDecoderComparisons":
            suggest = "dcrum_decoder_comparisons"
        elif key == "dcrumDecoders":
            suggest = "dcrum_decoders"
        elif key == "entityIdComparisons":
            suggest = "entity_id_comparisons"
        elif key == "hostTeches":
            suggest = "host_teches"
        elif key == "hypervisorTypeComparisions":
            suggest = "hypervisor_type_comparisions"
        elif key == "indexedNameComparisons":
            suggest = "indexed_name_comparisons"
        elif key == "indexedNames":
            suggest = "indexed_names"
        elif key == "indexedStringComparisons":
            suggest = "indexed_string_comparisons"
        elif key == "indexedStrings":
            suggest = "indexed_strings"
        elif key == "indexedTagComparisons":
            suggest = "indexed_tag_comparisons"
        elif key == "indexedTags":
            suggest = "indexed_tags"
        elif key == "integerComparisons":
            suggest = "integer_comparisons"
        elif key == "ipaddressComparisons":
            suggest = "ipaddress_comparisons"
        elif key == "mobilePlatformComparisons":
            suggest = "mobile_platform_comparisons"
        elif key == "mobilePlatforms":
            suggest = "mobile_platforms"
        elif key == "osArches":
            suggest = "os_arches"
        elif key == "osTypes":
            suggest = "os_types"
        elif key == "osarchitectureComparisons":
            suggest = "osarchitecture_comparisons"
        elif key == "ostypeComparisons":
            suggest = "ostype_comparisons"
        elif key == "paasTypeComparisons":
            suggest = "paas_type_comparisons"
        elif key == "paasTypes":
            suggest = "paas_types"
        elif key == "processMetadataConditionKeys":
            suggest = "process_metadata_condition_keys"
        elif key == "processMetadatas":
            suggest = "process_metadatas"
        elif key == "serviceTopologies":
            suggest = "service_topologies"
        elif key == "serviceTopologyComparisons":
            suggest = "service_topology_comparisons"
        elif key == "serviceTypeComparisons":
            suggest = "service_type_comparisons"
        elif key == "serviceTypes":
            suggest = "service_types"
        elif key == "simpleHostTechComparisons":
            suggest = "simple_host_tech_comparisons"
        elif key == "simpleTechComparisons":
            suggest = "simple_tech_comparisons"
        elif key == "stringComparisons":
            suggest = "string_comparisons"
        elif key == "stringConditionKeys":
            suggest = "string_condition_keys"
        elif key == "stringKeys":
            suggest = "string_keys"
        elif key == "syntheticEngineTypeComparisons":
            suggest = "synthetic_engine_type_comparisons"
        elif key == "syntheticEngines":
            suggest = "synthetic_engines"
        elif key == "tagComparisons":
            suggest = "tag_comparisons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_type_comparisons: Optional[Sequence['outputs.AutotagRuleConditionApplicationTypeComparison']] = None,
                 application_types: Optional[Sequence['outputs.AutotagRuleConditionApplicationType']] = None,
                 azure_compute_mode_comparisons: Optional[Sequence['outputs.AutotagRuleConditionAzureComputeModeComparison']] = None,
                 azure_compute_modes: Optional[Sequence['outputs.AutotagRuleConditionAzureComputeMode']] = None,
                 azure_sku_comparisions: Optional[Sequence['outputs.AutotagRuleConditionAzureSkuComparision']] = None,
                 azure_skus: Optional[Sequence['outputs.AutotagRuleConditionAzureSkus']] = None,
                 base_comparison_basics: Optional[Sequence['outputs.AutotagRuleConditionBaseComparisonBasic']] = None,
                 base_condition_keys: Optional[Sequence['outputs.AutotagRuleConditionBaseConditionKey']] = None,
                 bitness_comparisions: Optional[Sequence['outputs.AutotagRuleConditionBitnessComparision']] = None,
                 bitnesses: Optional[Sequence['outputs.AutotagRuleConditionBitness']] = None,
                 cloud_type_comparisons: Optional[Sequence['outputs.AutotagRuleConditionCloudTypeComparison']] = None,
                 cloud_types: Optional[Sequence['outputs.AutotagRuleConditionCloudType']] = None,
                 comparisons: Optional[Sequence['outputs.AutotagRuleConditionComparison']] = None,
                 custom_application_type_comparisons: Optional[Sequence['outputs.AutotagRuleConditionCustomApplicationTypeComparison']] = None,
                 custom_application_types: Optional[Sequence['outputs.AutotagRuleConditionCustomApplicationType']] = None,
                 custom_host_metadata_condition_keys: Optional[Sequence['outputs.AutotagRuleConditionCustomHostMetadataConditionKey']] = None,
                 custom_host_metadatas: Optional[Sequence['outputs.AutotagRuleConditionCustomHostMetadata']] = None,
                 custom_process_metadata_condition_keys: Optional[Sequence['outputs.AutotagRuleConditionCustomProcessMetadataConditionKey']] = None,
                 custom_process_metadatas: Optional[Sequence['outputs.AutotagRuleConditionCustomProcessMetadata']] = None,
                 database_topologies: Optional[Sequence['outputs.AutotagRuleConditionDatabaseTopology']] = None,
                 database_topology_comparisons: Optional[Sequence['outputs.AutotagRuleConditionDatabaseTopologyComparison']] = None,
                 dcrum_decoder_comparisons: Optional[Sequence['outputs.AutotagRuleConditionDcrumDecoderComparison']] = None,
                 dcrum_decoders: Optional[Sequence['outputs.AutotagRuleConditionDcrumDecoder']] = None,
                 entities: Optional[Sequence['outputs.AutotagRuleConditionEntity']] = None,
                 entity_id_comparisons: Optional[Sequence['outputs.AutotagRuleConditionEntityIdComparison']] = None,
                 host_teches: Optional[Sequence['outputs.AutotagRuleConditionHostTech']] = None,
                 hypervisor_type_comparisions: Optional[Sequence['outputs.AutotagRuleConditionHypervisorTypeComparision']] = None,
                 hypervisors: Optional[Sequence['outputs.AutotagRuleConditionHypervisor']] = None,
                 indexed_name_comparisons: Optional[Sequence['outputs.AutotagRuleConditionIndexedNameComparison']] = None,
                 indexed_names: Optional[Sequence['outputs.AutotagRuleConditionIndexedName']] = None,
                 indexed_string_comparisons: Optional[Sequence['outputs.AutotagRuleConditionIndexedStringComparison']] = None,
                 indexed_strings: Optional[Sequence['outputs.AutotagRuleConditionIndexedString']] = None,
                 indexed_tag_comparisons: Optional[Sequence['outputs.AutotagRuleConditionIndexedTagComparison']] = None,
                 indexed_tags: Optional[Sequence['outputs.AutotagRuleConditionIndexedTag']] = None,
                 integer_comparisons: Optional[Sequence['outputs.AutotagRuleConditionIntegerComparison']] = None,
                 integers: Optional[Sequence['outputs.AutotagRuleConditionInteger']] = None,
                 ipaddress_comparisons: Optional[Sequence['outputs.AutotagRuleConditionIpaddressComparison']] = None,
                 ipaddresses: Optional[Sequence['outputs.AutotagRuleConditionIpaddress']] = None,
                 keys: Optional[Sequence['outputs.AutotagRuleConditionKey']] = None,
                 mobile_platform_comparisons: Optional[Sequence['outputs.AutotagRuleConditionMobilePlatformComparison']] = None,
                 mobile_platforms: Optional[Sequence['outputs.AutotagRuleConditionMobilePlatform']] = None,
                 os_arches: Optional[Sequence['outputs.AutotagRuleConditionOsArch']] = None,
                 os_types: Optional[Sequence['outputs.AutotagRuleConditionOsType']] = None,
                 osarchitecture_comparisons: Optional[Sequence['outputs.AutotagRuleConditionOsarchitectureComparison']] = None,
                 ostype_comparisons: Optional[Sequence['outputs.AutotagRuleConditionOstypeComparison']] = None,
                 paas_type_comparisons: Optional[Sequence['outputs.AutotagRuleConditionPaasTypeComparison']] = None,
                 paas_types: Optional[Sequence['outputs.AutotagRuleConditionPaasType']] = None,
                 process_metadata_condition_keys: Optional[Sequence['outputs.AutotagRuleConditionProcessMetadataConditionKey']] = None,
                 process_metadatas: Optional[Sequence['outputs.AutotagRuleConditionProcessMetadata']] = None,
                 service_topologies: Optional[Sequence['outputs.AutotagRuleConditionServiceTopology']] = None,
                 service_topology_comparisons: Optional[Sequence['outputs.AutotagRuleConditionServiceTopologyComparison']] = None,
                 service_type_comparisons: Optional[Sequence['outputs.AutotagRuleConditionServiceTypeComparison']] = None,
                 service_types: Optional[Sequence['outputs.AutotagRuleConditionServiceType']] = None,
                 simple_host_tech_comparisons: Optional[Sequence['outputs.AutotagRuleConditionSimpleHostTechComparison']] = None,
                 simple_tech_comparisons: Optional[Sequence['outputs.AutotagRuleConditionSimpleTechComparison']] = None,
                 string_comparisons: Optional[Sequence['outputs.AutotagRuleConditionStringComparison']] = None,
                 string_condition_keys: Optional[Sequence['outputs.AutotagRuleConditionStringConditionKey']] = None,
                 string_keys: Optional[Sequence['outputs.AutotagRuleConditionStringKey']] = None,
                 strings: Optional[Sequence['outputs.AutotagRuleConditionString']] = None,
                 synthetic_engine_type_comparisons: Optional[Sequence['outputs.AutotagRuleConditionSyntheticEngineTypeComparison']] = None,
                 synthetic_engines: Optional[Sequence['outputs.AutotagRuleConditionSyntheticEngine']] = None,
                 tag_comparisons: Optional[Sequence['outputs.AutotagRuleConditionTagComparison']] = None,
                 tags: Optional[Sequence['outputs.AutotagRuleConditionTag']] = None,
                 teches: Optional[Sequence['outputs.AutotagRuleConditionTech']] = None,
                 unknowns: Optional[str] = None):
        if application_type_comparisons is not None:
            pulumi.set(__self__, "application_type_comparisons", application_type_comparisons)
        if application_types is not None:
            pulumi.set(__self__, "application_types", application_types)
        if azure_compute_mode_comparisons is not None:
            pulumi.set(__self__, "azure_compute_mode_comparisons", azure_compute_mode_comparisons)
        if azure_compute_modes is not None:
            pulumi.set(__self__, "azure_compute_modes", azure_compute_modes)
        if azure_sku_comparisions is not None:
            pulumi.set(__self__, "azure_sku_comparisions", azure_sku_comparisions)
        if azure_skus is not None:
            pulumi.set(__self__, "azure_skus", azure_skus)
        if base_comparison_basics is not None:
            pulumi.set(__self__, "base_comparison_basics", base_comparison_basics)
        if base_condition_keys is not None:
            pulumi.set(__self__, "base_condition_keys", base_condition_keys)
        if bitness_comparisions is not None:
            pulumi.set(__self__, "bitness_comparisions", bitness_comparisions)
        if bitnesses is not None:
            pulumi.set(__self__, "bitnesses", bitnesses)
        if cloud_type_comparisons is not None:
            pulumi.set(__self__, "cloud_type_comparisons", cloud_type_comparisons)
        if cloud_types is not None:
            pulumi.set(__self__, "cloud_types", cloud_types)
        if comparisons is not None:
            pulumi.set(__self__, "comparisons", comparisons)
        if custom_application_type_comparisons is not None:
            pulumi.set(__self__, "custom_application_type_comparisons", custom_application_type_comparisons)
        if custom_application_types is not None:
            pulumi.set(__self__, "custom_application_types", custom_application_types)
        if custom_host_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_host_metadata_condition_keys", custom_host_metadata_condition_keys)
        if custom_host_metadatas is not None:
            pulumi.set(__self__, "custom_host_metadatas", custom_host_metadatas)
        if custom_process_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_process_metadata_condition_keys", custom_process_metadata_condition_keys)
        if custom_process_metadatas is not None:
            pulumi.set(__self__, "custom_process_metadatas", custom_process_metadatas)
        if database_topologies is not None:
            pulumi.set(__self__, "database_topologies", database_topologies)
        if database_topology_comparisons is not None:
            pulumi.set(__self__, "database_topology_comparisons", database_topology_comparisons)
        if dcrum_decoder_comparisons is not None:
            pulumi.set(__self__, "dcrum_decoder_comparisons", dcrum_decoder_comparisons)
        if dcrum_decoders is not None:
            pulumi.set(__self__, "dcrum_decoders", dcrum_decoders)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if entity_id_comparisons is not None:
            pulumi.set(__self__, "entity_id_comparisons", entity_id_comparisons)
        if host_teches is not None:
            pulumi.set(__self__, "host_teches", host_teches)
        if hypervisor_type_comparisions is not None:
            pulumi.set(__self__, "hypervisor_type_comparisions", hypervisor_type_comparisions)
        if hypervisors is not None:
            pulumi.set(__self__, "hypervisors", hypervisors)
        if indexed_name_comparisons is not None:
            pulumi.set(__self__, "indexed_name_comparisons", indexed_name_comparisons)
        if indexed_names is not None:
            pulumi.set(__self__, "indexed_names", indexed_names)
        if indexed_string_comparisons is not None:
            pulumi.set(__self__, "indexed_string_comparisons", indexed_string_comparisons)
        if indexed_strings is not None:
            pulumi.set(__self__, "indexed_strings", indexed_strings)
        if indexed_tag_comparisons is not None:
            pulumi.set(__self__, "indexed_tag_comparisons", indexed_tag_comparisons)
        if indexed_tags is not None:
            pulumi.set(__self__, "indexed_tags", indexed_tags)
        if integer_comparisons is not None:
            pulumi.set(__self__, "integer_comparisons", integer_comparisons)
        if integers is not None:
            pulumi.set(__self__, "integers", integers)
        if ipaddress_comparisons is not None:
            pulumi.set(__self__, "ipaddress_comparisons", ipaddress_comparisons)
        if ipaddresses is not None:
            pulumi.set(__self__, "ipaddresses", ipaddresses)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if mobile_platform_comparisons is not None:
            pulumi.set(__self__, "mobile_platform_comparisons", mobile_platform_comparisons)
        if mobile_platforms is not None:
            pulumi.set(__self__, "mobile_platforms", mobile_platforms)
        if os_arches is not None:
            pulumi.set(__self__, "os_arches", os_arches)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if osarchitecture_comparisons is not None:
            pulumi.set(__self__, "osarchitecture_comparisons", osarchitecture_comparisons)
        if ostype_comparisons is not None:
            pulumi.set(__self__, "ostype_comparisons", ostype_comparisons)
        if paas_type_comparisons is not None:
            pulumi.set(__self__, "paas_type_comparisons", paas_type_comparisons)
        if paas_types is not None:
            pulumi.set(__self__, "paas_types", paas_types)
        if process_metadata_condition_keys is not None:
            pulumi.set(__self__, "process_metadata_condition_keys", process_metadata_condition_keys)
        if process_metadatas is not None:
            pulumi.set(__self__, "process_metadatas", process_metadatas)
        if service_topologies is not None:
            pulumi.set(__self__, "service_topologies", service_topologies)
        if service_topology_comparisons is not None:
            pulumi.set(__self__, "service_topology_comparisons", service_topology_comparisons)
        if service_type_comparisons is not None:
            pulumi.set(__self__, "service_type_comparisons", service_type_comparisons)
        if service_types is not None:
            pulumi.set(__self__, "service_types", service_types)
        if simple_host_tech_comparisons is not None:
            pulumi.set(__self__, "simple_host_tech_comparisons", simple_host_tech_comparisons)
        if simple_tech_comparisons is not None:
            pulumi.set(__self__, "simple_tech_comparisons", simple_tech_comparisons)
        if string_comparisons is not None:
            pulumi.set(__self__, "string_comparisons", string_comparisons)
        if string_condition_keys is not None:
            pulumi.set(__self__, "string_condition_keys", string_condition_keys)
        if string_keys is not None:
            pulumi.set(__self__, "string_keys", string_keys)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)
        if synthetic_engine_type_comparisons is not None:
            pulumi.set(__self__, "synthetic_engine_type_comparisons", synthetic_engine_type_comparisons)
        if synthetic_engines is not None:
            pulumi.set(__self__, "synthetic_engines", synthetic_engines)
        if tag_comparisons is not None:
            pulumi.set(__self__, "tag_comparisons", tag_comparisons)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if teches is not None:
            pulumi.set(__self__, "teches", teches)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="applicationTypeComparisons")
    def application_type_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionApplicationTypeComparison']]:
        return pulumi.get(self, "application_type_comparisons")

    @property
    @pulumi.getter(name="applicationTypes")
    def application_types(self) -> Optional[Sequence['outputs.AutotagRuleConditionApplicationType']]:
        return pulumi.get(self, "application_types")

    @property
    @pulumi.getter(name="azureComputeModeComparisons")
    def azure_compute_mode_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionAzureComputeModeComparison']]:
        return pulumi.get(self, "azure_compute_mode_comparisons")

    @property
    @pulumi.getter(name="azureComputeModes")
    def azure_compute_modes(self) -> Optional[Sequence['outputs.AutotagRuleConditionAzureComputeMode']]:
        return pulumi.get(self, "azure_compute_modes")

    @property
    @pulumi.getter(name="azureSkuComparisions")
    def azure_sku_comparisions(self) -> Optional[Sequence['outputs.AutotagRuleConditionAzureSkuComparision']]:
        return pulumi.get(self, "azure_sku_comparisions")

    @property
    @pulumi.getter(name="azureSkus")
    def azure_skus(self) -> Optional[Sequence['outputs.AutotagRuleConditionAzureSkus']]:
        return pulumi.get(self, "azure_skus")

    @property
    @pulumi.getter(name="baseComparisonBasics")
    def base_comparison_basics(self) -> Optional[Sequence['outputs.AutotagRuleConditionBaseComparisonBasic']]:
        return pulumi.get(self, "base_comparison_basics")

    @property
    @pulumi.getter(name="baseConditionKeys")
    def base_condition_keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionBaseConditionKey']]:
        return pulumi.get(self, "base_condition_keys")

    @property
    @pulumi.getter(name="bitnessComparisions")
    def bitness_comparisions(self) -> Optional[Sequence['outputs.AutotagRuleConditionBitnessComparision']]:
        return pulumi.get(self, "bitness_comparisions")

    @property
    @pulumi.getter
    def bitnesses(self) -> Optional[Sequence['outputs.AutotagRuleConditionBitness']]:
        return pulumi.get(self, "bitnesses")

    @property
    @pulumi.getter(name="cloudTypeComparisons")
    def cloud_type_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionCloudTypeComparison']]:
        return pulumi.get(self, "cloud_type_comparisons")

    @property
    @pulumi.getter(name="cloudTypes")
    def cloud_types(self) -> Optional[Sequence['outputs.AutotagRuleConditionCloudType']]:
        return pulumi.get(self, "cloud_types")

    @property
    @pulumi.getter
    def comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionComparison']]:
        return pulumi.get(self, "comparisons")

    @property
    @pulumi.getter(name="customApplicationTypeComparisons")
    def custom_application_type_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionCustomApplicationTypeComparison']]:
        return pulumi.get(self, "custom_application_type_comparisons")

    @property
    @pulumi.getter(name="customApplicationTypes")
    def custom_application_types(self) -> Optional[Sequence['outputs.AutotagRuleConditionCustomApplicationType']]:
        return pulumi.get(self, "custom_application_types")

    @property
    @pulumi.getter(name="customHostMetadataConditionKeys")
    def custom_host_metadata_condition_keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionCustomHostMetadataConditionKey']]:
        return pulumi.get(self, "custom_host_metadata_condition_keys")

    @property
    @pulumi.getter(name="customHostMetadatas")
    def custom_host_metadatas(self) -> Optional[Sequence['outputs.AutotagRuleConditionCustomHostMetadata']]:
        return pulumi.get(self, "custom_host_metadatas")

    @property
    @pulumi.getter(name="customProcessMetadataConditionKeys")
    def custom_process_metadata_condition_keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionCustomProcessMetadataConditionKey']]:
        return pulumi.get(self, "custom_process_metadata_condition_keys")

    @property
    @pulumi.getter(name="customProcessMetadatas")
    def custom_process_metadatas(self) -> Optional[Sequence['outputs.AutotagRuleConditionCustomProcessMetadata']]:
        return pulumi.get(self, "custom_process_metadatas")

    @property
    @pulumi.getter(name="databaseTopologies")
    def database_topologies(self) -> Optional[Sequence['outputs.AutotagRuleConditionDatabaseTopology']]:
        return pulumi.get(self, "database_topologies")

    @property
    @pulumi.getter(name="databaseTopologyComparisons")
    def database_topology_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionDatabaseTopologyComparison']]:
        return pulumi.get(self, "database_topology_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoderComparisons")
    def dcrum_decoder_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionDcrumDecoderComparison']]:
        return pulumi.get(self, "dcrum_decoder_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoders")
    def dcrum_decoders(self) -> Optional[Sequence['outputs.AutotagRuleConditionDcrumDecoder']]:
        return pulumi.get(self, "dcrum_decoders")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.AutotagRuleConditionEntity']]:
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="entityIdComparisons")
    def entity_id_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionEntityIdComparison']]:
        return pulumi.get(self, "entity_id_comparisons")

    @property
    @pulumi.getter(name="hostTeches")
    def host_teches(self) -> Optional[Sequence['outputs.AutotagRuleConditionHostTech']]:
        return pulumi.get(self, "host_teches")

    @property
    @pulumi.getter(name="hypervisorTypeComparisions")
    def hypervisor_type_comparisions(self) -> Optional[Sequence['outputs.AutotagRuleConditionHypervisorTypeComparision']]:
        return pulumi.get(self, "hypervisor_type_comparisions")

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[Sequence['outputs.AutotagRuleConditionHypervisor']]:
        return pulumi.get(self, "hypervisors")

    @property
    @pulumi.getter(name="indexedNameComparisons")
    def indexed_name_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionIndexedNameComparison']]:
        return pulumi.get(self, "indexed_name_comparisons")

    @property
    @pulumi.getter(name="indexedNames")
    def indexed_names(self) -> Optional[Sequence['outputs.AutotagRuleConditionIndexedName']]:
        return pulumi.get(self, "indexed_names")

    @property
    @pulumi.getter(name="indexedStringComparisons")
    def indexed_string_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionIndexedStringComparison']]:
        return pulumi.get(self, "indexed_string_comparisons")

    @property
    @pulumi.getter(name="indexedStrings")
    def indexed_strings(self) -> Optional[Sequence['outputs.AutotagRuleConditionIndexedString']]:
        return pulumi.get(self, "indexed_strings")

    @property
    @pulumi.getter(name="indexedTagComparisons")
    def indexed_tag_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionIndexedTagComparison']]:
        return pulumi.get(self, "indexed_tag_comparisons")

    @property
    @pulumi.getter(name="indexedTags")
    def indexed_tags(self) -> Optional[Sequence['outputs.AutotagRuleConditionIndexedTag']]:
        return pulumi.get(self, "indexed_tags")

    @property
    @pulumi.getter(name="integerComparisons")
    def integer_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionIntegerComparison']]:
        return pulumi.get(self, "integer_comparisons")

    @property
    @pulumi.getter
    def integers(self) -> Optional[Sequence['outputs.AutotagRuleConditionInteger']]:
        return pulumi.get(self, "integers")

    @property
    @pulumi.getter(name="ipaddressComparisons")
    def ipaddress_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionIpaddressComparison']]:
        return pulumi.get(self, "ipaddress_comparisons")

    @property
    @pulumi.getter
    def ipaddresses(self) -> Optional[Sequence['outputs.AutotagRuleConditionIpaddress']]:
        return pulumi.get(self, "ipaddresses")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionKey']]:
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter(name="mobilePlatformComparisons")
    def mobile_platform_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionMobilePlatformComparison']]:
        return pulumi.get(self, "mobile_platform_comparisons")

    @property
    @pulumi.getter(name="mobilePlatforms")
    def mobile_platforms(self) -> Optional[Sequence['outputs.AutotagRuleConditionMobilePlatform']]:
        return pulumi.get(self, "mobile_platforms")

    @property
    @pulumi.getter(name="osArches")
    def os_arches(self) -> Optional[Sequence['outputs.AutotagRuleConditionOsArch']]:
        return pulumi.get(self, "os_arches")

    @property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[Sequence['outputs.AutotagRuleConditionOsType']]:
        return pulumi.get(self, "os_types")

    @property
    @pulumi.getter(name="osarchitectureComparisons")
    def osarchitecture_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionOsarchitectureComparison']]:
        return pulumi.get(self, "osarchitecture_comparisons")

    @property
    @pulumi.getter(name="ostypeComparisons")
    def ostype_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionOstypeComparison']]:
        return pulumi.get(self, "ostype_comparisons")

    @property
    @pulumi.getter(name="paasTypeComparisons")
    def paas_type_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionPaasTypeComparison']]:
        return pulumi.get(self, "paas_type_comparisons")

    @property
    @pulumi.getter(name="paasTypes")
    def paas_types(self) -> Optional[Sequence['outputs.AutotagRuleConditionPaasType']]:
        return pulumi.get(self, "paas_types")

    @property
    @pulumi.getter(name="processMetadataConditionKeys")
    def process_metadata_condition_keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionProcessMetadataConditionKey']]:
        return pulumi.get(self, "process_metadata_condition_keys")

    @property
    @pulumi.getter(name="processMetadatas")
    def process_metadatas(self) -> Optional[Sequence['outputs.AutotagRuleConditionProcessMetadata']]:
        return pulumi.get(self, "process_metadatas")

    @property
    @pulumi.getter(name="serviceTopologies")
    def service_topologies(self) -> Optional[Sequence['outputs.AutotagRuleConditionServiceTopology']]:
        return pulumi.get(self, "service_topologies")

    @property
    @pulumi.getter(name="serviceTopologyComparisons")
    def service_topology_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionServiceTopologyComparison']]:
        return pulumi.get(self, "service_topology_comparisons")

    @property
    @pulumi.getter(name="serviceTypeComparisons")
    def service_type_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionServiceTypeComparison']]:
        return pulumi.get(self, "service_type_comparisons")

    @property
    @pulumi.getter(name="serviceTypes")
    def service_types(self) -> Optional[Sequence['outputs.AutotagRuleConditionServiceType']]:
        return pulumi.get(self, "service_types")

    @property
    @pulumi.getter(name="simpleHostTechComparisons")
    def simple_host_tech_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionSimpleHostTechComparison']]:
        return pulumi.get(self, "simple_host_tech_comparisons")

    @property
    @pulumi.getter(name="simpleTechComparisons")
    def simple_tech_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionSimpleTechComparison']]:
        return pulumi.get(self, "simple_tech_comparisons")

    @property
    @pulumi.getter(name="stringComparisons")
    def string_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionStringComparison']]:
        return pulumi.get(self, "string_comparisons")

    @property
    @pulumi.getter(name="stringConditionKeys")
    def string_condition_keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionStringConditionKey']]:
        return pulumi.get(self, "string_condition_keys")

    @property
    @pulumi.getter(name="stringKeys")
    def string_keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionStringKey']]:
        return pulumi.get(self, "string_keys")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence['outputs.AutotagRuleConditionString']]:
        return pulumi.get(self, "strings")

    @property
    @pulumi.getter(name="syntheticEngineTypeComparisons")
    def synthetic_engine_type_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionSyntheticEngineTypeComparison']]:
        return pulumi.get(self, "synthetic_engine_type_comparisons")

    @property
    @pulumi.getter(name="syntheticEngines")
    def synthetic_engines(self) -> Optional[Sequence['outputs.AutotagRuleConditionSyntheticEngine']]:
        return pulumi.get(self, "synthetic_engines")

    @property
    @pulumi.getter(name="tagComparisons")
    def tag_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionTagComparison']]:
        return pulumi.get(self, "tag_comparisons")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.AutotagRuleConditionTag']]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def teches(self) -> Optional[Sequence['outputs.AutotagRuleConditionTech']]:
        return pulumi.get(self, "teches")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionAzureComputeMode(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionAzureComputeModeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionAzureSkuComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionAzureSkus(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionBaseComparisonBasic(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionBaseConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionBitness(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionBitnessComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionCloudType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionCloudTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionComparison(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionCustomApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionCustomHostMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionCustomHostMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionCustomHostMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionCustomHostMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.AutotagRuleConditionCustomHostMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.AutotagRuleConditionCustomHostMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomHostMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionCustomHostMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.AutotagRuleConditionCustomHostMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.AutotagRuleConditionCustomHostMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomHostMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomHostMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionCustomProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionCustomProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionCustomProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.AutotagRuleConditionCustomProcessMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.AutotagRuleConditionCustomProcessMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionCustomProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.AutotagRuleConditionCustomProcessMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.AutotagRuleConditionCustomProcessMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomProcessMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomProcessMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionDatabaseTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionDatabaseTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionDcrumDecoder(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionDcrumDecoderComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionEntity(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionEntityIdComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionHostTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionHostTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionHostTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionHostTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionHostTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionHostTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionHostTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class AutotagRuleConditionHypervisor(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionHypervisorTypeComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedName(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedNameComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedString(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedStringComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionIndexedTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionIndexedTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionIndexedTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionIndexedTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionInteger(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIntegerComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIpaddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionIpaddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionIpaddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionIpaddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIpaddressComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionIpaddressComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionIpaddressComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionIpaddressComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionMobilePlatform(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionMobilePlatformComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionOsArch(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionOsType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionOsarchitectureComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionOstypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionPaasType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionPaasTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionServiceTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionServiceTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionServiceType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionServiceTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionSimpleHostTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionSimpleHostTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionSimpleHostTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionSimpleHostTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionSimpleHostTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class AutotagRuleConditionSimpleTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionSimpleTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionSimpleTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionSimpleTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionSimpleTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionSimpleTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionSimpleTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class AutotagRuleConditionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionStringComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionStringComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionStringComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionStringComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionStringConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionStringConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionStringConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionStringConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionStringKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionStringKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionStringKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionStringKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionSyntheticEngine(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionSyntheticEngineTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class AutotagV2Rules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.AutotagV2RulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.AutotagV2RulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class AutotagV2RulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueNormalization":
            suggest = "value_normalization"
        elif key == "attributeRule":
            suggest = "attribute_rule"
        elif key == "entitySelector":
            suggest = "entity_selector"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagV2RulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagV2RulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagV2RulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 type: str,
                 value_normalization: str,
                 attribute_rule: Optional['outputs.AutotagV2RulesRuleAttributeRule'] = None,
                 entity_selector: Optional[str] = None,
                 value_format: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value_normalization", value_normalization)
        if attribute_rule is not None:
            pulumi.set(__self__, "attribute_rule", attribute_rule)
        if entity_selector is not None:
            pulumi.set(__self__, "entity_selector", entity_selector)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="valueNormalization")
    def value_normalization(self) -> str:
        return pulumi.get(self, "value_normalization")

    @property
    @pulumi.getter(name="attributeRule")
    def attribute_rule(self) -> Optional['outputs.AutotagV2RulesRuleAttributeRule']:
        return pulumi.get(self, "attribute_rule")

    @property
    @pulumi.getter(name="entitySelector")
    def entity_selector(self) -> Optional[str]:
        return pulumi.get(self, "entity_selector")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[str]:
        return pulumi.get(self, "value_format")


@pulumi.output_type
class AutotagV2RulesRuleAttributeRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "azureToPgpropagation":
            suggest = "azure_to_pgpropagation"
        elif key == "azureToServicePropagation":
            suggest = "azure_to_service_propagation"
        elif key == "hostToPgpropagation":
            suggest = "host_to_pgpropagation"
        elif key == "pgToHostPropagation":
            suggest = "pg_to_host_propagation"
        elif key == "pgToServicePropagation":
            suggest = "pg_to_service_propagation"
        elif key == "serviceToHostPropagation":
            suggest = "service_to_host_propagation"
        elif key == "serviceToPgpropagation":
            suggest = "service_to_pgpropagation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagV2RulesRuleAttributeRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagV2RulesRuleAttributeRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagV2RulesRuleAttributeRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: 'outputs.AutotagV2RulesRuleAttributeRuleConditions',
                 entity_type: str,
                 azure_to_pgpropagation: Optional[bool] = None,
                 azure_to_service_propagation: Optional[bool] = None,
                 host_to_pgpropagation: Optional[bool] = None,
                 pg_to_host_propagation: Optional[bool] = None,
                 pg_to_service_propagation: Optional[bool] = None,
                 service_to_host_propagation: Optional[bool] = None,
                 service_to_pgpropagation: Optional[bool] = None):
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "entity_type", entity_type)
        if azure_to_pgpropagation is not None:
            pulumi.set(__self__, "azure_to_pgpropagation", azure_to_pgpropagation)
        if azure_to_service_propagation is not None:
            pulumi.set(__self__, "azure_to_service_propagation", azure_to_service_propagation)
        if host_to_pgpropagation is not None:
            pulumi.set(__self__, "host_to_pgpropagation", host_to_pgpropagation)
        if pg_to_host_propagation is not None:
            pulumi.set(__self__, "pg_to_host_propagation", pg_to_host_propagation)
        if pg_to_service_propagation is not None:
            pulumi.set(__self__, "pg_to_service_propagation", pg_to_service_propagation)
        if service_to_host_propagation is not None:
            pulumi.set(__self__, "service_to_host_propagation", service_to_host_propagation)
        if service_to_pgpropagation is not None:
            pulumi.set(__self__, "service_to_pgpropagation", service_to_pgpropagation)

    @property
    @pulumi.getter
    def conditions(self) -> 'outputs.AutotagV2RulesRuleAttributeRuleConditions':
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="azureToPgpropagation")
    def azure_to_pgpropagation(self) -> Optional[bool]:
        return pulumi.get(self, "azure_to_pgpropagation")

    @property
    @pulumi.getter(name="azureToServicePropagation")
    def azure_to_service_propagation(self) -> Optional[bool]:
        return pulumi.get(self, "azure_to_service_propagation")

    @property
    @pulumi.getter(name="hostToPgpropagation")
    def host_to_pgpropagation(self) -> Optional[bool]:
        return pulumi.get(self, "host_to_pgpropagation")

    @property
    @pulumi.getter(name="pgToHostPropagation")
    def pg_to_host_propagation(self) -> Optional[bool]:
        return pulumi.get(self, "pg_to_host_propagation")

    @property
    @pulumi.getter(name="pgToServicePropagation")
    def pg_to_service_propagation(self) -> Optional[bool]:
        return pulumi.get(self, "pg_to_service_propagation")

    @property
    @pulumi.getter(name="serviceToHostPropagation")
    def service_to_host_propagation(self) -> Optional[bool]:
        return pulumi.get(self, "service_to_host_propagation")

    @property
    @pulumi.getter(name="serviceToPgpropagation")
    def service_to_pgpropagation(self) -> Optional[bool]:
        return pulumi.get(self, "service_to_pgpropagation")


@pulumi.output_type
class AutotagV2RulesRuleAttributeRuleConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.AutotagV2RulesRuleAttributeRuleConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.AutotagV2RulesRuleAttributeRuleConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class AutotagV2RulesRuleAttributeRuleConditionsCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "dynamicKey":
            suggest = "dynamic_key"
        elif key == "dynamicKeySource":
            suggest = "dynamic_key_source"
        elif key == "entityId":
            suggest = "entity_id"
        elif key == "enumValue":
            suggest = "enum_value"
        elif key == "integerValue":
            suggest = "integer_value"
        elif key == "stringValue":
            suggest = "string_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagV2RulesRuleAttributeRuleConditionsCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagV2RulesRuleAttributeRuleConditionsCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagV2RulesRuleAttributeRuleConditionsCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 dynamic_key: Optional[str] = None,
                 dynamic_key_source: Optional[str] = None,
                 entity_id: Optional[str] = None,
                 enum_value: Optional[str] = None,
                 integer_value: Optional[int] = None,
                 string_value: Optional[str] = None,
                 tag: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if dynamic_key is not None:
            pulumi.set(__self__, "dynamic_key", dynamic_key)
        if dynamic_key_source is not None:
            pulumi.set(__self__, "dynamic_key_source", dynamic_key_source)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if enum_value is not None:
            pulumi.set(__self__, "enum_value", enum_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> Optional[str]:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter(name="dynamicKeySource")
    def dynamic_key_source(self) -> Optional[str]:
        return pulumi.get(self, "dynamic_key_source")

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[str]:
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter(name="enumValue")
    def enum_value(self) -> Optional[str]:
        return pulumi.get(self, "enum_value")

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[int]:
        return pulumi.get(self, "integer_value")

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[str]:
        return pulumi.get(self, "string_value")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")


@pulumi.output_type
class AwsAnomaliesEc2CandidateHighCpuDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesEc2CandidateHighCpuDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesEc2CandidateHighCpuDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesEc2CandidateHighCpuDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.AwsAnomaliesEc2CandidateHighCpuDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'AwsAnomaliesEc2CandidateHighCpuDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.AwsAnomaliesEc2CandidateHighCpuDetectionCustomThresholds']:
        """
        Alert if the condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class AwsAnomaliesEc2CandidateHighCpuDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuUsage":
            suggest = "cpu_usage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesEc2CandidateHighCpuDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesEc2CandidateHighCpuDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesEc2CandidateHighCpuDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_usage: float):
        pulumi.set(__self__, "cpu_usage", cpu_usage)

    @property
    @pulumi.getter(name="cpuUsage")
    def cpu_usage(self) -> float:
        return pulumi.get(self, "cpu_usage")


@pulumi.output_type
class AwsAnomaliesElbHighConnectionErrorsDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesElbHighConnectionErrorsDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesElbHighConnectionErrorsDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesElbHighConnectionErrorsDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.AwsAnomaliesElbHighConnectionErrorsDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'AwsAnomaliesElbHighConnectionErrorsDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.AwsAnomaliesElbHighConnectionErrorsDetectionCustomThresholds']:
        """
        Alert if the condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class AwsAnomaliesElbHighConnectionErrorsDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionErrorsPerMinute":
            suggest = "connection_errors_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesElbHighConnectionErrorsDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesElbHighConnectionErrorsDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesElbHighConnectionErrorsDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_errors_per_minute: int):
        pulumi.set(__self__, "connection_errors_per_minute", connection_errors_per_minute)

    @property
    @pulumi.getter(name="connectionErrorsPerMinute")
    def connection_errors_per_minute(self) -> int:
        return pulumi.get(self, "connection_errors_per_minute")


@pulumi.output_type
class AwsAnomaliesLambdaHighErrorRateDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesLambdaHighErrorRateDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesLambdaHighErrorRateDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesLambdaHighErrorRateDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.AwsAnomaliesLambdaHighErrorRateDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'AwsAnomaliesLambdaHighErrorRateDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.AwsAnomaliesLambdaHighErrorRateDetectionCustomThresholds']:
        """
        Alert if the condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class AwsAnomaliesLambdaHighErrorRateDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failedInvocationsRate":
            suggest = "failed_invocations_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesLambdaHighErrorRateDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesLambdaHighErrorRateDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesLambdaHighErrorRateDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failed_invocations_rate: int):
        pulumi.set(__self__, "failed_invocations_rate", failed_invocations_rate)

    @property
    @pulumi.getter(name="failedInvocationsRate")
    def failed_invocations_rate(self) -> int:
        return pulumi.get(self, "failed_invocations_rate")


@pulumi.output_type
class AwsAnomaliesRdsHighCpuDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsHighCpuDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsHighCpuDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsHighCpuDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.AwsAnomaliesRdsHighCpuDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'AwsAnomaliesRdsHighCpuDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.AwsAnomaliesRdsHighCpuDetectionCustomThresholds']:
        """
        Alert if the condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class AwsAnomaliesRdsHighCpuDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuUsage":
            suggest = "cpu_usage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsHighCpuDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsHighCpuDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsHighCpuDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_usage: float):
        pulumi.set(__self__, "cpu_usage", cpu_usage)

    @property
    @pulumi.getter(name="cpuUsage")
    def cpu_usage(self) -> float:
        return pulumi.get(self, "cpu_usage")


@pulumi.output_type
class AwsAnomaliesRdsHighMemoryDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsHighMemoryDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsHighMemoryDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsHighMemoryDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.AwsAnomaliesRdsHighMemoryDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'AwsAnomaliesRdsHighMemoryDetectionCustomThresholdsArgs' custom_thresholds: Alert if **both** conditions is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.AwsAnomaliesRdsHighMemoryDetectionCustomThresholds']:
        """
        Alert if **both** conditions is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class AwsAnomaliesRdsHighMemoryDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeMemory":
            suggest = "free_memory"
        elif key == "swapUsage":
            suggest = "swap_usage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsHighMemoryDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsHighMemoryDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsHighMemoryDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_memory: float,
                 swap_usage: float):
        pulumi.set(__self__, "free_memory", free_memory)
        pulumi.set(__self__, "swap_usage", swap_usage)

    @property
    @pulumi.getter(name="freeMemory")
    def free_memory(self) -> float:
        return pulumi.get(self, "free_memory")

    @property
    @pulumi.getter(name="swapUsage")
    def swap_usage(self) -> float:
        return pulumi.get(self, "swap_usage")


@pulumi.output_type
class AwsAnomaliesRdsHighWriteReadLatencyDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsHighWriteReadLatencyDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsHighWriteReadLatencyDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsHighWriteReadLatencyDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.AwsAnomaliesRdsHighWriteReadLatencyDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'AwsAnomaliesRdsHighWriteReadLatencyDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.AwsAnomaliesRdsHighWriteReadLatencyDetectionCustomThresholds']:
        """
        Alert if the condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class AwsAnomaliesRdsHighWriteReadLatencyDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readWriteLatency":
            suggest = "read_write_latency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsHighWriteReadLatencyDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsHighWriteReadLatencyDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsHighWriteReadLatencyDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 read_write_latency: int):
        pulumi.set(__self__, "read_write_latency", read_write_latency)

    @property
    @pulumi.getter(name="readWriteLatency")
    def read_write_latency(self) -> int:
        return pulumi.get(self, "read_write_latency")


@pulumi.output_type
class AwsAnomaliesRdsLowStorageDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsLowStorageDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsLowStorageDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsLowStorageDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.AwsAnomaliesRdsLowStorageDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'AwsAnomaliesRdsLowStorageDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.AwsAnomaliesRdsLowStorageDetectionCustomThresholds']:
        """
        Alert if the condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class AwsAnomaliesRdsLowStorageDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeStoragePercentage":
            suggest = "free_storage_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsLowStorageDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsLowStorageDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsLowStorageDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_storage_percentage: int):
        pulumi.set(__self__, "free_storage_percentage", free_storage_percentage)

    @property
    @pulumi.getter(name="freeStoragePercentage")
    def free_storage_percentage(self) -> int:
        return pulumi.get(self, "free_storage_percentage")


@pulumi.output_type
class AwsAnomaliesRdsRestartsSequenceDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsRestartsSequenceDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsRestartsSequenceDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsRestartsSequenceDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.AwsAnomaliesRdsRestartsSequenceDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'AwsAnomaliesRdsRestartsSequenceDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 2 out of 20 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.AwsAnomaliesRdsRestartsSequenceDetectionCustomThresholds']:
        """
        Alert if the condition is met in 2 out of 20 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class AwsAnomaliesRdsRestartsSequenceDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restartsPerMinute":
            suggest = "restarts_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAnomaliesRdsRestartsSequenceDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAnomaliesRdsRestartsSequenceDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAnomaliesRdsRestartsSequenceDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 restarts_per_minute: int):
        pulumi.set(__self__, "restarts_per_minute", restarts_per_minute)

    @property
    @pulumi.getter(name="restartsPerMinute")
    def restarts_per_minute(self) -> int:
        return pulumi.get(self, "restarts_per_minute")


@pulumi.output_type
class AwsCredentialsAuthenticationData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountId":
            suggest = "account_id"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "iamRole":
            suggest = "iam_role"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCredentialsAuthenticationData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCredentialsAuthenticationData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCredentialsAuthenticationData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 account_id: Optional[str] = None,
                 external_id: Optional[str] = None,
                 iam_role: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str access_key: the access key
        :param str account_id: the ID of the Amazon account
        :param str external_id: (Read only) the external ID token for setting an IAM role. You can obtain it with the `GET /aws/iamExternalId` request
        :param str iam_role: the IAM role to be used by Dynatrace to get monitoring data
        :param str secret_key: the secret access key
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if iam_role is not None:
            pulumi.set(__self__, "iam_role", iam_role)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        the access key
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        the ID of the Amazon account
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        (Read only) the external ID token for setting an IAM role. You can obtain it with the `GET /aws/iamExternalId` request
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="iamRole")
    def iam_role(self) -> Optional[str]:
        """
        the IAM role to be used by Dynatrace to get monitoring data
        """
        return pulumi.get(self, "iam_role")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        the secret access key
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AwsCredentialsSupportingServicesToMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitoredMetrics":
            suggest = "monitored_metrics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCredentialsSupportingServicesToMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCredentialsSupportingServicesToMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCredentialsSupportingServicesToMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitored_metrics: Optional[Sequence['outputs.AwsCredentialsSupportingServicesToMonitorMonitoredMetric']] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence['AwsCredentialsSupportingServicesToMonitorMonitoredMetricArgs'] monitored_metrics: a list of metrics to be monitored for this service
        :param str name: the name of the supporting service
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if monitored_metrics is not None:
            pulumi.set(__self__, "monitored_metrics", monitored_metrics)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="monitoredMetrics")
    def monitored_metrics(self) -> Optional[Sequence['outputs.AwsCredentialsSupportingServicesToMonitorMonitoredMetric']]:
        """
        a list of metrics to be monitored for this service
        """
        return pulumi.get(self, "monitored_metrics")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        the name of the supporting service
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AwsCredentialsSupportingServicesToMonitorMonitoredMetric(dict):
    def __init__(__self__, *,
                 dimensions: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 statistic: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AwsCredentialsTagsToMonitor(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: the key of the AWS tag.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: the value of the AWS tag
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        the key of the AWS tag.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        the value of the AWS tag
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AzureCredentialsMonitorOnlyExcludingTagPair(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the tag.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value of the tag.   If set to `null`, then resources with any value of the tag are monitored.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the tag.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag.   If set to `null`, then resources with any value of the tag are monitored.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AzureCredentialsMonitorOnlyTagPair(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the tag.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value of the tag.   If set to `null`, then resources with any value of the tag are monitored.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the tag.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag.   If set to `null`, then resources with any value of the tag are monitored.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AzureCredentialsSupportingService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitoredMetrics":
            suggest = "monitored_metrics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureCredentialsSupportingService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureCredentialsSupportingService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureCredentialsSupportingService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitored_metrics: Optional[Sequence['outputs.AzureCredentialsSupportingServiceMonitoredMetric']] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence['AzureCredentialsSupportingServiceMonitoredMetricArgs'] monitored_metrics: A list of Azure tags to be monitored.  You can specify up to 10 tags. A resource tagged with *any* of the specified tags is monitored.  Only applicable when the **monitorOnlyTaggedEntities** parameter is set to `true`
        :param str name: The name of the supporting service.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if monitored_metrics is not None:
            pulumi.set(__self__, "monitored_metrics", monitored_metrics)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="monitoredMetrics")
    def monitored_metrics(self) -> Optional[Sequence['outputs.AzureCredentialsSupportingServiceMonitoredMetric']]:
        """
        A list of Azure tags to be monitored.  You can specify up to 10 tags. A resource tagged with *any* of the specified tags is monitored.  Only applicable when the **monitorOnlyTaggedEntities** parameter is set to `true`
        """
        return pulumi.get(self, "monitored_metrics")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the supporting service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AzureCredentialsSupportingServiceMonitoredMetric(dict):
    def __init__(__self__, *,
                 dimensions: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class BrowserMonitorAnomalyDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadingTimeThresholds":
            suggest = "loading_time_thresholds"
        elif key == "outageHandlings":
            suggest = "outage_handlings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorAnomalyDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorAnomalyDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorAnomalyDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 loading_time_thresholds: Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionLoadingTimeThreshold']] = None,
                 outage_handlings: Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionOutageHandling']] = None):
        """
        :param Sequence['BrowserMonitorAnomalyDetectionLoadingTimeThresholdArgs'] loading_time_thresholds: Thresholds for loading times
        :param Sequence['BrowserMonitorAnomalyDetectionOutageHandlingArgs'] outage_handlings: Outage handling configuration
        """
        if loading_time_thresholds is not None:
            pulumi.set(__self__, "loading_time_thresholds", loading_time_thresholds)
        if outage_handlings is not None:
            pulumi.set(__self__, "outage_handlings", outage_handlings)

    @property
    @pulumi.getter(name="loadingTimeThresholds")
    def loading_time_thresholds(self) -> Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionLoadingTimeThreshold']]:
        """
        Thresholds for loading times
        """
        return pulumi.get(self, "loading_time_thresholds")

    @property
    @pulumi.getter(name="outageHandlings")
    def outage_handlings(self) -> Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionOutageHandling']]:
        """
        Outage handling configuration
        """
        return pulumi.get(self, "outage_handlings")


@pulumi.output_type
class BrowserMonitorAnomalyDetectionLoadingTimeThreshold(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 thresholds: Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionLoadingTimeThresholdThreshold']] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionLoadingTimeThresholdThreshold']]:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class BrowserMonitorAnomalyDetectionLoadingTimeThresholdThreshold(dict):
    def __init__(__self__, *,
                 thresholds: Sequence['outputs.BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold']):
        pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueMs":
            suggest = "value_ms"
        elif key == "eventIndex":
            suggest = "event_index"
        elif key == "requestIndex":
            suggest = "request_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value_ms: int,
                 event_index: Optional[int] = None,
                 request_index: Optional[int] = None,
                 type: Optional[str] = None):
        pulumi.set(__self__, "value_ms", value_ms)
        if event_index is not None:
            pulumi.set(__self__, "event_index", event_index)
        if request_index is not None:
            pulumi.set(__self__, "request_index", request_index)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="valueMs")
    def value_ms(self) -> int:
        return pulumi.get(self, "value_ms")

    @property
    @pulumi.getter(name="eventIndex")
    def event_index(self) -> Optional[int]:
        return pulumi.get(self, "event_index")

    @property
    @pulumi.getter(name="requestIndex")
    def request_index(self) -> Optional[int]:
        return pulumi.get(self, "request_index")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class BrowserMonitorAnomalyDetectionOutageHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "globalOutage":
            suggest = "global_outage"
        elif key == "globalOutagePolicies":
            suggest = "global_outage_policies"
        elif key == "localOutage":
            suggest = "local_outage"
        elif key == "localOutagePolicies":
            suggest = "local_outage_policies"
        elif key == "retryOnError":
            suggest = "retry_on_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorAnomalyDetectionOutageHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorAnomalyDetectionOutageHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorAnomalyDetectionOutageHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 global_outage: Optional[bool] = None,
                 global_outage_policies: Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy']] = None,
                 local_outage: Optional[bool] = None,
                 local_outage_policies: Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy']] = None,
                 retry_on_error: Optional[bool] = None):
        if global_outage is not None:
            pulumi.set(__self__, "global_outage", global_outage)
        if global_outage_policies is not None:
            pulumi.set(__self__, "global_outage_policies", global_outage_policies)
        if local_outage is not None:
            pulumi.set(__self__, "local_outage", local_outage)
        if local_outage_policies is not None:
            pulumi.set(__self__, "local_outage_policies", local_outage_policies)
        if retry_on_error is not None:
            pulumi.set(__self__, "retry_on_error", retry_on_error)

    @property
    @pulumi.getter(name="globalOutage")
    def global_outage(self) -> Optional[bool]:
        return pulumi.get(self, "global_outage")

    @property
    @pulumi.getter(name="globalOutagePolicies")
    def global_outage_policies(self) -> Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy']]:
        return pulumi.get(self, "global_outage_policies")

    @property
    @pulumi.getter(name="localOutage")
    def local_outage(self) -> Optional[bool]:
        return pulumi.get(self, "local_outage")

    @property
    @pulumi.getter(name="localOutagePolicies")
    def local_outage_policies(self) -> Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy']]:
        return pulumi.get(self, "local_outage_policies")

    @property
    @pulumi.getter(name="retryOnError")
    def retry_on_error(self) -> Optional[bool]:
        return pulumi.get(self, "retry_on_error")


@pulumi.output_type
class BrowserMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consecutiveRuns":
            suggest = "consecutive_runs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consecutive_runs: int):
        pulumi.set(__self__, "consecutive_runs", consecutive_runs)

    @property
    @pulumi.getter(name="consecutiveRuns")
    def consecutive_runs(self) -> int:
        return pulumi.get(self, "consecutive_runs")


@pulumi.output_type
class BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "affectedLocations":
            suggest = "affected_locations"
        elif key == "consecutiveRuns":
            suggest = "consecutive_runs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affected_locations: int,
                 consecutive_runs: int):
        pulumi.set(__self__, "affected_locations", affected_locations)
        pulumi.set(__self__, "consecutive_runs", consecutive_runs)

    @property
    @pulumi.getter(name="affectedLocations")
    def affected_locations(self) -> int:
        return pulumi.get(self, "affected_locations")

    @property
    @pulumi.getter(name="consecutiveRuns")
    def consecutive_runs(self) -> int:
        return pulumi.get(self, "consecutive_runs")


@pulumi.output_type
class BrowserMonitorKeyPerformanceMetrics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadActionKpm":
            suggest = "load_action_kpm"
        elif key == "xhrActionKpm":
            suggest = "xhr_action_kpm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorKeyPerformanceMetrics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorKeyPerformanceMetrics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorKeyPerformanceMetrics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load_action_kpm: str,
                 xhr_action_kpm: str):
        """
        :param str load_action_kpm: Defines the key performance metric for load actions. Supported values are `VISUALLY_COMPLETE`, `SPEED_INDEX`, `USER_ACTION_DURATION`, `TIME_TO_FIRST_BYTE`, `HTML_DOWNLOADED`, `DOM_INTERACTIVE`, `LOAD_EVENT_START` and `LOAD_EVENT_END`.
        :param str xhr_action_kpm: Defines the key performance metric for XHR actions. Supported values are `VISUALLY_COMPLETE`, `USER_ACTION_DURATION`, `TIME_TO_FIRST_BYTE` and `RESPONSE_END`.
        """
        pulumi.set(__self__, "load_action_kpm", load_action_kpm)
        pulumi.set(__self__, "xhr_action_kpm", xhr_action_kpm)

    @property
    @pulumi.getter(name="loadActionKpm")
    def load_action_kpm(self) -> str:
        """
        Defines the key performance metric for load actions. Supported values are `VISUALLY_COMPLETE`, `SPEED_INDEX`, `USER_ACTION_DURATION`, `TIME_TO_FIRST_BYTE`, `HTML_DOWNLOADED`, `DOM_INTERACTIVE`, `LOAD_EVENT_START` and `LOAD_EVENT_END`.
        """
        return pulumi.get(self, "load_action_kpm")

    @property
    @pulumi.getter(name="xhrActionKpm")
    def xhr_action_kpm(self) -> str:
        """
        Defines the key performance metric for XHR actions. Supported values are `VISUALLY_COMPLETE`, `USER_ACTION_DURATION`, `TIME_TO_FIRST_BYTE` and `RESPONSE_END`.
        """
        return pulumi.get(self, "xhr_action_kpm")


@pulumi.output_type
class BrowserMonitorPerformanceThresholds(dict):
    def __init__(__self__, *,
                 thresholds: Sequence['outputs.BrowserMonitorPerformanceThresholdsThreshold']):
        pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.BrowserMonitorPerformanceThresholdsThreshold']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class BrowserMonitorPerformanceThresholdsThreshold(dict):
    def __init__(__self__, *,
                 event: str,
                 threshold: float):
        pulumi.set(__self__, "event", event)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def event(self) -> str:
        return pulumi.get(self, "event")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class BrowserMonitorScript(dict):
    def __init__(__self__, *,
                 type: str,
                 configuration: Optional['outputs.BrowserMonitorScriptConfiguration'] = None,
                 events: Optional['outputs.BrowserMonitorScriptEvents'] = None):
        """
        :param str type: The type of monitor. Possible values are `clickpath` for clickpath monitors and `availability` for single-URL browser monitors. These monitors are only allowed to have one event of the `navigate` type
        :param 'BrowserMonitorScriptConfigurationArgs' configuration: The setup of the monitor
        :param 'BrowserMonitorScriptEventsArgs' events: Steps of the clickpaththe first step must always be of the `navigate` type
        """
        pulumi.set(__self__, "type", type)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if events is not None:
            pulumi.set(__self__, "events", events)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of monitor. Possible values are `clickpath` for clickpath monitors and `availability` for single-URL browser monitors. These monitors are only allowed to have one event of the `navigate` type
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.BrowserMonitorScriptConfiguration']:
        """
        The setup of the monitor
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def events(self) -> Optional['outputs.BrowserMonitorScriptEvents']:
        """
        Steps of the clickpaththe first step must always be of the `navigate` type
        """
        return pulumi.get(self, "events")


@pulumi.output_type
class BrowserMonitorScriptConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bypassCsp":
            suggest = "bypass_csp"
        elif key == "disableWebSecurity":
            suggest = "disable_web_security"
        elif key == "ignoredErrorCodes":
            suggest = "ignored_error_codes"
        elif key == "javascriptSetttings":
            suggest = "javascript_setttings"
        elif key == "monitorFrames":
            suggest = "monitor_frames"
        elif key == "userAgent":
            suggest = "user_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth: Optional['outputs.BrowserMonitorScriptConfigurationBandwidth'] = None,
                 blocks: Optional[Sequence[str]] = None,
                 bypass_csp: Optional[bool] = None,
                 cookies: Optional['outputs.BrowserMonitorScriptConfigurationCookies'] = None,
                 device: Optional['outputs.BrowserMonitorScriptConfigurationDevice'] = None,
                 disable_web_security: Optional[bool] = None,
                 headers: Optional['outputs.BrowserMonitorScriptConfigurationHeaders'] = None,
                 ignored_error_codes: Optional['outputs.BrowserMonitorScriptConfigurationIgnoredErrorCodes'] = None,
                 javascript_setttings: Optional['outputs.BrowserMonitorScriptConfigurationJavascriptSetttings'] = None,
                 monitor_frames: Optional[bool] = None,
                 user_agent: Optional[str] = None):
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if blocks is not None:
            pulumi.set(__self__, "blocks", blocks)
        if bypass_csp is not None:
            pulumi.set(__self__, "bypass_csp", bypass_csp)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if disable_web_security is not None:
            pulumi.set(__self__, "disable_web_security", disable_web_security)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ignored_error_codes is not None:
            pulumi.set(__self__, "ignored_error_codes", ignored_error_codes)
        if javascript_setttings is not None:
            pulumi.set(__self__, "javascript_setttings", javascript_setttings)
        if monitor_frames is not None:
            pulumi.set(__self__, "monitor_frames", monitor_frames)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional['outputs.BrowserMonitorScriptConfigurationBandwidth']:
        return pulumi.get(self, "bandwidth")

    @property
    @pulumi.getter
    def blocks(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "blocks")

    @property
    @pulumi.getter(name="bypassCsp")
    def bypass_csp(self) -> Optional[bool]:
        return pulumi.get(self, "bypass_csp")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.BrowserMonitorScriptConfigurationCookies']:
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def device(self) -> Optional['outputs.BrowserMonitorScriptConfigurationDevice']:
        return pulumi.get(self, "device")

    @property
    @pulumi.getter(name="disableWebSecurity")
    def disable_web_security(self) -> Optional[bool]:
        return pulumi.get(self, "disable_web_security")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.BrowserMonitorScriptConfigurationHeaders']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ignoredErrorCodes")
    def ignored_error_codes(self) -> Optional['outputs.BrowserMonitorScriptConfigurationIgnoredErrorCodes']:
        return pulumi.get(self, "ignored_error_codes")

    @property
    @pulumi.getter(name="javascriptSetttings")
    def javascript_setttings(self) -> Optional['outputs.BrowserMonitorScriptConfigurationJavascriptSetttings']:
        return pulumi.get(self, "javascript_setttings")

    @property
    @pulumi.getter(name="monitorFrames")
    def monitor_frames(self) -> Optional[bool]:
        return pulumi.get(self, "monitor_frames")

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[str]:
        return pulumi.get(self, "user_agent")


@pulumi.output_type
class BrowserMonitorScriptConfigurationBandwidth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkType":
            suggest = "network_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfigurationBandwidth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfigurationBandwidth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfigurationBandwidth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 download: Optional[int] = None,
                 latency: Optional[int] = None,
                 network_type: Optional[str] = None,
                 upload: Optional[int] = None):
        if download is not None:
            pulumi.set(__self__, "download", download)
        if latency is not None:
            pulumi.set(__self__, "latency", latency)
        if network_type is not None:
            pulumi.set(__self__, "network_type", network_type)
        if upload is not None:
            pulumi.set(__self__, "upload", upload)

    @property
    @pulumi.getter
    def download(self) -> Optional[int]:
        return pulumi.get(self, "download")

    @property
    @pulumi.getter
    def latency(self) -> Optional[int]:
        return pulumi.get(self, "latency")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[str]:
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter
    def upload(self) -> Optional[int]:
        return pulumi.get(self, "upload")


@pulumi.output_type
class BrowserMonitorScriptConfigurationCookies(dict):
    def __init__(__self__, *,
                 cookies: Sequence['outputs.BrowserMonitorScriptConfigurationCookiesCookie']):
        pulumi.set(__self__, "cookies", cookies)

    @property
    @pulumi.getter
    def cookies(self) -> Sequence['outputs.BrowserMonitorScriptConfigurationCookiesCookie']:
        return pulumi.get(self, "cookies")


@pulumi.output_type
class BrowserMonitorScriptConfigurationCookiesCookie(dict):
    def __init__(__self__, *,
                 domain: str,
                 name: str,
                 value: str,
                 path: Optional[str] = None):
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def domain(self) -> str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class BrowserMonitorScriptConfigurationDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleFactor":
            suggest = "scale_factor"
        elif key == "touchEnabled":
            suggest = "touch_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfigurationDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfigurationDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfigurationDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 height: Optional[int] = None,
                 mobile: Optional[bool] = None,
                 name: Optional[str] = None,
                 orientation: Optional[str] = None,
                 scale_factor: Optional[float] = None,
                 touch_enabled: Optional[bool] = None,
                 width: Optional[int] = None):
        if height is not None:
            pulumi.set(__self__, "height", height)
        if mobile is not None:
            pulumi.set(__self__, "mobile", mobile)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if orientation is not None:
            pulumi.set(__self__, "orientation", orientation)
        if scale_factor is not None:
            pulumi.set(__self__, "scale_factor", scale_factor)
        if touch_enabled is not None:
            pulumi.set(__self__, "touch_enabled", touch_enabled)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def mobile(self) -> Optional[bool]:
        return pulumi.get(self, "mobile")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def orientation(self) -> Optional[str]:
        return pulumi.get(self, "orientation")

    @property
    @pulumi.getter(name="scaleFactor")
    def scale_factor(self) -> Optional[float]:
        return pulumi.get(self, "scale_factor")

    @property
    @pulumi.getter(name="touchEnabled")
    def touch_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "touch_enabled")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        return pulumi.get(self, "width")


@pulumi.output_type
class BrowserMonitorScriptConfigurationHeaders(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.BrowserMonitorScriptConfigurationHeadersHeader'],
                 restrictions: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "headers", headers)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.BrowserMonitorScriptConfigurationHeadersHeader']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "restrictions")


@pulumi.output_type
class BrowserMonitorScriptConfigurationHeadersHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptConfigurationIgnoredErrorCodes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodes":
            suggest = "status_codes"
        elif key == "matchingDocumentRequests":
            suggest = "matching_document_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfigurationIgnoredErrorCodes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfigurationIgnoredErrorCodes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfigurationIgnoredErrorCodes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_codes: str,
                 matching_document_requests: Optional[str] = None):
        pulumi.set(__self__, "status_codes", status_codes)
        if matching_document_requests is not None:
            pulumi.set(__self__, "matching_document_requests", matching_document_requests)

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> str:
        return pulumi.get(self, "status_codes")

    @property
    @pulumi.getter(name="matchingDocumentRequests")
    def matching_document_requests(self) -> Optional[str]:
        return pulumi.get(self, "matching_document_requests")


@pulumi.output_type
class BrowserMonitorScriptConfigurationJavascriptSetttings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customProperties":
            suggest = "custom_properties"
        elif key == "timeoutSettings":
            suggest = "timeout_settings"
        elif key == "visuallyCompleteOptions":
            suggest = "visually_complete_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfigurationJavascriptSetttings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfigurationJavascriptSetttings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfigurationJavascriptSetttings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_properties: Optional[str] = None,
                 timeout_settings: Optional['outputs.BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings'] = None,
                 visually_complete_options: Optional['outputs.BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions'] = None):
        if custom_properties is not None:
            pulumi.set(__self__, "custom_properties", custom_properties)
        if timeout_settings is not None:
            pulumi.set(__self__, "timeout_settings", timeout_settings)
        if visually_complete_options is not None:
            pulumi.set(__self__, "visually_complete_options", visually_complete_options)

    @property
    @pulumi.getter(name="customProperties")
    def custom_properties(self) -> Optional[str]:
        return pulumi.get(self, "custom_properties")

    @property
    @pulumi.getter(name="timeoutSettings")
    def timeout_settings(self) -> Optional['outputs.BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings']:
        return pulumi.get(self, "timeout_settings")

    @property
    @pulumi.getter(name="visuallyCompleteOptions")
    def visually_complete_options(self) -> Optional['outputs.BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions']:
        return pulumi.get(self, "visually_complete_options")


@pulumi.output_type
class BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionLimit":
            suggest = "action_limit"
        elif key == "totalTimeout":
            suggest = "total_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_limit: int,
                 total_timeout: int):
        pulumi.set(__self__, "action_limit", action_limit)
        pulumi.set(__self__, "total_timeout", total_timeout)

    @property
    @pulumi.getter(name="actionLimit")
    def action_limit(self) -> int:
        return pulumi.get(self, "action_limit")

    @property
    @pulumi.getter(name="totalTimeout")
    def total_timeout(self) -> int:
        return pulumi.get(self, "total_timeout")


@pulumi.output_type
class BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageSizeThreshold":
            suggest = "image_size_threshold"
        elif key == "inactivityTimeout":
            suggest = "inactivity_timeout"
        elif key == "mutationTimeout":
            suggest = "mutation_timeout"
        elif key == "excludedElements":
            suggest = "excluded_elements"
        elif key == "excludedUrls":
            suggest = "excluded_urls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_size_threshold: int,
                 inactivity_timeout: int,
                 mutation_timeout: int,
                 excluded_elements: Optional[Sequence[str]] = None,
                 excluded_urls: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "image_size_threshold", image_size_threshold)
        pulumi.set(__self__, "inactivity_timeout", inactivity_timeout)
        pulumi.set(__self__, "mutation_timeout", mutation_timeout)
        if excluded_elements is not None:
            pulumi.set(__self__, "excluded_elements", excluded_elements)
        if excluded_urls is not None:
            pulumi.set(__self__, "excluded_urls", excluded_urls)

    @property
    @pulumi.getter(name="imageSizeThreshold")
    def image_size_threshold(self) -> int:
        return pulumi.get(self, "image_size_threshold")

    @property
    @pulumi.getter(name="inactivityTimeout")
    def inactivity_timeout(self) -> int:
        return pulumi.get(self, "inactivity_timeout")

    @property
    @pulumi.getter(name="mutationTimeout")
    def mutation_timeout(self) -> int:
        return pulumi.get(self, "mutation_timeout")

    @property
    @pulumi.getter(name="excludedElements")
    def excluded_elements(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_elements")

    @property
    @pulumi.getter(name="excludedUrls")
    def excluded_urls(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_urls")


@pulumi.output_type
class BrowserMonitorScriptEvents(dict):
    def __init__(__self__, *,
                 events: Optional[Sequence['outputs.BrowserMonitorScriptEventsEvent']] = None):
        if events is not None:
            pulumi.set(__self__, "events", events)

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEvent']]:
        return pulumi.get(self, "events")


@pulumi.output_type
class BrowserMonitorScriptEventsEvent(dict):
    def __init__(__self__, *,
                 description: str,
                 click: Optional['outputs.BrowserMonitorScriptEventsEventClick'] = None,
                 cookie: Optional['outputs.BrowserMonitorScriptEventsEventCookie'] = None,
                 javascript: Optional['outputs.BrowserMonitorScriptEventsEventJavascript'] = None,
                 keystrokes: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokes'] = None,
                 navigate: Optional['outputs.BrowserMonitorScriptEventsEventNavigate'] = None,
                 select: Optional['outputs.BrowserMonitorScriptEventsEventSelect'] = None,
                 tap: Optional['outputs.BrowserMonitorScriptEventsEventTap'] = None):
        pulumi.set(__self__, "description", description)
        if click is not None:
            pulumi.set(__self__, "click", click)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if javascript is not None:
            pulumi.set(__self__, "javascript", javascript)
        if keystrokes is not None:
            pulumi.set(__self__, "keystrokes", keystrokes)
        if navigate is not None:
            pulumi.set(__self__, "navigate", navigate)
        if select is not None:
            pulumi.set(__self__, "select", select)
        if tap is not None:
            pulumi.set(__self__, "tap", tap)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def click(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClick']:
        return pulumi.get(self, "click")

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.BrowserMonitorScriptEventsEventCookie']:
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter
    def javascript(self) -> Optional['outputs.BrowserMonitorScriptEventsEventJavascript']:
        return pulumi.get(self, "javascript")

    @property
    @pulumi.getter
    def keystrokes(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokes']:
        return pulumi.get(self, "keystrokes")

    @property
    @pulumi.getter
    def navigate(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigate']:
        return pulumi.get(self, "navigate")

    @property
    @pulumi.getter
    def select(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelect']:
        return pulumi.get(self, "select")

    @property
    @pulumi.getter
    def tap(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTap']:
        return pulumi.get(self, "tap")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClick(dict):
    def __init__(__self__, *,
                 button: int,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventClickTarget'] = None,
                 validate: Optional['outputs.BrowserMonitorScriptEventsEventClickValidate'] = None,
                 wait: Optional['outputs.BrowserMonitorScriptEventsEventClickWait'] = None):
        pulumi.set(__self__, "button", button)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if validate is not None:
            pulumi.set(__self__, "validate", validate)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def button(self) -> int:
        return pulumi.get(self, "button")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClickTarget']:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def validate(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClickValidate']:
        return pulumi.get(self, "validate")

    @property
    @pulumi.getter
    def wait(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClickWait']:
        return pulumi.get(self, "wait")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventClickTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventClickTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventClickTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventClickTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickValidate(dict):
    def __init__(__self__, *,
                 validations: Sequence['outputs.BrowserMonitorScriptEventsEventClickValidateValidation']):
        pulumi.set(__self__, "validations", validations)

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventClickValidateValidation']:
        return pulumi.get(self, "validations")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickValidateValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventClickValidateValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventClickValidateValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventClickValidateValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventClickValidateValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClickValidateValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickValidateValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventClickValidateValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventClickValidateValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickValidateValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventClickValidateValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventClickValidateValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickValidateValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickWait(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitFor":
            suggest = "wait_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventClickWait. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventClickWait.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventClickWait.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_for: str,
                 milliseconds: Optional[int] = None,
                 timeout: Optional[int] = None,
                 validation: Optional['outputs.BrowserMonitorScriptEventsEventClickWaitValidation'] = None):
        pulumi.set(__self__, "wait_for", wait_for)
        if milliseconds is not None:
            pulumi.set(__self__, "milliseconds", milliseconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter(name="waitFor")
    def wait_for(self) -> str:
        return pulumi.get(self, "wait_for")

    @property
    @pulumi.getter
    def milliseconds(self) -> Optional[int]:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClickWaitValidation']:
        return pulumi.get(self, "validation")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickWaitValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventClickWaitValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventClickWaitValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventClickWaitValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventClickWaitValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClickWaitValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickWaitValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventClickWaitValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventClickWaitValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickWaitValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventClickWaitValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventClickWaitValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickWaitValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventCookie(dict):
    def __init__(__self__, *,
                 cookies: 'outputs.BrowserMonitorScriptEventsEventCookieCookies'):
        pulumi.set(__self__, "cookies", cookies)

    @property
    @pulumi.getter
    def cookies(self) -> 'outputs.BrowserMonitorScriptEventsEventCookieCookies':
        return pulumi.get(self, "cookies")


@pulumi.output_type
class BrowserMonitorScriptEventsEventCookieCookies(dict):
    def __init__(__self__, *,
                 cookies: Sequence['outputs.BrowserMonitorScriptEventsEventCookieCookiesCookie']):
        pulumi.set(__self__, "cookies", cookies)

    @property
    @pulumi.getter
    def cookies(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventCookieCookiesCookie']:
        return pulumi.get(self, "cookies")


@pulumi.output_type
class BrowserMonitorScriptEventsEventCookieCookiesCookie(dict):
    def __init__(__self__, *,
                 domain: str,
                 name: str,
                 value: str,
                 path: Optional[str] = None):
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def domain(self) -> str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascript(dict):
    def __init__(__self__, *,
                 code: str,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventJavascriptTarget'] = None,
                 wait: Optional['outputs.BrowserMonitorScriptEventsEventJavascriptWait'] = None):
        pulumi.set(__self__, "code", code)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def code(self) -> str:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventJavascriptTarget']:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def wait(self) -> Optional['outputs.BrowserMonitorScriptEventsEventJavascriptWait']:
        return pulumi.get(self, "wait")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptWait(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitFor":
            suggest = "wait_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventJavascriptWait. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventJavascriptWait.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventJavascriptWait.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_for: str,
                 milliseconds: Optional[int] = None,
                 timeout: Optional[int] = None,
                 validation: Optional['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidation'] = None):
        pulumi.set(__self__, "wait_for", wait_for)
        if milliseconds is not None:
            pulumi.set(__self__, "milliseconds", milliseconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter(name="waitFor")
    def wait_for(self) -> str:
        return pulumi.get(self, "wait_for")

    @property
    @pulumi.getter
    def milliseconds(self) -> Optional[int]:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidation']:
        return pulumi.get(self, "validation")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptWaitValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventJavascriptWaitValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventJavascriptWaitValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventJavascriptWaitValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptWaitValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "simulateBlurEvent":
            suggest = "simulate_blur_event"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventKeystrokes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventKeystrokes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventKeystrokes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credential: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesCredential'] = None,
                 masked: Optional[bool] = None,
                 simulate_blur_event: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesTarget'] = None,
                 text: Optional[str] = None,
                 validate: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesValidate'] = None,
                 wait: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesWait'] = None):
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if masked is not None:
            pulumi.set(__self__, "masked", masked)
        if simulate_blur_event is not None:
            pulumi.set(__self__, "simulate_blur_event", simulate_blur_event)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if validate is not None:
            pulumi.set(__self__, "validate", validate)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def credential(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesCredential']:
        return pulumi.get(self, "credential")

    @property
    @pulumi.getter
    def masked(self) -> Optional[bool]:
        return pulumi.get(self, "masked")

    @property
    @pulumi.getter(name="simulateBlurEvent")
    def simulate_blur_event(self) -> Optional[bool]:
        return pulumi.get(self, "simulate_blur_event")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesTarget']:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def validate(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesValidate']:
        return pulumi.get(self, "validate")

    @property
    @pulumi.getter
    def wait(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesWait']:
        return pulumi.get(self, "wait")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesCredential(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vaultId":
            suggest = "vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventKeystrokesCredential. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesCredential.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesCredential.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: str,
                 vault_id: str):
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter
    def field(self) -> str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesValidate(dict):
    def __init__(__self__, *,
                 validations: Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidation']):
        pulumi.set(__self__, "validations", validations)

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidation']:
        return pulumi.get(self, "validations")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesValidateValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventKeystrokesValidateValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesValidateValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesValidateValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesValidateValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesWait(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitFor":
            suggest = "wait_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventKeystrokesWait. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesWait.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesWait.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_for: str,
                 milliseconds: Optional[int] = None,
                 timeout: Optional[int] = None,
                 validation: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidation'] = None):
        pulumi.set(__self__, "wait_for", wait_for)
        if milliseconds is not None:
            pulumi.set(__self__, "milliseconds", milliseconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter(name="waitFor")
    def wait_for(self) -> str:
        return pulumi.get(self, "wait_for")

    @property
    @pulumi.getter
    def milliseconds(self) -> Optional[int]:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidation']:
        return pulumi.get(self, "validation")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesWaitValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventKeystrokesWaitValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesWaitValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesWaitValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesWaitValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigate(dict):
    def __init__(__self__, *,
                 url: str,
                 authentication: Optional['outputs.BrowserMonitorScriptEventsEventNavigateAuthentication'] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventNavigateTarget'] = None,
                 validate: Optional['outputs.BrowserMonitorScriptEventsEventNavigateValidate'] = None,
                 wait: Optional['outputs.BrowserMonitorScriptEventsEventNavigateWait'] = None):
        pulumi.set(__self__, "url", url)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if validate is not None:
            pulumi.set(__self__, "validate", validate)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateAuthentication']:
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateTarget']:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def validate(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateValidate']:
        return pulumi.get(self, "validate")

    @property
    @pulumi.getter
    def wait(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateWait']:
        return pulumi.get(self, "wait")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateAuthentication(dict):
    def __init__(__self__, *,
                 creds: str,
                 type: str):
        pulumi.set(__self__, "creds", creds)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def creds(self) -> str:
        return pulumi.get(self, "creds")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventNavigateTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventNavigateTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventNavigateTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventNavigateTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateValidate(dict):
    def __init__(__self__, *,
                 validations: Sequence['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidation']):
        pulumi.set(__self__, "validations", validations)

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidation']:
        return pulumi.get(self, "validations")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateValidateValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventNavigateValidateValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventNavigateValidateValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventNavigateValidateValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateValidateValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateWait(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitFor":
            suggest = "wait_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventNavigateWait. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventNavigateWait.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventNavigateWait.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_for: str,
                 milliseconds: Optional[int] = None,
                 timeout: Optional[int] = None,
                 validation: Optional['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidation'] = None):
        pulumi.set(__self__, "wait_for", wait_for)
        if milliseconds is not None:
            pulumi.set(__self__, "milliseconds", milliseconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter(name="waitFor")
    def wait_for(self) -> str:
        return pulumi.get(self, "wait_for")

    @property
    @pulumi.getter
    def milliseconds(self) -> Optional[int]:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidation']:
        return pulumi.get(self, "validation")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateWaitValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventNavigateWaitValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventNavigateWaitValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventNavigateWaitValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateWaitValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelect(dict):
    def __init__(__self__, *,
                 selections: 'outputs.BrowserMonitorScriptEventsEventSelectSelections',
                 target: Optional['outputs.BrowserMonitorScriptEventsEventSelectTarget'] = None,
                 validate: Optional['outputs.BrowserMonitorScriptEventsEventSelectValidate'] = None,
                 wait: Optional['outputs.BrowserMonitorScriptEventsEventSelectWait'] = None):
        pulumi.set(__self__, "selections", selections)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if validate is not None:
            pulumi.set(__self__, "validate", validate)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def selections(self) -> 'outputs.BrowserMonitorScriptEventsEventSelectSelections':
        return pulumi.get(self, "selections")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelectTarget']:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def validate(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelectValidate']:
        return pulumi.get(self, "validate")

    @property
    @pulumi.getter
    def wait(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelectWait']:
        return pulumi.get(self, "wait")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectSelections(dict):
    def __init__(__self__, *,
                 options: Sequence['outputs.BrowserMonitorScriptEventsEventSelectSelectionsOption']):
        pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def options(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventSelectSelectionsOption']:
        return pulumi.get(self, "options")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectSelectionsOption(dict):
    def __init__(__self__, *,
                 index: int,
                 value: str):
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def index(self) -> int:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventSelectTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventSelectTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventSelectTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventSelectTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectValidate(dict):
    def __init__(__self__, *,
                 validations: Sequence['outputs.BrowserMonitorScriptEventsEventSelectValidateValidation']):
        pulumi.set(__self__, "validations", validations)

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventSelectValidateValidation']:
        return pulumi.get(self, "validations")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectValidateValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventSelectValidateValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventSelectValidateValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventSelectValidateValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectValidateValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectWait(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitFor":
            suggest = "wait_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventSelectWait. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventSelectWait.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventSelectWait.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_for: str,
                 milliseconds: Optional[int] = None,
                 timeout: Optional[int] = None,
                 validation: Optional['outputs.BrowserMonitorScriptEventsEventSelectWaitValidation'] = None):
        pulumi.set(__self__, "wait_for", wait_for)
        if milliseconds is not None:
            pulumi.set(__self__, "milliseconds", milliseconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter(name="waitFor")
    def wait_for(self) -> str:
        return pulumi.get(self, "wait_for")

    @property
    @pulumi.getter
    def milliseconds(self) -> Optional[int]:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelectWaitValidation']:
        return pulumi.get(self, "validation")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectWaitValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventSelectWaitValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventSelectWaitValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventSelectWaitValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectWaitValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTap(dict):
    def __init__(__self__, *,
                 button: int,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventTapTarget'] = None,
                 validate: Optional['outputs.BrowserMonitorScriptEventsEventTapValidate'] = None,
                 wait: Optional['outputs.BrowserMonitorScriptEventsEventTapWait'] = None):
        pulumi.set(__self__, "button", button)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if validate is not None:
            pulumi.set(__self__, "validate", validate)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def button(self) -> int:
        return pulumi.get(self, "button")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTapTarget']:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def validate(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTapValidate']:
        return pulumi.get(self, "validate")

    @property
    @pulumi.getter
    def wait(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTapWait']:
        return pulumi.get(self, "wait")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventTapTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventTapTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventTapTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventTapTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapValidate(dict):
    def __init__(__self__, *,
                 validations: Sequence['outputs.BrowserMonitorScriptEventsEventTapValidateValidation']):
        pulumi.set(__self__, "validations", validations)

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventTapValidateValidation']:
        return pulumi.get(self, "validations")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapValidateValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventTapValidateValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventTapValidateValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventTapValidateValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventTapValidateValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTapValidateValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapValidateValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventTapValidateValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventTapValidateValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapValidateValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventTapValidateValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventTapValidateValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapValidateValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapWait(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitFor":
            suggest = "wait_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventTapWait. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventTapWait.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventTapWait.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_for: str,
                 milliseconds: Optional[int] = None,
                 timeout: Optional[int] = None,
                 validation: Optional['outputs.BrowserMonitorScriptEventsEventTapWaitValidation'] = None):
        pulumi.set(__self__, "wait_for", wait_for)
        if milliseconds is not None:
            pulumi.set(__self__, "milliseconds", milliseconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter(name="waitFor")
    def wait_for(self) -> str:
        return pulumi.get(self, "wait_for")

    @property
    @pulumi.getter
    def milliseconds(self) -> Optional[int]:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTapWaitValidation']:
        return pulumi.get(self, "validation")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapWaitValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventTapWaitValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventTapWaitValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventTapWaitValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventTapWaitValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTapWaitValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapWaitValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventTapWaitValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventTapWaitValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapWaitValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventTapWaitValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventTapWaitValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapWaitValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorTag(dict):
    def __init__(__self__, *,
                 tags: Optional[Sequence['outputs.BrowserMonitorTagTag']] = None):
        """
        :param Sequence['BrowserMonitorTagTagArgs'] tags: Tag with source of a Dynatrace entity.
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.BrowserMonitorTagTag']]:
        """
        Tag with source of a Dynatrace entity.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BrowserMonitorTagTag(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 source: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class BusinessEventsOneagentEvent(dict):
    def __init__(__self__, *,
                 category: 'outputs.BusinessEventsOneagentEventCategory',
                 provider: 'outputs.BusinessEventsOneagentEventProvider',
                 type: 'outputs.BusinessEventsOneagentEventType',
                 data: Optional['outputs.BusinessEventsOneagentEventData'] = None):
        """
        :param 'BusinessEventsOneagentEventCategoryArgs' category: Event category
        :param 'BusinessEventsOneagentEventProviderArgs' provider: Event provider
        :param 'BusinessEventsOneagentEventTypeArgs' type: Event type
        :param 'BusinessEventsOneagentEventDataArgs' data: Additional attributes for the business event.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "type", type)
        if data is not None:
            pulumi.set(__self__, "data", data)

    @property
    @pulumi.getter
    def category(self) -> 'outputs.BusinessEventsOneagentEventCategory':
        """
        Event category
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def provider(self) -> 'outputs.BusinessEventsOneagentEventProvider':
        """
        Event provider
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def type(self) -> 'outputs.BusinessEventsOneagentEventType':
        """
        Event type
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def data(self) -> Optional['outputs.BusinessEventsOneagentEventData']:
        """
        Additional attributes for the business event.
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class BusinessEventsOneagentEventCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentEventCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentEventCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentEventCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 path: Optional[str] = None,
                 source: Optional[str] = None):
        pulumi.set(__self__, "source_type", source_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class BusinessEventsOneagentEventData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventDataFieldComplexes":
            suggest = "event_data_field_complexes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentEventData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentEventData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentEventData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_data_field_complexes: Sequence['outputs.BusinessEventsOneagentEventDataEventDataFieldComplex']):
        pulumi.set(__self__, "event_data_field_complexes", event_data_field_complexes)

    @property
    @pulumi.getter(name="eventDataFieldComplexes")
    def event_data_field_complexes(self) -> Sequence['outputs.BusinessEventsOneagentEventDataEventDataFieldComplex']:
        return pulumi.get(self, "event_data_field_complexes")


@pulumi.output_type
class BusinessEventsOneagentEventDataEventDataFieldComplex(dict):
    def __init__(__self__, *,
                 name: str,
                 source: 'outputs.BusinessEventsOneagentEventDataEventDataFieldComplexSource'):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def source(self) -> 'outputs.BusinessEventsOneagentEventDataEventDataFieldComplexSource':
        return pulumi.get(self, "source")


@pulumi.output_type
class BusinessEventsOneagentEventDataEventDataFieldComplexSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentEventDataEventDataFieldComplexSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentEventDataEventDataFieldComplexSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentEventDataEventDataFieldComplexSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 path: Optional[str] = None,
                 source: Optional[str] = None):
        pulumi.set(__self__, "source_type", source_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class BusinessEventsOneagentEventProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentEventProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentEventProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentEventProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 path: Optional[str] = None,
                 source: Optional[str] = None):
        pulumi.set(__self__, "source_type", source_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class BusinessEventsOneagentEventType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentEventType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentEventType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentEventType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 path: Optional[str] = None,
                 source: Optional[str] = None):
        pulumi.set(__self__, "source_type", source_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class BusinessEventsOneagentTriggers(dict):
    def __init__(__self__, *,
                 triggers: Sequence['outputs.BusinessEventsOneagentTriggersTrigger']):
        pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter
    def triggers(self) -> Sequence['outputs.BusinessEventsOneagentTriggersTrigger']:
        return pulumi.get(self, "triggers")


@pulumi.output_type
class BusinessEventsOneagentTriggersTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentTriggersTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentTriggersTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentTriggersTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: 'outputs.BusinessEventsOneagentTriggersTriggerSource',
                 type: str,
                 case_sensitive: Optional[bool] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "type", type)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def source(self) -> 'outputs.BusinessEventsOneagentTriggersTriggerSource':
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class BusinessEventsOneagentTriggersTriggerSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsOneagentTriggersTriggerSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsOneagentTriggersTriggerSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsOneagentTriggersTriggerSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 path: Optional[str] = None):
        pulumi.set(__self__, "data_source", data_source)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class BusinessEventsProcessingRuleTesting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sampleEvent":
            suggest = "sample_event"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsProcessingRuleTesting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsProcessingRuleTesting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsProcessingRuleTesting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sample_event: str):
        pulumi.set(__self__, "sample_event", sample_event)

    @property
    @pulumi.getter(name="sampleEvent")
    def sample_event(self) -> str:
        return pulumi.get(self, "sample_event")


@pulumi.output_type
class BusinessEventsProcessingTransformationFields(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationFields":
            suggest = "transformation_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BusinessEventsProcessingTransformationFields. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BusinessEventsProcessingTransformationFields.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BusinessEventsProcessingTransformationFields.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_fields: Sequence['outputs.BusinessEventsProcessingTransformationFieldsTransformationField']):
        pulumi.set(__self__, "transformation_fields", transformation_fields)

    @property
    @pulumi.getter(name="transformationFields")
    def transformation_fields(self) -> Sequence['outputs.BusinessEventsProcessingTransformationFieldsTransformationField']:
        return pulumi.get(self, "transformation_fields")


@pulumi.output_type
class BusinessEventsProcessingTransformationFieldsTransformationField(dict):
    def __init__(__self__, *,
                 array: bool,
                 name: str,
                 optional: bool,
                 readonly: bool,
                 type: str):
        pulumi.set(__self__, "array", array)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "optional", optional)
        pulumi.set(__self__, "readonly", readonly)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def array(self) -> bool:
        return pulumi.get(self, "array")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> bool:
        return pulumi.get(self, "optional")

    @property
    @pulumi.getter
    def readonly(self) -> bool:
        return pulumi.get(self, "readonly")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class CalculatedServiceMetricCondition(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.CalculatedServiceMetricConditionCondition']] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.CalculatedServiceMetricConditionCondition']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class CalculatedServiceMetricConditionCondition(dict):
    def __init__(__self__, *,
                 attribute: str,
                 comparison: 'outputs.CalculatedServiceMetricConditionConditionComparison',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "comparison", comparison)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def comparison(self) -> 'outputs.CalculatedServiceMetricConditionConditionComparison':
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "esbInputNodeType":
            suggest = "esb_input_node_type"
        elif key == "failedState":
            suggest = "failed_state"
        elif key == "failureReason":
            suggest = "failure_reason"
        elif key == "fastString":
            suggest = "fast_string"
        elif key == "flawState":
            suggest = "flaw_state"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "httpStatusClass":
            suggest = "http_status_class"
        elif key == "iibInputNodeType":
            suggest = "iib_input_node_type"
        elif key == "numberRequestAttribute":
            suggest = "number_request_attribute"
        elif key == "serviceType":
            suggest = "service_type"
        elif key == "stringRequestAttribute":
            suggest = "string_request_attribute"
        elif key == "zosCallType":
            suggest = "zos_call_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boolean: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonBoolean'] = None,
                 esb_input_node_type: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonEsbInputNodeType'] = None,
                 failed_state: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFailedState'] = None,
                 failure_reason: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFailureReason'] = None,
                 fast_string: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFastString'] = None,
                 flaw_state: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFlawState'] = None,
                 generic: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonGeneric'] = None,
                 http_method: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonHttpMethod'] = None,
                 http_status_class: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonHttpStatusClass'] = None,
                 iib_input_node_type: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonIibInputNodeType'] = None,
                 negate: Optional[bool] = None,
                 number: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumber'] = None,
                 number_request_attribute: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute'] = None,
                 service_type: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonServiceType'] = None,
                 string: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonString'] = None,
                 string_request_attribute: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute'] = None,
                 tag: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonTag'] = None,
                 zos_call_type: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonZosCallType'] = None):
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if esb_input_node_type is not None:
            pulumi.set(__self__, "esb_input_node_type", esb_input_node_type)
        if failed_state is not None:
            pulumi.set(__self__, "failed_state", failed_state)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if fast_string is not None:
            pulumi.set(__self__, "fast_string", fast_string)
        if flaw_state is not None:
            pulumi.set(__self__, "flaw_state", flaw_state)
        if generic is not None:
            pulumi.set(__self__, "generic", generic)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if http_status_class is not None:
            pulumi.set(__self__, "http_status_class", http_status_class)
        if iib_input_node_type is not None:
            pulumi.set(__self__, "iib_input_node_type", iib_input_node_type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if number_request_attribute is not None:
            pulumi.set(__self__, "number_request_attribute", number_request_attribute)
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_request_attribute is not None:
            pulumi.set(__self__, "string_request_attribute", string_request_attribute)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if zos_call_type is not None:
            pulumi.set(__self__, "zos_call_type", zos_call_type)

    @property
    @pulumi.getter
    def boolean(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonBoolean']:
        return pulumi.get(self, "boolean")

    @property
    @pulumi.getter(name="esbInputNodeType")
    def esb_input_node_type(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonEsbInputNodeType']:
        return pulumi.get(self, "esb_input_node_type")

    @property
    @pulumi.getter(name="failedState")
    def failed_state(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFailedState']:
        return pulumi.get(self, "failed_state")

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFailureReason']:
        return pulumi.get(self, "failure_reason")

    @property
    @pulumi.getter(name="fastString")
    def fast_string(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFastString']:
        return pulumi.get(self, "fast_string")

    @property
    @pulumi.getter(name="flawState")
    def flaw_state(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFlawState']:
        return pulumi.get(self, "flaw_state")

    @property
    @pulumi.getter
    def generic(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonGeneric']:
        return pulumi.get(self, "generic")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonHttpMethod']:
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter(name="httpStatusClass")
    def http_status_class(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonHttpStatusClass']:
        return pulumi.get(self, "http_status_class")

    @property
    @pulumi.getter(name="iibInputNodeType")
    def iib_input_node_type(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonIibInputNodeType']:
        return pulumi.get(self, "iib_input_node_type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def number(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumber']:
        return pulumi.get(self, "number")

    @property
    @pulumi.getter(name="numberRequestAttribute")
    def number_request_attribute(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute']:
        return pulumi.get(self, "number_request_attribute")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonServiceType']:
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def string(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonString']:
        return pulumi.get(self, "string")

    @property
    @pulumi.getter(name="stringRequestAttribute")
    def string_request_attribute(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute']:
        return pulumi.get(self, "string_request_attribute")

    @property
    @pulumi.getter
    def tag(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonTag']:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="zosCallType")
    def zos_call_type(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonZosCallType']:
        return pulumi.get(self, "zos_call_type")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonBoolean(dict):
    def __init__(__self__, *,
                 value: bool,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 values: Optional[Sequence[bool]] = None):
        pulumi.set(__self__, "value", value)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[bool]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonEsbInputNodeType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonFailedState(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonFailureReason(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonFastString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonFastString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonFastString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonFastString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonFlawState(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonGeneric(dict):
    def __init__(__self__, *,
                 type: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonHttpMethod(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonHttpStatusClass(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonIibInputNodeType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonNumber(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[float] = None,
                 values: Optional[Sequence[float]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"
        elif key == "matchOnChildCalls":
            suggest = "match_on_child_calls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_attribute: str,
                 match_on_child_calls: Optional[bool] = None,
                 operator: Optional[str] = None,
                 source: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource'] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[float] = None,
                 values: Optional[Sequence[float]] = None):
        pulumi.set(__self__, "request_attribute", request_attribute)
        if match_on_child_calls is not None:
            pulumi.set(__self__, "match_on_child_calls", match_on_child_calls)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> str:
        return pulumi.get(self, "request_attribute")

    @property
    @pulumi.getter(name="matchOnChildCalls")
    def match_on_child_calls(self) -> Optional[bool]:
        return pulumi.get(self, "match_on_child_calls")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource']:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZone":
            suggest = "management_zone"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zone: Optional[str] = None,
                 service_tag: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag'] = None,
                 unknowns: Optional[str] = None):
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag']:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 tag_key: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTagTagKey'] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTagTagKey']:
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTagTagKey(dict):
    def __init__(__self__, *,
                 context: Optional[str] = None,
                 key: Optional[str] = None):
        if context is not None:
            pulumi.set(__self__, "context", context)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonServiceType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchOnChildCalls":
            suggest = "match_on_child_calls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_attribute: str,
                 case_sensitive: Optional[bool] = None,
                 match_on_child_calls: Optional[bool] = None,
                 operator: Optional[str] = None,
                 source: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource'] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "request_attribute", request_attribute)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_on_child_calls is not None:
            pulumi.set(__self__, "match_on_child_calls", match_on_child_calls)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> str:
        return pulumi.get(self, "request_attribute")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchOnChildCalls")
    def match_on_child_calls(self) -> Optional[bool]:
        return pulumi.get(self, "match_on_child_calls")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource']:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZone":
            suggest = "management_zone"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zone: Optional[str] = None,
                 service_tag: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag'] = None,
                 unknowns: Optional[str] = None):
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag']:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 tag_key: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTagTagKey'] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTagTagKey']:
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTagTagKey(dict):
    def __init__(__self__, *,
                 context: Optional[str] = None,
                 key: Optional[str] = None):
        if context is not None:
            pulumi.set(__self__, "context", context)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonTag(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonTagValue'] = None,
                 values: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonTagValues'] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonTagValue']:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonTagValues']:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonTagValues(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence['outputs.CalculatedServiceMetricConditionConditionComparisonTagValuesValue']] = None):
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.CalculatedServiceMetricConditionConditionComparisonTagValuesValue']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonTagValuesValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonZosCallType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricDimensionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topX":
            suggest = "top_x"
        elif key == "topXAggregation":
            suggest = "top_x_aggregation"
        elif key == "topXDirection":
            suggest = "top_x_direction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricDimensionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricDimensionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricDimensionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension: str,
                 name: str,
                 top_x: int,
                 top_x_aggregation: str,
                 top_x_direction: str,
                 placeholders: Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholders'] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "dimension", dimension)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "top_x", top_x)
        pulumi.set(__self__, "top_x_aggregation", top_x_aggregation)
        pulumi.set(__self__, "top_x_direction", top_x_direction)
        if placeholders is not None:
            pulumi.set(__self__, "placeholders", placeholders)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def dimension(self) -> str:
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="topX")
    def top_x(self) -> int:
        return pulumi.get(self, "top_x")

    @property
    @pulumi.getter(name="topXAggregation")
    def top_x_aggregation(self) -> str:
        return pulumi.get(self, "top_x_aggregation")

    @property
    @pulumi.getter(name="topXDirection")
    def top_x_direction(self) -> str:
        return pulumi.get(self, "top_x_direction")

    @property
    @pulumi.getter
    def placeholders(self) -> Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholders']:
        return pulumi.get(self, "placeholders")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CalculatedServiceMetricDimensionDefinitionPlaceholders(dict):
    def __init__(__self__, *,
                 placeholders: Optional[Sequence['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder']] = None):
        if placeholders is not None:
            pulumi.set(__self__, "placeholders", placeholders)

    @property
    @pulumi.getter
    def placeholders(self) -> Optional[Sequence['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder']]:
        return pulumi.get(self, "placeholders")


@pulumi.output_type
class CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delimiterOrRegex":
            suggest = "delimiter_or_regex"
        elif key == "endDelimiter":
            suggest = "end_delimiter"
        elif key == "requestAttribute":
            suggest = "request_attribute"
        elif key == "useFromChildCalls":
            suggest = "use_from_child_calls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 kind: str,
                 name: str,
                 aggregation: Optional[str] = None,
                 delimiter_or_regex: Optional[str] = None,
                 end_delimiter: Optional[str] = None,
                 normalization: Optional[str] = None,
                 request_attribute: Optional[str] = None,
                 source: Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource'] = None,
                 unknowns: Optional[str] = None,
                 use_from_child_calls: Optional[bool] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if delimiter_or_regex is not None:
            pulumi.set(__self__, "delimiter_or_regex", delimiter_or_regex)
        if end_delimiter is not None:
            pulumi.set(__self__, "end_delimiter", end_delimiter)
        if normalization is not None:
            pulumi.set(__self__, "normalization", normalization)
        if request_attribute is not None:
            pulumi.set(__self__, "request_attribute", request_attribute)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if use_from_child_calls is not None:
            pulumi.set(__self__, "use_from_child_calls", use_from_child_calls)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def kind(self) -> str:
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="delimiterOrRegex")
    def delimiter_or_regex(self) -> Optional[str]:
        return pulumi.get(self, "delimiter_or_regex")

    @property
    @pulumi.getter(name="endDelimiter")
    def end_delimiter(self) -> Optional[str]:
        return pulumi.get(self, "end_delimiter")

    @property
    @pulumi.getter
    def normalization(self) -> Optional[str]:
        return pulumi.get(self, "normalization")

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> Optional[str]:
        return pulumi.get(self, "request_attribute")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource']:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="useFromChildCalls")
    def use_from_child_calls(self) -> Optional[bool]:
        return pulumi.get(self, "use_from_child_calls")


@pulumi.output_type
class CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZone":
            suggest = "management_zone"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zone: Optional[str] = None,
                 service_tag: Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag'] = None,
                 unknowns: Optional[str] = None):
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag']:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 tag_key: Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKey'] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKey']:
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKey(dict):
    def __init__(__self__, *,
                 context: Optional[str] = None,
                 key: Optional[str] = None):
        if context is not None:
            pulumi.set(__self__, "context", context)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")


@pulumi.output_type
class CalculatedServiceMetricMetricDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricMetricDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricMetricDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricMetricDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 request_attribute: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if request_attribute is not None:
            pulumi.set(__self__, "request_attribute", request_attribute)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> Optional[str]:
        return pulumi.get(self, "request_attribute")


@pulumi.output_type
class CloudappWorkloaddetectionCloudFoundry(dict):
    def __init__(__self__, *,
                 enabled: bool):
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class CloudappWorkloaddetectionDocker(dict):
    def __init__(__self__, *,
                 enabled: bool):
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class CloudappWorkloaddetectionKubernetes(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 filters: Optional['outputs.CloudappWorkloaddetectionKubernetesFilters'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def filters(self) -> Optional['outputs.CloudappWorkloaddetectionKubernetesFilters']:
        return pulumi.get(self, "filters")


@pulumi.output_type
class CloudappWorkloaddetectionKubernetesFilters(dict):
    def __init__(__self__, *,
                 filters: Sequence['outputs.CloudappWorkloaddetectionKubernetesFiltersFilter']):
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.CloudappWorkloaddetectionKubernetesFiltersFilter']:
        return pulumi.get(self, "filters")


@pulumi.output_type
class CloudappWorkloaddetectionKubernetesFiltersFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inclusionToggles":
            suggest = "inclusion_toggles"
        elif key == "matchFilter":
            suggest = "match_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudappWorkloaddetectionKubernetesFiltersFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudappWorkloaddetectionKubernetesFiltersFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudappWorkloaddetectionKubernetesFiltersFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 inclusion_toggles: 'outputs.CloudappWorkloaddetectionKubernetesFiltersFilterInclusionToggles',
                 match_filter: 'outputs.CloudappWorkloaddetectionKubernetesFiltersFilterMatchFilter'):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "inclusion_toggles", inclusion_toggles)
        pulumi.set(__self__, "match_filter", match_filter)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="inclusionToggles")
    def inclusion_toggles(self) -> 'outputs.CloudappWorkloaddetectionKubernetesFiltersFilterInclusionToggles':
        return pulumi.get(self, "inclusion_toggles")

    @property
    @pulumi.getter(name="matchFilter")
    def match_filter(self) -> 'outputs.CloudappWorkloaddetectionKubernetesFiltersFilterMatchFilter':
        return pulumi.get(self, "match_filter")


@pulumi.output_type
class CloudappWorkloaddetectionKubernetesFiltersFilterInclusionToggles(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incBasepod":
            suggest = "inc_basepod"
        elif key == "incContainer":
            suggest = "inc_container"
        elif key == "incNamespace":
            suggest = "inc_namespace"
        elif key == "incProduct":
            suggest = "inc_product"
        elif key == "incStage":
            suggest = "inc_stage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudappWorkloaddetectionKubernetesFiltersFilterInclusionToggles. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudappWorkloaddetectionKubernetesFiltersFilterInclusionToggles.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudappWorkloaddetectionKubernetesFiltersFilterInclusionToggles.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inc_basepod: bool,
                 inc_container: bool,
                 inc_namespace: bool,
                 inc_product: bool,
                 inc_stage: bool):
        pulumi.set(__self__, "inc_basepod", inc_basepod)
        pulumi.set(__self__, "inc_container", inc_container)
        pulumi.set(__self__, "inc_namespace", inc_namespace)
        pulumi.set(__self__, "inc_product", inc_product)
        pulumi.set(__self__, "inc_stage", inc_stage)

    @property
    @pulumi.getter(name="incBasepod")
    def inc_basepod(self) -> bool:
        return pulumi.get(self, "inc_basepod")

    @property
    @pulumi.getter(name="incContainer")
    def inc_container(self) -> bool:
        return pulumi.get(self, "inc_container")

    @property
    @pulumi.getter(name="incNamespace")
    def inc_namespace(self) -> bool:
        return pulumi.get(self, "inc_namespace")

    @property
    @pulumi.getter(name="incProduct")
    def inc_product(self) -> bool:
        return pulumi.get(self, "inc_product")

    @property
    @pulumi.getter(name="incStage")
    def inc_stage(self) -> bool:
        return pulumi.get(self, "inc_stage")


@pulumi.output_type
class CloudappWorkloaddetectionKubernetesFiltersFilterMatchFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOperator":
            suggest = "match_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudappWorkloaddetectionKubernetesFiltersFilterMatchFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudappWorkloaddetectionKubernetesFiltersFilterMatchFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudappWorkloaddetectionKubernetesFiltersFilterMatchFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_operator: str,
                 namespace: Optional[str] = None):
        pulumi.set(__self__, "match_operator", match_operator)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> str:
        return pulumi.get(self, "match_operator")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")


@pulumi.output_type
class CredentialsCredentialUsageSummary(dict):
    def __init__(__self__, *,
                 count: int,
                 type: str):
        """
        :param int count: The number of uses
        :param str type: Type of usage, `HTTP_MONITOR` or `BROWSER_MONITOR`
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of uses
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of usage, `HTTP_MONITOR` or `BROWSER_MONITOR`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CredentialsExternal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientSecret":
            suggest = "client_secret"
        elif key == "credentialsUsedForExternalSynchronizations":
            suggest = "credentials_used_for_external_synchronizations"
        elif key == "passwordSecretName":
            suggest = "password_secret_name"
        elif key == "pathToCredentials":
            suggest = "path_to_credentials"
        elif key == "tokenSecretName":
            suggest = "token_secret_name"
        elif key == "usernameSecretName":
            suggest = "username_secret_name"
        elif key == "vaultNamespace":
            suggest = "vault_namespace"
        elif key == "vaultUrl":
            suggest = "vault_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CredentialsExternal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CredentialsExternal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CredentialsExternal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 clientid: Optional[str] = None,
                 credentials_used_for_external_synchronizations: Optional[Sequence[str]] = None,
                 password_secret_name: Optional[str] = None,
                 path_to_credentials: Optional[str] = None,
                 roleid: Optional[str] = None,
                 secretid: Optional[str] = None,
                 tenantid: Optional[str] = None,
                 token_secret_name: Optional[str] = None,
                 username_secret_name: Optional[str] = None,
                 vault_namespace: Optional[str] = None,
                 vault_url: Optional[str] = None):
        """
        :param str certificate: Required for Hashicorp Certificate. The ID of Credentials within the Certificate Vault holding the certificate
        :param str client_secret: Required for Azure Client Secret. No further documentation available
        :param str clientid: Required for Azure Client Secret. No further documentation available
        :param Sequence[str] credentials_used_for_external_synchronizations: No documentation available
        :param str password_secret_name: No documentation available
        :param str path_to_credentials: Required for Hashicorp App Role or Hashicorp Certificate. No further documentation available
        :param str roleid: Required for Hashicorp App Role. No further documentation available
        :param str secretid: Required for Hashicorp App Role. The ID of Credentials within the Certificate Vault holding the secret id
        :param str tenantid: Required for Azure Client Secret. No further documentation available
        :param str token_secret_name: No documentation available
        :param str username_secret_name: No documentation available
        :param str vault_namespace: Required for Hashicorp App Role. No further documentation available
        :param str vault_url: No documentation available
        """
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if clientid is not None:
            pulumi.set(__self__, "clientid", clientid)
        if credentials_used_for_external_synchronizations is not None:
            pulumi.set(__self__, "credentials_used_for_external_synchronizations", credentials_used_for_external_synchronizations)
        if password_secret_name is not None:
            pulumi.set(__self__, "password_secret_name", password_secret_name)
        if path_to_credentials is not None:
            pulumi.set(__self__, "path_to_credentials", path_to_credentials)
        if roleid is not None:
            pulumi.set(__self__, "roleid", roleid)
        if secretid is not None:
            pulumi.set(__self__, "secretid", secretid)
        if tenantid is not None:
            pulumi.set(__self__, "tenantid", tenantid)
        if token_secret_name is not None:
            pulumi.set(__self__, "token_secret_name", token_secret_name)
        if username_secret_name is not None:
            pulumi.set(__self__, "username_secret_name", username_secret_name)
        if vault_namespace is not None:
            pulumi.set(__self__, "vault_namespace", vault_namespace)
        if vault_url is not None:
            pulumi.set(__self__, "vault_url", vault_url)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        Required for Hashicorp Certificate. The ID of Credentials within the Certificate Vault holding the certificate
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        Required for Azure Client Secret. No further documentation available
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def clientid(self) -> Optional[str]:
        """
        Required for Azure Client Secret. No further documentation available
        """
        return pulumi.get(self, "clientid")

    @property
    @pulumi.getter(name="credentialsUsedForExternalSynchronizations")
    def credentials_used_for_external_synchronizations(self) -> Optional[Sequence[str]]:
        """
        No documentation available
        """
        return pulumi.get(self, "credentials_used_for_external_synchronizations")

    @property
    @pulumi.getter(name="passwordSecretName")
    def password_secret_name(self) -> Optional[str]:
        """
        No documentation available
        """
        return pulumi.get(self, "password_secret_name")

    @property
    @pulumi.getter(name="pathToCredentials")
    def path_to_credentials(self) -> Optional[str]:
        """
        Required for Hashicorp App Role or Hashicorp Certificate. No further documentation available
        """
        return pulumi.get(self, "path_to_credentials")

    @property
    @pulumi.getter
    def roleid(self) -> Optional[str]:
        """
        Required for Hashicorp App Role. No further documentation available
        """
        return pulumi.get(self, "roleid")

    @property
    @pulumi.getter
    def secretid(self) -> Optional[str]:
        """
        Required for Hashicorp App Role. The ID of Credentials within the Certificate Vault holding the secret id
        """
        return pulumi.get(self, "secretid")

    @property
    @pulumi.getter
    def tenantid(self) -> Optional[str]:
        """
        Required for Azure Client Secret. No further documentation available
        """
        return pulumi.get(self, "tenantid")

    @property
    @pulumi.getter(name="tokenSecretName")
    def token_secret_name(self) -> Optional[str]:
        """
        No documentation available
        """
        return pulumi.get(self, "token_secret_name")

    @property
    @pulumi.getter(name="usernameSecretName")
    def username_secret_name(self) -> Optional[str]:
        """
        No documentation available
        """
        return pulumi.get(self, "username_secret_name")

    @property
    @pulumi.getter(name="vaultNamespace")
    def vault_namespace(self) -> Optional[str]:
        """
        Required for Hashicorp App Role. No further documentation available
        """
        return pulumi.get(self, "vault_namespace")

    @property
    @pulumi.getter(name="vaultUrl")
    def vault_url(self) -> Optional[str]:
        """
        No documentation available
        """
        return pulumi.get(self, "vault_url")


@pulumi.output_type
class CustomAnomaliesDimension(dict):
    def __init__(__self__, *,
                 dimensions: Optional[Sequence['outputs.CustomAnomaliesDimensionDimension']] = None,
                 entities: Optional[Sequence['outputs.CustomAnomaliesDimensionEntity']] = None,
                 strings: Optional[Sequence['outputs.CustomAnomaliesDimensionString']] = None):
        """
        :param Sequence['CustomAnomaliesDimensionDimensionArgs'] dimensions: A generic definition for a filter
        :param Sequence['CustomAnomaliesDimensionEntityArgs'] entities: A filter for the metrics entity dimensions
        :param Sequence['CustomAnomaliesDimensionStringArgs'] strings: A filter for the metrics string dimensions
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.CustomAnomaliesDimensionDimension']]:
        """
        A generic definition for a filter
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.CustomAnomaliesDimensionEntity']]:
        """
        A filter for the metrics entity dimensions
        """
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence['outputs.CustomAnomaliesDimensionString']]:
        """
        A filter for the metrics string dimensions
        """
        return pulumi.get(self, "strings")


@pulumi.output_type
class CustomAnomaliesDimensionDimension(dict):
    def __init__(__self__, *,
                 type: str,
                 index: Optional[int] = None,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str name: The name of the metric event displayed in the UI
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "type", type)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def index(self) -> Optional[int]:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the metric event displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesDimensionEntity(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesDimensionEntityFilter',
                 key: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesDimensionEntityFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesDimensionEntityFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesDimensionString(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesDimensionStringFilter',
                 index: Optional[int] = None,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str name: The name of the metric event displayed in the UI
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesDimensionStringFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def index(self) -> Optional[int]:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the metric event displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesDimensionStringFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDeviceGroupNames":
            suggest = "custom_device_group_names"
        elif key == "hostGroupNames":
            suggest = "host_group_names"
        elif key == "hostNames":
            suggest = "host_names"
        elif key == "managementZones":
            suggest = "management_zones"
        elif key == "processGroupIds":
            suggest = "process_group_ids"
        elif key == "processGroupNames":
            suggest = "process_group_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAnomaliesScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAnomaliesScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAnomaliesScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_device_group_names: Optional[Sequence['outputs.CustomAnomaliesScopeCustomDeviceGroupName']] = None,
                 entities: Optional[Sequence['outputs.CustomAnomaliesScopeEntity']] = None,
                 host_group_names: Optional[Sequence['outputs.CustomAnomaliesScopeHostGroupName']] = None,
                 host_names: Optional[Sequence['outputs.CustomAnomaliesScopeHostName']] = None,
                 management_zones: Optional[Sequence['outputs.CustomAnomaliesScopeManagementZone']] = None,
                 names: Optional[Sequence['outputs.CustomAnomaliesScopeName']] = None,
                 process_group_ids: Optional[Sequence['outputs.CustomAnomaliesScopeProcessGroupId']] = None,
                 process_group_names: Optional[Sequence['outputs.CustomAnomaliesScopeProcessGroupName']] = None,
                 scopes: Optional[Sequence['outputs.CustomAnomaliesScopeScope']] = None,
                 tags: Optional[Sequence['outputs.CustomAnomaliesScopeTag']] = None):
        """
        :param Sequence['CustomAnomaliesScopeCustomDeviceGroupNameArgs'] custom_device_group_names: A scope filter for the related custom device group name
        :param Sequence['CustomAnomaliesScopeEntityArgs'] entities: A scope filter for a monitored entity identifier
        :param Sequence['CustomAnomaliesScopeHostGroupNameArgs'] host_group_names: A scope filter for the related host group name
        :param Sequence['CustomAnomaliesScopeHostNameArgs'] host_names: A scope filter for the related host name
        :param Sequence['CustomAnomaliesScopeManagementZoneArgs'] management_zones: A scope filter for a management zone identifier
        :param Sequence['CustomAnomaliesScopeNameArgs'] names: A scope filter for a monitored entity name
        :param Sequence['CustomAnomaliesScopeProcessGroupIdArgs'] process_group_ids: A scope filter for a process group identifier
        :param Sequence['CustomAnomaliesScopeProcessGroupNameArgs'] process_group_names: A scope filter for the related process group name
        :param Sequence['CustomAnomaliesScopeScopeArgs'] scopes: A generic scope filter
        :param Sequence['CustomAnomaliesScopeTagArgs'] tags: A scope filter for tags on entities
        """
        if custom_device_group_names is not None:
            pulumi.set(__self__, "custom_device_group_names", custom_device_group_names)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if host_group_names is not None:
            pulumi.set(__self__, "host_group_names", host_group_names)
        if host_names is not None:
            pulumi.set(__self__, "host_names", host_names)
        if management_zones is not None:
            pulumi.set(__self__, "management_zones", management_zones)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if process_group_ids is not None:
            pulumi.set(__self__, "process_group_ids", process_group_ids)
        if process_group_names is not None:
            pulumi.set(__self__, "process_group_names", process_group_names)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="customDeviceGroupNames")
    def custom_device_group_names(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeCustomDeviceGroupName']]:
        """
        A scope filter for the related custom device group name
        """
        return pulumi.get(self, "custom_device_group_names")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeEntity']]:
        """
        A scope filter for a monitored entity identifier
        """
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="hostGroupNames")
    def host_group_names(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeHostGroupName']]:
        """
        A scope filter for the related host group name
        """
        return pulumi.get(self, "host_group_names")

    @property
    @pulumi.getter(name="hostNames")
    def host_names(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeHostName']]:
        """
        A scope filter for the related host name
        """
        return pulumi.get(self, "host_names")

    @property
    @pulumi.getter(name="managementZones")
    def management_zones(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeManagementZone']]:
        """
        A scope filter for a management zone identifier
        """
        return pulumi.get(self, "management_zones")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeName']]:
        """
        A scope filter for a monitored entity name
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter(name="processGroupIds")
    def process_group_ids(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeProcessGroupId']]:
        """
        A scope filter for a process group identifier
        """
        return pulumi.get(self, "process_group_ids")

    @property
    @pulumi.getter(name="processGroupNames")
    def process_group_names(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeProcessGroupName']]:
        """
        A scope filter for the related process group name
        """
        return pulumi.get(self, "process_group_names")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeScope']]:
        """
        A generic scope filter
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeTag']]:
        """
        A scope filter for tags on entities
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CustomAnomaliesScopeCustomDeviceGroupName(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesScopeCustomDeviceGroupNameFilter',
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesScopeCustomDeviceGroupNameFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeCustomDeviceGroupNameFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesScopeEntity(dict):
    def __init__(__self__, *,
                 id: str,
                 unknowns: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "id", id)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeHostGroupName(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesScopeHostGroupNameFilter',
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesScopeHostGroupNameFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeHostGroupNameFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesScopeHostName(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesScopeHostNameFilter',
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesScopeHostNameFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeHostNameFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesScopeManagementZone(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeName(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesScopeNameFilter',
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesScopeNameFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeNameFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesScopeProcessGroupId(dict):
    def __init__(__self__, *,
                 id: str,
                 unknowns: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "id", id)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeProcessGroupName(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesScopeProcessGroupNameFilter',
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesScopeProcessGroupNameFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeProcessGroupNameFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesScopeScope(dict):
    def __init__(__self__, *,
                 type: str,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeTag(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesScopeTagFilter',
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesScopeTagFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeTagFilter(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesStrategy(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.CustomAnomaliesStrategyAuto'] = None,
                 generics: Optional[Sequence['outputs.CustomAnomaliesStrategyGeneric']] = None,
                 static: Optional['outputs.CustomAnomaliesStrategyStatic'] = None):
        """
        :param 'CustomAnomaliesStrategyAutoArgs' auto: An auto-adaptive baseline strategy to detect anomalies within metrics that show a regular change over time, as the baseline is also updated automatically. An example is to detect an anomaly in the number of received network packets or within the number of user actions over time
        :param Sequence['CustomAnomaliesStrategyGenericArgs'] generics: A generic monitoring strategy
        :param 'CustomAnomaliesStrategyStaticArgs' static: A static threshold monitoring strategy to alert on hard limits within a given metric. An example is the violation of a critical memory limit
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if generics is not None:
            pulumi.set(__self__, "generics", generics)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.CustomAnomaliesStrategyAuto']:
        """
        An auto-adaptive baseline strategy to detect anomalies within metrics that show a regular change over time, as the baseline is also updated automatically. An example is to detect an anomaly in the number of received network packets or within the number of user actions over time
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def generics(self) -> Optional[Sequence['outputs.CustomAnomaliesStrategyGeneric']]:
        """
        A generic monitoring strategy
        """
        return pulumi.get(self, "generics")

    @property
    @pulumi.getter
    def static(self) -> Optional['outputs.CustomAnomaliesStrategyStatic']:
        """
        A static threshold monitoring strategy to alert on hard limits within a given metric. An example is the violation of a critical memory limit
        """
        return pulumi.get(self, "static")


@pulumi.output_type
class CustomAnomaliesStrategyAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertCondition":
            suggest = "alert_condition"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "signalFluctuations":
            suggest = "signal_fluctuations"
        elif key == "violatingSamples":
            suggest = "violating_samples"
        elif key == "alertingOnMissingData":
            suggest = "alerting_on_missing_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAnomaliesStrategyAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAnomaliesStrategyAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAnomaliesStrategyAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_condition: str,
                 dealerting_samples: int,
                 samples: int,
                 signal_fluctuations: float,
                 violating_samples: int,
                 alerting_on_missing_data: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "alert_condition", alert_condition)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "samples", samples)
        pulumi.set(__self__, "signal_fluctuations", signal_fluctuations)
        pulumi.set(__self__, "violating_samples", violating_samples)
        if alerting_on_missing_data is not None:
            pulumi.set(__self__, "alerting_on_missing_data", alerting_on_missing_data)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="alertCondition")
    def alert_condition(self) -> str:
        return pulumi.get(self, "alert_condition")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter
    def samples(self) -> int:
        return pulumi.get(self, "samples")

    @property
    @pulumi.getter(name="signalFluctuations")
    def signal_fluctuations(self) -> float:
        return pulumi.get(self, "signal_fluctuations")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        return pulumi.get(self, "violating_samples")

    @property
    @pulumi.getter(name="alertingOnMissingData")
    def alerting_on_missing_data(self) -> Optional[bool]:
        return pulumi.get(self, "alerting_on_missing_data")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesStrategyGeneric(dict):
    def __init__(__self__, *,
                 type: str,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesStrategyStatic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertCondition":
            suggest = "alert_condition"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingSamples":
            suggest = "violating_samples"
        elif key == "alertingOnMissingData":
            suggest = "alerting_on_missing_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAnomaliesStrategyStatic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAnomaliesStrategyStatic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAnomaliesStrategyStatic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_condition: str,
                 dealerting_samples: int,
                 samples: int,
                 threshold: float,
                 unit: str,
                 violating_samples: int,
                 alerting_on_missing_data: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "alert_condition", alert_condition)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "samples", samples)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "violating_samples", violating_samples)
        if alerting_on_missing_data is not None:
            pulumi.set(__self__, "alerting_on_missing_data", alerting_on_missing_data)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="alertCondition")
    def alert_condition(self) -> str:
        return pulumi.get(self, "alert_condition")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter
    def samples(self) -> int:
        return pulumi.get(self, "samples")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        return pulumi.get(self, "violating_samples")

    @property
    @pulumi.getter(name="alertingOnMissingData")
    def alerting_on_missing_data(self) -> Optional[bool]:
        return pulumi.get(self, "alerting_on_missing_data")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAppAnomaliesErrorRateIncrease(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectionMode":
            suggest = "detection_mode"
        elif key == "errorRateIncreaseAuto":
            suggest = "error_rate_increase_auto"
        elif key == "errorRateIncreaseFixed":
            suggest = "error_rate_increase_fixed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesErrorRateIncrease. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesErrorRateIncrease.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesErrorRateIncrease.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 detection_mode: Optional[str] = None,
                 error_rate_increase_auto: Optional['outputs.CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto'] = None,
                 error_rate_increase_fixed: Optional['outputs.CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param str detection_mode: Possible Values: `Auto`, `Fixed`
        :param 'CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseAutoArgs' error_rate_increase_auto: Alert if the percentage of user actions affected by reported errors exceeds **both** the absolute threshold and the relative threshold
        :param 'CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixedArgs' error_rate_increase_fixed: Alert if the custom reported error rate threshold is exceeded during any 5-minute period
        """
        pulumi.set(__self__, "enabled", enabled)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if error_rate_increase_auto is not None:
            pulumi.set(__self__, "error_rate_increase_auto", error_rate_increase_auto)
        if error_rate_increase_fixed is not None:
            pulumi.set(__self__, "error_rate_increase_fixed", error_rate_increase_fixed)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Fixed`
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter(name="errorRateIncreaseAuto")
    def error_rate_increase_auto(self) -> Optional['outputs.CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto']:
        """
        Alert if the percentage of user actions affected by reported errors exceeds **both** the absolute threshold and the relative threshold
        """
        return pulumi.get(self, "error_rate_increase_auto")

    @property
    @pulumi.getter(name="errorRateIncreaseFixed")
    def error_rate_increase_fixed(self) -> Optional['outputs.CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed']:
        """
        Alert if the custom reported error rate threshold is exceeded during any 5-minute period
        """
        return pulumi.get(self, "error_rate_increase_fixed")


@pulumi.output_type
class CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdAbsolute":
            suggest = "threshold_absolute"
        elif key == "thresholdRelative":
            suggest = "threshold_relative"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 threshold_absolute: float,
                 threshold_relative: float):
        pulumi.set(__self__, "threshold_absolute", threshold_absolute)
        pulumi.set(__self__, "threshold_relative", threshold_relative)

    @property
    @pulumi.getter(name="thresholdAbsolute")
    def threshold_absolute(self) -> float:
        return pulumi.get(self, "threshold_absolute")

    @property
    @pulumi.getter(name="thresholdRelative")
    def threshold_relative(self) -> float:
        return pulumi.get(self, "threshold_relative")


@pulumi.output_type
class CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdAbsolute":
            suggest = "threshold_absolute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sensitivity: str,
                 threshold_absolute: float):
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold_absolute", threshold_absolute)

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter(name="thresholdAbsolute")
    def threshold_absolute(self) -> float:
        return pulumi.get(self, "threshold_absolute")


@pulumi.output_type
class CustomAppAnomaliesSlowUserActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectionMode":
            suggest = "detection_mode"
        elif key == "slowUserActionsAuto":
            suggest = "slow_user_actions_auto"
        elif key == "slowUserActionsFixed":
            suggest = "slow_user_actions_fixed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesSlowUserActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesSlowUserActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesSlowUserActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 detection_mode: Optional[str] = None,
                 slow_user_actions_auto: Optional['outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAuto'] = None,
                 slow_user_actions_fixed: Optional['outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixed'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param str detection_mode: Possible Values: `Auto`, `Fixed`
        :param 'CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoArgs' slow_user_actions_auto: no documentation available
        :param 'CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedArgs' slow_user_actions_fixed: no documentation available
        """
        pulumi.set(__self__, "enabled", enabled)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if slow_user_actions_auto is not None:
            pulumi.set(__self__, "slow_user_actions_auto", slow_user_actions_auto)
        if slow_user_actions_fixed is not None:
            pulumi.set(__self__, "slow_user_actions_fixed", slow_user_actions_fixed)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Fixed`
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter(name="slowUserActionsAuto")
    def slow_user_actions_auto(self) -> Optional['outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAuto']:
        """
        no documentation available
        """
        return pulumi.get(self, "slow_user_actions_auto")

    @property
    @pulumi.getter(name="slowUserActionsFixed")
    def slow_user_actions_fixed(self) -> Optional['outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixed']:
        """
        no documentation available
        """
        return pulumi.get(self, "slow_user_actions_fixed")


@pulumi.output_type
class CustomAppAnomaliesSlowUserActionsSlowUserActionsAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationAvoidOveralerting":
            suggest = "duration_avoid_overalerting"
        elif key == "durationThresholdAll":
            suggest = "duration_threshold_all"
        elif key == "durationThresholdSlowest":
            suggest = "duration_threshold_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesSlowUserActionsSlowUserActionsAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_avoid_overalerting: 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting',
                 duration_threshold_all: 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll',
                 duration_threshold_slowest: 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest'):
        pulumi.set(__self__, "duration_avoid_overalerting", duration_avoid_overalerting)
        pulumi.set(__self__, "duration_threshold_all", duration_threshold_all)
        pulumi.set(__self__, "duration_threshold_slowest", duration_threshold_slowest)

    @property
    @pulumi.getter(name="durationAvoidOveralerting")
    def duration_avoid_overalerting(self) -> 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting':
        return pulumi.get(self, "duration_avoid_overalerting")

    @property
    @pulumi.getter(name="durationThresholdAll")
    def duration_threshold_all(self) -> 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll':
        return pulumi.get(self, "duration_threshold_all")

    @property
    @pulumi.getter(name="durationThresholdSlowest")
    def duration_threshold_slowest(self) -> 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest':
        return pulumi.get(self, "duration_threshold_slowest")


@pulumi.output_type
class CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minActionRate":
            suggest = "min_action_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_action_rate: int):
        pulumi.set(__self__, "min_action_rate", min_action_rate)

    @property
    @pulumi.getter(name="minActionRate")
    def min_action_rate(self) -> int:
        return pulumi.get(self, "min_action_rate")


@pulumi.output_type
class CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationThreshold":
            suggest = "duration_threshold"
        elif key == "slowdownPercentage":
            suggest = "slowdown_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_threshold: float,
                 slowdown_percentage: float):
        pulumi.set(__self__, "duration_threshold", duration_threshold)
        pulumi.set(__self__, "slowdown_percentage", slowdown_percentage)

    @property
    @pulumi.getter(name="durationThreshold")
    def duration_threshold(self) -> float:
        return pulumi.get(self, "duration_threshold")

    @property
    @pulumi.getter(name="slowdownPercentage")
    def slowdown_percentage(self) -> float:
        return pulumi.get(self, "slowdown_percentage")


@pulumi.output_type
class CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationThreshold":
            suggest = "duration_threshold"
        elif key == "slowdownPercentage":
            suggest = "slowdown_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_threshold: float,
                 slowdown_percentage: float):
        pulumi.set(__self__, "duration_threshold", duration_threshold)
        pulumi.set(__self__, "slowdown_percentage", slowdown_percentage)

    @property
    @pulumi.getter(name="durationThreshold")
    def duration_threshold(self) -> float:
        return pulumi.get(self, "duration_threshold")

    @property
    @pulumi.getter(name="slowdownPercentage")
    def slowdown_percentage(self) -> float:
        return pulumi.get(self, "slowdown_percentage")


@pulumi.output_type
class CustomAppAnomaliesSlowUserActionsSlowUserActionsFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationAvoidOveralerting":
            suggest = "duration_avoid_overalerting"
        elif key == "durationThresholdAllFixed":
            suggest = "duration_threshold_all_fixed"
        elif key == "durationThresholdSlowest":
            suggest = "duration_threshold_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesSlowUserActionsSlowUserActionsFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_avoid_overalerting: 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting',
                 duration_threshold_all_fixed: 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed',
                 duration_threshold_slowest: 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest',
                 sensitivity: str):
        pulumi.set(__self__, "duration_avoid_overalerting", duration_avoid_overalerting)
        pulumi.set(__self__, "duration_threshold_all_fixed", duration_threshold_all_fixed)
        pulumi.set(__self__, "duration_threshold_slowest", duration_threshold_slowest)
        pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="durationAvoidOveralerting")
    def duration_avoid_overalerting(self) -> 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting':
        return pulumi.get(self, "duration_avoid_overalerting")

    @property
    @pulumi.getter(name="durationThresholdAllFixed")
    def duration_threshold_all_fixed(self) -> 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed':
        return pulumi.get(self, "duration_threshold_all_fixed")

    @property
    @pulumi.getter(name="durationThresholdSlowest")
    def duration_threshold_slowest(self) -> 'outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest':
        return pulumi.get(self, "duration_threshold_slowest")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minActionRate":
            suggest = "min_action_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_action_rate: int):
        pulumi.set(__self__, "min_action_rate", min_action_rate)

    @property
    @pulumi.getter(name="minActionRate")
    def min_action_rate(self) -> int:
        return pulumi.get(self, "min_action_rate")


@pulumi.output_type
class CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationThreshold":
            suggest = "duration_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_threshold: float):
        pulumi.set(__self__, "duration_threshold", duration_threshold)

    @property
    @pulumi.getter(name="durationThreshold")
    def duration_threshold(self) -> float:
        return pulumi.get(self, "duration_threshold")


@pulumi.output_type
class CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationThreshold":
            suggest = "duration_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_threshold: float):
        pulumi.set(__self__, "duration_threshold", duration_threshold)

    @property
    @pulumi.getter(name="durationThreshold")
    def duration_threshold(self) -> float:
        return pulumi.get(self, "duration_threshold")


@pulumi.output_type
class CustomAppAnomaliesUnexpectedHighLoad(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdPercentage":
            suggest = "threshold_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesUnexpectedHighLoad. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesUnexpectedHighLoad.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesUnexpectedHighLoad.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 threshold_percentage: Optional[float] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param float threshold_percentage: Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic spikes within your application.
        """
        pulumi.set(__self__, "enabled", enabled)
        if threshold_percentage is not None:
            pulumi.set(__self__, "threshold_percentage", threshold_percentage)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="thresholdPercentage")
    def threshold_percentage(self) -> Optional[float]:
        """
        Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic spikes within your application.
        """
        return pulumi.get(self, "threshold_percentage")


@pulumi.output_type
class CustomAppAnomaliesUnexpectedLowLoad(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdPercentage":
            suggest = "threshold_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppAnomaliesUnexpectedLowLoad. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppAnomaliesUnexpectedLowLoad.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppAnomaliesUnexpectedLowLoad.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 threshold_percentage: Optional[float] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param float threshold_percentage: Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic drops within your application.
        """
        pulumi.set(__self__, "enabled", enabled)
        if threshold_percentage is not None:
            pulumi.set(__self__, "threshold_percentage", threshold_percentage)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="thresholdPercentage")
    def threshold_percentage(self) -> Optional[float]:
        """
        Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic drops within your application.
        """
        return pulumi.get(self, "threshold_percentage")


@pulumi.output_type
class CustomAppCrashRateCrashRateIncrease(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crashRateIncreaseAuto":
            suggest = "crash_rate_increase_auto"
        elif key == "crashRateIncreaseFixed":
            suggest = "crash_rate_increase_fixed"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppCrashRateCrashRateIncrease. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppCrashRateCrashRateIncrease.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppCrashRateCrashRateIncrease.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 crash_rate_increase_auto: Optional['outputs.CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto'] = None,
                 crash_rate_increase_fixed: Optional['outputs.CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseAutoArgs' crash_rate_increase_auto: Alert crash rate increases when auto-detected baseline is exceeded by a certain number of users
        :param 'CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseFixedArgs' crash_rate_increase_fixed: Alert crash rate increases when the defined threshold is exceeded by a certain number of users
        :param str detection_mode: Possible Values: `Auto`, `Fixed`
        """
        pulumi.set(__self__, "enabled", enabled)
        if crash_rate_increase_auto is not None:
            pulumi.set(__self__, "crash_rate_increase_auto", crash_rate_increase_auto)
        if crash_rate_increase_fixed is not None:
            pulumi.set(__self__, "crash_rate_increase_fixed", crash_rate_increase_fixed)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="crashRateIncreaseAuto")
    def crash_rate_increase_auto(self) -> Optional['outputs.CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto']:
        """
        Alert crash rate increases when auto-detected baseline is exceeded by a certain number of users
        """
        return pulumi.get(self, "crash_rate_increase_auto")

    @property
    @pulumi.getter(name="crashRateIncreaseFixed")
    def crash_rate_increase_fixed(self) -> Optional['outputs.CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed']:
        """
        Alert crash rate increases when the defined threshold is exceeded by a certain number of users
        """
        return pulumi.get(self, "crash_rate_increase_fixed")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Fixed`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baselineViolationPercentage":
            suggest = "baseline_violation_percentage"
        elif key == "concurrentUsers":
            suggest = "concurrent_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 baseline_violation_percentage: float,
                 concurrent_users: float,
                 sensitivity: str):
        pulumi.set(__self__, "baseline_violation_percentage", baseline_violation_percentage)
        pulumi.set(__self__, "concurrent_users", concurrent_users)
        pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="baselineViolationPercentage")
    def baseline_violation_percentage(self) -> float:
        return pulumi.get(self, "baseline_violation_percentage")

    @property
    @pulumi.getter(name="concurrentUsers")
    def concurrent_users(self) -> float:
        return pulumi.get(self, "concurrent_users")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "absoluteCrashRate":
            suggest = "absolute_crash_rate"
        elif key == "concurrentUsers":
            suggest = "concurrent_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 absolute_crash_rate: float,
                 concurrent_users: int):
        pulumi.set(__self__, "absolute_crash_rate", absolute_crash_rate)
        pulumi.set(__self__, "concurrent_users", concurrent_users)

    @property
    @pulumi.getter(name="absoluteCrashRate")
    def absolute_crash_rate(self) -> float:
        return pulumi.get(self, "absolute_crash_rate")

    @property
    @pulumi.getter(name="concurrentUsers")
    def concurrent_users(self) -> int:
        return pulumi.get(self, "concurrent_users")


@pulumi.output_type
class CustomAppEnablementRum(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costAndTrafficControl":
            suggest = "cost_and_traffic_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppEnablementRum. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppEnablementRum.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppEnablementRum.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_and_traffic_control: int,
                 enabled: bool):
        """
        :param int cost_and_traffic_control: (Field has overlap with `MobileApplication`) Percentage of user sessions captured and analyzed. By default, Dynatrace captures all user actions and user sessions for analysis. This approach ensures complete insight into your applications performance and customer experience. You can optionally reduce the granularity of user-action and user-session analysis by capturing a lower percentage of user sessions. While this approach can reduce monitoring costs, it also results in lower visibility into how your customers are using your applications. For example, a setting of 10% results in Dynatrace analyzing only every tenth user session.
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        """
        pulumi.set(__self__, "cost_and_traffic_control", cost_and_traffic_control)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="costAndTrafficControl")
    def cost_and_traffic_control(self) -> int:
        """
        (Field has overlap with `MobileApplication`) Percentage of user sessions captured and analyzed. By default, Dynatrace captures all user actions and user sessions for analysis. This approach ensures complete insight into your applications performance and customer experience. You can optionally reduce the granularity of user-action and user-session analysis by capturing a lower percentage of user sessions. While this approach can reduce monitoring costs, it also results in lower visibility into how your customers are using your applications. For example, a setting of 10% results in Dynatrace analyzing only every tenth user session.
        """
        return pulumi.get(self, "cost_and_traffic_control")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class CustomServiceRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "class":
            suggest = "class_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomServiceRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomServiceRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomServiceRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 methods: Sequence['outputs.CustomServiceRuleMethod'],
                 annotations: Optional[Sequence[str]] = None,
                 class_: Optional['outputs.CustomServiceRuleClass'] = None,
                 file: Optional['outputs.CustomServiceRuleFile'] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool enabled: Rule enabled/disabled
        :param Sequence['CustomServiceRuleMethodArgs'] methods: methods to instrument
        :param Sequence[str] annotations: Additional annotations filter of the rule. Only classes where all listed annotations are available in the class itself or any of its superclasses are instrumented. Not applicable to PHP
        :param 'CustomServiceRuleClassArgs' class_: The fully qualified class or interface to instrument (or a substring if matching to a string). Required for Java and .NET custom services. Not applicable to PHP
        :param 'CustomServiceRuleFileArgs' file: The PHP file containing the class or methods to instrument. Required for PHP custom service. Not applicable to Java and .NET
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "methods", methods)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Rule enabled/disabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def methods(self) -> Sequence['outputs.CustomServiceRuleMethod']:
        """
        methods to instrument
        """
        return pulumi.get(self, "methods")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[str]]:
        """
        Additional annotations filter of the rule. Only classes where all listed annotations are available in the class itself or any of its superclasses are instrumented. Not applicable to PHP
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional['outputs.CustomServiceRuleClass']:
        """
        The fully qualified class or interface to instrument (or a substring if matching to a string). Required for Java and .NET custom services. Not applicable to PHP
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.CustomServiceRuleFile']:
        """
        The PHP file containing the class or methods to instrument. Required for PHP custom service. Not applicable to Java and .NET
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomServiceRuleClass(dict):
    def __init__(__self__, *,
                 name: str,
                 match: Optional[str] = None):
        """
        :param str name: The name of the custom service, displayed in the UI
        """
        pulumi.set(__self__, "name", name)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the custom service, displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")


@pulumi.output_type
class CustomServiceRuleFile(dict):
    def __init__(__self__, *,
                 name: str,
                 match: Optional[str] = None):
        """
        :param str name: The name of the custom service, displayed in the UI
        """
        pulumi.set(__self__, "name", name)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the custom service, displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")


@pulumi.output_type
class CustomServiceRuleMethod(dict):
    def __init__(__self__, *,
                 name: str,
                 arguments: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 modifiers: Optional[Sequence[str]] = None,
                 returns: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 visibility: Optional[str] = None):
        """
        :param str name: The name of the custom service, displayed in the UI
        :param str id: The ID of this resource.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "name", name)
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if modifiers is not None:
            pulumi.set(__self__, "modifiers", modifiers)
        if returns is not None:
            pulumi.set(__self__, "returns", returns)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the custom service, displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def arguments(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "arguments")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def modifiers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "modifiers")

    @property
    @pulumi.getter
    def returns(self) -> Optional[str]:
        return pulumi.get(self, "returns")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def visibility(self) -> Optional[str]:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class CustomTagsTags(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.CustomTagsTagsFilter']] = None):
        """
        :param Sequence['CustomTagsTagsFilterArgs'] filters: A Tag Filter
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.CustomTagsTagsFilter']]:
        """
        A Tag Filter
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class CustomTagsTagsFilter(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardDashboardMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consistentColors":
            suggest = "consistent_colors"
        elif key == "dynamicFilters":
            suggest = "dynamic_filters"
        elif key == "sharingDetails":
            suggest = "sharing_details"
        elif key == "tilesNameSize":
            suggest = "tiles_name_size"
        elif key == "validFilterKeys":
            suggest = "valid_filter_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 owner: str,
                 consistent_colors: Optional[bool] = None,
                 dynamic_filters: Optional['outputs.DashboardDashboardMetadataDynamicFilters'] = None,
                 filter: Optional['outputs.DashboardDashboardMetadataFilter'] = None,
                 preset: Optional[bool] = None,
                 shared: Optional[bool] = None,
                 sharing_details: Optional['outputs.DashboardDashboardMetadataSharingDetails'] = None,
                 tags: Optional[Sequence[str]] = None,
                 tiles_name_size: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 valid_filter_keys: Optional[Sequence[str]] = None):
        """
        :param str name: the name of the dashboard
        :param str owner: the owner of the dashboard
        :param bool consistent_colors: The tile uses consistent colors when rendering its content
        :param 'DashboardDashboardMetadataDynamicFiltersArgs' dynamic_filters: Dashboard filter configuration of a dashboard
        :param 'DashboardDashboardMetadataFilterArgs' filter: Global filter Settings for the Dashboard
        :param bool preset: the dashboard is a preset (`true`) or not (`false`). Default is `false`.
        :param bool shared: the dashboard is shared (`true`) or private (`false`)
        :param 'DashboardDashboardMetadataSharingDetailsArgs' sharing_details: represents sharing configuration of a dashboard
        :param Sequence[str] tags: a set of tags assigned to the dashboard
        :param str tiles_name_size: No documentation available
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param Sequence[str] valid_filter_keys: a set of all possible global dashboard filters that can be applied to dashboard
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner", owner)
        if consistent_colors is not None:
            pulumi.set(__self__, "consistent_colors", consistent_colors)
        if dynamic_filters is not None:
            pulumi.set(__self__, "dynamic_filters", dynamic_filters)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)
        if shared is not None:
            pulumi.set(__self__, "shared", shared)
        if sharing_details is not None:
            pulumi.set(__self__, "sharing_details", sharing_details)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tiles_name_size is not None:
            pulumi.set(__self__, "tiles_name_size", tiles_name_size)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if valid_filter_keys is not None:
            pulumi.set(__self__, "valid_filter_keys", valid_filter_keys)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        the name of the dashboard
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def owner(self) -> str:
        """
        the owner of the dashboard
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="consistentColors")
    def consistent_colors(self) -> Optional[bool]:
        """
        The tile uses consistent colors when rendering its content
        """
        return pulumi.get(self, "consistent_colors")

    @property
    @pulumi.getter(name="dynamicFilters")
    def dynamic_filters(self) -> Optional['outputs.DashboardDashboardMetadataDynamicFilters']:
        """
        Dashboard filter configuration of a dashboard
        """
        return pulumi.get(self, "dynamic_filters")

    @property
    @pulumi.getter
    def filter(self) -> Optional['outputs.DashboardDashboardMetadataFilter']:
        """
        Global filter Settings for the Dashboard
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def preset(self) -> Optional[bool]:
        """
        the dashboard is a preset (`true`) or not (`false`). Default is `false`.
        """
        return pulumi.get(self, "preset")

    @property
    @pulumi.getter
    def shared(self) -> Optional[bool]:
        """
        the dashboard is shared (`true`) or private (`false`)
        """
        return pulumi.get(self, "shared")

    @property
    @pulumi.getter(name="sharingDetails")
    def sharing_details(self) -> Optional['outputs.DashboardDashboardMetadataSharingDetails']:
        """
        represents sharing configuration of a dashboard
        """
        return pulumi.get(self, "sharing_details")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        a set of tags assigned to the dashboard
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tilesNameSize")
    def tiles_name_size(self) -> Optional[str]:
        """
        No documentation available
        """
        return pulumi.get(self, "tiles_name_size")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="validFilterKeys")
    def valid_filter_keys(self) -> Optional[Sequence[str]]:
        """
        a set of all possible global dashboard filters that can be applied to dashboard
        """
        return pulumi.get(self, "valid_filter_keys")


@pulumi.output_type
class DashboardDashboardMetadataDynamicFilters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "genericTagFilters":
            suggest = "generic_tag_filters"
        elif key == "tagSuggestionTypes":
            suggest = "tag_suggestion_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardMetadataDynamicFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardMetadataDynamicFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardMetadataDynamicFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Sequence[str],
                 generic_tag_filters: Optional['outputs.DashboardDashboardMetadataDynamicFiltersGenericTagFilters'] = None,
                 tag_suggestion_types: Optional[Sequence[str]] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filters", filters)
        if generic_tag_filters is not None:
            pulumi.set(__self__, "generic_tag_filters", generic_tag_filters)
        if tag_suggestion_types is not None:
            pulumi.set(__self__, "tag_suggestion_types", tag_suggestion_types)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filters(self) -> Sequence[str]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="genericTagFilters")
    def generic_tag_filters(self) -> Optional['outputs.DashboardDashboardMetadataDynamicFiltersGenericTagFilters']:
        return pulumi.get(self, "generic_tag_filters")

    @property
    @pulumi.getter(name="tagSuggestionTypes")
    def tag_suggestion_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tag_suggestion_types")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardDashboardMetadataDynamicFiltersGenericTagFilters(dict):
    def __init__(__self__, *,
                 filters: Sequence['outputs.DashboardDashboardMetadataDynamicFiltersGenericTagFiltersFilter']):
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.DashboardDashboardMetadataDynamicFiltersGenericTagFiltersFilter']:
        return pulumi.get(self, "filters")


@pulumi.output_type
class DashboardDashboardMetadataDynamicFiltersGenericTagFiltersFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityTypes":
            suggest = "entity_types"
        elif key == "suggestionsFromEntityType":
            suggest = "suggestions_from_entity_type"
        elif key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardMetadataDynamicFiltersGenericTagFiltersFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardMetadataDynamicFiltersGenericTagFiltersFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardMetadataDynamicFiltersGenericTagFiltersFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_types: Sequence[str],
                 name: Optional[str] = None,
                 suggestions_from_entity_type: Optional[str] = None,
                 tag_key: Optional[str] = None):
        pulumi.set(__self__, "entity_types", entity_types)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if suggestions_from_entity_type is not None:
            pulumi.set(__self__, "suggestions_from_entity_type", suggestions_from_entity_type)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)

    @property
    @pulumi.getter(name="entityTypes")
    def entity_types(self) -> Sequence[str]:
        return pulumi.get(self, "entity_types")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="suggestionsFromEntityType")
    def suggestions_from_entity_type(self) -> Optional[str]:
        return pulumi.get(self, "suggestions_from_entity_type")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[str]:
        return pulumi.get(self, "tag_key")


@pulumi.output_type
class DashboardDashboardMetadataFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZones":
            suggest = "management_zones"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardMetadataFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardMetadataFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardMetadataFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zones: Optional[Sequence['outputs.DashboardDashboardMetadataFilterManagementZone']] = None,
                 timeframe: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if management_zones is not None:
            pulumi.set(__self__, "management_zones", management_zones)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZones")
    def management_zones(self) -> Optional[Sequence['outputs.DashboardDashboardMetadataFilterManagementZone']]:
        return pulumi.get(self, "management_zones")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        return pulumi.get(self, "timeframe")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardDashboardMetadataFilterManagementZone(dict):
    def __init__(__self__, *,
                 id: str,
                 description: Optional[str] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "id", id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardDashboardMetadataSharingDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkShared":
            suggest = "link_shared"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardMetadataSharingDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardMetadataSharingDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardMetadataSharingDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 link_shared: Optional[bool] = None,
                 published: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if link_shared is not None:
            pulumi.set(__self__, "link_shared", link_shared)
        if published is not None:
            pulumi.set(__self__, "published", published)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="linkShared")
    def link_shared(self) -> Optional[bool]:
        return pulumi.get(self, "link_shared")

    @property
    @pulumi.getter
    def published(self) -> Optional[bool]:
        return pulumi.get(self, "published")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "configurationVersions":
            suggest = "configuration_versions"
        elif key == "currentConfigurationVersions":
            suggest = "current_configuration_versions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_version: Optional[str] = None,
                 configuration_versions: Optional[Sequence[int]] = None,
                 current_configuration_versions: Optional[Sequence[str]] = None):
        """
        :param str cluster_version: Dynatrace server version
        :param Sequence[int] configuration_versions: A Sorted list of the version numbers of the configuration
        :param Sequence[str] current_configuration_versions: A Sorted list of the version numbers of the configuration
        """
        if cluster_version is not None:
            pulumi.set(__self__, "cluster_version", cluster_version)
        if configuration_versions is not None:
            pulumi.set(__self__, "configuration_versions", configuration_versions)
        if current_configuration_versions is not None:
            pulumi.set(__self__, "current_configuration_versions", current_configuration_versions)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> Optional[str]:
        """
        Dynatrace server version
        """
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter(name="configurationVersions")
    def configuration_versions(self) -> Optional[Sequence[int]]:
        """
        A Sorted list of the version numbers of the configuration
        """
        return pulumi.get(self, "configuration_versions")

    @property
    @pulumi.getter(name="currentConfigurationVersions")
    def current_configuration_versions(self) -> Optional[Sequence[str]]:
        """
        A Sorted list of the version numbers of the configuration
        """
        return pulumi.get(self, "current_configuration_versions")


@pulumi.output_type
class DashboardSharingPermissions(dict):
    def __init__(__self__, *,
                 permissions: Optional[Sequence['outputs.DashboardSharingPermissionsPermission']] = None):
        """
        :param Sequence['DashboardSharingPermissionsPermissionArgs'] permissions: Access permissions of the dashboard
        """
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['outputs.DashboardSharingPermissionsPermission']]:
        """
        Access permissions of the dashboard
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class DashboardSharingPermissionsPermission(dict):
    def __init__(__self__, *,
                 level: str,
                 type: str,
                 id: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def level(self) -> str:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DashboardSharingPublic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZones":
            suggest = "management_zones"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSharingPublic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSharingPublic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSharingPublic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zones: Sequence[str],
                 urls: Optional[Mapping[str, str]] = None):
        """
        :param Sequence[str] management_zones: A list of management zones that can display data on the publicly shared dashboard.
        """
        pulumi.set(__self__, "management_zones", management_zones)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter(name="managementZones")
    def management_zones(self) -> Sequence[str]:
        """
        A list of management zones that can display data on the publicly shared dashboard.
        """
        return pulumi.get(self, "management_zones")

    @property
    @pulumi.getter
    def urls(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class DashboardTile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tileType":
            suggest = "tile_type"
        elif key == "assignedEntities":
            suggest = "assigned_entities"
        elif key == "autoRefreshDisabled":
            suggest = "auto_refresh_disabled"
        elif key == "chartVisible":
            suggest = "chart_visible"
        elif key == "customName":
            suggest = "custom_name"
        elif key == "excludeMaintenanceWindows":
            suggest = "exclude_maintenance_windows"
        elif key == "filterConfig":
            suggest = "filter_config"
        elif key == "nameSize":
            suggest = "name_size"
        elif key == "timeFrameShift":
            suggest = "time_frame_shift"
        elif key == "visualizationConfig":
            suggest = "visualization_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 tile_type: str,
                 assigned_entities: Optional[Sequence[str]] = None,
                 auto_refresh_disabled: Optional[bool] = None,
                 bounds: Optional['outputs.DashboardTileBounds'] = None,
                 chart_visible: Optional[bool] = None,
                 configured: Optional[bool] = None,
                 custom_name: Optional[str] = None,
                 exclude_maintenance_windows: Optional[bool] = None,
                 filter: Optional['outputs.DashboardTileFilter'] = None,
                 filter_config: Optional['outputs.DashboardTileFilterConfig'] = None,
                 limit: Optional[int] = None,
                 markdown: Optional[str] = None,
                 metric: Optional[str] = None,
                 name_size: Optional[str] = None,
                 query: Optional[str] = None,
                 time_frame_shift: Optional[str] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 visualization: Optional[str] = None,
                 visualization_config: Optional['outputs.DashboardTileVisualizationConfig'] = None):
        """
        :param str name: the name of the tile
        :param str tile_type: the type of the tile. Must be either `APPLICATION_WORLDMAP`, `RESOURCES`, `THIRD_PARTY_MOST_ACTIVE`, `UEM_CONVERSIONS_PER_GOAL`, `PROCESS_GROUPS_ONE` or `HOST` .
        :param Sequence[str] assigned_entities: The list of Dynatrace entities, assigned to the tile
        :param bool auto_refresh_disabled: Auto Refresh is disabled (`true`)
        :param 'DashboardTileBoundsArgs' bounds: the position and size of a tile
        :param bool configured: The tile is configured and ready to use (`true`) or just placed on the dashboard (`false`)
        :param str custom_name: The name of the tile, set by user
        :param bool exclude_maintenance_windows: Include (`false') or exclude (`true`) maintenance windows from availability calculations
        :param 'DashboardTileFilterArgs' filter: is filter applied to a tile. It overrides dashboard's filter
        :param 'DashboardTileFilterConfigArgs' filter_config: the position and size of a tile
        :param int limit: The limit of the results, if not set will use the default value of the system
        :param str markdown: The markdown-formatted content of the tile
        :param str metric: The metric assigned to the tile
        :param str name_size: The size of the tile name. Possible values are `small`, `medium` and `large`.
        :param str query: A [user session query](https://www.dynatrace.com/support/help/shortlink/usql-info) executed by the tile
        :param str time_frame_shift: The comparison timeframe of the query. If specified, you additionally get the results of the same query with the specified time shift
        :param str type: The attribute `type` exists for backwards compatibilty. Usage is discouraged. You should use `visualization` instead.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str visualization: The visualization of the tile. Possible values are: `COLUMN_CHART`, `FUNNEL`, `LINE_CHART`, `PIE_CHART`, `SINGLE_VALUE`, `TABLE`
        :param 'DashboardTileVisualizationConfigArgs' visualization_config: Configuration of a User session query visualization tile
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tile_type", tile_type)
        if assigned_entities is not None:
            pulumi.set(__self__, "assigned_entities", assigned_entities)
        if auto_refresh_disabled is not None:
            pulumi.set(__self__, "auto_refresh_disabled", auto_refresh_disabled)
        if bounds is not None:
            pulumi.set(__self__, "bounds", bounds)
        if chart_visible is not None:
            pulumi.set(__self__, "chart_visible", chart_visible)
        if configured is not None:
            pulumi.set(__self__, "configured", configured)
        if custom_name is not None:
            pulumi.set(__self__, "custom_name", custom_name)
        if exclude_maintenance_windows is not None:
            pulumi.set(__self__, "exclude_maintenance_windows", exclude_maintenance_windows)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if filter_config is not None:
            pulumi.set(__self__, "filter_config", filter_config)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if markdown is not None:
            pulumi.set(__self__, "markdown", markdown)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if name_size is not None:
            pulumi.set(__self__, "name_size", name_size)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if time_frame_shift is not None:
            pulumi.set(__self__, "time_frame_shift", time_frame_shift)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if visualization is not None:
            pulumi.set(__self__, "visualization", visualization)
        if visualization_config is not None:
            pulumi.set(__self__, "visualization_config", visualization_config)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        the name of the tile
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="tileType")
    def tile_type(self) -> str:
        """
        the type of the tile. Must be either `APPLICATION_WORLDMAP`, `RESOURCES`, `THIRD_PARTY_MOST_ACTIVE`, `UEM_CONVERSIONS_PER_GOAL`, `PROCESS_GROUPS_ONE` or `HOST` .
        """
        return pulumi.get(self, "tile_type")

    @property
    @pulumi.getter(name="assignedEntities")
    def assigned_entities(self) -> Optional[Sequence[str]]:
        """
        The list of Dynatrace entities, assigned to the tile
        """
        return pulumi.get(self, "assigned_entities")

    @property
    @pulumi.getter(name="autoRefreshDisabled")
    def auto_refresh_disabled(self) -> Optional[bool]:
        """
        Auto Refresh is disabled (`true`)
        """
        return pulumi.get(self, "auto_refresh_disabled")

    @property
    @pulumi.getter
    def bounds(self) -> Optional['outputs.DashboardTileBounds']:
        """
        the position and size of a tile
        """
        return pulumi.get(self, "bounds")

    @property
    @pulumi.getter(name="chartVisible")
    def chart_visible(self) -> Optional[bool]:
        return pulumi.get(self, "chart_visible")

    @property
    @pulumi.getter
    def configured(self) -> Optional[bool]:
        """
        The tile is configured and ready to use (`true`) or just placed on the dashboard (`false`)
        """
        return pulumi.get(self, "configured")

    @property
    @pulumi.getter(name="customName")
    def custom_name(self) -> Optional[str]:
        """
        The name of the tile, set by user
        """
        return pulumi.get(self, "custom_name")

    @property
    @pulumi.getter(name="excludeMaintenanceWindows")
    def exclude_maintenance_windows(self) -> Optional[bool]:
        """
        Include (`false') or exclude (`true`) maintenance windows from availability calculations
        """
        return pulumi.get(self, "exclude_maintenance_windows")

    @property
    @pulumi.getter
    def filter(self) -> Optional['outputs.DashboardTileFilter']:
        """
        is filter applied to a tile. It overrides dashboard's filter
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="filterConfig")
    def filter_config(self) -> Optional['outputs.DashboardTileFilterConfig']:
        """
        the position and size of a tile
        """
        return pulumi.get(self, "filter_config")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The limit of the results, if not set will use the default value of the system
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def markdown(self) -> Optional[str]:
        """
        The markdown-formatted content of the tile
        """
        return pulumi.get(self, "markdown")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric assigned to the tile
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="nameSize")
    def name_size(self) -> Optional[str]:
        """
        The size of the tile name. Possible values are `small`, `medium` and `large`.
        """
        return pulumi.get(self, "name_size")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        A [user session query](https://www.dynatrace.com/support/help/shortlink/usql-info) executed by the tile
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="timeFrameShift")
    def time_frame_shift(self) -> Optional[str]:
        """
        The comparison timeframe of the query. If specified, you additionally get the results of the same query with the specified time shift
        """
        return pulumi.get(self, "time_frame_shift")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The attribute `type` exists for backwards compatibilty. Usage is discouraged. You should use `visualization` instead.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def visualization(self) -> Optional[str]:
        """
        The visualization of the tile. Possible values are: `COLUMN_CHART`, `FUNNEL`, `LINE_CHART`, `PIE_CHART`, `SINGLE_VALUE`, `TABLE`
        """
        return pulumi.get(self, "visualization")

    @property
    @pulumi.getter(name="visualizationConfig")
    def visualization_config(self) -> Optional['outputs.DashboardTileVisualizationConfig']:
        """
        Configuration of a User session query visualization tile
        """
        return pulumi.get(self, "visualization_config")


@pulumi.output_type
class DashboardTileBounds(dict):
    def __init__(__self__, *,
                 height: int,
                 left: int,
                 top: int,
                 width: int,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "left", left)
        pulumi.set(__self__, "top", top)
        pulumi.set(__self__, "width", width)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def height(self) -> int:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def left(self) -> int:
        return pulumi.get(self, "left")

    @property
    @pulumi.getter
    def top(self) -> int:
        return pulumi.get(self, "top")

    @property
    @pulumi.getter
    def width(self) -> int:
        return pulumi.get(self, "width")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZones":
            suggest = "management_zones"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zones: Optional[Sequence['outputs.DashboardTileFilterManagementZone']] = None,
                 timeframe: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if management_zones is not None:
            pulumi.set(__self__, "management_zones", management_zones)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZones")
    def management_zones(self) -> Optional[Sequence['outputs.DashboardTileFilterManagementZone']]:
        return pulumi.get(self, "management_zones")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        return pulumi.get(self, "timeframe")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileFilterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customName":
            suggest = "custom_name"
        elif key == "defaultName":
            suggest = "default_name"
        elif key == "chartConfig":
            suggest = "chart_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_name: str,
                 default_name: str,
                 type: str,
                 chart_config: Optional['outputs.DashboardTileFilterConfigChartConfig'] = None,
                 filters: Optional['outputs.DashboardTileFilterConfigFilters'] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "custom_name", custom_name)
        pulumi.set(__self__, "default_name", default_name)
        pulumi.set(__self__, "type", type)
        if chart_config is not None:
            pulumi.set(__self__, "chart_config", chart_config)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="customName")
    def custom_name(self) -> str:
        return pulumi.get(self, "custom_name")

    @property
    @pulumi.getter(name="defaultName")
    def default_name(self) -> str:
        return pulumi.get(self, "default_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="chartConfig")
    def chart_config(self) -> Optional['outputs.DashboardTileFilterConfigChartConfig']:
        return pulumi.get(self, "chart_config")

    @property
    @pulumi.getter
    def filters(self) -> Optional['outputs.DashboardTileFilterConfigFilters']:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileFilterConfigChartConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisLimits":
            suggest = "axis_limits"
        elif key == "leftAxisCustomUnit":
            suggest = "left_axis_custom_unit"
        elif key == "resultMetadatas":
            suggest = "result_metadatas"
        elif key == "rightAxisCustomUnit":
            suggest = "right_axis_custom_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilterConfigChartConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilterConfigChartConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilterConfigChartConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 axis_limits: Optional[Mapping[str, float]] = None,
                 left_axis_custom_unit: Optional[str] = None,
                 legend: Optional[bool] = None,
                 result_metadatas: Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigResultMetadata']] = None,
                 right_axis_custom_unit: Optional[str] = None,
                 series: Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigSeries']] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "type", type)
        if axis_limits is not None:
            pulumi.set(__self__, "axis_limits", axis_limits)
        if left_axis_custom_unit is not None:
            pulumi.set(__self__, "left_axis_custom_unit", left_axis_custom_unit)
        if legend is not None:
            pulumi.set(__self__, "legend", legend)
        if result_metadatas is not None:
            pulumi.set(__self__, "result_metadatas", result_metadatas)
        if right_axis_custom_unit is not None:
            pulumi.set(__self__, "right_axis_custom_unit", right_axis_custom_unit)
        if series is not None:
            pulumi.set(__self__, "series", series)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="axisLimits")
    def axis_limits(self) -> Optional[Mapping[str, float]]:
        return pulumi.get(self, "axis_limits")

    @property
    @pulumi.getter(name="leftAxisCustomUnit")
    def left_axis_custom_unit(self) -> Optional[str]:
        return pulumi.get(self, "left_axis_custom_unit")

    @property
    @pulumi.getter
    def legend(self) -> Optional[bool]:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="resultMetadatas")
    def result_metadatas(self) -> Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigResultMetadata']]:
        return pulumi.get(self, "result_metadatas")

    @property
    @pulumi.getter(name="rightAxisCustomUnit")
    def right_axis_custom_unit(self) -> Optional[str]:
        return pulumi.get(self, "right_axis_custom_unit")

    @property
    @pulumi.getter
    def series(self) -> Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigSeries']]:
        return pulumi.get(self, "series")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileFilterConfigChartConfigResultMetadata(dict):
    def __init__(__self__, *,
                 configs: Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigResultMetadataConfig']] = None):
        if configs is not None:
            pulumi.set(__self__, "configs", configs)

    @property
    @pulumi.getter
    def configs(self) -> Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigResultMetadataConfig']]:
        return pulumi.get(self, "configs")


@pulumi.output_type
class DashboardTileFilterConfigChartConfigResultMetadataConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customColor":
            suggest = "custom_color"
        elif key == "lastModified":
            suggest = "last_modified"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilterConfigChartConfigResultMetadataConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilterConfigChartConfigResultMetadataConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilterConfigChartConfigResultMetadataConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_color: Optional[str] = None,
                 key: Optional[str] = None,
                 last_modified: Optional[int] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if custom_color is not None:
            pulumi.set(__self__, "custom_color", custom_color)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if last_modified is not None:
            pulumi.set(__self__, "last_modified", last_modified)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="customColor")
    def custom_color(self) -> Optional[str]:
        return pulumi.get(self, "custom_color")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="lastModified")
    def last_modified(self) -> Optional[int]:
        return pulumi.get(self, "last_modified")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileFilterConfigChartConfigSeries(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "aggregationRate":
            suggest = "aggregation_rate"
        elif key == "sortAscending":
            suggest = "sort_ascending"
        elif key == "sortColumn":
            suggest = "sort_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilterConfigChartConfigSeries. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilterConfigChartConfigSeries.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilterConfigChartConfigSeries.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation: str,
                 entity_type: str,
                 metric: str,
                 type: str,
                 aggregation_rate: Optional[str] = None,
                 dimensions: Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigSeriesDimension']] = None,
                 percentile: Optional[int] = None,
                 sort_ascending: Optional[bool] = None,
                 sort_column: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "type", type)
        if aggregation_rate is not None:
            pulumi.set(__self__, "aggregation_rate", aggregation_rate)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if percentile is not None:
            pulumi.set(__self__, "percentile", percentile)
        if sort_ascending is not None:
            pulumi.set(__self__, "sort_ascending", sort_ascending)
        if sort_column is not None:
            pulumi.set(__self__, "sort_column", sort_column)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="aggregationRate")
    def aggregation_rate(self) -> Optional[str]:
        return pulumi.get(self, "aggregation_rate")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigSeriesDimension']]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def percentile(self) -> Optional[int]:
        return pulumi.get(self, "percentile")

    @property
    @pulumi.getter(name="sortAscending")
    def sort_ascending(self) -> Optional[bool]:
        return pulumi.get(self, "sort_ascending")

    @property
    @pulumi.getter(name="sortColumn")
    def sort_column(self) -> Optional[bool]:
        return pulumi.get(self, "sort_column")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileFilterConfigChartConfigSeriesDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityDimension":
            suggest = "entity_dimension"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilterConfigChartConfigSeriesDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilterConfigChartConfigSeriesDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilterConfigChartConfigSeriesDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 entity_dimension: Optional[bool] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str id: The ID of this resource.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "id", id)
        if entity_dimension is not None:
            pulumi.set(__self__, "entity_dimension", entity_dimension)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="entityDimension")
    def entity_dimension(self) -> Optional[bool]:
        return pulumi.get(self, "entity_dimension")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardTileFilterConfigFilters(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.DashboardTileFilterConfigFiltersFilter']] = None):
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.DashboardTileFilterConfigFiltersFilter']]:
        return pulumi.get(self, "filters")


@pulumi.output_type
class DashboardTileFilterConfigFiltersFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilterConfigFiltersFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilterConfigFiltersFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilterConfigFiltersFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 matches: Optional[Sequence['outputs.DashboardTileFilterConfigFiltersFilterMatch']] = None):
        pulumi.set(__self__, "entity_type", entity_type)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.DashboardTileFilterConfigFiltersFilterMatch']]:
        return pulumi.get(self, "matches")


@pulumi.output_type
class DashboardTileFilterConfigFiltersFilterMatch(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardTileFilterManagementZone(dict):
    def __init__(__self__, *,
                 id: str,
                 description: Optional[str] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "id", id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileVisualizationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hasAxisBucketing":
            suggest = "has_axis_bucketing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileVisualizationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileVisualizationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileVisualizationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 has_axis_bucketing: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if has_axis_bucketing is not None:
            pulumi.set(__self__, "has_axis_bucketing", has_axis_bucketing)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="hasAxisBucketing")
    def has_axis_bucketing(self) -> Optional[bool]:
        return pulumi.get(self, "has_axis_bucketing")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardsAllowlistAllowlist(dict):
    def __init__(__self__, *,
                 urlpatterns: Sequence['outputs.DashboardsAllowlistAllowlistUrlpattern']):
        pulumi.set(__self__, "urlpatterns", urlpatterns)

    @property
    @pulumi.getter
    def urlpatterns(self) -> Sequence['outputs.DashboardsAllowlistAllowlistUrlpattern']:
        return pulumi.get(self, "urlpatterns")


@pulumi.output_type
class DashboardsAllowlistAllowlistUrlpattern(dict):
    def __init__(__self__, *,
                 rule: str,
                 template: str):
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def rule(self) -> str:
        return pulumi.get(self, "rule")

    @property
    @pulumi.getter
    def template(self) -> str:
        return pulumi.get(self, "template")


@pulumi.output_type
class DashboardsGeneralDefaultDashboardList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDashboards":
            suggest = "default_dashboards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardsGeneralDefaultDashboardList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardsGeneralDefaultDashboardList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardsGeneralDefaultDashboardList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_dashboards: Sequence['outputs.DashboardsGeneralDefaultDashboardListDefaultDashboard']):
        pulumi.set(__self__, "default_dashboards", default_dashboards)

    @property
    @pulumi.getter(name="defaultDashboards")
    def default_dashboards(self) -> Sequence['outputs.DashboardsGeneralDefaultDashboardListDefaultDashboard']:
        return pulumi.get(self, "default_dashboards")


@pulumi.output_type
class DashboardsGeneralDefaultDashboardListDefaultDashboard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userGroup":
            suggest = "user_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardsGeneralDefaultDashboardListDefaultDashboard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardsGeneralDefaultDashboardListDefaultDashboard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardsGeneralDefaultDashboardListDefaultDashboard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboard: str,
                 user_group: str):
        pulumi.set(__self__, "dashboard", dashboard)
        pulumi.set(__self__, "user_group", user_group)

    @property
    @pulumi.getter
    def dashboard(self) -> str:
        return pulumi.get(self, "dashboard")

    @property
    @pulumi.getter(name="userGroup")
    def user_group(self) -> str:
        return pulumi.get(self, "user_group")


@pulumi.output_type
class DashboardsPresetsDashboardPresetsList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dashboardPresets":
            suggest = "dashboard_presets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardsPresetsDashboardPresetsList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardsPresetsDashboardPresetsList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardsPresetsDashboardPresetsList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboard_presets: Sequence['outputs.DashboardsPresetsDashboardPresetsListDashboardPreset']):
        pulumi.set(__self__, "dashboard_presets", dashboard_presets)

    @property
    @pulumi.getter(name="dashboardPresets")
    def dashboard_presets(self) -> Sequence['outputs.DashboardsPresetsDashboardPresetsListDashboardPreset']:
        return pulumi.get(self, "dashboard_presets")


@pulumi.output_type
class DashboardsPresetsDashboardPresetsListDashboardPreset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dashboardPreset":
            suggest = "dashboard_preset"
        elif key == "userGroup":
            suggest = "user_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardsPresetsDashboardPresetsListDashboardPreset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardsPresetsDashboardPresetsListDashboardPreset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardsPresetsDashboardPresetsListDashboardPreset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboard_preset: str,
                 user_group: str):
        pulumi.set(__self__, "dashboard_preset", dashboard_preset)
        pulumi.set(__self__, "user_group", user_group)

    @property
    @pulumi.getter(name="dashboardPreset")
    def dashboard_preset(self) -> str:
        return pulumi.get(self, "dashboard_preset")

    @property
    @pulumi.getter(name="userGroup")
    def user_group(self) -> str:
        return pulumi.get(self, "user_group")


@pulumi.output_type
class DataPrivacyDataCollection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optInModeEnabled":
            suggest = "opt_in_mode_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataPrivacyDataCollection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataPrivacyDataCollection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataPrivacyDataCollection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 opt_in_mode_enabled: bool):
        """
        :param bool opt_in_mode_enabled: With [Data-collection and opt-in mode](https://dt-url.net/7l3p0p3h) enabled, Real User Monitoring data isn't captured until dtrum.enable() is called for specific user sessions.
        """
        pulumi.set(__self__, "opt_in_mode_enabled", opt_in_mode_enabled)

    @property
    @pulumi.getter(name="optInModeEnabled")
    def opt_in_mode_enabled(self) -> bool:
        """
        With [Data-collection and opt-in mode](https://dt-url.net/7l3p0p3h) enabled, Real User Monitoring data isn't captured until dtrum.enable() is called for specific user sessions.
        """
        return pulumi.get(self, "opt_in_mode_enabled")


@pulumi.output_type
class DataPrivacyDoNotTrack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "complyWithDoNotTrack":
            suggest = "comply_with_do_not_track"
        elif key == "doNotTrack":
            suggest = "do_not_track"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataPrivacyDoNotTrack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataPrivacyDoNotTrack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataPrivacyDoNotTrack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comply_with_do_not_track: bool,
                 do_not_track: Optional[str] = None):
        """
        :param bool comply_with_do_not_track: Comply with "Do Not Track" browser settings
        :param str do_not_track: Possible Values: `Anonymous`, `Disable_rum`
        """
        pulumi.set(__self__, "comply_with_do_not_track", comply_with_do_not_track)
        if do_not_track is not None:
            pulumi.set(__self__, "do_not_track", do_not_track)

    @property
    @pulumi.getter(name="complyWithDoNotTrack")
    def comply_with_do_not_track(self) -> bool:
        """
        Comply with "Do Not Track" browser settings
        """
        return pulumi.get(self, "comply_with_do_not_track")

    @property
    @pulumi.getter(name="doNotTrack")
    def do_not_track(self) -> Optional[str]:
        """
        Possible Values: `Anonymous`, `Disable_rum`
        """
        return pulumi.get(self, "do_not_track")


@pulumi.output_type
class DataPrivacyMasking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddressMaskingEnabled":
            suggest = "ip_address_masking_enabled"
        elif key == "personalDataUriMaskingEnabled":
            suggest = "personal_data_uri_masking_enabled"
        elif key == "userActionMaskingEnabled":
            suggest = "user_action_masking_enabled"
        elif key == "ipAddressMasking":
            suggest = "ip_address_masking"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataPrivacyMasking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataPrivacyMasking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataPrivacyMasking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address_masking_enabled: bool,
                 personal_data_uri_masking_enabled: bool,
                 user_action_masking_enabled: bool,
                 ip_address_masking: Optional[str] = None):
        """
        :param bool ip_address_masking_enabled: Dynatrace captures the IP addresses of your end-users to determine the regions from which they access your application. To learn more, visit [Mask IPs and GPS coordinates](https://dt-url.net/mask-end-users-ip-addresses).. Dynatrace also captures GPS data from mobile apps that provide their users with the option of sharing geolocation data. On the server side, Dynatrace captures IP addresses to enable detailed troubleshooting for Dynatrace service calls.
        """
        pulumi.set(__self__, "ip_address_masking_enabled", ip_address_masking_enabled)
        pulumi.set(__self__, "personal_data_uri_masking_enabled", personal_data_uri_masking_enabled)
        pulumi.set(__self__, "user_action_masking_enabled", user_action_masking_enabled)
        if ip_address_masking is not None:
            pulumi.set(__self__, "ip_address_masking", ip_address_masking)

    @property
    @pulumi.getter(name="ipAddressMaskingEnabled")
    def ip_address_masking_enabled(self) -> bool:
        """
        Dynatrace captures the IP addresses of your end-users to determine the regions from which they access your application. To learn more, visit [Mask IPs and GPS coordinates](https://dt-url.net/mask-end-users-ip-addresses).. Dynatrace also captures GPS data from mobile apps that provide their users with the option of sharing geolocation data. On the server side, Dynatrace captures IP addresses to enable detailed troubleshooting for Dynatrace service calls.
        """
        return pulumi.get(self, "ip_address_masking_enabled")

    @property
    @pulumi.getter(name="personalDataUriMaskingEnabled")
    def personal_data_uri_masking_enabled(self) -> bool:
        return pulumi.get(self, "personal_data_uri_masking_enabled")

    @property
    @pulumi.getter(name="userActionMaskingEnabled")
    def user_action_masking_enabled(self) -> bool:
        return pulumi.get(self, "user_action_masking_enabled")

    @property
    @pulumi.getter(name="ipAddressMasking")
    def ip_address_masking(self) -> Optional[str]:
        return pulumi.get(self, "ip_address_masking")


@pulumi.output_type
class DataPrivacyUserTracking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "persistentCookieEnabled":
            suggest = "persistent_cookie_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataPrivacyUserTracking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataPrivacyUserTracking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataPrivacyUserTracking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 persistent_cookie_enabled: bool):
        """
        :param bool persistent_cookie_enabled: When enabled, Dynatrace places a [persistent cookie](https://dt-url.net/313o0p4n) on all end-user devices to identify returning users.
        """
        pulumi.set(__self__, "persistent_cookie_enabled", persistent_cookie_enabled)

    @property
    @pulumi.getter(name="persistentCookieEnabled")
    def persistent_cookie_enabled(self) -> bool:
        """
        When enabled, Dynatrace places a [persistent cookie](https://dt-url.net/313o0p4n) on all end-user devices to identify returning users.
        """
        return pulumi.get(self, "persistent_cookie_enabled")


@pulumi.output_type
class DatabaseAnomaliesDbConnectFailures(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionFailsCount":
            suggest = "connection_fails_count"
        elif key == "evalPeriod":
            suggest = "eval_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesDbConnectFailures. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesDbConnectFailures.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesDbConnectFailures.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_fails_count: Optional[int] = None,
                 eval_period: Optional[int] = None):
        """
        :param int connection_fails_count: Number of failed database connections during any **eval_period** minutes period to trigger an alert
        :param int eval_period: The *X* minutes time period during which the **connection*fails*count** is evaluated
        """
        if connection_fails_count is not None:
            pulumi.set(__self__, "connection_fails_count", connection_fails_count)
        if eval_period is not None:
            pulumi.set(__self__, "eval_period", eval_period)

    @property
    @pulumi.getter(name="connectionFailsCount")
    def connection_fails_count(self) -> Optional[int]:
        """
        Number of failed database connections during any **eval_period** minutes period to trigger an alert
        """
        return pulumi.get(self, "connection_fails_count")

    @property
    @pulumi.getter(name="evalPeriod")
    def eval_period(self) -> Optional[int]:
        """
        The *X* minutes time period during which the **connection*fails*count** is evaluated
        """
        return pulumi.get(self, "eval_period")


@pulumi.output_type
class DatabaseAnomaliesFailureRate(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.DatabaseAnomaliesFailureRateAuto'] = None,
                 thresholds: Optional['outputs.DatabaseAnomaliesFailureRateThresholds'] = None):
        """
        :param 'DatabaseAnomaliesFailureRateAutoArgs' auto: Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
        :param 'DatabaseAnomaliesFailureRateThresholdsArgs' thresholds: Fixed thresholds for failure rate increase detection
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.DatabaseAnomaliesFailureRateAuto']:
        """
        Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.DatabaseAnomaliesFailureRateThresholds']:
        """
        Fixed thresholds for failure rate increase detection
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class DatabaseAnomaliesFailureRateAuto(dict):
    def __init__(__self__, *,
                 absolute: int,
                 relative: int,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "absolute", absolute)
        pulumi.set(__self__, "relative", relative)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def absolute(self) -> int:
        return pulumi.get(self, "absolute")

    @property
    @pulumi.getter
    def relative(self) -> int:
        return pulumi.get(self, "relative")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DatabaseAnomaliesFailureRateThresholds(dict):
    def __init__(__self__, *,
                 sensitivity: str,
                 threshold: int,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold", threshold)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DatabaseAnomaliesLoad(dict):
    def __init__(__self__, *,
                 drops: Optional['outputs.DatabaseAnomaliesLoadDrops'] = None,
                 spikes: Optional['outputs.DatabaseAnomaliesLoadSpikes'] = None):
        """
        :param 'DatabaseAnomaliesLoadDropsArgs' drops: The configuration of traffic drops detection
        :param 'DatabaseAnomaliesLoadSpikesArgs' spikes: The configuration of traffic spikes detection
        """
        if drops is not None:
            pulumi.set(__self__, "drops", drops)
        if spikes is not None:
            pulumi.set(__self__, "spikes", spikes)

    @property
    @pulumi.getter
    def drops(self) -> Optional['outputs.DatabaseAnomaliesLoadDrops']:
        """
        The configuration of traffic drops detection
        """
        return pulumi.get(self, "drops")

    @property
    @pulumi.getter
    def spikes(self) -> Optional['outputs.DatabaseAnomaliesLoadSpikes']:
        """
        The configuration of traffic spikes detection
        """
        return pulumi.get(self, "spikes")


@pulumi.output_type
class DatabaseAnomaliesLoadDrops(dict):
    def __init__(__self__, *,
                 minutes: Optional[int] = None,
                 percent: Optional[int] = None):
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        return pulumi.get(self, "percent")


@pulumi.output_type
class DatabaseAnomaliesLoadSpikes(dict):
    def __init__(__self__, *,
                 minutes: Optional[int] = None,
                 percent: Optional[int] = None,
                 unknowns: Optional[str] = None):
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        return pulumi.get(self, "percent")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DatabaseAnomaliesResponseTime(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.DatabaseAnomaliesResponseTimeAuto'] = None,
                 thresholds: Optional['outputs.DatabaseAnomaliesResponseTimeThresholds'] = None):
        """
        :param 'DatabaseAnomaliesResponseTimeAutoArgs' auto: Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
        :param 'DatabaseAnomaliesResponseTimeThresholdsArgs' thresholds: Fixed thresholds for response time degradation detection
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.DatabaseAnomaliesResponseTimeAuto']:
        """
        Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.DatabaseAnomaliesResponseTimeThresholds']:
        """
        Fixed thresholds for response time degradation detection
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class DatabaseAnomaliesResponseTimeAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestMilliseconds":
            suggest = "slowest_milliseconds"
        elif key == "slowestPercent":
            suggest = "slowest_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesResponseTimeAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesResponseTimeAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesResponseTimeAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load: str,
                 milliseconds: int,
                 percent: int,
                 slowest_milliseconds: int,
                 slowest_percent: int,
                 unknowns: Optional[str] = None):
        """
        :param str load: Configuration for anomalies regarding load drops and spikes
        """
        pulumi.set(__self__, "load", load)
        pulumi.set(__self__, "milliseconds", milliseconds)
        pulumi.set(__self__, "percent", percent)
        pulumi.set(__self__, "slowest_milliseconds", slowest_milliseconds)
        pulumi.set(__self__, "slowest_percent", slowest_percent)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def load(self) -> str:
        """
        Configuration for anomalies regarding load drops and spikes
        """
        return pulumi.get(self, "load")

    @property
    @pulumi.getter
    def milliseconds(self) -> int:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def percent(self) -> int:
        return pulumi.get(self, "percent")

    @property
    @pulumi.getter(name="slowestMilliseconds")
    def slowest_milliseconds(self) -> int:
        return pulumi.get(self, "slowest_milliseconds")

    @property
    @pulumi.getter(name="slowestPercent")
    def slowest_percent(self) -> int:
        return pulumi.get(self, "slowest_percent")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DatabaseAnomaliesResponseTimeThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestMilliseconds":
            suggest = "slowest_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesResponseTimeThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesResponseTimeThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesResponseTimeThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load: str,
                 milliseconds: int,
                 sensitivity: str,
                 slowest_milliseconds: int,
                 unknowns: Optional[str] = None):
        """
        :param str load: Configuration for anomalies regarding load drops and spikes
        """
        pulumi.set(__self__, "load", load)
        pulumi.set(__self__, "milliseconds", milliseconds)
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "slowest_milliseconds", slowest_milliseconds)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def load(self) -> str:
        """
        Configuration for anomalies regarding load drops and spikes
        """
        return pulumi.get(self, "load")

    @property
    @pulumi.getter
    def milliseconds(self) -> int:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter(name="slowestMilliseconds")
    def slowest_milliseconds(self) -> int:
        return pulumi.get(self, "slowest_milliseconds")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DatabaseAnomaliesV2DatabaseConnections(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxFailedConnects":
            suggest = "max_failed_connects"
        elif key == "timePeriod":
            suggest = "time_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2DatabaseConnections. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2DatabaseConnections.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2DatabaseConnections.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 max_failed_connects: Optional[int] = None,
                 time_period: Optional[int] = None):
        """
        :param bool enabled: Detect failed database connects
        :param int max_failed_connects: Threshold
        :param int time_period: Time span
        """
        pulumi.set(__self__, "enabled", enabled)
        if max_failed_connects is not None:
            pulumi.set(__self__, "max_failed_connects", max_failed_connects)
        if time_period is not None:
            pulumi.set(__self__, "time_period", time_period)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect failed database connects
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxFailedConnects")
    def max_failed_connects(self) -> Optional[int]:
        """
        Threshold
        """
        return pulumi.get(self, "max_failed_connects")

    @property
    @pulumi.getter(name="timePeriod")
    def time_period(self) -> Optional[int]:
        """
        Time span
        """
        return pulumi.get(self, "time_period")


@pulumi.output_type
class DatabaseAnomaliesV2FailureRate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDetection":
            suggest = "auto_detection"
        elif key == "detectionMode":
            suggest = "detection_mode"
        elif key == "fixedDetection":
            suggest = "fixed_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2FailureRate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2FailureRate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2FailureRate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 auto_detection: Optional['outputs.DatabaseAnomaliesV2FailureRateAutoDetection'] = None,
                 detection_mode: Optional[str] = None,
                 fixed_detection: Optional['outputs.DatabaseAnomaliesV2FailureRateFixedDetection'] = None):
        """
        :param bool enabled: Detect increases in failure rate
        :param 'DatabaseAnomaliesV2FailureRateAutoDetectionArgs' auto_detection: Alert if the percentage of failing service calls increases by **both** the absolute and relative thresholds:
        :param str detection_mode: Detection mode for increases in failure rate
        :param 'DatabaseAnomaliesV2FailureRateFixedDetectionArgs' fixed_detection: Alert if a given failure rate is exceeded during any 5-minute-period
        """
        pulumi.set(__self__, "enabled", enabled)
        if auto_detection is not None:
            pulumi.set(__self__, "auto_detection", auto_detection)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if fixed_detection is not None:
            pulumi.set(__self__, "fixed_detection", fixed_detection)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect increases in failure rate
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="autoDetection")
    def auto_detection(self) -> Optional['outputs.DatabaseAnomaliesV2FailureRateAutoDetection']:
        """
        Alert if the percentage of failing service calls increases by **both** the absolute and relative thresholds:
        """
        return pulumi.get(self, "auto_detection")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for increases in failure rate
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter(name="fixedDetection")
    def fixed_detection(self) -> Optional['outputs.DatabaseAnomaliesV2FailureRateFixedDetection']:
        """
        Alert if a given failure rate is exceeded during any 5-minute-period
        """
        return pulumi.get(self, "fixed_detection")


@pulumi.output_type
class DatabaseAnomaliesV2FailureRateAutoDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "absoluteIncrease":
            suggest = "absolute_increase"
        elif key == "overAlertingProtection":
            suggest = "over_alerting_protection"
        elif key == "relativeIncrease":
            suggest = "relative_increase"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2FailureRateAutoDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2FailureRateAutoDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2FailureRateAutoDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 absolute_increase: float,
                 over_alerting_protection: 'outputs.DatabaseAnomaliesV2FailureRateAutoDetectionOverAlertingProtection',
                 relative_increase: float):
        pulumi.set(__self__, "absolute_increase", absolute_increase)
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "relative_increase", relative_increase)

    @property
    @pulumi.getter(name="absoluteIncrease")
    def absolute_increase(self) -> float:
        return pulumi.get(self, "absolute_increase")

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.DatabaseAnomaliesV2FailureRateAutoDetectionOverAlertingProtection':
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter(name="relativeIncrease")
    def relative_increase(self) -> float:
        return pulumi.get(self, "relative_increase")


@pulumi.output_type
class DatabaseAnomaliesV2FailureRateAutoDetectionOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"
        elif key == "requestsPerMinute":
            suggest = "requests_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2FailureRateAutoDetectionOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2FailureRateAutoDetectionOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2FailureRateAutoDetectionOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_abnormal_state: int,
                 requests_per_minute: float):
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)
        pulumi.set(__self__, "requests_per_minute", requests_per_minute)

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> int:
        return pulumi.get(self, "minutes_abnormal_state")

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> float:
        return pulumi.get(self, "requests_per_minute")


@pulumi.output_type
class DatabaseAnomaliesV2FailureRateFixedDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overAlertingProtection":
            suggest = "over_alerting_protection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2FailureRateFixedDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2FailureRateFixedDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2FailureRateFixedDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 over_alerting_protection: 'outputs.DatabaseAnomaliesV2FailureRateFixedDetectionOverAlertingProtection',
                 sensitivity: str,
                 threshold: float):
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.DatabaseAnomaliesV2FailureRateFixedDetectionOverAlertingProtection':
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class DatabaseAnomaliesV2FailureRateFixedDetectionOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"
        elif key == "requestsPerMinute":
            suggest = "requests_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2FailureRateFixedDetectionOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2FailureRateFixedDetectionOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2FailureRateFixedDetectionOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_abnormal_state: int,
                 requests_per_minute: float):
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)
        pulumi.set(__self__, "requests_per_minute", requests_per_minute)

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> int:
        return pulumi.get(self, "minutes_abnormal_state")

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> float:
        return pulumi.get(self, "requests_per_minute")


@pulumi.output_type
class DatabaseAnomaliesV2LoadDrops(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadDropPercent":
            suggest = "load_drop_percent"
        elif key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2LoadDrops. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2LoadDrops.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2LoadDrops.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 load_drop_percent: Optional[float] = None,
                 minutes_abnormal_state: Optional[int] = None):
        """
        :param bool enabled: Detect service load drops
        :param float load_drop_percent: Threshold
        :param int minutes_abnormal_state: Time span
        """
        pulumi.set(__self__, "enabled", enabled)
        if load_drop_percent is not None:
            pulumi.set(__self__, "load_drop_percent", load_drop_percent)
        if minutes_abnormal_state is not None:
            pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect service load drops
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="loadDropPercent")
    def load_drop_percent(self) -> Optional[float]:
        """
        Threshold
        """
        return pulumi.get(self, "load_drop_percent")

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> Optional[int]:
        """
        Time span
        """
        return pulumi.get(self, "minutes_abnormal_state")


@pulumi.output_type
class DatabaseAnomaliesV2LoadSpikes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadSpikePercent":
            suggest = "load_spike_percent"
        elif key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2LoadSpikes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2LoadSpikes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2LoadSpikes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 load_spike_percent: Optional[float] = None,
                 minutes_abnormal_state: Optional[int] = None):
        """
        :param bool enabled: Detect service load spikes
        :param float load_spike_percent: Threshold
        :param int minutes_abnormal_state: Time span
        """
        pulumi.set(__self__, "enabled", enabled)
        if load_spike_percent is not None:
            pulumi.set(__self__, "load_spike_percent", load_spike_percent)
        if minutes_abnormal_state is not None:
            pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect service load spikes
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="loadSpikePercent")
    def load_spike_percent(self) -> Optional[float]:
        """
        Threshold
        """
        return pulumi.get(self, "load_spike_percent")

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> Optional[int]:
        """
        Time span
        """
        return pulumi.get(self, "minutes_abnormal_state")


@pulumi.output_type
class DatabaseAnomaliesV2ResponseTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDetection":
            suggest = "auto_detection"
        elif key == "detectionMode":
            suggest = "detection_mode"
        elif key == "fixedDetection":
            suggest = "fixed_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2ResponseTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2ResponseTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2ResponseTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 auto_detection: Optional['outputs.DatabaseAnomaliesV2ResponseTimeAutoDetection'] = None,
                 detection_mode: Optional[str] = None,
                 fixed_detection: Optional['outputs.DatabaseAnomaliesV2ResponseTimeFixedDetection'] = None):
        """
        :param bool enabled: Detect response time degradations
        :param 'DatabaseAnomaliesV2ResponseTimeAutoDetectionArgs' auto_detection: no documentation available
        :param str detection_mode: Detection mode for response time degradations
        :param 'DatabaseAnomaliesV2ResponseTimeFixedDetectionArgs' fixed_detection: no documentation available
        """
        pulumi.set(__self__, "enabled", enabled)
        if auto_detection is not None:
            pulumi.set(__self__, "auto_detection", auto_detection)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if fixed_detection is not None:
            pulumi.set(__self__, "fixed_detection", fixed_detection)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect response time degradations
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="autoDetection")
    def auto_detection(self) -> Optional['outputs.DatabaseAnomaliesV2ResponseTimeAutoDetection']:
        """
        no documentation available
        """
        return pulumi.get(self, "auto_detection")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for response time degradations
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter(name="fixedDetection")
    def fixed_detection(self) -> Optional['outputs.DatabaseAnomaliesV2ResponseTimeFixedDetection']:
        """
        no documentation available
        """
        return pulumi.get(self, "fixed_detection")


@pulumi.output_type
class DatabaseAnomaliesV2ResponseTimeAutoDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overAlertingProtection":
            suggest = "over_alerting_protection"
        elif key == "responseTimeAll":
            suggest = "response_time_all"
        elif key == "responseTimeSlowest":
            suggest = "response_time_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2ResponseTimeAutoDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2ResponseTimeAutoDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2ResponseTimeAutoDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 over_alerting_protection: 'outputs.DatabaseAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection',
                 response_time_all: 'outputs.DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll',
                 response_time_slowest: 'outputs.DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest'):
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "response_time_all", response_time_all)
        pulumi.set(__self__, "response_time_slowest", response_time_slowest)

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.DatabaseAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection':
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter(name="responseTimeAll")
    def response_time_all(self) -> 'outputs.DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll':
        return pulumi.get(self, "response_time_all")

    @property
    @pulumi.getter(name="responseTimeSlowest")
    def response_time_slowest(self) -> 'outputs.DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest':
        return pulumi.get(self, "response_time_slowest")


@pulumi.output_type
class DatabaseAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"
        elif key == "requestsPerMinute":
            suggest = "requests_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_abnormal_state: int,
                 requests_per_minute: float):
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)
        pulumi.set(__self__, "requests_per_minute", requests_per_minute)

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> int:
        return pulumi.get(self, "minutes_abnormal_state")

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> float:
        return pulumi.get(self, "requests_per_minute")


@pulumi.output_type
class DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "degradationMilliseconds":
            suggest = "degradation_milliseconds"
        elif key == "degradationPercent":
            suggest = "degradation_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 degradation_milliseconds: float,
                 degradation_percent: float):
        pulumi.set(__self__, "degradation_milliseconds", degradation_milliseconds)
        pulumi.set(__self__, "degradation_percent", degradation_percent)

    @property
    @pulumi.getter(name="degradationMilliseconds")
    def degradation_milliseconds(self) -> float:
        return pulumi.get(self, "degradation_milliseconds")

    @property
    @pulumi.getter(name="degradationPercent")
    def degradation_percent(self) -> float:
        return pulumi.get(self, "degradation_percent")


@pulumi.output_type
class DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestDegradationMilliseconds":
            suggest = "slowest_degradation_milliseconds"
        elif key == "slowestDegradationPercent":
            suggest = "slowest_degradation_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slowest_degradation_milliseconds: float,
                 slowest_degradation_percent: float):
        pulumi.set(__self__, "slowest_degradation_milliseconds", slowest_degradation_milliseconds)
        pulumi.set(__self__, "slowest_degradation_percent", slowest_degradation_percent)

    @property
    @pulumi.getter(name="slowestDegradationMilliseconds")
    def slowest_degradation_milliseconds(self) -> float:
        return pulumi.get(self, "slowest_degradation_milliseconds")

    @property
    @pulumi.getter(name="slowestDegradationPercent")
    def slowest_degradation_percent(self) -> float:
        return pulumi.get(self, "slowest_degradation_percent")


@pulumi.output_type
class DatabaseAnomaliesV2ResponseTimeFixedDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overAlertingProtection":
            suggest = "over_alerting_protection"
        elif key == "responseTimeAll":
            suggest = "response_time_all"
        elif key == "responseTimeSlowest":
            suggest = "response_time_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2ResponseTimeFixedDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2ResponseTimeFixedDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2ResponseTimeFixedDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 over_alerting_protection: 'outputs.DatabaseAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection',
                 response_time_all: 'outputs.DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll',
                 response_time_slowest: 'outputs.DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest',
                 sensitivity: str):
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "response_time_all", response_time_all)
        pulumi.set(__self__, "response_time_slowest", response_time_slowest)
        pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.DatabaseAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection':
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter(name="responseTimeAll")
    def response_time_all(self) -> 'outputs.DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll':
        return pulumi.get(self, "response_time_all")

    @property
    @pulumi.getter(name="responseTimeSlowest")
    def response_time_slowest(self) -> 'outputs.DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest':
        return pulumi.get(self, "response_time_slowest")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class DatabaseAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"
        elif key == "requestsPerMinute":
            suggest = "requests_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_abnormal_state: int,
                 requests_per_minute: float):
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)
        pulumi.set(__self__, "requests_per_minute", requests_per_minute)

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> int:
        return pulumi.get(self, "minutes_abnormal_state")

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> float:
        return pulumi.get(self, "requests_per_minute")


@pulumi.output_type
class DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "degradationMilliseconds":
            suggest = "degradation_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 degradation_milliseconds: float):
        pulumi.set(__self__, "degradation_milliseconds", degradation_milliseconds)

    @property
    @pulumi.getter(name="degradationMilliseconds")
    def degradation_milliseconds(self) -> float:
        return pulumi.get(self, "degradation_milliseconds")


@pulumi.output_type
class DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestDegradationMilliseconds":
            suggest = "slowest_degradation_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slowest_degradation_milliseconds: float):
        pulumi.set(__self__, "slowest_degradation_milliseconds", slowest_degradation_milliseconds)

    @property
    @pulumi.getter(name="slowestDegradationMilliseconds")
    def slowest_degradation_milliseconds(self) -> float:
        return pulumi.get(self, "slowest_degradation_milliseconds")


@pulumi.output_type
class DduPoolEvents(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 type: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param bool enabled: Is the limit configuration enabled
        :param str type: Type of the limit applied: MONTHLY or ANNUAL
        :param int value: Value of the DDU limit applied for provided timerange
        """
        pulumi.set(__self__, "enabled", enabled)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the limit configuration enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the limit applied: MONTHLY or ANNUAL
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        Value of the DDU limit applied for provided timerange
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DduPoolLogMonitoring(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 type: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param bool enabled: Is the limit configuration enabled
        :param str type: Type of the limit applied: MONTHLY or ANNUAL
        :param int value: Value of the DDU limit applied for provided timerange
        """
        pulumi.set(__self__, "enabled", enabled)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the limit configuration enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the limit applied: MONTHLY or ANNUAL
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        Value of the DDU limit applied for provided timerange
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DduPoolMetrics(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 type: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param bool enabled: Is the limit configuration enabled
        :param str type: Type of the limit applied: MONTHLY or ANNUAL
        :param int value: Value of the DDU limit applied for provided timerange
        """
        pulumi.set(__self__, "enabled", enabled)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the limit configuration enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the limit applied: MONTHLY or ANNUAL
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        Value of the DDU limit applied for provided timerange
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DduPoolServerless(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 type: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param bool enabled: Is the limit configuration enabled
        :param str type: Type of the limit applied: MONTHLY or ANNUAL
        :param int value: Value of the DDU limit applied for provided timerange
        """
        pulumi.set(__self__, "enabled", enabled)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the limit configuration enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the limit applied: MONTHLY or ANNUAL
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        Value of the DDU limit applied for provided timerange
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DduPoolTraces(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 type: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param bool enabled: Is the limit configuration enabled
        :param str type: Type of the limit applied: MONTHLY or ANNUAL
        :param int value: Value of the DDU limit applied for provided timerange
        """
        pulumi.set(__self__, "enabled", enabled)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the limit configuration enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the limit applied: MONTHLY or ANNUAL
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        Value of the DDU limit applied for provided timerange
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DeclarativeGroupingDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "processDefinitions":
            suggest = "process_definitions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeclarativeGroupingDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeclarativeGroupingDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeclarativeGroupingDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 process_definitions: Sequence['outputs.DeclarativeGroupingDetectionProcessDefinition']):
        pulumi.set(__self__, "process_definitions", process_definitions)

    @property
    @pulumi.getter(name="processDefinitions")
    def process_definitions(self) -> Sequence['outputs.DeclarativeGroupingDetectionProcessDefinition']:
        return pulumi.get(self, "process_definitions")


@pulumi.output_type
class DeclarativeGroupingDetectionProcessDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "processGroupName":
            suggest = "process_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeclarativeGroupingDetectionProcessDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeclarativeGroupingDetectionProcessDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeclarativeGroupingDetectionProcessDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 process_group_name: str,
                 report: str,
                 rules: Optional['outputs.DeclarativeGroupingDetectionProcessDefinitionRules'] = None):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "process_group_name", process_group_name)
        pulumi.set(__self__, "report", report)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="processGroupName")
    def process_group_name(self) -> str:
        return pulumi.get(self, "process_group_name")

    @property
    @pulumi.getter
    def report(self) -> str:
        return pulumi.get(self, "report")

    @property
    @pulumi.getter
    def rules(self) -> Optional['outputs.DeclarativeGroupingDetectionProcessDefinitionRules']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class DeclarativeGroupingDetectionProcessDefinitionRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.DeclarativeGroupingDetectionProcessDefinitionRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.DeclarativeGroupingDetectionProcessDefinitionRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class DeclarativeGroupingDetectionProcessDefinitionRulesRule(dict):
    def __init__(__self__, *,
                 condition: str,
                 property: str):
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "property", property)

    @property
    @pulumi.getter
    def condition(self) -> str:
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def property(self) -> str:
        return pulumi.get(self, "property")


@pulumi.output_type
class DiskAnomaliesDiskName(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        """
        :param str operator: Possible values are: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_EQUAL`, `DOES_NOT_START_WITH`, `EQUALS` and `STARTS_WITH`
        :param str value: Value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Possible values are: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_EQUAL`, `DOES_NOT_START_WITH`, `EQUALS` and `STARTS_WITH`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DiskAnomaliesTags(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.DiskAnomaliesTagsFilter']] = None):
        """
        :param Sequence['DiskAnomaliesTagsFilterArgs'] filters: A Tag Filter
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.DiskAnomaliesTagsFilter']]:
        """
        A Tag Filter
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class DiskAnomaliesTagsFilter(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DiskAnomaliesV2Disk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskLowInodesDetection":
            suggest = "disk_low_inodes_detection"
        elif key == "diskLowSpaceDetection":
            suggest = "disk_low_space_detection"
        elif key == "diskSlowWritesAndReadsDetection":
            suggest = "disk_slow_writes_and_reads_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskAnomaliesV2Disk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskAnomaliesV2Disk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskAnomaliesV2Disk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_low_inodes_detection: 'outputs.DiskAnomaliesV2DiskDiskLowInodesDetection',
                 disk_low_space_detection: 'outputs.DiskAnomaliesV2DiskDiskLowSpaceDetection',
                 disk_slow_writes_and_reads_detection: 'outputs.DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetection'):
        """
        :param 'DiskAnomaliesV2DiskDiskLowInodesDetectionArgs' disk_low_inodes_detection: no documentation available
        :param 'DiskAnomaliesV2DiskDiskLowSpaceDetectionArgs' disk_low_space_detection: no documentation available
        :param 'DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionArgs' disk_slow_writes_and_reads_detection: no documentation available
        """
        pulumi.set(__self__, "disk_low_inodes_detection", disk_low_inodes_detection)
        pulumi.set(__self__, "disk_low_space_detection", disk_low_space_detection)
        pulumi.set(__self__, "disk_slow_writes_and_reads_detection", disk_slow_writes_and_reads_detection)

    @property
    @pulumi.getter(name="diskLowInodesDetection")
    def disk_low_inodes_detection(self) -> 'outputs.DiskAnomaliesV2DiskDiskLowInodesDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "disk_low_inodes_detection")

    @property
    @pulumi.getter(name="diskLowSpaceDetection")
    def disk_low_space_detection(self) -> 'outputs.DiskAnomaliesV2DiskDiskLowSpaceDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "disk_low_space_detection")

    @property
    @pulumi.getter(name="diskSlowWritesAndReadsDetection")
    def disk_slow_writes_and_reads_detection(self) -> 'outputs.DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "disk_slow_writes_and_reads_detection")


@pulumi.output_type
class DiskAnomaliesV2DiskDiskLowInodesDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskAnomaliesV2DiskDiskLowInodesDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskAnomaliesV2DiskDiskLowInodesDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskAnomaliesV2DiskDiskLowInodesDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.DiskAnomaliesV2DiskDiskLowInodesDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.DiskAnomaliesV2DiskDiskLowInodesDetectionCustomThresholds']:
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class DiskAnomaliesV2DiskDiskLowInodesDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeInodesPercentage":
            suggest = "free_inodes_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskAnomaliesV2DiskDiskLowInodesDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskAnomaliesV2DiskDiskLowInodesDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskAnomaliesV2DiskDiskLowInodesDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_inodes_percentage: int):
        pulumi.set(__self__, "free_inodes_percentage", free_inodes_percentage)

    @property
    @pulumi.getter(name="freeInodesPercentage")
    def free_inodes_percentage(self) -> int:
        return pulumi.get(self, "free_inodes_percentage")


@pulumi.output_type
class DiskAnomaliesV2DiskDiskLowSpaceDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskAnomaliesV2DiskDiskLowSpaceDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskAnomaliesV2DiskDiskLowSpaceDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskAnomaliesV2DiskDiskLowSpaceDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.DiskAnomaliesV2DiskDiskLowSpaceDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.DiskAnomaliesV2DiskDiskLowSpaceDetectionCustomThresholds']:
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class DiskAnomaliesV2DiskDiskLowSpaceDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeSpacePercentage":
            suggest = "free_space_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskAnomaliesV2DiskDiskLowSpaceDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskAnomaliesV2DiskDiskLowSpaceDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskAnomaliesV2DiskDiskLowSpaceDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_space_percentage: int):
        pulumi.set(__self__, "free_space_percentage", free_space_percentage)

    @property
    @pulumi.getter(name="freeSpacePercentage")
    def free_space_percentage(self) -> int:
        return pulumi.get(self, "free_space_percentage")


@pulumi.output_type
class DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionCustomThresholds']:
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "writeAndReadTime":
            suggest = "write_and_read_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 write_and_read_time: int):
        pulumi.set(__self__, "write_and_read_time", write_and_read_time)

    @property
    @pulumi.getter(name="writeAndReadTime")
    def write_and_read_time(self) -> int:
        return pulumi.get(self, "write_and_read_time")


@pulumi.output_type
class DiskAnomalyRulesDiskNameFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: Optional[str] = None):
        """
        :param str operator: Possible Values: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_EQUAL`, `DOES_NOT_START_WITH`, `EQUALS`, `STARTS_WITH`
        :param str value: Matching text
        """
        pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Possible Values: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_EQUAL`, `DOES_NOT_START_WITH`, `EQUALS`, `STARTS_WITH`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Matching text
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DiskAnomalyRulesSampleLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskAnomalyRulesSampleLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskAnomalyRulesSampleLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskAnomalyRulesSampleLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 samples: int,
                 violating_samples: int):
        """
        :param int samples: .. within the last
        :param int violating_samples: Minimum number of violating samples
        """
        pulumi.set(__self__, "samples", samples)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter
    def samples(self) -> int:
        """
        .. within the last
        """
        return pulumi.get(self, "samples")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        Minimum number of violating samples
        """
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class DiskOptionsExclusions(dict):
    def __init__(__self__, *,
                 exclusions: Sequence['outputs.DiskOptionsExclusionsExclusion']):
        pulumi.set(__self__, "exclusions", exclusions)

    @property
    @pulumi.getter
    def exclusions(self) -> Sequence['outputs.DiskOptionsExclusionsExclusion']:
        return pulumi.get(self, "exclusions")


@pulumi.output_type
class DiskOptionsExclusionsExclusion(dict):
    def __init__(__self__, *,
                 os: str,
                 filesystem: Optional[str] = None,
                 mountpoint: Optional[str] = None):
        pulumi.set(__self__, "os", os)
        if filesystem is not None:
            pulumi.set(__self__, "filesystem", filesystem)
        if mountpoint is not None:
            pulumi.set(__self__, "mountpoint", mountpoint)

    @property
    @pulumi.getter
    def os(self) -> str:
        return pulumi.get(self, "os")

    @property
    @pulumi.getter
    def filesystem(self) -> Optional[str]:
        return pulumi.get(self, "filesystem")

    @property
    @pulumi.getter
    def mountpoint(self) -> Optional[str]:
        return pulumi.get(self, "mountpoint")


@pulumi.output_type
class DiskSpecificAnomaliesV2DiskLowInodesDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskSpecificAnomaliesV2DiskLowInodesDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskSpecificAnomaliesV2DiskLowInodesDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskSpecificAnomaliesV2DiskLowInodesDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.DiskSpecificAnomaliesV2DiskLowInodesDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: Detect low inodes number available
        :param 'DiskSpecificAnomaliesV2DiskLowInodesDetectionCustomThresholdsArgs' custom_thresholds: no documentation available
        :param str detection_mode: Detection mode for low inodes number available
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect low inodes number available
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.DiskSpecificAnomaliesV2DiskLowInodesDetectionCustomThresholds']:
        """
        no documentation available
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for low inodes number available
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class DiskSpecificAnomaliesV2DiskLowInodesDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeInodesPercentage":
            suggest = "free_inodes_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskSpecificAnomaliesV2DiskLowInodesDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskSpecificAnomaliesV2DiskLowInodesDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskSpecificAnomaliesV2DiskLowInodesDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_inodes_percentage: int):
        pulumi.set(__self__, "free_inodes_percentage", free_inodes_percentage)

    @property
    @pulumi.getter(name="freeInodesPercentage")
    def free_inodes_percentage(self) -> int:
        return pulumi.get(self, "free_inodes_percentage")


@pulumi.output_type
class DiskSpecificAnomaliesV2DiskLowSpaceDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskSpecificAnomaliesV2DiskLowSpaceDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskSpecificAnomaliesV2DiskLowSpaceDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskSpecificAnomaliesV2DiskLowSpaceDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.DiskSpecificAnomaliesV2DiskLowSpaceDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: Detect low disk space
        :param 'DiskSpecificAnomaliesV2DiskLowSpaceDetectionCustomThresholdsArgs' custom_thresholds: no documentation available
        :param str detection_mode: Detection mode for low disk space
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect low disk space
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.DiskSpecificAnomaliesV2DiskLowSpaceDetectionCustomThresholds']:
        """
        no documentation available
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for low disk space
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class DiskSpecificAnomaliesV2DiskLowSpaceDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeSpacePercentage":
            suggest = "free_space_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskSpecificAnomaliesV2DiskLowSpaceDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskSpecificAnomaliesV2DiskLowSpaceDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskSpecificAnomaliesV2DiskLowSpaceDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_space_percentage: int):
        pulumi.set(__self__, "free_space_percentage", free_space_percentage)

    @property
    @pulumi.getter(name="freeSpacePercentage")
    def free_space_percentage(self) -> int:
        return pulumi.get(self, "free_space_percentage")


@pulumi.output_type
class DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: Detect slow-running disks
        :param 'DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetectionCustomThresholdsArgs' custom_thresholds: no documentation available
        :param str detection_mode: Detection mode for slow running disks
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect slow-running disks
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetectionCustomThresholds']:
        """
        no documentation available
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for slow running disks
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "writeAndReadTime":
            suggest = "write_and_read_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 write_and_read_time: int):
        pulumi.set(__self__, "write_and_read_time", write_and_read_time)

    @property
    @pulumi.getter(name="writeAndReadTime")
    def write_and_read_time(self) -> int:
        return pulumi.get(self, "write_and_read_time")


@pulumi.output_type
class EnvironmentQuotas(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "demUnits":
            suggest = "dem_units"
        elif key == "hostUnits":
            suggest = "host_units"
        elif key == "userSessions":
            suggest = "user_sessions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentQuotas. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentQuotas.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentQuotas.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ddus: Optional['outputs.EnvironmentQuotasDdus'] = None,
                 dem_units: Optional['outputs.EnvironmentQuotasDemUnits'] = None,
                 host_units: Optional[int] = None,
                 logs: Optional['outputs.EnvironmentQuotasLogs'] = None,
                 synthetic: Optional['outputs.EnvironmentQuotasSynthetic'] = None,
                 user_sessions: Optional['outputs.EnvironmentQuotasUserSessions'] = None):
        """
        :param 'EnvironmentQuotasDdusArgs' ddus: Davis Data Units consumption and quota information on environment level. Not set (and not editable) if Davis data units is not enabled
        :param 'EnvironmentQuotasDemUnitsArgs' dem_units: DEM units consumption and quota information on environment level
        :param int host_units: Host units consumption and quota information on environment level
        :param 'EnvironmentQuotasLogsArgs' logs: Log Monitoring consumption and quota information on environment level. Not set (and not editable) if Log monitoring is not enabled. Not set (and not editable) if Log monitoring is migrated to Davis data on license level
        :param 'EnvironmentQuotasSyntheticArgs' synthetic: Synthetic monitors consumption and quota information on environment level. Not set (and not editable) if neither Synthetic nor DEM units is enabled
        :param 'EnvironmentQuotasUserSessionsArgs' user_sessions: User sessions consumption and quota information on environment level
        """
        if ddus is not None:
            pulumi.set(__self__, "ddus", ddus)
        if dem_units is not None:
            pulumi.set(__self__, "dem_units", dem_units)
        if host_units is not None:
            pulumi.set(__self__, "host_units", host_units)
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if synthetic is not None:
            pulumi.set(__self__, "synthetic", synthetic)
        if user_sessions is not None:
            pulumi.set(__self__, "user_sessions", user_sessions)

    @property
    @pulumi.getter
    def ddus(self) -> Optional['outputs.EnvironmentQuotasDdus']:
        """
        Davis Data Units consumption and quota information on environment level. Not set (and not editable) if Davis data units is not enabled
        """
        return pulumi.get(self, "ddus")

    @property
    @pulumi.getter(name="demUnits")
    def dem_units(self) -> Optional['outputs.EnvironmentQuotasDemUnits']:
        """
        DEM units consumption and quota information on environment level
        """
        return pulumi.get(self, "dem_units")

    @property
    @pulumi.getter(name="hostUnits")
    def host_units(self) -> Optional[int]:
        """
        Host units consumption and quota information on environment level
        """
        return pulumi.get(self, "host_units")

    @property
    @pulumi.getter
    def logs(self) -> Optional['outputs.EnvironmentQuotasLogs']:
        """
        Log Monitoring consumption and quota information on environment level. Not set (and not editable) if Log monitoring is not enabled. Not set (and not editable) if Log monitoring is migrated to Davis data on license level
        """
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def synthetic(self) -> Optional['outputs.EnvironmentQuotasSynthetic']:
        """
        Synthetic monitors consumption and quota information on environment level. Not set (and not editable) if neither Synthetic nor DEM units is enabled
        """
        return pulumi.get(self, "synthetic")

    @property
    @pulumi.getter(name="userSessions")
    def user_sessions(self) -> Optional['outputs.EnvironmentQuotasUserSessions']:
        """
        User sessions consumption and quota information on environment level
        """
        return pulumi.get(self, "user_sessions")


@pulumi.output_type
class EnvironmentQuotasDdus(dict):
    def __init__(__self__, *,
                 annual: Optional[int] = None,
                 monthly: Optional[int] = None):
        if annual is not None:
            pulumi.set(__self__, "annual", annual)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)

    @property
    @pulumi.getter
    def annual(self) -> Optional[int]:
        return pulumi.get(self, "annual")

    @property
    @pulumi.getter
    def monthly(self) -> Optional[int]:
        return pulumi.get(self, "monthly")


@pulumi.output_type
class EnvironmentQuotasDemUnits(dict):
    def __init__(__self__, *,
                 annual: Optional[int] = None,
                 monthly: Optional[int] = None):
        if annual is not None:
            pulumi.set(__self__, "annual", annual)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)

    @property
    @pulumi.getter
    def annual(self) -> Optional[int]:
        return pulumi.get(self, "annual")

    @property
    @pulumi.getter
    def monthly(self) -> Optional[int]:
        return pulumi.get(self, "monthly")


@pulumi.output_type
class EnvironmentQuotasLogs(dict):
    def __init__(__self__, *,
                 annual: Optional[int] = None,
                 monthly: Optional[int] = None):
        if annual is not None:
            pulumi.set(__self__, "annual", annual)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)

    @property
    @pulumi.getter
    def annual(self) -> Optional[int]:
        return pulumi.get(self, "annual")

    @property
    @pulumi.getter
    def monthly(self) -> Optional[int]:
        return pulumi.get(self, "monthly")


@pulumi.output_type
class EnvironmentQuotasSynthetic(dict):
    def __init__(__self__, *,
                 annual: Optional[int] = None,
                 monthly: Optional[int] = None):
        if annual is not None:
            pulumi.set(__self__, "annual", annual)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)

    @property
    @pulumi.getter
    def annual(self) -> Optional[int]:
        return pulumi.get(self, "annual")

    @property
    @pulumi.getter
    def monthly(self) -> Optional[int]:
        return pulumi.get(self, "monthly")


@pulumi.output_type
class EnvironmentQuotasUserSessions(dict):
    def __init__(__self__, *,
                 annual: Optional[int] = None,
                 monthly: Optional[int] = None):
        if annual is not None:
            pulumi.set(__self__, "annual", annual)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)

    @property
    @pulumi.getter
    def annual(self) -> Optional[int]:
        return pulumi.get(self, "annual")

    @property
    @pulumi.getter
    def monthly(self) -> Optional[int]:
        return pulumi.get(self, "monthly")


@pulumi.output_type
class EnvironmentStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userActions":
            suggest = "user_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transactions: int,
                 limits: Optional['outputs.EnvironmentStorageLimits'] = None,
                 retention: Optional['outputs.EnvironmentStorageRetention'] = None,
                 user_actions: Optional[int] = None):
        """
        :param int transactions: Maximum number of newly monitored entry point PurePaths captured per process/minute on environment level. Can be set to any value from 100 to 100000
        :param int user_actions: Maximum number of user actions generated per minute on environment level. Can be set to any value from 1 to 2147483646 or left unlimited by omitting this property
        """
        pulumi.set(__self__, "transactions", transactions)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if retention is not None:
            pulumi.set(__self__, "retention", retention)
        if user_actions is not None:
            pulumi.set(__self__, "user_actions", user_actions)

    @property
    @pulumi.getter
    def transactions(self) -> int:
        """
        Maximum number of newly monitored entry point PurePaths captured per process/minute on environment level. Can be set to any value from 100 to 100000
        """
        return pulumi.get(self, "transactions")

    @property
    @pulumi.getter
    def limits(self) -> Optional['outputs.EnvironmentStorageLimits']:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def retention(self) -> Optional['outputs.EnvironmentStorageRetention']:
        return pulumi.get(self, "retention")

    @property
    @pulumi.getter(name="userActions")
    def user_actions(self) -> Optional[int]:
        """
        Maximum number of user actions generated per minute on environment level. Can be set to any value from 1 to 2147483646 or left unlimited by omitting this property
        """
        return pulumi.get(self, "user_actions")


@pulumi.output_type
class EnvironmentStorageLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sessionReplay":
            suggest = "session_replay"
        elif key == "symbolFiles":
            suggest = "symbol_files"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentStorageLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentStorageLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentStorageLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logs: Optional[int] = None,
                 session_replay: Optional[int] = None,
                 symbol_files: Optional[int] = None,
                 transactions: Optional[int] = None):
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if session_replay is not None:
            pulumi.set(__self__, "session_replay", session_replay)
        if symbol_files is not None:
            pulumi.set(__self__, "symbol_files", symbol_files)
        if transactions is not None:
            pulumi.set(__self__, "transactions", transactions)

    @property
    @pulumi.getter
    def logs(self) -> Optional[int]:
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter(name="sessionReplay")
    def session_replay(self) -> Optional[int]:
        return pulumi.get(self, "session_replay")

    @property
    @pulumi.getter(name="symbolFiles")
    def symbol_files(self) -> Optional[int]:
        return pulumi.get(self, "symbol_files")

    @property
    @pulumi.getter
    def transactions(self) -> Optional[int]:
        return pulumi.get(self, "transactions")


@pulumi.output_type
class EnvironmentStorageRetention(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceCodeLevel":
            suggest = "service_code_level"
        elif key == "serviceRequestLevel":
            suggest = "service_request_level"
        elif key == "sessionReplay":
            suggest = "session_replay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentStorageRetention. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentStorageRetention.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentStorageRetention.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rum: int,
                 service_code_level: int,
                 service_request_level: int,
                 session_replay: int,
                 synthetic: int,
                 logs: Optional[int] = None):
        pulumi.set(__self__, "rum", rum)
        pulumi.set(__self__, "service_code_level", service_code_level)
        pulumi.set(__self__, "service_request_level", service_request_level)
        pulumi.set(__self__, "session_replay", session_replay)
        pulumi.set(__self__, "synthetic", synthetic)
        if logs is not None:
            pulumi.set(__self__, "logs", logs)

    @property
    @pulumi.getter
    def rum(self) -> int:
        return pulumi.get(self, "rum")

    @property
    @pulumi.getter(name="serviceCodeLevel")
    def service_code_level(self) -> int:
        return pulumi.get(self, "service_code_level")

    @property
    @pulumi.getter(name="serviceRequestLevel")
    def service_request_level(self) -> int:
        return pulumi.get(self, "service_request_level")

    @property
    @pulumi.getter(name="sessionReplay")
    def session_replay(self) -> int:
        return pulumi.get(self, "session_replay")

    @property
    @pulumi.getter
    def synthetic(self) -> int:
        return pulumi.get(self, "synthetic")

    @property
    @pulumi.getter
    def logs(self) -> Optional[int]:
        return pulumi.get(self, "logs")


@pulumi.output_type
class FailureDetectionParametersBrokenLinks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "http404NotFoundFailures":
            suggest = "http404_not_found_failures"
        elif key == "brokenLinkDomains":
            suggest = "broken_link_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersBrokenLinks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersBrokenLinks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersBrokenLinks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http404_not_found_failures: bool,
                 broken_link_domains: Optional[Sequence[str]] = None):
        """
        :param bool http404_not_found_failures: Consider 404 HTTP response codes as failures
        :param Sequence[str] broken_link_domains: If your application relies on other hosts at other domains, add the associated domain names here. Once configured, Dynatrace will consider 404s thrown by hosts at these domains to be service failures related to your application.
        """
        pulumi.set(__self__, "http404_not_found_failures", http404_not_found_failures)
        if broken_link_domains is not None:
            pulumi.set(__self__, "broken_link_domains", broken_link_domains)

    @property
    @pulumi.getter(name="http404NotFoundFailures")
    def http404_not_found_failures(self) -> bool:
        """
        Consider 404 HTTP response codes as failures
        """
        return pulumi.get(self, "http404_not_found_failures")

    @property
    @pulumi.getter(name="brokenLinkDomains")
    def broken_link_domains(self) -> Optional[Sequence[str]]:
        """
        If your application relies on other hosts at other domains, add the associated domain names here. Once configured, Dynatrace will consider 404s thrown by hosts at these domains to be service failures related to your application.
        """
        return pulumi.get(self, "broken_link_domains")


@pulumi.output_type
class FailureDetectionParametersExceptionRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreAllExceptions":
            suggest = "ignore_all_exceptions"
        elif key == "ignoreSpanFailureDetection":
            suggest = "ignore_span_failure_detection"
        elif key == "customErrorRules":
            suggest = "custom_error_rules"
        elif key == "customHandledExceptions":
            suggest = "custom_handled_exceptions"
        elif key == "ignoredExceptions":
            suggest = "ignored_exceptions"
        elif key == "successForcingExceptions":
            suggest = "success_forcing_exceptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ignore_all_exceptions: bool,
                 ignore_span_failure_detection: bool,
                 custom_error_rules: Optional['outputs.FailureDetectionParametersExceptionRulesCustomErrorRules'] = None,
                 custom_handled_exceptions: Optional['outputs.FailureDetectionParametersExceptionRulesCustomHandledExceptions'] = None,
                 ignored_exceptions: Optional['outputs.FailureDetectionParametersExceptionRulesIgnoredExceptions'] = None,
                 success_forcing_exceptions: Optional['outputs.FailureDetectionParametersExceptionRulesSuccessForcingExceptions'] = None):
        """
        :param bool ignore_all_exceptions: Ignore all exceptions
        :param bool ignore_span_failure_detection: Ignore span failure detection
        :param 'FailureDetectionParametersExceptionRulesCustomErrorRulesArgs' custom_error_rules: Some custom error situations are only detectable via a return value or other means. To support such cases, [define a request attribute](https://dt-url.net/ys5k0p4y) that captures the required data. Then define a custom error rule that determines if the request has failed based on the value of the request attribute.
        :param 'FailureDetectionParametersExceptionRulesCustomHandledExceptionsArgs' custom_handled_exceptions: There may be situations where your application code handles exceptions gracefully in a manner that these failures aren't detected by Dynatrace. Use this setting to define specific gracefully-handled exceptions that should be treated as service failures.
        :param 'FailureDetectionParametersExceptionRulesIgnoredExceptionsArgs' ignored_exceptions: Some exceptions that are thrown by legacy or 3rd-party code indicate a specific response, not an error. Use this setting to instruct Dynatrace to treat such exceptions as non-failed requests.. If an exception matching any of the defined patterns occurs in a request, it will not be considered as a failure. Other exceptions occurring at the same request might still mark the request as failed.
        :param 'FailureDetectionParametersExceptionRulesSuccessForcingExceptionsArgs' success_forcing_exceptions: Define exceptions which indicate that a service call should not be considered as failed. E.g. an exception indicating that the client aborted the operation.. If an exception matching any of the defined patterns occurs on the entry node of the service, it will be considered successful. Compared to ignored exceptions, the request will be considered successful even if other exceptions occur in the same request.
        """
        pulumi.set(__self__, "ignore_all_exceptions", ignore_all_exceptions)
        pulumi.set(__self__, "ignore_span_failure_detection", ignore_span_failure_detection)
        if custom_error_rules is not None:
            pulumi.set(__self__, "custom_error_rules", custom_error_rules)
        if custom_handled_exceptions is not None:
            pulumi.set(__self__, "custom_handled_exceptions", custom_handled_exceptions)
        if ignored_exceptions is not None:
            pulumi.set(__self__, "ignored_exceptions", ignored_exceptions)
        if success_forcing_exceptions is not None:
            pulumi.set(__self__, "success_forcing_exceptions", success_forcing_exceptions)

    @property
    @pulumi.getter(name="ignoreAllExceptions")
    def ignore_all_exceptions(self) -> bool:
        """
        Ignore all exceptions
        """
        return pulumi.get(self, "ignore_all_exceptions")

    @property
    @pulumi.getter(name="ignoreSpanFailureDetection")
    def ignore_span_failure_detection(self) -> bool:
        """
        Ignore span failure detection
        """
        return pulumi.get(self, "ignore_span_failure_detection")

    @property
    @pulumi.getter(name="customErrorRules")
    def custom_error_rules(self) -> Optional['outputs.FailureDetectionParametersExceptionRulesCustomErrorRules']:
        """
        Some custom error situations are only detectable via a return value or other means. To support such cases, [define a request attribute](https://dt-url.net/ys5k0p4y) that captures the required data. Then define a custom error rule that determines if the request has failed based on the value of the request attribute.
        """
        return pulumi.get(self, "custom_error_rules")

    @property
    @pulumi.getter(name="customHandledExceptions")
    def custom_handled_exceptions(self) -> Optional['outputs.FailureDetectionParametersExceptionRulesCustomHandledExceptions']:
        """
        There may be situations where your application code handles exceptions gracefully in a manner that these failures aren't detected by Dynatrace. Use this setting to define specific gracefully-handled exceptions that should be treated as service failures.
        """
        return pulumi.get(self, "custom_handled_exceptions")

    @property
    @pulumi.getter(name="ignoredExceptions")
    def ignored_exceptions(self) -> Optional['outputs.FailureDetectionParametersExceptionRulesIgnoredExceptions']:
        """
        Some exceptions that are thrown by legacy or 3rd-party code indicate a specific response, not an error. Use this setting to instruct Dynatrace to treat such exceptions as non-failed requests.. If an exception matching any of the defined patterns occurs in a request, it will not be considered as a failure. Other exceptions occurring at the same request might still mark the request as failed.
        """
        return pulumi.get(self, "ignored_exceptions")

    @property
    @pulumi.getter(name="successForcingExceptions")
    def success_forcing_exceptions(self) -> Optional['outputs.FailureDetectionParametersExceptionRulesSuccessForcingExceptions']:
        """
        Define exceptions which indicate that a service call should not be considered as failed. E.g. an exception indicating that the client aborted the operation.. If an exception matching any of the defined patterns occurs on the entry node of the service, it will be considered successful. Compared to ignored exceptions, the request will be considered successful even if other exceptions occur in the same request.
        """
        return pulumi.get(self, "success_forcing_exceptions")


@pulumi.output_type
class FailureDetectionParametersExceptionRulesCustomErrorRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customErrorRules":
            suggest = "custom_error_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRulesCustomErrorRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRulesCustomErrorRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRulesCustomErrorRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_error_rules: Sequence['outputs.FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRule']):
        pulumi.set(__self__, "custom_error_rules", custom_error_rules)

    @property
    @pulumi.getter(name="customErrorRules")
    def custom_error_rules(self) -> Sequence['outputs.FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRule']:
        return pulumi.get(self, "custom_error_rules")


@pulumi.output_type
class FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: 'outputs.FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRuleCondition',
                 request_attribute: str):
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "request_attribute", request_attribute)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRuleCondition':
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> str:
        return pulumi.get(self, "request_attribute")


@pulumi.output_type
class FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compareOperationType":
            suggest = "compare_operation_type"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "doubleValue":
            suggest = "double_value"
        elif key == "intValue":
            suggest = "int_value"
        elif key == "textValue":
            suggest = "text_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compare_operation_type: str,
                 case_sensitive: Optional[bool] = None,
                 double_value: Optional[float] = None,
                 int_value: Optional[int] = None,
                 text_value: Optional[str] = None):
        pulumi.set(__self__, "compare_operation_type", compare_operation_type)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int_value is not None:
            pulumi.set(__self__, "int_value", int_value)
        if text_value is not None:
            pulumi.set(__self__, "text_value", text_value)

    @property
    @pulumi.getter(name="compareOperationType")
    def compare_operation_type(self) -> str:
        return pulumi.get(self, "compare_operation_type")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[float]:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="intValue")
    def int_value(self) -> Optional[int]:
        return pulumi.get(self, "int_value")

    @property
    @pulumi.getter(name="textValue")
    def text_value(self) -> Optional[str]:
        return pulumi.get(self, "text_value")


@pulumi.output_type
class FailureDetectionParametersExceptionRulesCustomHandledExceptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHandledExceptions":
            suggest = "custom_handled_exceptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRulesCustomHandledExceptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRulesCustomHandledExceptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRulesCustomHandledExceptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_handled_exceptions: Sequence['outputs.FailureDetectionParametersExceptionRulesCustomHandledExceptionsCustomHandledException']):
        pulumi.set(__self__, "custom_handled_exceptions", custom_handled_exceptions)

    @property
    @pulumi.getter(name="customHandledExceptions")
    def custom_handled_exceptions(self) -> Sequence['outputs.FailureDetectionParametersExceptionRulesCustomHandledExceptionsCustomHandledException']:
        return pulumi.get(self, "custom_handled_exceptions")


@pulumi.output_type
class FailureDetectionParametersExceptionRulesCustomHandledExceptionsCustomHandledException(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPattern":
            suggest = "class_pattern"
        elif key == "messagePattern":
            suggest = "message_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRulesCustomHandledExceptionsCustomHandledException. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRulesCustomHandledExceptionsCustomHandledException.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRulesCustomHandledExceptionsCustomHandledException.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_pattern: Optional[str] = None,
                 message_pattern: Optional[str] = None):
        if class_pattern is not None:
            pulumi.set(__self__, "class_pattern", class_pattern)
        if message_pattern is not None:
            pulumi.set(__self__, "message_pattern", message_pattern)

    @property
    @pulumi.getter(name="classPattern")
    def class_pattern(self) -> Optional[str]:
        return pulumi.get(self, "class_pattern")

    @property
    @pulumi.getter(name="messagePattern")
    def message_pattern(self) -> Optional[str]:
        return pulumi.get(self, "message_pattern")


@pulumi.output_type
class FailureDetectionParametersExceptionRulesIgnoredExceptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHandledExceptions":
            suggest = "custom_handled_exceptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRulesIgnoredExceptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRulesIgnoredExceptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRulesIgnoredExceptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_handled_exceptions: Sequence['outputs.FailureDetectionParametersExceptionRulesIgnoredExceptionsCustomHandledException']):
        pulumi.set(__self__, "custom_handled_exceptions", custom_handled_exceptions)

    @property
    @pulumi.getter(name="customHandledExceptions")
    def custom_handled_exceptions(self) -> Sequence['outputs.FailureDetectionParametersExceptionRulesIgnoredExceptionsCustomHandledException']:
        return pulumi.get(self, "custom_handled_exceptions")


@pulumi.output_type
class FailureDetectionParametersExceptionRulesIgnoredExceptionsCustomHandledException(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPattern":
            suggest = "class_pattern"
        elif key == "messagePattern":
            suggest = "message_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRulesIgnoredExceptionsCustomHandledException. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRulesIgnoredExceptionsCustomHandledException.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRulesIgnoredExceptionsCustomHandledException.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_pattern: Optional[str] = None,
                 message_pattern: Optional[str] = None):
        if class_pattern is not None:
            pulumi.set(__self__, "class_pattern", class_pattern)
        if message_pattern is not None:
            pulumi.set(__self__, "message_pattern", message_pattern)

    @property
    @pulumi.getter(name="classPattern")
    def class_pattern(self) -> Optional[str]:
        return pulumi.get(self, "class_pattern")

    @property
    @pulumi.getter(name="messagePattern")
    def message_pattern(self) -> Optional[str]:
        return pulumi.get(self, "message_pattern")


@pulumi.output_type
class FailureDetectionParametersExceptionRulesSuccessForcingExceptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHandledExceptions":
            suggest = "custom_handled_exceptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRulesSuccessForcingExceptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRulesSuccessForcingExceptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRulesSuccessForcingExceptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_handled_exceptions: Sequence['outputs.FailureDetectionParametersExceptionRulesSuccessForcingExceptionsCustomHandledException']):
        pulumi.set(__self__, "custom_handled_exceptions", custom_handled_exceptions)

    @property
    @pulumi.getter(name="customHandledExceptions")
    def custom_handled_exceptions(self) -> Sequence['outputs.FailureDetectionParametersExceptionRulesSuccessForcingExceptionsCustomHandledException']:
        return pulumi.get(self, "custom_handled_exceptions")


@pulumi.output_type
class FailureDetectionParametersExceptionRulesSuccessForcingExceptionsCustomHandledException(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPattern":
            suggest = "class_pattern"
        elif key == "messagePattern":
            suggest = "message_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersExceptionRulesSuccessForcingExceptionsCustomHandledException. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersExceptionRulesSuccessForcingExceptionsCustomHandledException.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersExceptionRulesSuccessForcingExceptionsCustomHandledException.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_pattern: Optional[str] = None,
                 message_pattern: Optional[str] = None):
        if class_pattern is not None:
            pulumi.set(__self__, "class_pattern", class_pattern)
        if message_pattern is not None:
            pulumi.set(__self__, "message_pattern", message_pattern)

    @property
    @pulumi.getter(name="classPattern")
    def class_pattern(self) -> Optional[str]:
        return pulumi.get(self, "class_pattern")

    @property
    @pulumi.getter(name="messagePattern")
    def message_pattern(self) -> Optional[str]:
        return pulumi.get(self, "message_pattern")


@pulumi.output_type
class FailureDetectionParametersHttpResponseCodes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientSideErrors":
            suggest = "client_side_errors"
        elif key == "failOnMissingResponseCodeClientSide":
            suggest = "fail_on_missing_response_code_client_side"
        elif key == "failOnMissingResponseCodeServerSide":
            suggest = "fail_on_missing_response_code_server_side"
        elif key == "serverSideErrors":
            suggest = "server_side_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionParametersHttpResponseCodes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionParametersHttpResponseCodes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionParametersHttpResponseCodes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_side_errors: str,
                 fail_on_missing_response_code_client_side: bool,
                 fail_on_missing_response_code_server_side: bool,
                 server_side_errors: str):
        """
        :param str client_side_errors: HTTP response codes which indicate client side errors
        :param bool fail_on_missing_response_code_client_side: Treat missing HTTP response code as client side error
        :param bool fail_on_missing_response_code_server_side: Treat missing HTTP response code as server side errors
        :param str server_side_errors: HTTP response codes which indicate an error on the server side
        """
        pulumi.set(__self__, "client_side_errors", client_side_errors)
        pulumi.set(__self__, "fail_on_missing_response_code_client_side", fail_on_missing_response_code_client_side)
        pulumi.set(__self__, "fail_on_missing_response_code_server_side", fail_on_missing_response_code_server_side)
        pulumi.set(__self__, "server_side_errors", server_side_errors)

    @property
    @pulumi.getter(name="clientSideErrors")
    def client_side_errors(self) -> str:
        """
        HTTP response codes which indicate client side errors
        """
        return pulumi.get(self, "client_side_errors")

    @property
    @pulumi.getter(name="failOnMissingResponseCodeClientSide")
    def fail_on_missing_response_code_client_side(self) -> bool:
        """
        Treat missing HTTP response code as client side error
        """
        return pulumi.get(self, "fail_on_missing_response_code_client_side")

    @property
    @pulumi.getter(name="failOnMissingResponseCodeServerSide")
    def fail_on_missing_response_code_server_side(self) -> bool:
        """
        Treat missing HTTP response code as server side errors
        """
        return pulumi.get(self, "fail_on_missing_response_code_server_side")

    @property
    @pulumi.getter(name="serverSideErrors")
    def server_side_errors(self) -> str:
        """
        HTTP response codes which indicate an error on the server side
        """
        return pulumi.get(self, "server_side_errors")


@pulumi.output_type
class FailureDetectionRulesConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.FailureDetectionRulesConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.FailureDetectionRulesConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class FailureDetectionRulesConditionsCondition(dict):
    def __init__(__self__, *,
                 attribute: str,
                 predicate: 'outputs.FailureDetectionRulesConditionsConditionPredicate'):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "predicate", predicate)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def predicate(self) -> 'outputs.FailureDetectionRulesConditionsConditionPredicate':
        return pulumi.get(self, "predicate")


@pulumi.output_type
class FailureDetectionRulesConditionsConditionPredicate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predicateType":
            suggest = "predicate_type"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "managementZones":
            suggest = "management_zones"
        elif key == "serviceTypes":
            suggest = "service_types"
        elif key == "tagKeys":
            suggest = "tag_keys"
        elif key == "textValues":
            suggest = "text_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailureDetectionRulesConditionsConditionPredicate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailureDetectionRulesConditionsConditionPredicate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailureDetectionRulesConditionsConditionPredicate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 predicate_type: str,
                 case_sensitive: Optional[bool] = None,
                 management_zones: Optional[Sequence[str]] = None,
                 service_types: Optional[Sequence[str]] = None,
                 tag_keys: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None,
                 text_values: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "predicate_type", predicate_type)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if management_zones is not None:
            pulumi.set(__self__, "management_zones", management_zones)
        if service_types is not None:
            pulumi.set(__self__, "service_types", service_types)
        if tag_keys is not None:
            pulumi.set(__self__, "tag_keys", tag_keys)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if text_values is not None:
            pulumi.set(__self__, "text_values", text_values)

    @property
    @pulumi.getter(name="predicateType")
    def predicate_type(self) -> str:
        return pulumi.get(self, "predicate_type")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="managementZones")
    def management_zones(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "management_zones")

    @property
    @pulumi.getter(name="serviceTypes")
    def service_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_types")

    @property
    @pulumi.getter(name="tagKeys")
    def tag_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tag_keys")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="textValues")
    def text_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "text_values")


@pulumi.output_type
class GenericRelationshipsSources(dict):
    def __init__(__self__, *,
                 sources: Sequence['outputs.GenericRelationshipsSourcesSource']):
        pulumi.set(__self__, "sources", sources)

    @property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GenericRelationshipsSourcesSource']:
        return pulumi.get(self, "sources")


@pulumi.output_type
class GenericRelationshipsSourcesSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"
        elif key == "mappingRules":
            suggest = "mapping_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenericRelationshipsSourcesSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenericRelationshipsSourcesSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenericRelationshipsSourcesSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 condition: Optional[str] = None,
                 mapping_rules: Optional['outputs.GenericRelationshipsSourcesSourceMappingRules'] = None):
        pulumi.set(__self__, "source_type", source_type)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if mapping_rules is not None:
            pulumi.set(__self__, "mapping_rules", mapping_rules)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="mappingRules")
    def mapping_rules(self) -> Optional['outputs.GenericRelationshipsSourcesSourceMappingRules']:
        return pulumi.get(self, "mapping_rules")


@pulumi.output_type
class GenericRelationshipsSourcesSourceMappingRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mappingRules":
            suggest = "mapping_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenericRelationshipsSourcesSourceMappingRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenericRelationshipsSourcesSourceMappingRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenericRelationshipsSourcesSourceMappingRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mapping_rules: Sequence['outputs.GenericRelationshipsSourcesSourceMappingRulesMappingRule']):
        pulumi.set(__self__, "mapping_rules", mapping_rules)

    @property
    @pulumi.getter(name="mappingRules")
    def mapping_rules(self) -> Sequence['outputs.GenericRelationshipsSourcesSourceMappingRulesMappingRule']:
        return pulumi.get(self, "mapping_rules")


@pulumi.output_type
class GenericRelationshipsSourcesSourceMappingRulesMappingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationProperty":
            suggest = "destination_property"
        elif key == "destinationTransformation":
            suggest = "destination_transformation"
        elif key == "sourceProperty":
            suggest = "source_property"
        elif key == "sourceTransformation":
            suggest = "source_transformation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenericRelationshipsSourcesSourceMappingRulesMappingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenericRelationshipsSourcesSourceMappingRulesMappingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenericRelationshipsSourcesSourceMappingRulesMappingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_property: str,
                 destination_transformation: str,
                 source_property: str,
                 source_transformation: str):
        pulumi.set(__self__, "destination_property", destination_property)
        pulumi.set(__self__, "destination_transformation", destination_transformation)
        pulumi.set(__self__, "source_property", source_property)
        pulumi.set(__self__, "source_transformation", source_transformation)

    @property
    @pulumi.getter(name="destinationProperty")
    def destination_property(self) -> str:
        return pulumi.get(self, "destination_property")

    @property
    @pulumi.getter(name="destinationTransformation")
    def destination_transformation(self) -> str:
        return pulumi.get(self, "destination_transformation")

    @property
    @pulumi.getter(name="sourceProperty")
    def source_property(self) -> str:
        return pulumi.get(self, "source_property")

    @property
    @pulumi.getter(name="sourceTransformation")
    def source_transformation(self) -> str:
        return pulumi.get(self, "source_transformation")


@pulumi.output_type
class GenericTypesRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GenericTypesRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GenericTypesRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GenericTypesRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idPattern":
            suggest = "id_pattern"
        elif key == "iconPattern":
            suggest = "icon_pattern"
        elif key == "instanceNamePattern":
            suggest = "instance_name_pattern"
        elif key == "requiredDimensions":
            suggest = "required_dimensions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenericTypesRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenericTypesRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenericTypesRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id_pattern: str,
                 sources: 'outputs.GenericTypesRulesRuleSources',
                 attributes: Optional['outputs.GenericTypesRulesRuleAttributes'] = None,
                 icon_pattern: Optional[str] = None,
                 instance_name_pattern: Optional[str] = None,
                 required_dimensions: Optional['outputs.GenericTypesRulesRuleRequiredDimensions'] = None,
                 role: Optional[str] = None):
        pulumi.set(__self__, "id_pattern", id_pattern)
        pulumi.set(__self__, "sources", sources)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if icon_pattern is not None:
            pulumi.set(__self__, "icon_pattern", icon_pattern)
        if instance_name_pattern is not None:
            pulumi.set(__self__, "instance_name_pattern", instance_name_pattern)
        if required_dimensions is not None:
            pulumi.set(__self__, "required_dimensions", required_dimensions)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter(name="idPattern")
    def id_pattern(self) -> str:
        return pulumi.get(self, "id_pattern")

    @property
    @pulumi.getter
    def sources(self) -> 'outputs.GenericTypesRulesRuleSources':
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def attributes(self) -> Optional['outputs.GenericTypesRulesRuleAttributes']:
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter(name="iconPattern")
    def icon_pattern(self) -> Optional[str]:
        return pulumi.get(self, "icon_pattern")

    @property
    @pulumi.getter(name="instanceNamePattern")
    def instance_name_pattern(self) -> Optional[str]:
        return pulumi.get(self, "instance_name_pattern")

    @property
    @pulumi.getter(name="requiredDimensions")
    def required_dimensions(self) -> Optional['outputs.GenericTypesRulesRuleRequiredDimensions']:
        return pulumi.get(self, "required_dimensions")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")


@pulumi.output_type
class GenericTypesRulesRuleAttributes(dict):
    def __init__(__self__, *,
                 attributes: Sequence['outputs.GenericTypesRulesRuleAttributesAttribute']):
        pulumi.set(__self__, "attributes", attributes)

    @property
    @pulumi.getter
    def attributes(self) -> Sequence['outputs.GenericTypesRulesRuleAttributesAttribute']:
        return pulumi.get(self, "attributes")


@pulumi.output_type
class GenericTypesRulesRuleAttributesAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenericTypesRulesRuleAttributesAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenericTypesRulesRuleAttributesAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenericTypesRulesRuleAttributesAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 pattern: str,
                 display_name: Optional[str] = None):
        """
        :param str display_name: The human readable type name for this entity type.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "pattern", pattern)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def pattern(self) -> str:
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The human readable type name for this entity type.
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class GenericTypesRulesRuleRequiredDimensions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requiredDimensions":
            suggest = "required_dimensions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenericTypesRulesRuleRequiredDimensions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenericTypesRulesRuleRequiredDimensions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenericTypesRulesRuleRequiredDimensions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 required_dimensions: Sequence['outputs.GenericTypesRulesRuleRequiredDimensionsRequiredDimension']):
        pulumi.set(__self__, "required_dimensions", required_dimensions)

    @property
    @pulumi.getter(name="requiredDimensions")
    def required_dimensions(self) -> Sequence['outputs.GenericTypesRulesRuleRequiredDimensionsRequiredDimension']:
        return pulumi.get(self, "required_dimensions")


@pulumi.output_type
class GenericTypesRulesRuleRequiredDimensionsRequiredDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valuePattern":
            suggest = "value_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenericTypesRulesRuleRequiredDimensionsRequiredDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenericTypesRulesRuleRequiredDimensionsRequiredDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenericTypesRulesRuleRequiredDimensionsRequiredDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 value_pattern: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if value_pattern is not None:
            pulumi.set(__self__, "value_pattern", value_pattern)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="valuePattern")
    def value_pattern(self) -> Optional[str]:
        return pulumi.get(self, "value_pattern")


@pulumi.output_type
class GenericTypesRulesRuleSources(dict):
    def __init__(__self__, *,
                 sources: Sequence['outputs.GenericTypesRulesRuleSourcesSource']):
        pulumi.set(__self__, "sources", sources)

    @property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GenericTypesRulesRuleSourcesSource']:
        return pulumi.get(self, "sources")


@pulumi.output_type
class GenericTypesRulesRuleSourcesSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenericTypesRulesRuleSourcesSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenericTypesRulesRuleSourcesSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenericTypesRulesRuleSourcesSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 condition: Optional[str] = None):
        pulumi.set(__self__, "source_type", source_type)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        return pulumi.get(self, "condition")


@pulumi.output_type
class HostAnomaliesConnections(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enabledOnGracefulShutdowns":
            suggest = "enabled_on_graceful_shutdowns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesConnections. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesConnections.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesConnections.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 enabled_on_graceful_shutdowns: bool):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param bool enabled_on_graceful_shutdowns: Alert (`true`) on graceful host shutdowns
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "enabled_on_graceful_shutdowns", enabled_on_graceful_shutdowns)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="enabledOnGracefulShutdowns")
    def enabled_on_graceful_shutdowns(self) -> bool:
        """
        Alert (`true`) on graceful host shutdowns
        """
        return pulumi.get(self, "enabled_on_graceful_shutdowns")


@pulumi.output_type
class HostAnomaliesCpu(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesCpuThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesCpuThresholdsArgs' thresholds: Custom thresholds for high CPU saturation. If not set then the automatic mode is used
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesCpuThresholds']:
        """
        Custom thresholds for high CPU saturation. If not set then the automatic mode is used
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesCpuThresholds(dict):
    def __init__(__self__, *,
                 saturation: int):
        pulumi.set(__self__, "saturation", saturation)

    @property
    @pulumi.getter
    def saturation(self) -> int:
        return pulumi.get(self, "saturation")


@pulumi.output_type
class HostAnomaliesDisks(dict):
    def __init__(__self__, *,
                 inodes: Optional['outputs.HostAnomaliesDisksInodes'] = None,
                 space: Optional['outputs.HostAnomaliesDisksSpace'] = None,
                 speed: Optional['outputs.HostAnomaliesDisksSpeed'] = None):
        """
        :param 'HostAnomaliesDisksInodesArgs' inodes: Configuration of low disk inodes number detection
        :param 'HostAnomaliesDisksSpaceArgs' space: Configuration of low disk space detection
        :param 'HostAnomaliesDisksSpeedArgs' speed: Configuration of slow running disks detection
        """
        if inodes is not None:
            pulumi.set(__self__, "inodes", inodes)
        if space is not None:
            pulumi.set(__self__, "space", space)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)

    @property
    @pulumi.getter
    def inodes(self) -> Optional['outputs.HostAnomaliesDisksInodes']:
        """
        Configuration of low disk inodes number detection
        """
        return pulumi.get(self, "inodes")

    @property
    @pulumi.getter
    def space(self) -> Optional['outputs.HostAnomaliesDisksSpace']:
        """
        Configuration of low disk space detection
        """
        return pulumi.get(self, "space")

    @property
    @pulumi.getter
    def speed(self) -> Optional['outputs.HostAnomaliesDisksSpeed']:
        """
        Configuration of slow running disks detection
        """
        return pulumi.get(self, "speed")


@pulumi.output_type
class HostAnomaliesDisksInodes(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesDisksInodesThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesDisksInodesThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesDisksInodesThresholds(dict):
    def __init__(__self__, *,
                 percentage: int):
        pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter
    def percentage(self) -> int:
        return pulumi.get(self, "percentage")


@pulumi.output_type
class HostAnomaliesDisksSpace(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesDisksSpaceThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesDisksSpaceThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesDisksSpaceThresholds(dict):
    def __init__(__self__, *,
                 percentage: int):
        pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter
    def percentage(self) -> int:
        return pulumi.get(self, "percentage")


@pulumi.output_type
class HostAnomaliesDisksSpeed(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesDisksSpeedThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesDisksSpeedThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesDisksSpeedThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "writeAndReadTime":
            suggest = "write_and_read_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesDisksSpeedThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesDisksSpeedThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesDisksSpeedThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 write_and_read_time: int):
        pulumi.set(__self__, "write_and_read_time", write_and_read_time)

    @property
    @pulumi.getter(name="writeAndReadTime")
    def write_and_read_time(self) -> int:
        return pulumi.get(self, "write_and_read_time")


@pulumi.output_type
class HostAnomaliesGc(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesGcThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesGcThresholdsArgs' thresholds: Custom thresholds for high GC activity. If not set, automatic mode is used.   Meeting **any** of these conditions triggers an alert
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesGcThresholds']:
        """
        Custom thresholds for high GC activity. If not set, automatic mode is used.   Meeting **any** of these conditions triggers an alert
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesGcThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "suspensionPercentage":
            suggest = "suspension_percentage"
        elif key == "timePercentage":
            suggest = "time_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesGcThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesGcThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesGcThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 suspension_percentage: int,
                 time_percentage: int):
        pulumi.set(__self__, "suspension_percentage", suspension_percentage)
        pulumi.set(__self__, "time_percentage", time_percentage)

    @property
    @pulumi.getter(name="suspensionPercentage")
    def suspension_percentage(self) -> int:
        return pulumi.get(self, "suspension_percentage")

    @property
    @pulumi.getter(name="timePercentage")
    def time_percentage(self) -> int:
        return pulumi.get(self, "time_percentage")


@pulumi.output_type
class HostAnomaliesJava(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outOfMemory":
            suggest = "out_of_memory"
        elif key == "outOfThreads":
            suggest = "out_of_threads"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesJava. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesJava.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesJava.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 out_of_memory: Optional['outputs.HostAnomaliesJavaOutOfMemory'] = None,
                 out_of_threads: Optional['outputs.HostAnomaliesJavaOutOfThreads'] = None):
        """
        :param 'HostAnomaliesJavaOutOfMemoryArgs' out_of_memory: Configuration of Java out of memory problems detection
        :param 'HostAnomaliesJavaOutOfThreadsArgs' out_of_threads: Configuration of Java out of threads problems detection
        """
        if out_of_memory is not None:
            pulumi.set(__self__, "out_of_memory", out_of_memory)
        if out_of_threads is not None:
            pulumi.set(__self__, "out_of_threads", out_of_threads)

    @property
    @pulumi.getter(name="outOfMemory")
    def out_of_memory(self) -> Optional['outputs.HostAnomaliesJavaOutOfMemory']:
        """
        Configuration of Java out of memory problems detection
        """
        return pulumi.get(self, "out_of_memory")

    @property
    @pulumi.getter(name="outOfThreads")
    def out_of_threads(self) -> Optional['outputs.HostAnomaliesJavaOutOfThreads']:
        """
        Configuration of Java out of threads problems detection
        """
        return pulumi.get(self, "out_of_threads")


@pulumi.output_type
class HostAnomaliesJavaOutOfMemory(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesJavaOutOfMemoryThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesJavaOutOfMemoryThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesJavaOutOfMemoryThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exceptionCount":
            suggest = "exception_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesJavaOutOfMemoryThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesJavaOutOfMemoryThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesJavaOutOfMemoryThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exception_count: int):
        pulumi.set(__self__, "exception_count", exception_count)

    @property
    @pulumi.getter(name="exceptionCount")
    def exception_count(self) -> int:
        return pulumi.get(self, "exception_count")


@pulumi.output_type
class HostAnomaliesJavaOutOfThreads(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesJavaOutOfThreadsThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesJavaOutOfThreadsThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesJavaOutOfThreadsThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exceptionCount":
            suggest = "exception_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesJavaOutOfThreadsThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesJavaOutOfThreadsThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesJavaOutOfThreadsThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exception_count: int):
        pulumi.set(__self__, "exception_count", exception_count)

    @property
    @pulumi.getter(name="exceptionCount")
    def exception_count(self) -> int:
        return pulumi.get(self, "exception_count")


@pulumi.output_type
class HostAnomaliesMemory(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesMemoryThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesMemoryThresholdsArgs' thresholds: Custom thresholds for high memory usage. If not set then the automatic mode is used. **Both** conditions must be met to trigger an alert
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesMemoryThresholds']:
        """
        Custom thresholds for high memory usage. If not set then the automatic mode is used. **Both** conditions must be met to trigger an alert
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesMemoryThresholds(dict):
    def __init__(__self__, *,
                 linux: 'outputs.HostAnomaliesMemoryThresholdsLinux',
                 windows: 'outputs.HostAnomaliesMemoryThresholdsWindows'):
        pulumi.set(__self__, "linux", linux)
        pulumi.set(__self__, "windows", windows)

    @property
    @pulumi.getter
    def linux(self) -> 'outputs.HostAnomaliesMemoryThresholdsLinux':
        return pulumi.get(self, "linux")

    @property
    @pulumi.getter
    def windows(self) -> 'outputs.HostAnomaliesMemoryThresholdsWindows':
        return pulumi.get(self, "windows")


@pulumi.output_type
class HostAnomaliesMemoryThresholdsLinux(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pageFaults":
            suggest = "page_faults"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesMemoryThresholdsLinux. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesMemoryThresholdsLinux.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesMemoryThresholdsLinux.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 page_faults: int,
                 usage: int):
        pulumi.set(__self__, "page_faults", page_faults)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter(name="pageFaults")
    def page_faults(self) -> int:
        return pulumi.get(self, "page_faults")

    @property
    @pulumi.getter
    def usage(self) -> int:
        return pulumi.get(self, "usage")


@pulumi.output_type
class HostAnomaliesMemoryThresholdsWindows(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pageFaults":
            suggest = "page_faults"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesMemoryThresholdsWindows. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesMemoryThresholdsWindows.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesMemoryThresholdsWindows.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 page_faults: int,
                 usage: int):
        pulumi.set(__self__, "page_faults", page_faults)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter(name="pageFaults")
    def page_faults(self) -> int:
        return pulumi.get(self, "page_faults")

    @property
    @pulumi.getter
    def usage(self) -> int:
        return pulumi.get(self, "usage")


@pulumi.output_type
class HostAnomaliesNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "droppedPackets":
            suggest = "dropped_packets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connectivity: Optional['outputs.HostAnomaliesNetworkConnectivity'] = None,
                 dropped_packets: Optional['outputs.HostAnomaliesNetworkDroppedPackets'] = None,
                 errors: Optional['outputs.HostAnomaliesNetworkErrors'] = None,
                 retransmission: Optional['outputs.HostAnomaliesNetworkRetransmission'] = None,
                 utilization: Optional['outputs.HostAnomaliesNetworkUtilization'] = None):
        """
        :param 'HostAnomaliesNetworkConnectivityArgs' connectivity: Configuration of TCP connectivity problems detection
        :param 'HostAnomaliesNetworkDroppedPacketsArgs' dropped_packets: Configuration of high number of dropped packets detection
        :param 'HostAnomaliesNetworkErrorsArgs' errors: Configuration of high number of network errors detection
        :param 'HostAnomaliesNetworkRetransmissionArgs' retransmission: Configuration of high retransmission rate detection
        :param 'HostAnomaliesNetworkUtilizationArgs' utilization: Configuration of high network utilization detection
        """
        if connectivity is not None:
            pulumi.set(__self__, "connectivity", connectivity)
        if dropped_packets is not None:
            pulumi.set(__self__, "dropped_packets", dropped_packets)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if retransmission is not None:
            pulumi.set(__self__, "retransmission", retransmission)
        if utilization is not None:
            pulumi.set(__self__, "utilization", utilization)

    @property
    @pulumi.getter
    def connectivity(self) -> Optional['outputs.HostAnomaliesNetworkConnectivity']:
        """
        Configuration of TCP connectivity problems detection
        """
        return pulumi.get(self, "connectivity")

    @property
    @pulumi.getter(name="droppedPackets")
    def dropped_packets(self) -> Optional['outputs.HostAnomaliesNetworkDroppedPackets']:
        """
        Configuration of high number of dropped packets detection
        """
        return pulumi.get(self, "dropped_packets")

    @property
    @pulumi.getter
    def errors(self) -> Optional['outputs.HostAnomaliesNetworkErrors']:
        """
        Configuration of high number of network errors detection
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def retransmission(self) -> Optional['outputs.HostAnomaliesNetworkRetransmission']:
        """
        Configuration of high retransmission rate detection
        """
        return pulumi.get(self, "retransmission")

    @property
    @pulumi.getter
    def utilization(self) -> Optional['outputs.HostAnomaliesNetworkUtilization']:
        """
        Configuration of high network utilization detection
        """
        return pulumi.get(self, "utilization")


@pulumi.output_type
class HostAnomaliesNetworkConnectivity(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesNetworkConnectivityThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesNetworkConnectivityThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesNetworkConnectivityThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failedConnections":
            suggest = "failed_connections"
        elif key == "newConnectionFailures":
            suggest = "new_connection_failures"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesNetworkConnectivityThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesNetworkConnectivityThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesNetworkConnectivityThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failed_connections: int,
                 new_connection_failures: int):
        pulumi.set(__self__, "failed_connections", failed_connections)
        pulumi.set(__self__, "new_connection_failures", new_connection_failures)

    @property
    @pulumi.getter(name="failedConnections")
    def failed_connections(self) -> int:
        return pulumi.get(self, "failed_connections")

    @property
    @pulumi.getter(name="newConnectionFailures")
    def new_connection_failures(self) -> int:
        return pulumi.get(self, "new_connection_failures")


@pulumi.output_type
class HostAnomaliesNetworkDroppedPackets(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesNetworkDroppedPacketsThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesNetworkDroppedPacketsThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesNetworkDroppedPacketsThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "droppedPackets":
            suggest = "dropped_packets"
        elif key == "totalPacketsRate":
            suggest = "total_packets_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesNetworkDroppedPacketsThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesNetworkDroppedPacketsThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesNetworkDroppedPacketsThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dropped_packets: int,
                 total_packets_rate: int):
        pulumi.set(__self__, "dropped_packets", dropped_packets)
        pulumi.set(__self__, "total_packets_rate", total_packets_rate)

    @property
    @pulumi.getter(name="droppedPackets")
    def dropped_packets(self) -> int:
        return pulumi.get(self, "dropped_packets")

    @property
    @pulumi.getter(name="totalPacketsRate")
    def total_packets_rate(self) -> int:
        return pulumi.get(self, "total_packets_rate")


@pulumi.output_type
class HostAnomaliesNetworkErrors(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesNetworkErrorsThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesNetworkErrorsThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesNetworkErrorsThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorsPercentage":
            suggest = "errors_percentage"
        elif key == "totalPacketsRate":
            suggest = "total_packets_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesNetworkErrorsThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesNetworkErrorsThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesNetworkErrorsThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 errors_percentage: int,
                 total_packets_rate: int):
        pulumi.set(__self__, "errors_percentage", errors_percentage)
        pulumi.set(__self__, "total_packets_rate", total_packets_rate)

    @property
    @pulumi.getter(name="errorsPercentage")
    def errors_percentage(self) -> int:
        return pulumi.get(self, "errors_percentage")

    @property
    @pulumi.getter(name="totalPacketsRate")
    def total_packets_rate(self) -> int:
        return pulumi.get(self, "total_packets_rate")


@pulumi.output_type
class HostAnomaliesNetworkRetransmission(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesNetworkRetransmissionThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesNetworkRetransmissionThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesNetworkRetransmissionThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retransmissionRate":
            suggest = "retransmission_rate"
        elif key == "retransmittedPackets":
            suggest = "retransmitted_packets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesNetworkRetransmissionThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesNetworkRetransmissionThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesNetworkRetransmissionThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retransmission_rate: int,
                 retransmitted_packets: int):
        pulumi.set(__self__, "retransmission_rate", retransmission_rate)
        pulumi.set(__self__, "retransmitted_packets", retransmitted_packets)

    @property
    @pulumi.getter(name="retransmissionRate")
    def retransmission_rate(self) -> int:
        return pulumi.get(self, "retransmission_rate")

    @property
    @pulumi.getter(name="retransmittedPackets")
    def retransmitted_packets(self) -> int:
        return pulumi.get(self, "retransmitted_packets")


@pulumi.output_type
class HostAnomaliesNetworkUtilization(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesNetworkUtilizationThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesNetworkUtilizationThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesNetworkUtilizationThresholds(dict):
    def __init__(__self__, *,
                 utilization: int):
        pulumi.set(__self__, "utilization", utilization)

    @property
    @pulumi.getter
    def utilization(self) -> int:
        return pulumi.get(self, "utilization")


@pulumi.output_type
class HostAnomaliesV2Host(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionLostDetection":
            suggest = "connection_lost_detection"
        elif key == "highCpuSaturationDetection":
            suggest = "high_cpu_saturation_detection"
        elif key == "highGcActivityDetection":
            suggest = "high_gc_activity_detection"
        elif key == "highMemoryDetection":
            suggest = "high_memory_detection"
        elif key == "highSystemLoadDetection":
            suggest = "high_system_load_detection"
        elif key == "outOfMemoryDetection":
            suggest = "out_of_memory_detection"
        elif key == "outOfThreadsDetection":
            suggest = "out_of_threads_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2Host. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2Host.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2Host.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_lost_detection: 'outputs.HostAnomaliesV2HostConnectionLostDetection',
                 high_cpu_saturation_detection: 'outputs.HostAnomaliesV2HostHighCpuSaturationDetection',
                 high_gc_activity_detection: 'outputs.HostAnomaliesV2HostHighGcActivityDetection',
                 high_memory_detection: 'outputs.HostAnomaliesV2HostHighMemoryDetection',
                 high_system_load_detection: 'outputs.HostAnomaliesV2HostHighSystemLoadDetection',
                 out_of_memory_detection: 'outputs.HostAnomaliesV2HostOutOfMemoryDetection',
                 out_of_threads_detection: 'outputs.HostAnomaliesV2HostOutOfThreadsDetection'):
        """
        :param 'HostAnomaliesV2HostConnectionLostDetectionArgs' connection_lost_detection: no documentation available
        :param 'HostAnomaliesV2HostHighCpuSaturationDetectionArgs' high_cpu_saturation_detection: no documentation available
        :param 'HostAnomaliesV2HostHighGcActivityDetectionArgs' high_gc_activity_detection: no documentation available
        :param 'HostAnomaliesV2HostHighMemoryDetectionArgs' high_memory_detection: no documentation available
        :param 'HostAnomaliesV2HostHighSystemLoadDetectionArgs' high_system_load_detection: no documentation available
        :param 'HostAnomaliesV2HostOutOfMemoryDetectionArgs' out_of_memory_detection: no documentation available
        :param 'HostAnomaliesV2HostOutOfThreadsDetectionArgs' out_of_threads_detection: no documentation available
        """
        pulumi.set(__self__, "connection_lost_detection", connection_lost_detection)
        pulumi.set(__self__, "high_cpu_saturation_detection", high_cpu_saturation_detection)
        pulumi.set(__self__, "high_gc_activity_detection", high_gc_activity_detection)
        pulumi.set(__self__, "high_memory_detection", high_memory_detection)
        pulumi.set(__self__, "high_system_load_detection", high_system_load_detection)
        pulumi.set(__self__, "out_of_memory_detection", out_of_memory_detection)
        pulumi.set(__self__, "out_of_threads_detection", out_of_threads_detection)

    @property
    @pulumi.getter(name="connectionLostDetection")
    def connection_lost_detection(self) -> 'outputs.HostAnomaliesV2HostConnectionLostDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "connection_lost_detection")

    @property
    @pulumi.getter(name="highCpuSaturationDetection")
    def high_cpu_saturation_detection(self) -> 'outputs.HostAnomaliesV2HostHighCpuSaturationDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "high_cpu_saturation_detection")

    @property
    @pulumi.getter(name="highGcActivityDetection")
    def high_gc_activity_detection(self) -> 'outputs.HostAnomaliesV2HostHighGcActivityDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "high_gc_activity_detection")

    @property
    @pulumi.getter(name="highMemoryDetection")
    def high_memory_detection(self) -> 'outputs.HostAnomaliesV2HostHighMemoryDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "high_memory_detection")

    @property
    @pulumi.getter(name="highSystemLoadDetection")
    def high_system_load_detection(self) -> 'outputs.HostAnomaliesV2HostHighSystemLoadDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "high_system_load_detection")

    @property
    @pulumi.getter(name="outOfMemoryDetection")
    def out_of_memory_detection(self) -> 'outputs.HostAnomaliesV2HostOutOfMemoryDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "out_of_memory_detection")

    @property
    @pulumi.getter(name="outOfThreadsDetection")
    def out_of_threads_detection(self) -> 'outputs.HostAnomaliesV2HostOutOfThreadsDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "out_of_threads_detection")


@pulumi.output_type
class HostAnomaliesV2HostConnectionLostDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onGracefulShutdowns":
            suggest = "on_graceful_shutdowns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostConnectionLostDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostConnectionLostDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostConnectionLostDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 on_graceful_shutdowns: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if on_graceful_shutdowns is not None:
            pulumi.set(__self__, "on_graceful_shutdowns", on_graceful_shutdowns)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="onGracefulShutdowns")
    def on_graceful_shutdowns(self) -> Optional[str]:
        return pulumi.get(self, "on_graceful_shutdowns")


@pulumi.output_type
class HostAnomaliesV2HostHighCpuSaturationDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighCpuSaturationDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighCpuSaturationDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighCpuSaturationDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholds']:
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuSaturation":
            suggest = "cpu_saturation"
        elif key == "eventThresholds":
            suggest = "event_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_saturation: int,
                 event_thresholds: 'outputs.HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholdsEventThresholds'):
        pulumi.set(__self__, "cpu_saturation", cpu_saturation)
        pulumi.set(__self__, "event_thresholds", event_thresholds)

    @property
    @pulumi.getter(name="cpuSaturation")
    def cpu_saturation(self) -> int:
        return pulumi.get(self, "cpu_saturation")

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholdsEventThresholds':
        return pulumi.get(self, "event_thresholds")


@pulumi.output_type
class HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2HostHighGcActivityDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighGcActivityDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighGcActivityDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighGcActivityDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2HostHighGcActivityDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2HostHighGcActivityDetectionCustomThresholds']:
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2HostHighGcActivityDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventThresholds":
            suggest = "event_thresholds"
        elif key == "gcSuspensionPercentage":
            suggest = "gc_suspension_percentage"
        elif key == "gcTimePercentage":
            suggest = "gc_time_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighGcActivityDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighGcActivityDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighGcActivityDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_thresholds: 'outputs.HostAnomaliesV2HostHighGcActivityDetectionCustomThresholdsEventThresholds',
                 gc_suspension_percentage: int,
                 gc_time_percentage: int):
        pulumi.set(__self__, "event_thresholds", event_thresholds)
        pulumi.set(__self__, "gc_suspension_percentage", gc_suspension_percentage)
        pulumi.set(__self__, "gc_time_percentage", gc_time_percentage)

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2HostHighGcActivityDetectionCustomThresholdsEventThresholds':
        return pulumi.get(self, "event_thresholds")

    @property
    @pulumi.getter(name="gcSuspensionPercentage")
    def gc_suspension_percentage(self) -> int:
        return pulumi.get(self, "gc_suspension_percentage")

    @property
    @pulumi.getter(name="gcTimePercentage")
    def gc_time_percentage(self) -> int:
        return pulumi.get(self, "gc_time_percentage")


@pulumi.output_type
class HostAnomaliesV2HostHighGcActivityDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighGcActivityDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighGcActivityDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighGcActivityDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2HostHighMemoryDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighMemoryDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighMemoryDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighMemoryDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2HostHighMemoryDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2HostHighMemoryDetectionCustomThresholds']:
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2HostHighMemoryDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventThresholds":
            suggest = "event_thresholds"
        elif key == "pageFaultsPerSecondNonWindows":
            suggest = "page_faults_per_second_non_windows"
        elif key == "pageFaultsPerSecondWindows":
            suggest = "page_faults_per_second_windows"
        elif key == "usedMemoryPercentageNonWindows":
            suggest = "used_memory_percentage_non_windows"
        elif key == "usedMemoryPercentageWindows":
            suggest = "used_memory_percentage_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighMemoryDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighMemoryDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighMemoryDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_thresholds: 'outputs.HostAnomaliesV2HostHighMemoryDetectionCustomThresholdsEventThresholds',
                 page_faults_per_second_non_windows: int,
                 page_faults_per_second_windows: int,
                 used_memory_percentage_non_windows: int,
                 used_memory_percentage_windows: int):
        pulumi.set(__self__, "event_thresholds", event_thresholds)
        pulumi.set(__self__, "page_faults_per_second_non_windows", page_faults_per_second_non_windows)
        pulumi.set(__self__, "page_faults_per_second_windows", page_faults_per_second_windows)
        pulumi.set(__self__, "used_memory_percentage_non_windows", used_memory_percentage_non_windows)
        pulumi.set(__self__, "used_memory_percentage_windows", used_memory_percentage_windows)

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2HostHighMemoryDetectionCustomThresholdsEventThresholds':
        return pulumi.get(self, "event_thresholds")

    @property
    @pulumi.getter(name="pageFaultsPerSecondNonWindows")
    def page_faults_per_second_non_windows(self) -> int:
        return pulumi.get(self, "page_faults_per_second_non_windows")

    @property
    @pulumi.getter(name="pageFaultsPerSecondWindows")
    def page_faults_per_second_windows(self) -> int:
        return pulumi.get(self, "page_faults_per_second_windows")

    @property
    @pulumi.getter(name="usedMemoryPercentageNonWindows")
    def used_memory_percentage_non_windows(self) -> int:
        return pulumi.get(self, "used_memory_percentage_non_windows")

    @property
    @pulumi.getter(name="usedMemoryPercentageWindows")
    def used_memory_percentage_windows(self) -> int:
        return pulumi.get(self, "used_memory_percentage_windows")


@pulumi.output_type
class HostAnomaliesV2HostHighMemoryDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighMemoryDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighMemoryDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighMemoryDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2HostHighSystemLoadDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighSystemLoadDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighSystemLoadDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighSystemLoadDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholds']:
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventThresholds":
            suggest = "event_thresholds"
        elif key == "systemLoad":
            suggest = "system_load"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_thresholds: 'outputs.HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholdsEventThresholds',
                 system_load: float):
        pulumi.set(__self__, "event_thresholds", event_thresholds)
        pulumi.set(__self__, "system_load", system_load)

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholdsEventThresholds':
        return pulumi.get(self, "event_thresholds")

    @property
    @pulumi.getter(name="systemLoad")
    def system_load(self) -> float:
        return pulumi.get(self, "system_load")


@pulumi.output_type
class HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2HostOutOfMemoryDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostOutOfMemoryDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostOutOfMemoryDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostOutOfMemoryDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholds']:
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventThresholds":
            suggest = "event_thresholds"
        elif key == "outOfMemoryExceptionsNumber":
            suggest = "out_of_memory_exceptions_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_thresholds: 'outputs.HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholdsEventThresholds',
                 out_of_memory_exceptions_number: int):
        pulumi.set(__self__, "event_thresholds", event_thresholds)
        pulumi.set(__self__, "out_of_memory_exceptions_number", out_of_memory_exceptions_number)

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholdsEventThresholds':
        return pulumi.get(self, "event_thresholds")

    @property
    @pulumi.getter(name="outOfMemoryExceptionsNumber")
    def out_of_memory_exceptions_number(self) -> int:
        return pulumi.get(self, "out_of_memory_exceptions_number")


@pulumi.output_type
class HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2HostOutOfThreadsDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostOutOfThreadsDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostOutOfThreadsDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostOutOfThreadsDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholds']:
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventThresholds":
            suggest = "event_thresholds"
        elif key == "outOfThreadsExceptionsNumber":
            suggest = "out_of_threads_exceptions_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_thresholds: 'outputs.HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholdsEventThresholds',
                 out_of_threads_exceptions_number: int):
        pulumi.set(__self__, "event_thresholds", event_thresholds)
        pulumi.set(__self__, "out_of_threads_exceptions_number", out_of_threads_exceptions_number)

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholdsEventThresholds':
        return pulumi.get(self, "event_thresholds")

    @property
    @pulumi.getter(name="outOfThreadsExceptionsNumber")
    def out_of_threads_exceptions_number(self) -> int:
        return pulumi.get(self, "out_of_threads_exceptions_number")


@pulumi.output_type
class HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2Network(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "highNetworkDetection":
            suggest = "high_network_detection"
        elif key == "networkDroppedPacketsDetection":
            suggest = "network_dropped_packets_detection"
        elif key == "networkErrorsDetection":
            suggest = "network_errors_detection"
        elif key == "networkHighRetransmissionDetection":
            suggest = "network_high_retransmission_detection"
        elif key == "networkTcpProblemsDetection":
            suggest = "network_tcp_problems_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2Network. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2Network.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2Network.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 high_network_detection: 'outputs.HostAnomaliesV2NetworkHighNetworkDetection',
                 network_dropped_packets_detection: 'outputs.HostAnomaliesV2NetworkNetworkDroppedPacketsDetection',
                 network_errors_detection: 'outputs.HostAnomaliesV2NetworkNetworkErrorsDetection',
                 network_high_retransmission_detection: 'outputs.HostAnomaliesV2NetworkNetworkHighRetransmissionDetection',
                 network_tcp_problems_detection: 'outputs.HostAnomaliesV2NetworkNetworkTcpProblemsDetection'):
        """
        :param 'HostAnomaliesV2NetworkHighNetworkDetectionArgs' high_network_detection: no documentation available
        :param 'HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionArgs' network_dropped_packets_detection: no documentation available
        :param 'HostAnomaliesV2NetworkNetworkErrorsDetectionArgs' network_errors_detection: no documentation available
        :param 'HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionArgs' network_high_retransmission_detection: no documentation available
        :param 'HostAnomaliesV2NetworkNetworkTcpProblemsDetectionArgs' network_tcp_problems_detection: no documentation available
        """
        pulumi.set(__self__, "high_network_detection", high_network_detection)
        pulumi.set(__self__, "network_dropped_packets_detection", network_dropped_packets_detection)
        pulumi.set(__self__, "network_errors_detection", network_errors_detection)
        pulumi.set(__self__, "network_high_retransmission_detection", network_high_retransmission_detection)
        pulumi.set(__self__, "network_tcp_problems_detection", network_tcp_problems_detection)

    @property
    @pulumi.getter(name="highNetworkDetection")
    def high_network_detection(self) -> 'outputs.HostAnomaliesV2NetworkHighNetworkDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "high_network_detection")

    @property
    @pulumi.getter(name="networkDroppedPacketsDetection")
    def network_dropped_packets_detection(self) -> 'outputs.HostAnomaliesV2NetworkNetworkDroppedPacketsDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "network_dropped_packets_detection")

    @property
    @pulumi.getter(name="networkErrorsDetection")
    def network_errors_detection(self) -> 'outputs.HostAnomaliesV2NetworkNetworkErrorsDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "network_errors_detection")

    @property
    @pulumi.getter(name="networkHighRetransmissionDetection")
    def network_high_retransmission_detection(self) -> 'outputs.HostAnomaliesV2NetworkNetworkHighRetransmissionDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "network_high_retransmission_detection")

    @property
    @pulumi.getter(name="networkTcpProblemsDetection")
    def network_tcp_problems_detection(self) -> 'outputs.HostAnomaliesV2NetworkNetworkTcpProblemsDetection':
        """
        no documentation available
        """
        return pulumi.get(self, "network_tcp_problems_detection")


@pulumi.output_type
class HostAnomaliesV2NetworkHighNetworkDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkHighNetworkDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkHighNetworkDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkHighNetworkDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholds']:
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorsPercentage":
            suggest = "errors_percentage"
        elif key == "eventThresholds":
            suggest = "event_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 errors_percentage: int,
                 event_thresholds: 'outputs.HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholdsEventThresholds'):
        pulumi.set(__self__, "errors_percentage", errors_percentage)
        pulumi.set(__self__, "event_thresholds", event_thresholds)

    @property
    @pulumi.getter(name="errorsPercentage")
    def errors_percentage(self) -> int:
        return pulumi.get(self, "errors_percentage")

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholdsEventThresholds':
        return pulumi.get(self, "event_thresholds")


@pulumi.output_type
class HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkDroppedPacketsDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkDroppedPacketsDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkDroppedPacketsDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkDroppedPacketsDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholds']:
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "droppedPacketsPercentage":
            suggest = "dropped_packets_percentage"
        elif key == "eventThresholds":
            suggest = "event_thresholds"
        elif key == "totalPacketsRate":
            suggest = "total_packets_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dropped_packets_percentage: int,
                 event_thresholds: 'outputs.HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholdsEventThresholds',
                 total_packets_rate: int):
        pulumi.set(__self__, "dropped_packets_percentage", dropped_packets_percentage)
        pulumi.set(__self__, "event_thresholds", event_thresholds)
        pulumi.set(__self__, "total_packets_rate", total_packets_rate)

    @property
    @pulumi.getter(name="droppedPacketsPercentage")
    def dropped_packets_percentage(self) -> int:
        return pulumi.get(self, "dropped_packets_percentage")

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholdsEventThresholds':
        return pulumi.get(self, "event_thresholds")

    @property
    @pulumi.getter(name="totalPacketsRate")
    def total_packets_rate(self) -> int:
        return pulumi.get(self, "total_packets_rate")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkErrorsDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkErrorsDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkErrorsDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkErrorsDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholds']:
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorsPercentage":
            suggest = "errors_percentage"
        elif key == "eventThresholds":
            suggest = "event_thresholds"
        elif key == "totalPacketsRate":
            suggest = "total_packets_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 errors_percentage: int,
                 event_thresholds: 'outputs.HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholdsEventThresholds',
                 total_packets_rate: int):
        pulumi.set(__self__, "errors_percentage", errors_percentage)
        pulumi.set(__self__, "event_thresholds", event_thresholds)
        pulumi.set(__self__, "total_packets_rate", total_packets_rate)

    @property
    @pulumi.getter(name="errorsPercentage")
    def errors_percentage(self) -> int:
        return pulumi.get(self, "errors_percentage")

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholdsEventThresholds':
        return pulumi.get(self, "event_thresholds")

    @property
    @pulumi.getter(name="totalPacketsRate")
    def total_packets_rate(self) -> int:
        return pulumi.get(self, "total_packets_rate")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkHighRetransmissionDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkHighRetransmissionDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkHighRetransmissionDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkHighRetransmissionDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholds']:
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventThresholds":
            suggest = "event_thresholds"
        elif key == "retransmissionRatePercentage":
            suggest = "retransmission_rate_percentage"
        elif key == "retransmittedPacketsNumberPerMinute":
            suggest = "retransmitted_packets_number_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_thresholds: 'outputs.HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholdsEventThresholds',
                 retransmission_rate_percentage: int,
                 retransmitted_packets_number_per_minute: int):
        pulumi.set(__self__, "event_thresholds", event_thresholds)
        pulumi.set(__self__, "retransmission_rate_percentage", retransmission_rate_percentage)
        pulumi.set(__self__, "retransmitted_packets_number_per_minute", retransmitted_packets_number_per_minute)

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholdsEventThresholds':
        return pulumi.get(self, "event_thresholds")

    @property
    @pulumi.getter(name="retransmissionRatePercentage")
    def retransmission_rate_percentage(self) -> int:
        return pulumi.get(self, "retransmission_rate_percentage")

    @property
    @pulumi.getter(name="retransmittedPacketsNumberPerMinute")
    def retransmitted_packets_number_per_minute(self) -> int:
        return pulumi.get(self, "retransmitted_packets_number_per_minute")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkTcpProblemsDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkTcpProblemsDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkTcpProblemsDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkTcpProblemsDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholds']:
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventThresholds":
            suggest = "event_thresholds"
        elif key == "failedConnectionsNumberPerMinute":
            suggest = "failed_connections_number_per_minute"
        elif key == "newConnectionFailuresPercentage":
            suggest = "new_connection_failures_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_thresholds: 'outputs.HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholdsEventThresholds',
                 failed_connections_number_per_minute: int,
                 new_connection_failures_percentage: int):
        pulumi.set(__self__, "event_thresholds", event_thresholds)
        pulumi.set(__self__, "failed_connections_number_per_minute", failed_connections_number_per_minute)
        pulumi.set(__self__, "new_connection_failures_percentage", new_connection_failures_percentage)

    @property
    @pulumi.getter(name="eventThresholds")
    def event_thresholds(self) -> 'outputs.HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholdsEventThresholds':
        return pulumi.get(self, "event_thresholds")

    @property
    @pulumi.getter(name="failedConnectionsNumberPerMinute")
    def failed_connections_number_per_minute(self) -> int:
        return pulumi.get(self, "failed_connections_number_per_minute")

    @property
    @pulumi.getter(name="newConnectionFailuresPercentage")
    def new_connection_failures_percentage(self) -> int:
        return pulumi.get(self, "new_connection_failures_percentage")


@pulumi.output_type
class HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholdsEventThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dealertingEvaluationWindow":
            suggest = "dealerting_evaluation_window"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingEvaluationWindow":
            suggest = "violating_evaluation_window"
        elif key == "violatingSamples":
            suggest = "violating_samples"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholdsEventThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholdsEventThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dealerting_evaluation_window: int,
                 dealerting_samples: int,
                 violating_evaluation_window: int,
                 violating_samples: int):
        pulumi.set(__self__, "dealerting_evaluation_window", dealerting_evaluation_window)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "violating_evaluation_window", violating_evaluation_window)
        pulumi.set(__self__, "violating_samples", violating_samples)

    @property
    @pulumi.getter(name="dealertingEvaluationWindow")
    def dealerting_evaluation_window(self) -> int:
        return pulumi.get(self, "dealerting_evaluation_window")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter(name="violatingEvaluationWindow")
    def violating_evaluation_window(self) -> int:
        return pulumi.get(self, "violating_evaluation_window")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        return pulumi.get(self, "violating_samples")


@pulumi.output_type
class HostNamingCondition(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.HostNamingConditionCondition']] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.HostNamingConditionCondition']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class HostNamingConditionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationTypeComparisons":
            suggest = "application_type_comparisons"
        elif key == "applicationTypes":
            suggest = "application_types"
        elif key == "azureComputeModeComparisons":
            suggest = "azure_compute_mode_comparisons"
        elif key == "azureComputeModes":
            suggest = "azure_compute_modes"
        elif key == "azureSkuComparisions":
            suggest = "azure_sku_comparisions"
        elif key == "azureSkus":
            suggest = "azure_skus"
        elif key == "baseComparisonBasics":
            suggest = "base_comparison_basics"
        elif key == "baseConditionKeys":
            suggest = "base_condition_keys"
        elif key == "bitnessComparisions":
            suggest = "bitness_comparisions"
        elif key == "cloudTypeComparisons":
            suggest = "cloud_type_comparisons"
        elif key == "cloudTypes":
            suggest = "cloud_types"
        elif key == "customApplicationTypeComparisons":
            suggest = "custom_application_type_comparisons"
        elif key == "customApplicationTypes":
            suggest = "custom_application_types"
        elif key == "customHostMetadataConditionKeys":
            suggest = "custom_host_metadata_condition_keys"
        elif key == "customHostMetadatas":
            suggest = "custom_host_metadatas"
        elif key == "customProcessMetadataConditionKeys":
            suggest = "custom_process_metadata_condition_keys"
        elif key == "customProcessMetadatas":
            suggest = "custom_process_metadatas"
        elif key == "databaseTopologies":
            suggest = "database_topologies"
        elif key == "databaseTopologyComparisons":
            suggest = "database_topology_comparisons"
        elif key == "dcrumDecoderComparisons":
            suggest = "dcrum_decoder_comparisons"
        elif key == "dcrumDecoders":
            suggest = "dcrum_decoders"
        elif key == "entityIdComparisons":
            suggest = "entity_id_comparisons"
        elif key == "hostTeches":
            suggest = "host_teches"
        elif key == "hypervisorTypeComparisions":
            suggest = "hypervisor_type_comparisions"
        elif key == "indexedNameComparisons":
            suggest = "indexed_name_comparisons"
        elif key == "indexedNames":
            suggest = "indexed_names"
        elif key == "indexedStringComparisons":
            suggest = "indexed_string_comparisons"
        elif key == "indexedStrings":
            suggest = "indexed_strings"
        elif key == "indexedTagComparisons":
            suggest = "indexed_tag_comparisons"
        elif key == "indexedTags":
            suggest = "indexed_tags"
        elif key == "integerComparisons":
            suggest = "integer_comparisons"
        elif key == "ipaddressComparisons":
            suggest = "ipaddress_comparisons"
        elif key == "mobilePlatformComparisons":
            suggest = "mobile_platform_comparisons"
        elif key == "mobilePlatforms":
            suggest = "mobile_platforms"
        elif key == "osArches":
            suggest = "os_arches"
        elif key == "osTypes":
            suggest = "os_types"
        elif key == "osarchitectureComparisons":
            suggest = "osarchitecture_comparisons"
        elif key == "ostypeComparisons":
            suggest = "ostype_comparisons"
        elif key == "paasTypeComparisons":
            suggest = "paas_type_comparisons"
        elif key == "paasTypes":
            suggest = "paas_types"
        elif key == "processMetadataConditionKeys":
            suggest = "process_metadata_condition_keys"
        elif key == "processMetadatas":
            suggest = "process_metadatas"
        elif key == "serviceTopologies":
            suggest = "service_topologies"
        elif key == "serviceTopologyComparisons":
            suggest = "service_topology_comparisons"
        elif key == "serviceTypeComparisons":
            suggest = "service_type_comparisons"
        elif key == "serviceTypes":
            suggest = "service_types"
        elif key == "simpleHostTechComparisons":
            suggest = "simple_host_tech_comparisons"
        elif key == "simpleTechComparisons":
            suggest = "simple_tech_comparisons"
        elif key == "stringComparisons":
            suggest = "string_comparisons"
        elif key == "stringConditionKeys":
            suggest = "string_condition_keys"
        elif key == "stringKeys":
            suggest = "string_keys"
        elif key == "syntheticEngineTypeComparisons":
            suggest = "synthetic_engine_type_comparisons"
        elif key == "syntheticEngines":
            suggest = "synthetic_engines"
        elif key == "tagComparisons":
            suggest = "tag_comparisons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_type_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionApplicationTypeComparison']] = None,
                 application_types: Optional[Sequence['outputs.HostNamingConditionConditionApplicationType']] = None,
                 azure_compute_mode_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionAzureComputeModeComparison']] = None,
                 azure_compute_modes: Optional[Sequence['outputs.HostNamingConditionConditionAzureComputeMode']] = None,
                 azure_sku_comparisions: Optional[Sequence['outputs.HostNamingConditionConditionAzureSkuComparision']] = None,
                 azure_skus: Optional[Sequence['outputs.HostNamingConditionConditionAzureSkus']] = None,
                 base_comparison_basics: Optional[Sequence['outputs.HostNamingConditionConditionBaseComparisonBasic']] = None,
                 base_condition_keys: Optional[Sequence['outputs.HostNamingConditionConditionBaseConditionKey']] = None,
                 bitness_comparisions: Optional[Sequence['outputs.HostNamingConditionConditionBitnessComparision']] = None,
                 bitnesses: Optional[Sequence['outputs.HostNamingConditionConditionBitness']] = None,
                 cloud_type_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionCloudTypeComparison']] = None,
                 cloud_types: Optional[Sequence['outputs.HostNamingConditionConditionCloudType']] = None,
                 comparisons: Optional[Sequence['outputs.HostNamingConditionConditionComparison']] = None,
                 custom_application_type_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionCustomApplicationTypeComparison']] = None,
                 custom_application_types: Optional[Sequence['outputs.HostNamingConditionConditionCustomApplicationType']] = None,
                 custom_host_metadata_condition_keys: Optional[Sequence['outputs.HostNamingConditionConditionCustomHostMetadataConditionKey']] = None,
                 custom_host_metadatas: Optional[Sequence['outputs.HostNamingConditionConditionCustomHostMetadata']] = None,
                 custom_process_metadata_condition_keys: Optional[Sequence['outputs.HostNamingConditionConditionCustomProcessMetadataConditionKey']] = None,
                 custom_process_metadatas: Optional[Sequence['outputs.HostNamingConditionConditionCustomProcessMetadata']] = None,
                 database_topologies: Optional[Sequence['outputs.HostNamingConditionConditionDatabaseTopology']] = None,
                 database_topology_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionDatabaseTopologyComparison']] = None,
                 dcrum_decoder_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionDcrumDecoderComparison']] = None,
                 dcrum_decoders: Optional[Sequence['outputs.HostNamingConditionConditionDcrumDecoder']] = None,
                 entities: Optional[Sequence['outputs.HostNamingConditionConditionEntity']] = None,
                 entity_id_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionEntityIdComparison']] = None,
                 host_teches: Optional[Sequence['outputs.HostNamingConditionConditionHostTech']] = None,
                 hypervisor_type_comparisions: Optional[Sequence['outputs.HostNamingConditionConditionHypervisorTypeComparision']] = None,
                 hypervisors: Optional[Sequence['outputs.HostNamingConditionConditionHypervisor']] = None,
                 indexed_name_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionIndexedNameComparison']] = None,
                 indexed_names: Optional[Sequence['outputs.HostNamingConditionConditionIndexedName']] = None,
                 indexed_string_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionIndexedStringComparison']] = None,
                 indexed_strings: Optional[Sequence['outputs.HostNamingConditionConditionIndexedString']] = None,
                 indexed_tag_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionIndexedTagComparison']] = None,
                 indexed_tags: Optional[Sequence['outputs.HostNamingConditionConditionIndexedTag']] = None,
                 integer_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionIntegerComparison']] = None,
                 integers: Optional[Sequence['outputs.HostNamingConditionConditionInteger']] = None,
                 ipaddress_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionIpaddressComparison']] = None,
                 ipaddresses: Optional[Sequence['outputs.HostNamingConditionConditionIpaddress']] = None,
                 keys: Optional[Sequence['outputs.HostNamingConditionConditionKey']] = None,
                 mobile_platform_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionMobilePlatformComparison']] = None,
                 mobile_platforms: Optional[Sequence['outputs.HostNamingConditionConditionMobilePlatform']] = None,
                 os_arches: Optional[Sequence['outputs.HostNamingConditionConditionOsArch']] = None,
                 os_types: Optional[Sequence['outputs.HostNamingConditionConditionOsType']] = None,
                 osarchitecture_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionOsarchitectureComparison']] = None,
                 ostype_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionOstypeComparison']] = None,
                 paas_type_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionPaasTypeComparison']] = None,
                 paas_types: Optional[Sequence['outputs.HostNamingConditionConditionPaasType']] = None,
                 process_metadata_condition_keys: Optional[Sequence['outputs.HostNamingConditionConditionProcessMetadataConditionKey']] = None,
                 process_metadatas: Optional[Sequence['outputs.HostNamingConditionConditionProcessMetadata']] = None,
                 service_topologies: Optional[Sequence['outputs.HostNamingConditionConditionServiceTopology']] = None,
                 service_topology_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionServiceTopologyComparison']] = None,
                 service_type_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionServiceTypeComparison']] = None,
                 service_types: Optional[Sequence['outputs.HostNamingConditionConditionServiceType']] = None,
                 simple_host_tech_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionSimpleHostTechComparison']] = None,
                 simple_tech_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionSimpleTechComparison']] = None,
                 string_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionStringComparison']] = None,
                 string_condition_keys: Optional[Sequence['outputs.HostNamingConditionConditionStringConditionKey']] = None,
                 string_keys: Optional[Sequence['outputs.HostNamingConditionConditionStringKey']] = None,
                 strings: Optional[Sequence['outputs.HostNamingConditionConditionString']] = None,
                 synthetic_engine_type_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionSyntheticEngineTypeComparison']] = None,
                 synthetic_engines: Optional[Sequence['outputs.HostNamingConditionConditionSyntheticEngine']] = None,
                 tag_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionTagComparison']] = None,
                 tags: Optional[Sequence['outputs.HostNamingConditionConditionTag']] = None,
                 teches: Optional[Sequence['outputs.HostNamingConditionConditionTech']] = None,
                 unknowns: Optional[str] = None):
        if application_type_comparisons is not None:
            pulumi.set(__self__, "application_type_comparisons", application_type_comparisons)
        if application_types is not None:
            pulumi.set(__self__, "application_types", application_types)
        if azure_compute_mode_comparisons is not None:
            pulumi.set(__self__, "azure_compute_mode_comparisons", azure_compute_mode_comparisons)
        if azure_compute_modes is not None:
            pulumi.set(__self__, "azure_compute_modes", azure_compute_modes)
        if azure_sku_comparisions is not None:
            pulumi.set(__self__, "azure_sku_comparisions", azure_sku_comparisions)
        if azure_skus is not None:
            pulumi.set(__self__, "azure_skus", azure_skus)
        if base_comparison_basics is not None:
            pulumi.set(__self__, "base_comparison_basics", base_comparison_basics)
        if base_condition_keys is not None:
            pulumi.set(__self__, "base_condition_keys", base_condition_keys)
        if bitness_comparisions is not None:
            pulumi.set(__self__, "bitness_comparisions", bitness_comparisions)
        if bitnesses is not None:
            pulumi.set(__self__, "bitnesses", bitnesses)
        if cloud_type_comparisons is not None:
            pulumi.set(__self__, "cloud_type_comparisons", cloud_type_comparisons)
        if cloud_types is not None:
            pulumi.set(__self__, "cloud_types", cloud_types)
        if comparisons is not None:
            pulumi.set(__self__, "comparisons", comparisons)
        if custom_application_type_comparisons is not None:
            pulumi.set(__self__, "custom_application_type_comparisons", custom_application_type_comparisons)
        if custom_application_types is not None:
            pulumi.set(__self__, "custom_application_types", custom_application_types)
        if custom_host_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_host_metadata_condition_keys", custom_host_metadata_condition_keys)
        if custom_host_metadatas is not None:
            pulumi.set(__self__, "custom_host_metadatas", custom_host_metadatas)
        if custom_process_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_process_metadata_condition_keys", custom_process_metadata_condition_keys)
        if custom_process_metadatas is not None:
            pulumi.set(__self__, "custom_process_metadatas", custom_process_metadatas)
        if database_topologies is not None:
            pulumi.set(__self__, "database_topologies", database_topologies)
        if database_topology_comparisons is not None:
            pulumi.set(__self__, "database_topology_comparisons", database_topology_comparisons)
        if dcrum_decoder_comparisons is not None:
            pulumi.set(__self__, "dcrum_decoder_comparisons", dcrum_decoder_comparisons)
        if dcrum_decoders is not None:
            pulumi.set(__self__, "dcrum_decoders", dcrum_decoders)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if entity_id_comparisons is not None:
            pulumi.set(__self__, "entity_id_comparisons", entity_id_comparisons)
        if host_teches is not None:
            pulumi.set(__self__, "host_teches", host_teches)
        if hypervisor_type_comparisions is not None:
            pulumi.set(__self__, "hypervisor_type_comparisions", hypervisor_type_comparisions)
        if hypervisors is not None:
            pulumi.set(__self__, "hypervisors", hypervisors)
        if indexed_name_comparisons is not None:
            pulumi.set(__self__, "indexed_name_comparisons", indexed_name_comparisons)
        if indexed_names is not None:
            pulumi.set(__self__, "indexed_names", indexed_names)
        if indexed_string_comparisons is not None:
            pulumi.set(__self__, "indexed_string_comparisons", indexed_string_comparisons)
        if indexed_strings is not None:
            pulumi.set(__self__, "indexed_strings", indexed_strings)
        if indexed_tag_comparisons is not None:
            pulumi.set(__self__, "indexed_tag_comparisons", indexed_tag_comparisons)
        if indexed_tags is not None:
            pulumi.set(__self__, "indexed_tags", indexed_tags)
        if integer_comparisons is not None:
            pulumi.set(__self__, "integer_comparisons", integer_comparisons)
        if integers is not None:
            pulumi.set(__self__, "integers", integers)
        if ipaddress_comparisons is not None:
            pulumi.set(__self__, "ipaddress_comparisons", ipaddress_comparisons)
        if ipaddresses is not None:
            pulumi.set(__self__, "ipaddresses", ipaddresses)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if mobile_platform_comparisons is not None:
            pulumi.set(__self__, "mobile_platform_comparisons", mobile_platform_comparisons)
        if mobile_platforms is not None:
            pulumi.set(__self__, "mobile_platforms", mobile_platforms)
        if os_arches is not None:
            pulumi.set(__self__, "os_arches", os_arches)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if osarchitecture_comparisons is not None:
            pulumi.set(__self__, "osarchitecture_comparisons", osarchitecture_comparisons)
        if ostype_comparisons is not None:
            pulumi.set(__self__, "ostype_comparisons", ostype_comparisons)
        if paas_type_comparisons is not None:
            pulumi.set(__self__, "paas_type_comparisons", paas_type_comparisons)
        if paas_types is not None:
            pulumi.set(__self__, "paas_types", paas_types)
        if process_metadata_condition_keys is not None:
            pulumi.set(__self__, "process_metadata_condition_keys", process_metadata_condition_keys)
        if process_metadatas is not None:
            pulumi.set(__self__, "process_metadatas", process_metadatas)
        if service_topologies is not None:
            pulumi.set(__self__, "service_topologies", service_topologies)
        if service_topology_comparisons is not None:
            pulumi.set(__self__, "service_topology_comparisons", service_topology_comparisons)
        if service_type_comparisons is not None:
            pulumi.set(__self__, "service_type_comparisons", service_type_comparisons)
        if service_types is not None:
            pulumi.set(__self__, "service_types", service_types)
        if simple_host_tech_comparisons is not None:
            pulumi.set(__self__, "simple_host_tech_comparisons", simple_host_tech_comparisons)
        if simple_tech_comparisons is not None:
            pulumi.set(__self__, "simple_tech_comparisons", simple_tech_comparisons)
        if string_comparisons is not None:
            pulumi.set(__self__, "string_comparisons", string_comparisons)
        if string_condition_keys is not None:
            pulumi.set(__self__, "string_condition_keys", string_condition_keys)
        if string_keys is not None:
            pulumi.set(__self__, "string_keys", string_keys)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)
        if synthetic_engine_type_comparisons is not None:
            pulumi.set(__self__, "synthetic_engine_type_comparisons", synthetic_engine_type_comparisons)
        if synthetic_engines is not None:
            pulumi.set(__self__, "synthetic_engines", synthetic_engines)
        if tag_comparisons is not None:
            pulumi.set(__self__, "tag_comparisons", tag_comparisons)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if teches is not None:
            pulumi.set(__self__, "teches", teches)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="applicationTypeComparisons")
    def application_type_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionApplicationTypeComparison']]:
        return pulumi.get(self, "application_type_comparisons")

    @property
    @pulumi.getter(name="applicationTypes")
    def application_types(self) -> Optional[Sequence['outputs.HostNamingConditionConditionApplicationType']]:
        return pulumi.get(self, "application_types")

    @property
    @pulumi.getter(name="azureComputeModeComparisons")
    def azure_compute_mode_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionAzureComputeModeComparison']]:
        return pulumi.get(self, "azure_compute_mode_comparisons")

    @property
    @pulumi.getter(name="azureComputeModes")
    def azure_compute_modes(self) -> Optional[Sequence['outputs.HostNamingConditionConditionAzureComputeMode']]:
        return pulumi.get(self, "azure_compute_modes")

    @property
    @pulumi.getter(name="azureSkuComparisions")
    def azure_sku_comparisions(self) -> Optional[Sequence['outputs.HostNamingConditionConditionAzureSkuComparision']]:
        return pulumi.get(self, "azure_sku_comparisions")

    @property
    @pulumi.getter(name="azureSkus")
    def azure_skus(self) -> Optional[Sequence['outputs.HostNamingConditionConditionAzureSkus']]:
        return pulumi.get(self, "azure_skus")

    @property
    @pulumi.getter(name="baseComparisonBasics")
    def base_comparison_basics(self) -> Optional[Sequence['outputs.HostNamingConditionConditionBaseComparisonBasic']]:
        return pulumi.get(self, "base_comparison_basics")

    @property
    @pulumi.getter(name="baseConditionKeys")
    def base_condition_keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionBaseConditionKey']]:
        return pulumi.get(self, "base_condition_keys")

    @property
    @pulumi.getter(name="bitnessComparisions")
    def bitness_comparisions(self) -> Optional[Sequence['outputs.HostNamingConditionConditionBitnessComparision']]:
        return pulumi.get(self, "bitness_comparisions")

    @property
    @pulumi.getter
    def bitnesses(self) -> Optional[Sequence['outputs.HostNamingConditionConditionBitness']]:
        return pulumi.get(self, "bitnesses")

    @property
    @pulumi.getter(name="cloudTypeComparisons")
    def cloud_type_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCloudTypeComparison']]:
        return pulumi.get(self, "cloud_type_comparisons")

    @property
    @pulumi.getter(name="cloudTypes")
    def cloud_types(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCloudType']]:
        return pulumi.get(self, "cloud_types")

    @property
    @pulumi.getter
    def comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionComparison']]:
        return pulumi.get(self, "comparisons")

    @property
    @pulumi.getter(name="customApplicationTypeComparisons")
    def custom_application_type_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCustomApplicationTypeComparison']]:
        return pulumi.get(self, "custom_application_type_comparisons")

    @property
    @pulumi.getter(name="customApplicationTypes")
    def custom_application_types(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCustomApplicationType']]:
        return pulumi.get(self, "custom_application_types")

    @property
    @pulumi.getter(name="customHostMetadataConditionKeys")
    def custom_host_metadata_condition_keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCustomHostMetadataConditionKey']]:
        return pulumi.get(self, "custom_host_metadata_condition_keys")

    @property
    @pulumi.getter(name="customHostMetadatas")
    def custom_host_metadatas(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCustomHostMetadata']]:
        return pulumi.get(self, "custom_host_metadatas")

    @property
    @pulumi.getter(name="customProcessMetadataConditionKeys")
    def custom_process_metadata_condition_keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCustomProcessMetadataConditionKey']]:
        return pulumi.get(self, "custom_process_metadata_condition_keys")

    @property
    @pulumi.getter(name="customProcessMetadatas")
    def custom_process_metadatas(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCustomProcessMetadata']]:
        return pulumi.get(self, "custom_process_metadatas")

    @property
    @pulumi.getter(name="databaseTopologies")
    def database_topologies(self) -> Optional[Sequence['outputs.HostNamingConditionConditionDatabaseTopology']]:
        return pulumi.get(self, "database_topologies")

    @property
    @pulumi.getter(name="databaseTopologyComparisons")
    def database_topology_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionDatabaseTopologyComparison']]:
        return pulumi.get(self, "database_topology_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoderComparisons")
    def dcrum_decoder_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionDcrumDecoderComparison']]:
        return pulumi.get(self, "dcrum_decoder_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoders")
    def dcrum_decoders(self) -> Optional[Sequence['outputs.HostNamingConditionConditionDcrumDecoder']]:
        return pulumi.get(self, "dcrum_decoders")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.HostNamingConditionConditionEntity']]:
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="entityIdComparisons")
    def entity_id_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionEntityIdComparison']]:
        return pulumi.get(self, "entity_id_comparisons")

    @property
    @pulumi.getter(name="hostTeches")
    def host_teches(self) -> Optional[Sequence['outputs.HostNamingConditionConditionHostTech']]:
        return pulumi.get(self, "host_teches")

    @property
    @pulumi.getter(name="hypervisorTypeComparisions")
    def hypervisor_type_comparisions(self) -> Optional[Sequence['outputs.HostNamingConditionConditionHypervisorTypeComparision']]:
        return pulumi.get(self, "hypervisor_type_comparisions")

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[Sequence['outputs.HostNamingConditionConditionHypervisor']]:
        return pulumi.get(self, "hypervisors")

    @property
    @pulumi.getter(name="indexedNameComparisons")
    def indexed_name_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIndexedNameComparison']]:
        return pulumi.get(self, "indexed_name_comparisons")

    @property
    @pulumi.getter(name="indexedNames")
    def indexed_names(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIndexedName']]:
        return pulumi.get(self, "indexed_names")

    @property
    @pulumi.getter(name="indexedStringComparisons")
    def indexed_string_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIndexedStringComparison']]:
        return pulumi.get(self, "indexed_string_comparisons")

    @property
    @pulumi.getter(name="indexedStrings")
    def indexed_strings(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIndexedString']]:
        return pulumi.get(self, "indexed_strings")

    @property
    @pulumi.getter(name="indexedTagComparisons")
    def indexed_tag_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIndexedTagComparison']]:
        return pulumi.get(self, "indexed_tag_comparisons")

    @property
    @pulumi.getter(name="indexedTags")
    def indexed_tags(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIndexedTag']]:
        return pulumi.get(self, "indexed_tags")

    @property
    @pulumi.getter(name="integerComparisons")
    def integer_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIntegerComparison']]:
        return pulumi.get(self, "integer_comparisons")

    @property
    @pulumi.getter
    def integers(self) -> Optional[Sequence['outputs.HostNamingConditionConditionInteger']]:
        return pulumi.get(self, "integers")

    @property
    @pulumi.getter(name="ipaddressComparisons")
    def ipaddress_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIpaddressComparison']]:
        return pulumi.get(self, "ipaddress_comparisons")

    @property
    @pulumi.getter
    def ipaddresses(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIpaddress']]:
        return pulumi.get(self, "ipaddresses")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionKey']]:
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter(name="mobilePlatformComparisons")
    def mobile_platform_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionMobilePlatformComparison']]:
        return pulumi.get(self, "mobile_platform_comparisons")

    @property
    @pulumi.getter(name="mobilePlatforms")
    def mobile_platforms(self) -> Optional[Sequence['outputs.HostNamingConditionConditionMobilePlatform']]:
        return pulumi.get(self, "mobile_platforms")

    @property
    @pulumi.getter(name="osArches")
    def os_arches(self) -> Optional[Sequence['outputs.HostNamingConditionConditionOsArch']]:
        return pulumi.get(self, "os_arches")

    @property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[Sequence['outputs.HostNamingConditionConditionOsType']]:
        return pulumi.get(self, "os_types")

    @property
    @pulumi.getter(name="osarchitectureComparisons")
    def osarchitecture_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionOsarchitectureComparison']]:
        return pulumi.get(self, "osarchitecture_comparisons")

    @property
    @pulumi.getter(name="ostypeComparisons")
    def ostype_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionOstypeComparison']]:
        return pulumi.get(self, "ostype_comparisons")

    @property
    @pulumi.getter(name="paasTypeComparisons")
    def paas_type_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionPaasTypeComparison']]:
        return pulumi.get(self, "paas_type_comparisons")

    @property
    @pulumi.getter(name="paasTypes")
    def paas_types(self) -> Optional[Sequence['outputs.HostNamingConditionConditionPaasType']]:
        return pulumi.get(self, "paas_types")

    @property
    @pulumi.getter(name="processMetadataConditionKeys")
    def process_metadata_condition_keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionProcessMetadataConditionKey']]:
        return pulumi.get(self, "process_metadata_condition_keys")

    @property
    @pulumi.getter(name="processMetadatas")
    def process_metadatas(self) -> Optional[Sequence['outputs.HostNamingConditionConditionProcessMetadata']]:
        return pulumi.get(self, "process_metadatas")

    @property
    @pulumi.getter(name="serviceTopologies")
    def service_topologies(self) -> Optional[Sequence['outputs.HostNamingConditionConditionServiceTopology']]:
        return pulumi.get(self, "service_topologies")

    @property
    @pulumi.getter(name="serviceTopologyComparisons")
    def service_topology_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionServiceTopologyComparison']]:
        return pulumi.get(self, "service_topology_comparisons")

    @property
    @pulumi.getter(name="serviceTypeComparisons")
    def service_type_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionServiceTypeComparison']]:
        return pulumi.get(self, "service_type_comparisons")

    @property
    @pulumi.getter(name="serviceTypes")
    def service_types(self) -> Optional[Sequence['outputs.HostNamingConditionConditionServiceType']]:
        return pulumi.get(self, "service_types")

    @property
    @pulumi.getter(name="simpleHostTechComparisons")
    def simple_host_tech_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionSimpleHostTechComparison']]:
        return pulumi.get(self, "simple_host_tech_comparisons")

    @property
    @pulumi.getter(name="simpleTechComparisons")
    def simple_tech_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionSimpleTechComparison']]:
        return pulumi.get(self, "simple_tech_comparisons")

    @property
    @pulumi.getter(name="stringComparisons")
    def string_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionStringComparison']]:
        return pulumi.get(self, "string_comparisons")

    @property
    @pulumi.getter(name="stringConditionKeys")
    def string_condition_keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionStringConditionKey']]:
        return pulumi.get(self, "string_condition_keys")

    @property
    @pulumi.getter(name="stringKeys")
    def string_keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionStringKey']]:
        return pulumi.get(self, "string_keys")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence['outputs.HostNamingConditionConditionString']]:
        return pulumi.get(self, "strings")

    @property
    @pulumi.getter(name="syntheticEngineTypeComparisons")
    def synthetic_engine_type_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionSyntheticEngineTypeComparison']]:
        return pulumi.get(self, "synthetic_engine_type_comparisons")

    @property
    @pulumi.getter(name="syntheticEngines")
    def synthetic_engines(self) -> Optional[Sequence['outputs.HostNamingConditionConditionSyntheticEngine']]:
        return pulumi.get(self, "synthetic_engines")

    @property
    @pulumi.getter(name="tagComparisons")
    def tag_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionTagComparison']]:
        return pulumi.get(self, "tag_comparisons")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.HostNamingConditionConditionTag']]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def teches(self) -> Optional[Sequence['outputs.HostNamingConditionConditionTech']]:
        return pulumi.get(self, "teches")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionAzureComputeMode(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionAzureComputeModeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionAzureSkuComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionAzureSkus(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionBaseComparisonBasic(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionBaseConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionBitness(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionBitnessComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionCloudType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionCloudTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionComparison(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionCustomApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionCustomHostMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionCustomHostMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionCustomHostMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionCustomHostMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.HostNamingConditionConditionCustomHostMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.HostNamingConditionConditionCustomHostMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomHostMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionCustomHostMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.HostNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.HostNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomHostMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionCustomProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionCustomProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionCustomProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.HostNamingConditionConditionCustomProcessMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.HostNamingConditionConditionCustomProcessMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionCustomProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.HostNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.HostNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomProcessMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionDatabaseTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionDatabaseTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionDcrumDecoder(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionDcrumDecoderComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionEntity(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionEntityIdComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionHostTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionHostTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionHostTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionHostTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionHostTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionHostTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionHostTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class HostNamingConditionConditionHypervisor(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionHypervisorTypeComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedName(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedNameComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedString(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedStringComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionIndexedTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionIndexedTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionIndexedTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionIndexedTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionInteger(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIntegerComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIpaddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionIpaddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionIpaddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionIpaddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIpaddressComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionIpaddressComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionIpaddressComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionIpaddressComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionMobilePlatform(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionMobilePlatformComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionOsArch(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionOsType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionOsarchitectureComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionOstypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionPaasType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionPaasTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionServiceTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionServiceTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionServiceType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionServiceTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionSimpleHostTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionSimpleHostTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionSimpleHostTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionSimpleHostTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionSimpleHostTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class HostNamingConditionConditionSimpleTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionSimpleTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionSimpleTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionSimpleTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionSimpleTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionSimpleTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionSimpleTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class HostNamingConditionConditionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionStringComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionStringComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionStringComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionStringComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionStringConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionStringConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionStringConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionStringConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionStringKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionStringKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionStringKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionStringKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionSyntheticEngine(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionSyntheticEngineTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class HttpMonitorAnomalyDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadingTimeThresholds":
            suggest = "loading_time_thresholds"
        elif key == "outageHandlings":
            suggest = "outage_handlings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorAnomalyDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorAnomalyDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorAnomalyDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 loading_time_thresholds: Optional[Sequence['outputs.HttpMonitorAnomalyDetectionLoadingTimeThreshold']] = None,
                 outage_handlings: Optional[Sequence['outputs.HttpMonitorAnomalyDetectionOutageHandling']] = None):
        """
        :param Sequence['HttpMonitorAnomalyDetectionLoadingTimeThresholdArgs'] loading_time_thresholds: Thresholds for loading times
        :param Sequence['HttpMonitorAnomalyDetectionOutageHandlingArgs'] outage_handlings: Outage handling configuration
        """
        if loading_time_thresholds is not None:
            pulumi.set(__self__, "loading_time_thresholds", loading_time_thresholds)
        if outage_handlings is not None:
            pulumi.set(__self__, "outage_handlings", outage_handlings)

    @property
    @pulumi.getter(name="loadingTimeThresholds")
    def loading_time_thresholds(self) -> Optional[Sequence['outputs.HttpMonitorAnomalyDetectionLoadingTimeThreshold']]:
        """
        Thresholds for loading times
        """
        return pulumi.get(self, "loading_time_thresholds")

    @property
    @pulumi.getter(name="outageHandlings")
    def outage_handlings(self) -> Optional[Sequence['outputs.HttpMonitorAnomalyDetectionOutageHandling']]:
        """
        Outage handling configuration
        """
        return pulumi.get(self, "outage_handlings")


@pulumi.output_type
class HttpMonitorAnomalyDetectionLoadingTimeThreshold(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 thresholds: Optional[Sequence['outputs.HttpMonitorAnomalyDetectionLoadingTimeThresholdThreshold']] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional[Sequence['outputs.HttpMonitorAnomalyDetectionLoadingTimeThresholdThreshold']]:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HttpMonitorAnomalyDetectionLoadingTimeThresholdThreshold(dict):
    def __init__(__self__, *,
                 thresholds: Sequence['outputs.HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold']):
        pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueMs":
            suggest = "value_ms"
        elif key == "eventIndex":
            suggest = "event_index"
        elif key == "requestIndex":
            suggest = "request_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value_ms: int,
                 event_index: Optional[int] = None,
                 request_index: Optional[int] = None,
                 type: Optional[str] = None):
        pulumi.set(__self__, "value_ms", value_ms)
        if event_index is not None:
            pulumi.set(__self__, "event_index", event_index)
        if request_index is not None:
            pulumi.set(__self__, "request_index", request_index)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="valueMs")
    def value_ms(self) -> int:
        return pulumi.get(self, "value_ms")

    @property
    @pulumi.getter(name="eventIndex")
    def event_index(self) -> Optional[int]:
        return pulumi.get(self, "event_index")

    @property
    @pulumi.getter(name="requestIndex")
    def request_index(self) -> Optional[int]:
        return pulumi.get(self, "request_index")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class HttpMonitorAnomalyDetectionOutageHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "globalOutage":
            suggest = "global_outage"
        elif key == "globalOutagePolicies":
            suggest = "global_outage_policies"
        elif key == "localOutage":
            suggest = "local_outage"
        elif key == "localOutagePolicies":
            suggest = "local_outage_policies"
        elif key == "retryOnError":
            suggest = "retry_on_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorAnomalyDetectionOutageHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorAnomalyDetectionOutageHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorAnomalyDetectionOutageHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 global_outage: Optional[bool] = None,
                 global_outage_policies: Optional[Sequence['outputs.HttpMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy']] = None,
                 local_outage: Optional[bool] = None,
                 local_outage_policies: Optional[Sequence['outputs.HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy']] = None,
                 retry_on_error: Optional[bool] = None):
        if global_outage is not None:
            pulumi.set(__self__, "global_outage", global_outage)
        if global_outage_policies is not None:
            pulumi.set(__self__, "global_outage_policies", global_outage_policies)
        if local_outage is not None:
            pulumi.set(__self__, "local_outage", local_outage)
        if local_outage_policies is not None:
            pulumi.set(__self__, "local_outage_policies", local_outage_policies)
        if retry_on_error is not None:
            pulumi.set(__self__, "retry_on_error", retry_on_error)

    @property
    @pulumi.getter(name="globalOutage")
    def global_outage(self) -> Optional[bool]:
        return pulumi.get(self, "global_outage")

    @property
    @pulumi.getter(name="globalOutagePolicies")
    def global_outage_policies(self) -> Optional[Sequence['outputs.HttpMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy']]:
        return pulumi.get(self, "global_outage_policies")

    @property
    @pulumi.getter(name="localOutage")
    def local_outage(self) -> Optional[bool]:
        return pulumi.get(self, "local_outage")

    @property
    @pulumi.getter(name="localOutagePolicies")
    def local_outage_policies(self) -> Optional[Sequence['outputs.HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy']]:
        return pulumi.get(self, "local_outage_policies")

    @property
    @pulumi.getter(name="retryOnError")
    def retry_on_error(self) -> Optional[bool]:
        return pulumi.get(self, "retry_on_error")


@pulumi.output_type
class HttpMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consecutiveRuns":
            suggest = "consecutive_runs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consecutive_runs: int):
        pulumi.set(__self__, "consecutive_runs", consecutive_runs)

    @property
    @pulumi.getter(name="consecutiveRuns")
    def consecutive_runs(self) -> int:
        return pulumi.get(self, "consecutive_runs")


@pulumi.output_type
class HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "affectedLocations":
            suggest = "affected_locations"
        elif key == "consecutiveRuns":
            suggest = "consecutive_runs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affected_locations: int,
                 consecutive_runs: int):
        pulumi.set(__self__, "affected_locations", affected_locations)
        pulumi.set(__self__, "consecutive_runs", consecutive_runs)

    @property
    @pulumi.getter(name="affectedLocations")
    def affected_locations(self) -> int:
        return pulumi.get(self, "affected_locations")

    @property
    @pulumi.getter(name="consecutiveRuns")
    def consecutive_runs(self) -> int:
        return pulumi.get(self, "consecutive_runs")


@pulumi.output_type
class HttpMonitorCookiesCookies(dict):
    def __init__(__self__, *,
                 cookies: Sequence['outputs.HttpMonitorCookiesCookiesCookie']):
        pulumi.set(__self__, "cookies", cookies)

    @property
    @pulumi.getter
    def cookies(self) -> Sequence['outputs.HttpMonitorCookiesCookiesCookie']:
        return pulumi.get(self, "cookies")


@pulumi.output_type
class HttpMonitorCookiesCookiesCookie(dict):
    def __init__(__self__, *,
                 domain: str,
                 name: str,
                 value: str,
                 path: Optional[str] = None):
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def domain(self) -> str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class HttpMonitorPerformanceThresholds(dict):
    def __init__(__self__, *,
                 thresholds: Sequence['outputs.HttpMonitorPerformanceThresholdsThreshold']):
        pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.HttpMonitorPerformanceThresholdsThreshold']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HttpMonitorPerformanceThresholdsThreshold(dict):
    def __init__(__self__, *,
                 event: str,
                 threshold: float):
        pulumi.set(__self__, "event", event)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def event(self) -> str:
        return pulumi.get(self, "event")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class HttpMonitorScript(dict):
    def __init__(__self__, *,
                 requests: Sequence['outputs.HttpMonitorScriptRequest']):
        """
        :param Sequence['HttpMonitorScriptRequestArgs'] requests: A HTTP request to be performed by the monitor.
        """
        pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def requests(self) -> Sequence['outputs.HttpMonitorScriptRequest']:
        """
        A HTTP request to be performed by the monitor.
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class HttpMonitorScriptRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postProcessing":
            suggest = "post_processing"
        elif key == "preProcessing":
            suggest = "pre_processing"
        elif key == "requestTimeout":
            suggest = "request_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorScriptRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorScriptRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorScriptRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 url: str,
                 authentication: Optional['outputs.HttpMonitorScriptRequestAuthentication'] = None,
                 body: Optional[str] = None,
                 configuration: Optional['outputs.HttpMonitorScriptRequestConfiguration'] = None,
                 description: Optional[str] = None,
                 post_processing: Optional[str] = None,
                 pre_processing: Optional[str] = None,
                 request_timeout: Optional[int] = None,
                 validation: Optional['outputs.HttpMonitorScriptRequestValidation'] = None):
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "url", url)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if post_processing is not None:
            pulumi.set(__self__, "post_processing", post_processing)
        if pre_processing is not None:
            pulumi.set(__self__, "pre_processing", pre_processing)
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def method(self) -> str:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.HttpMonitorScriptRequestAuthentication']:
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.HttpMonitorScriptRequestConfiguration']:
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="postProcessing")
    def post_processing(self) -> Optional[str]:
        return pulumi.get(self, "post_processing")

    @property
    @pulumi.getter(name="preProcessing")
    def pre_processing(self) -> Optional[str]:
        return pulumi.get(self, "pre_processing")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[int]:
        return pulumi.get(self, "request_timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.HttpMonitorScriptRequestValidation']:
        return pulumi.get(self, "validation")


@pulumi.output_type
class HttpMonitorScriptRequestAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kdcIp":
            suggest = "kdc_ip"
        elif key == "realmName":
            suggest = "realm_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorScriptRequestAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorScriptRequestAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorScriptRequestAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: str,
                 type: str,
                 kdc_ip: Optional[str] = None,
                 realm_name: Optional[str] = None):
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "type", type)
        if kdc_ip is not None:
            pulumi.set(__self__, "kdc_ip", kdc_ip)
        if realm_name is not None:
            pulumi.set(__self__, "realm_name", realm_name)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="kdcIp")
    def kdc_ip(self) -> Optional[str]:
        return pulumi.get(self, "kdc_ip")

    @property
    @pulumi.getter(name="realmName")
    def realm_name(self) -> Optional[str]:
        return pulumi.get(self, "realm_name")


@pulumi.output_type
class HttpMonitorScriptRequestConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptAnyCertificate":
            suggest = "accept_any_certificate"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "followRedirects":
            suggest = "follow_redirects"
        elif key == "sensitiveData":
            suggest = "sensitive_data"
        elif key == "userAgent":
            suggest = "user_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorScriptRequestConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorScriptRequestConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorScriptRequestConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept_any_certificate: Optional[bool] = None,
                 client_certificate: Optional[str] = None,
                 follow_redirects: Optional[bool] = None,
                 headers: Optional['outputs.HttpMonitorScriptRequestConfigurationHeaders'] = None,
                 sensitive_data: Optional[bool] = None,
                 user_agent: Optional[str] = None):
        if accept_any_certificate is not None:
            pulumi.set(__self__, "accept_any_certificate", accept_any_certificate)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if sensitive_data is not None:
            pulumi.set(__self__, "sensitive_data", sensitive_data)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)

    @property
    @pulumi.getter(name="acceptAnyCertificate")
    def accept_any_certificate(self) -> Optional[bool]:
        return pulumi.get(self, "accept_any_certificate")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[bool]:
        return pulumi.get(self, "follow_redirects")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.HttpMonitorScriptRequestConfigurationHeaders']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="sensitiveData")
    def sensitive_data(self) -> Optional[bool]:
        return pulumi.get(self, "sensitive_data")

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[str]:
        return pulumi.get(self, "user_agent")


@pulumi.output_type
class HttpMonitorScriptRequestConfigurationHeaders(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.HttpMonitorScriptRequestConfigurationHeadersHeader']):
        pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.HttpMonitorScriptRequestConfigurationHeadersHeader']:
        return pulumi.get(self, "headers")


@pulumi.output_type
class HttpMonitorScriptRequestConfigurationHeadersHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class HttpMonitorScriptRequestValidation(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.HttpMonitorScriptRequestValidationRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.HttpMonitorScriptRequestValidationRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class HttpMonitorScriptRequestValidationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passIfFound":
            suggest = "pass_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorScriptRequestValidationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorScriptRequestValidationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorScriptRequestValidationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 value: str,
                 pass_if_found: Optional[bool] = None):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if pass_if_found is not None:
            pulumi.set(__self__, "pass_if_found", pass_if_found)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="passIfFound")
    def pass_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "pass_if_found")


@pulumi.output_type
class HttpMonitorTag(dict):
    def __init__(__self__, *,
                 tags: Optional[Sequence['outputs.HttpMonitorTagTag']] = None):
        """
        :param Sequence['HttpMonitorTagTagArgs'] tags: Tag with source of a Dynatrace entity.
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.HttpMonitorTagTag']]:
        """
        Tag with source of a Dynatrace entity.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class HttpMonitorTagTag(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 source: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class IamGroupPermissions(dict):
    def __init__(__self__, *,
                 permissions: Sequence['outputs.IamGroupPermissionsPermission']):
        """
        :param Sequence['IamGroupPermissionsPermissionArgs'] permissions: A Permission
        """
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence['outputs.IamGroupPermissionsPermission']:
        """
        A Permission
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class IamGroupPermissionsPermission(dict):
    def __init__(__self__, *,
                 name: str,
                 scope: str,
                 type: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def scope(self) -> str:
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class ImsBridgesQueueManager(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueManagers":
            suggest = "queue_managers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImsBridgesQueueManager. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImsBridgesQueueManager.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImsBridgesQueueManager.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue_managers: Optional[Sequence['outputs.ImsBridgesQueueManagerQueueManager']] = None):
        """
        :param Sequence['ImsBridgesQueueManagerQueueManagerArgs'] queue_managers: Queue manager definition for IMS bridge
        """
        if queue_managers is not None:
            pulumi.set(__self__, "queue_managers", queue_managers)

    @property
    @pulumi.getter(name="queueManagers")
    def queue_managers(self) -> Optional[Sequence['outputs.ImsBridgesQueueManagerQueueManager']]:
        """
        Queue manager definition for IMS bridge
        """
        return pulumi.get(self, "queue_managers")


@pulumi.output_type
class ImsBridgesQueueManagerQueueManager(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueManagerQueues":
            suggest = "queue_manager_queues"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImsBridgesQueueManagerQueueManager. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImsBridgesQueueManagerQueueManager.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImsBridgesQueueManagerQueueManager.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 queue_manager_queues: Optional[Sequence[str]] = None):
        """
        :param str name: The name of the IMS bridge
        """
        pulumi.set(__self__, "name", name)
        if queue_manager_queues is not None:
            pulumi.set(__self__, "queue_manager_queues", queue_manager_queues)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the IMS bridge
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="queueManagerQueues")
    def queue_manager_queues(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "queue_manager_queues")


@pulumi.output_type
class K8sClusterAnomaliesCpuRequestsSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sClusterAnomaliesCpuRequestsSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sClusterAnomaliesCpuRequestsSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sClusterAnomaliesCpuRequestsSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sClusterAnomaliesCpuRequestsSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sClusterAnomaliesCpuRequestsSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sClusterAnomaliesCpuRequestsSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sClusterAnomaliesCpuRequestsSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sClusterAnomaliesMemoryRequestsSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sClusterAnomaliesMemoryRequestsSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sClusterAnomaliesMemoryRequestsSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sClusterAnomaliesMemoryRequestsSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sClusterAnomaliesMemoryRequestsSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sClusterAnomaliesMemoryRequestsSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sClusterAnomaliesMemoryRequestsSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sClusterAnomaliesMemoryRequestsSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sClusterAnomaliesMonitoringIssues(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sClusterAnomaliesMonitoringIssuesConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sClusterAnomaliesMonitoringIssuesConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sClusterAnomaliesMonitoringIssuesConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sClusterAnomaliesMonitoringIssuesConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sClusterAnomaliesMonitoringIssuesConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sClusterAnomaliesMonitoringIssuesConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sClusterAnomaliesMonitoringIssuesConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")


@pulumi.output_type
class K8sClusterAnomaliesPodsSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sClusterAnomaliesPodsSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sClusterAnomaliesPodsSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sClusterAnomaliesPodsSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sClusterAnomaliesPodsSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sClusterAnomaliesPodsSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sClusterAnomaliesPodsSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sClusterAnomaliesPodsSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sClusterAnomaliesReadinessIssues(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sClusterAnomaliesReadinessIssuesConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sClusterAnomaliesReadinessIssuesConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sClusterAnomaliesReadinessIssuesConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sClusterAnomaliesReadinessIssuesConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sClusterAnomaliesReadinessIssuesConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sClusterAnomaliesReadinessIssuesConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sClusterAnomaliesReadinessIssuesConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")


@pulumi.output_type
class K8sCredentialsEventsFieldSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldSelector":
            suggest = "field_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCredentialsEventsFieldSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCredentialsEventsFieldSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCredentialsEventsFieldSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 field_selector: str,
                 label: str,
                 unknowns: Optional[str] = None):
        """
        :param bool active: Whether subscription to this events field selector is enabled (value set to `true`). If disabled (value set to `false`), Dynatrace will stop fetching events from the Kubernetes API for this events field selector
        :param str field_selector: The field selector string (url decoding is applied) when storing it.
        :param str label: A label of the events field selector.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "field_selector", field_selector)
        pulumi.set(__self__, "label", label)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        Whether subscription to this events field selector is enabled (value set to `true`). If disabled (value set to `false`), Dynatrace will stop fetching events from the Kubernetes API for this events field selector
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="fieldSelector")
    def field_selector(self) -> str:
        """
        The field selector string (url decoding is applied) when storing it.
        """
        return pulumi.get(self, "field_selector")

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        A label of the events field selector.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class K8sNamespaceAnomaliesCpuLimitsQuotaSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNamespaceAnomaliesCpuLimitsQuotaSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNamespaceAnomaliesCpuLimitsQuotaSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNamespaceAnomaliesCpuLimitsQuotaSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNamespaceAnomaliesCpuLimitsQuotaSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNamespaceAnomaliesCpuLimitsQuotaSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNamespaceAnomaliesCpuLimitsQuotaSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNamespaceAnomaliesCpuLimitsQuotaSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sNamespaceAnomaliesCpuRequestsQuotaSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNamespaceAnomaliesCpuRequestsQuotaSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNamespaceAnomaliesCpuRequestsQuotaSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNamespaceAnomaliesCpuRequestsQuotaSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNamespaceAnomaliesCpuRequestsQuotaSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNamespaceAnomaliesCpuRequestsQuotaSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNamespaceAnomaliesCpuRequestsQuotaSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNamespaceAnomaliesCpuRequestsQuotaSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sNamespaceAnomaliesMemoryLimitsQuotaSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNamespaceAnomaliesMemoryLimitsQuotaSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNamespaceAnomaliesMemoryLimitsQuotaSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNamespaceAnomaliesMemoryLimitsQuotaSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNamespaceAnomaliesMemoryLimitsQuotaSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNamespaceAnomaliesMemoryLimitsQuotaSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNamespaceAnomaliesMemoryLimitsQuotaSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNamespaceAnomaliesMemoryLimitsQuotaSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sNamespaceAnomaliesMemoryRequestsQuotaSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNamespaceAnomaliesMemoryRequestsQuotaSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNamespaceAnomaliesMemoryRequestsQuotaSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNamespaceAnomaliesMemoryRequestsQuotaSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNamespaceAnomaliesMemoryRequestsQuotaSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNamespaceAnomaliesMemoryRequestsQuotaSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNamespaceAnomaliesMemoryRequestsQuotaSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNamespaceAnomaliesMemoryRequestsQuotaSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sNamespaceAnomaliesPodsQuotaSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNamespaceAnomaliesPodsQuotaSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNamespaceAnomaliesPodsQuotaSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNamespaceAnomaliesPodsQuotaSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNamespaceAnomaliesPodsQuotaSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNamespaceAnomaliesPodsQuotaSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNamespaceAnomaliesPodsQuotaSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNamespaceAnomaliesPodsQuotaSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sNodeAnomaliesCpuRequestsSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNodeAnomaliesCpuRequestsSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNodeAnomaliesCpuRequestsSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNodeAnomaliesCpuRequestsSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNodeAnomaliesCpuRequestsSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNodeAnomaliesCpuRequestsSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNodeAnomaliesCpuRequestsSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNodeAnomaliesCpuRequestsSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sNodeAnomaliesMemoryRequestsSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNodeAnomaliesMemoryRequestsSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNodeAnomaliesMemoryRequestsSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNodeAnomaliesMemoryRequestsSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNodeAnomaliesMemoryRequestsSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNodeAnomaliesMemoryRequestsSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNodeAnomaliesMemoryRequestsSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNodeAnomaliesMemoryRequestsSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sNodeAnomaliesNodeProblematicCondition(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNodeAnomaliesNodeProblematicConditionConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNodeAnomaliesNodeProblematicConditionConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNodeAnomaliesNodeProblematicConditionConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNodeAnomaliesNodeProblematicConditionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNodeAnomaliesNodeProblematicConditionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNodeAnomaliesNodeProblematicConditionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNodeAnomaliesNodeProblematicConditionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")


@pulumi.output_type
class K8sNodeAnomaliesPodsSaturation(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNodeAnomaliesPodsSaturationConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNodeAnomaliesPodsSaturationConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNodeAnomaliesPodsSaturationConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNodeAnomaliesPodsSaturationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNodeAnomaliesPodsSaturationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNodeAnomaliesPodsSaturationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNodeAnomaliesPodsSaturationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sNodeAnomaliesReadinessIssues(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sNodeAnomaliesReadinessIssuesConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sNodeAnomaliesReadinessIssuesConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sNodeAnomaliesReadinessIssuesConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sNodeAnomaliesReadinessIssuesConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sNodeAnomaliesReadinessIssuesConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sNodeAnomaliesReadinessIssuesConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sNodeAnomaliesReadinessIssuesConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")


@pulumi.output_type
class K8sPvcAnomaliesLowDiskSpaceCritical(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sPvcAnomaliesLowDiskSpaceCriticalConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sPvcAnomaliesLowDiskSpaceCriticalConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sPvcAnomaliesLowDiskSpaceCriticalConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sPvcAnomaliesLowDiskSpaceCriticalConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sPvcAnomaliesLowDiskSpaceCriticalConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sPvcAnomaliesLowDiskSpaceCriticalConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sPvcAnomaliesLowDiskSpaceCriticalConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sPvcAnomaliesLowDiskSpaceCriticalPercentage(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sPvcAnomaliesLowDiskSpaceCriticalPercentageConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sPvcAnomaliesLowDiskSpaceCriticalPercentageConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sPvcAnomaliesLowDiskSpaceCriticalPercentageConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sPvcAnomaliesLowDiskSpaceCriticalPercentageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sPvcAnomaliesLowDiskSpaceCriticalPercentageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sPvcAnomaliesLowDiskSpaceCriticalPercentageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sPvcAnomaliesLowDiskSpaceCriticalPercentageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sWorkloadAnomaliesContainerRestarts(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sWorkloadAnomaliesContainerRestartsConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sWorkloadAnomaliesContainerRestartsConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sWorkloadAnomaliesContainerRestartsConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sWorkloadAnomaliesContainerRestartsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sWorkloadAnomaliesContainerRestartsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sWorkloadAnomaliesContainerRestartsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sWorkloadAnomaliesContainerRestartsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sWorkloadAnomaliesDeploymentStuck(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sWorkloadAnomaliesDeploymentStuckConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sWorkloadAnomaliesDeploymentStuckConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sWorkloadAnomaliesDeploymentStuckConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sWorkloadAnomaliesDeploymentStuckConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sWorkloadAnomaliesDeploymentStuckConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sWorkloadAnomaliesDeploymentStuckConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sWorkloadAnomaliesDeploymentStuckConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")


@pulumi.output_type
class K8sWorkloadAnomaliesHighCpuThrottling(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sWorkloadAnomaliesHighCpuThrottlingConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sWorkloadAnomaliesHighCpuThrottlingConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sWorkloadAnomaliesHighCpuThrottlingConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sWorkloadAnomaliesHighCpuThrottlingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sWorkloadAnomaliesHighCpuThrottlingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sWorkloadAnomaliesHighCpuThrottlingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sWorkloadAnomaliesHighCpuThrottlingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sWorkloadAnomaliesHighCpuUsage(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sWorkloadAnomaliesHighCpuUsageConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sWorkloadAnomaliesHighCpuUsageConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sWorkloadAnomaliesHighCpuUsageConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sWorkloadAnomaliesHighCpuUsageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sWorkloadAnomaliesHighCpuUsageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sWorkloadAnomaliesHighCpuUsageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sWorkloadAnomaliesHighCpuUsageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sWorkloadAnomaliesHighMemoryUsage(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sWorkloadAnomaliesHighMemoryUsageConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sWorkloadAnomaliesHighMemoryUsageConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sWorkloadAnomaliesHighMemoryUsageConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sWorkloadAnomaliesHighMemoryUsageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sWorkloadAnomaliesHighMemoryUsageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sWorkloadAnomaliesHighMemoryUsageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sWorkloadAnomaliesHighMemoryUsageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sWorkloadAnomaliesNotAllPodsReady(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sWorkloadAnomaliesNotAllPodsReadyConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sWorkloadAnomaliesNotAllPodsReadyConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sWorkloadAnomaliesNotAllPodsReadyConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sWorkloadAnomaliesNotAllPodsReadyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sWorkloadAnomaliesNotAllPodsReadyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sWorkloadAnomaliesNotAllPodsReadyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sWorkloadAnomaliesNotAllPodsReadyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")


@pulumi.output_type
class K8sWorkloadAnomaliesPendingPods(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sWorkloadAnomaliesPendingPodsConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sWorkloadAnomaliesPendingPodsConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sWorkloadAnomaliesPendingPodsConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sWorkloadAnomaliesPendingPodsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sWorkloadAnomaliesPendingPodsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sWorkloadAnomaliesPendingPodsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sWorkloadAnomaliesPendingPodsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int,
                 threshold: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class K8sWorkloadAnomaliesPodStuckInTerminating(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sWorkloadAnomaliesPodStuckInTerminatingConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sWorkloadAnomaliesPodStuckInTerminatingConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sWorkloadAnomaliesPodStuckInTerminatingConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sWorkloadAnomaliesPodStuckInTerminatingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sWorkloadAnomaliesPodStuckInTerminatingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sWorkloadAnomaliesPodStuckInTerminatingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sWorkloadAnomaliesPodStuckInTerminatingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")


@pulumi.output_type
class K8sWorkloadAnomaliesWorkloadWithoutReadyPods(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 configuration: Optional['outputs.K8sWorkloadAnomaliesWorkloadWithoutReadyPodsConfiguration'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'K8sWorkloadAnomaliesWorkloadWithoutReadyPodsConfigurationArgs' configuration: Alert if
        """
        pulumi.set(__self__, "enabled", enabled)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.K8sWorkloadAnomaliesWorkloadWithoutReadyPodsConfiguration']:
        """
        Alert if
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class K8sWorkloadAnomaliesWorkloadWithoutReadyPodsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observationPeriodInMinutes":
            suggest = "observation_period_in_minutes"
        elif key == "samplePeriodInMinutes":
            suggest = "sample_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sWorkloadAnomaliesWorkloadWithoutReadyPodsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sWorkloadAnomaliesWorkloadWithoutReadyPodsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sWorkloadAnomaliesWorkloadWithoutReadyPodsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observation_period_in_minutes: int,
                 sample_period_in_minutes: int):
        pulumi.set(__self__, "observation_period_in_minutes", observation_period_in_minutes)
        pulumi.set(__self__, "sample_period_in_minutes", sample_period_in_minutes)

    @property
    @pulumi.getter(name="observationPeriodInMinutes")
    def observation_period_in_minutes(self) -> int:
        return pulumi.get(self, "observation_period_in_minutes")

    @property
    @pulumi.getter(name="samplePeriodInMinutes")
    def sample_period_in_minutes(self) -> int:
        return pulumi.get(self, "sample_period_in_minutes")


@pulumi.output_type
class KubernetesEventPatterns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventPatterns":
            suggest = "event_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesEventPatterns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesEventPatterns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesEventPatterns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_patterns: Sequence['outputs.KubernetesEventPatternsEventPattern']):
        pulumi.set(__self__, "event_patterns", event_patterns)

    @property
    @pulumi.getter(name="eventPatterns")
    def event_patterns(self) -> Sequence['outputs.KubernetesEventPatternsEventPattern']:
        return pulumi.get(self, "event_patterns")


@pulumi.output_type
class KubernetesEventPatternsEventPattern(dict):
    def __init__(__self__, *,
                 active: bool,
                 label: str,
                 pattern: str):
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def active(self) -> bool:
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def pattern(self) -> str:
        return pulumi.get(self, "pattern")


@pulumi.output_type
class LogCustomSourceContext(dict):
    def __init__(__self__, *,
                 contexts: Sequence['outputs.LogCustomSourceContextContext']):
        """
        :param Sequence['LogCustomSourceContextContextArgs'] contexts: Define Custom Log Source only within context if provided
        """
        pulumi.set(__self__, "contexts", contexts)

    @property
    @pulumi.getter
    def contexts(self) -> Sequence['outputs.LogCustomSourceContextContext']:
        """
        Define Custom Log Source only within context if provided
        """
        return pulumi.get(self, "contexts")


@pulumi.output_type
class LogCustomSourceContextContext(dict):
    def __init__(__self__, *,
                 attribute: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class LogCustomSourceCustomLogSource(dict):
    def __init__(__self__, *,
                 type: str,
                 values: Sequence[str]):
        """
        :param str type: Possible Values: `LOG_PATH_PATTERN`, `WINDOWS_EVENT_LOG`
        :param Sequence[str] values: It might be either an absolute path to log(s) with optional wildcards or Windows Event Log name.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `LOG_PATH_PATTERN`, `WINDOWS_EVENT_LOG`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        It might be either an absolute path to log(s) with optional wildcards or Windows Event Log name.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class LogEventsEventTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"
        elif key == "davisMerge":
            suggest = "davis_merge"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogEventsEventTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogEventsEventTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogEventsEventTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 event_type: str,
                 title: str,
                 davis_merge: Optional[bool] = None,
                 metadata: Optional['outputs.LogEventsEventTemplateMetadata'] = None):
        """
        :param str description: The description of the event to trigger.
        :param str event_type: Possible Values: `AVAILABILITY`, `CUSTOM_ALERT`, `CUSTOM_ANNOTATION`, `CUSTOM_CONFIGURATION`, `CUSTOM_DEPLOYMENT`, `ERROR`, `INFO`, `MARKED_FOR_TERMINATION`, `RESOURCE`, `SLOWDOWN`
        :param str title: The title of the event to trigger.
        :param bool davis_merge: Davis AI will try to merge this event into existing problems, otherwise a new problem will always be created.
        :param 'LogEventsEventTemplateMetadataArgs' metadata: Set of additional key-value properties to be attached to the triggered event.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "title", title)
        if davis_merge is not None:
            pulumi.set(__self__, "davis_merge", davis_merge)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the event to trigger.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> str:
        """
        Possible Values: `AVAILABILITY`, `CUSTOM_ALERT`, `CUSTOM_ANNOTATION`, `CUSTOM_CONFIGURATION`, `CUSTOM_DEPLOYMENT`, `ERROR`, `INFO`, `MARKED_FOR_TERMINATION`, `RESOURCE`, `SLOWDOWN`
        """
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The title of the event to trigger.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="davisMerge")
    def davis_merge(self) -> Optional[bool]:
        """
        Davis AI will try to merge this event into existing problems, otherwise a new problem will always be created.
        """
        return pulumi.get(self, "davis_merge")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.LogEventsEventTemplateMetadata']:
        """
        Set of additional key-value properties to be attached to the triggered event.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class LogEventsEventTemplateMetadata(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.LogEventsEventTemplateMetadataItem']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.LogEventsEventTemplateMetadataItem']:
        return pulumi.get(self, "items")


@pulumi.output_type
class LogEventsEventTemplateMetadataItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataKey":
            suggest = "metadata_key"
        elif key == "metadataValue":
            suggest = "metadata_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogEventsEventTemplateMetadataItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogEventsEventTemplateMetadataItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogEventsEventTemplateMetadataItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_key: str,
                 metadata_value: str):
        pulumi.set(__self__, "metadata_key", metadata_key)
        pulumi.set(__self__, "metadata_value", metadata_value)

    @property
    @pulumi.getter(name="metadataKey")
    def metadata_key(self) -> str:
        return pulumi.get(self, "metadata_key")

    @property
    @pulumi.getter(name="metadataValue")
    def metadata_value(self) -> str:
        return pulumi.get(self, "metadata_value")


@pulumi.output_type
class LogProcessingProcessorDefinition(dict):
    def __init__(__self__, *,
                 rule: str):
        pulumi.set(__self__, "rule", rule)

    @property
    @pulumi.getter
    def rule(self) -> str:
        return pulumi.get(self, "rule")


@pulumi.output_type
class LogProcessingRuleTesting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sampleLog":
            suggest = "sample_log"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogProcessingRuleTesting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogProcessingRuleTesting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogProcessingRuleTesting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sample_log: str):
        pulumi.set(__self__, "sample_log", sample_log)

    @property
    @pulumi.getter(name="sampleLog")
    def sample_log(self) -> str:
        return pulumi.get(self, "sample_log")


@pulumi.output_type
class LogSensitiveDataMaskingMasking(dict):
    def __init__(__self__, *,
                 expression: str,
                 type: str,
                 replacement: Optional[str] = None):
        """
        :param str expression: Maximum one capture group is allowed. If none was given, the whole expression will be treated as a capture group.
        :param str type: Possible Values: `SHA1`, `STRING`
        :param str replacement: The string to replace the masked expression with. Irrelevant if `type` is `SHA1`.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "type", type)
        if replacement is not None:
            pulumi.set(__self__, "replacement", replacement)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Maximum one capture group is allowed. If none was given, the whole expression will be treated as a capture group.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `SHA1`, `STRING`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def replacement(self) -> Optional[str]:
        """
        The string to replace the masked expression with. Irrelevant if `type` is `SHA1`.
        """
        return pulumi.get(self, "replacement")


@pulumi.output_type
class LogSensitiveDataMaskingMatchers(dict):
    def __init__(__self__, *,
                 matchers: Sequence['outputs.LogSensitiveDataMaskingMatchersMatcher']):
        pulumi.set(__self__, "matchers", matchers)

    @property
    @pulumi.getter
    def matchers(self) -> Sequence['outputs.LogSensitiveDataMaskingMatchersMatcher']:
        return pulumi.get(self, "matchers")


@pulumi.output_type
class LogSensitiveDataMaskingMatchersMatcher(dict):
    def __init__(__self__, *,
                 attribute: str,
                 operator: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class LogStorageMatchers(dict):
    def __init__(__self__, *,
                 matchers: Sequence['outputs.LogStorageMatchersMatcher']):
        pulumi.set(__self__, "matchers", matchers)

    @property
    @pulumi.getter
    def matchers(self) -> Sequence['outputs.LogStorageMatchersMatcher']:
        return pulumi.get(self, "matchers")


@pulumi.output_type
class LogStorageMatchersMatcher(dict):
    def __init__(__self__, *,
                 attribute: str,
                 operator: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class LogTimestampMatchers(dict):
    def __init__(__self__, *,
                 matchers: Sequence['outputs.LogTimestampMatchersMatcher']):
        pulumi.set(__self__, "matchers", matchers)

    @property
    @pulumi.getter
    def matchers(self) -> Sequence['outputs.LogTimestampMatchersMatcher']:
        return pulumi.get(self, "matchers")


@pulumi.output_type
class LogTimestampMatchersMatcher(dict):
    def __init__(__self__, *,
                 attribute: str,
                 operator: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class MaintenanceFilter(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.MaintenanceFilterFilter']] = None):
        """
        :param Sequence['MaintenanceFilterFilterArgs'] filters: A list of matching rules for dynamic filter formation.  If several rules are set, the OR logic applies
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.MaintenanceFilterFilter']]:
        """
        A list of matching rules for dynamic filter formation.  If several rules are set, the OR logic applies
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class MaintenanceFilterFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityId":
            suggest = "entity_id"
        elif key == "entityTags":
            suggest = "entity_tags"
        elif key == "entityType":
            suggest = "entity_type"
        elif key == "managementZones":
            suggest = "management_zones"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceFilterFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceFilterFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceFilterFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_id: Optional[str] = None,
                 entity_tags: Optional[Sequence[str]] = None,
                 entity_type: Optional[str] = None,
                 management_zones: Optional[Sequence[str]] = None):
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_tags is not None:
            pulumi.set(__self__, "entity_tags", entity_tags)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if management_zones is not None:
            pulumi.set(__self__, "management_zones", management_zones)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[str]:
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter(name="entityTags")
    def entity_tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "entity_tags")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[str]:
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="managementZones")
    def management_zones(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "management_zones")


@pulumi.output_type
class MaintenanceGeneralProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableSynthetic":
            suggest = "disable_synthetic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceGeneralProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceGeneralProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceGeneralProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 suppression: str,
                 type: str,
                 description: Optional[str] = None,
                 disable_synthetic: Optional[bool] = None):
        """
        :param str name: The name of the maintenance window, displayed in the UI
        :param str suppression: The type of suppression of alerting and problem detection during the maintenance
        :param str type: The type of the maintenance: planned or unplanned
        :param str description: A short description of the maintenance purpose
        :param bool disable_synthetic: Suppress execution of synthetic monitors during the maintenance
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "suppression", suppression)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_synthetic is not None:
            pulumi.set(__self__, "disable_synthetic", disable_synthetic)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the maintenance window, displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def suppression(self) -> str:
        """
        The type of suppression of alerting and problem detection during the maintenance
        """
        return pulumi.get(self, "suppression")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the maintenance: planned or unplanned
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A short description of the maintenance purpose
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableSynthetic")
    def disable_synthetic(self) -> Optional[bool]:
        """
        Suppress execution of synthetic monitors during the maintenance
        """
        return pulumi.get(self, "disable_synthetic")


@pulumi.output_type
class MaintenanceSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dailyRecurrence":
            suggest = "daily_recurrence"
        elif key == "monthlyRecurrence":
            suggest = "monthly_recurrence"
        elif key == "onceRecurrence":
            suggest = "once_recurrence"
        elif key == "weeklyRecurrence":
            suggest = "weekly_recurrence"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 daily_recurrence: Optional['outputs.MaintenanceScheduleDailyRecurrence'] = None,
                 monthly_recurrence: Optional['outputs.MaintenanceScheduleMonthlyRecurrence'] = None,
                 once_recurrence: Optional['outputs.MaintenanceScheduleOnceRecurrence'] = None,
                 weekly_recurrence: Optional['outputs.MaintenanceScheduleWeeklyRecurrence'] = None):
        """
        :param str type: The time window of the maintenance window
        :param 'MaintenanceScheduleDailyRecurrenceArgs' daily_recurrence: The configuration for maintenance windows occuring daily
        :param 'MaintenanceScheduleMonthlyRecurrenceArgs' monthly_recurrence: The configuration for maintenance windows occuring monthly
        :param 'MaintenanceScheduleOnceRecurrenceArgs' once_recurrence: The configuration for maintenance windows occuring once
        :param 'MaintenanceScheduleWeeklyRecurrenceArgs' weekly_recurrence: The configuration for maintenance windows occuring weekly
        """
        pulumi.set(__self__, "type", type)
        if daily_recurrence is not None:
            pulumi.set(__self__, "daily_recurrence", daily_recurrence)
        if monthly_recurrence is not None:
            pulumi.set(__self__, "monthly_recurrence", monthly_recurrence)
        if once_recurrence is not None:
            pulumi.set(__self__, "once_recurrence", once_recurrence)
        if weekly_recurrence is not None:
            pulumi.set(__self__, "weekly_recurrence", weekly_recurrence)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The time window of the maintenance window
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="dailyRecurrence")
    def daily_recurrence(self) -> Optional['outputs.MaintenanceScheduleDailyRecurrence']:
        """
        The configuration for maintenance windows occuring daily
        """
        return pulumi.get(self, "daily_recurrence")

    @property
    @pulumi.getter(name="monthlyRecurrence")
    def monthly_recurrence(self) -> Optional['outputs.MaintenanceScheduleMonthlyRecurrence']:
        """
        The configuration for maintenance windows occuring monthly
        """
        return pulumi.get(self, "monthly_recurrence")

    @property
    @pulumi.getter(name="onceRecurrence")
    def once_recurrence(self) -> Optional['outputs.MaintenanceScheduleOnceRecurrence']:
        """
        The configuration for maintenance windows occuring once
        """
        return pulumi.get(self, "once_recurrence")

    @property
    @pulumi.getter(name="weeklyRecurrence")
    def weekly_recurrence(self) -> Optional['outputs.MaintenanceScheduleWeeklyRecurrence']:
        """
        The configuration for maintenance windows occuring weekly
        """
        return pulumi.get(self, "weekly_recurrence")


@pulumi.output_type
class MaintenanceScheduleDailyRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurrenceRange":
            suggest = "recurrence_range"
        elif key == "timeWindow":
            suggest = "time_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleDailyRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleDailyRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleDailyRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recurrence_range: 'outputs.MaintenanceScheduleDailyRecurrenceRecurrenceRange',
                 time_window: 'outputs.MaintenanceScheduleDailyRecurrenceTimeWindow'):
        pulumi.set(__self__, "recurrence_range", recurrence_range)
        pulumi.set(__self__, "time_window", time_window)

    @property
    @pulumi.getter(name="recurrenceRange")
    def recurrence_range(self) -> 'outputs.MaintenanceScheduleDailyRecurrenceRecurrenceRange':
        return pulumi.get(self, "recurrence_range")

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> 'outputs.MaintenanceScheduleDailyRecurrenceTimeWindow':
        return pulumi.get(self, "time_window")


@pulumi.output_type
class MaintenanceScheduleDailyRecurrenceRecurrenceRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleDailyRecurrenceRecurrenceRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleDailyRecurrenceRecurrenceRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleDailyRecurrenceRecurrenceRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: str,
                 start_date: str):
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        return pulumi.get(self, "start_date")


@pulumi.output_type
class MaintenanceScheduleDailyRecurrenceTimeWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleDailyRecurrenceTimeWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleDailyRecurrenceTimeWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleDailyRecurrenceTimeWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 start_time: str,
                 time_zone: str):
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class MaintenanceScheduleMonthlyRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfMonth":
            suggest = "day_of_month"
        elif key == "recurrenceRange":
            suggest = "recurrence_range"
        elif key == "timeWindow":
            suggest = "time_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleMonthlyRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleMonthlyRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleMonthlyRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_month: int,
                 recurrence_range: 'outputs.MaintenanceScheduleMonthlyRecurrenceRecurrenceRange',
                 time_window: 'outputs.MaintenanceScheduleMonthlyRecurrenceTimeWindow'):
        pulumi.set(__self__, "day_of_month", day_of_month)
        pulumi.set(__self__, "recurrence_range", recurrence_range)
        pulumi.set(__self__, "time_window", time_window)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> int:
        return pulumi.get(self, "day_of_month")

    @property
    @pulumi.getter(name="recurrenceRange")
    def recurrence_range(self) -> 'outputs.MaintenanceScheduleMonthlyRecurrenceRecurrenceRange':
        return pulumi.get(self, "recurrence_range")

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> 'outputs.MaintenanceScheduleMonthlyRecurrenceTimeWindow':
        return pulumi.get(self, "time_window")


@pulumi.output_type
class MaintenanceScheduleMonthlyRecurrenceRecurrenceRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleMonthlyRecurrenceRecurrenceRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleMonthlyRecurrenceRecurrenceRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleMonthlyRecurrenceRecurrenceRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: str,
                 start_date: str):
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        return pulumi.get(self, "start_date")


@pulumi.output_type
class MaintenanceScheduleMonthlyRecurrenceTimeWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleMonthlyRecurrenceTimeWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleMonthlyRecurrenceTimeWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleMonthlyRecurrenceTimeWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 start_time: str,
                 time_zone: str):
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class MaintenanceScheduleOnceRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleOnceRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleOnceRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleOnceRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 start_time: str,
                 time_zone: str):
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class MaintenanceScheduleWeeklyRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "recurrenceRange":
            suggest = "recurrence_range"
        elif key == "timeWindow":
            suggest = "time_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleWeeklyRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleWeeklyRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleWeeklyRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: str,
                 recurrence_range: 'outputs.MaintenanceScheduleWeeklyRecurrenceRecurrenceRange',
                 time_window: 'outputs.MaintenanceScheduleWeeklyRecurrenceTimeWindow'):
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "recurrence_range", recurrence_range)
        pulumi.set(__self__, "time_window", time_window)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> str:
        return pulumi.get(self, "day_of_week")

    @property
    @pulumi.getter(name="recurrenceRange")
    def recurrence_range(self) -> 'outputs.MaintenanceScheduleWeeklyRecurrenceRecurrenceRange':
        return pulumi.get(self, "recurrence_range")

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> 'outputs.MaintenanceScheduleWeeklyRecurrenceTimeWindow':
        return pulumi.get(self, "time_window")


@pulumi.output_type
class MaintenanceScheduleWeeklyRecurrenceRecurrenceRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleWeeklyRecurrenceRecurrenceRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleWeeklyRecurrenceRecurrenceRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleWeeklyRecurrenceRecurrenceRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: str,
                 start_date: str):
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        return pulumi.get(self, "start_date")


@pulumi.output_type
class MaintenanceScheduleWeeklyRecurrenceTimeWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleWeeklyRecurrenceTimeWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleWeeklyRecurrenceTimeWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleWeeklyRecurrenceTimeWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 start_time: str,
                 time_zone: str):
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class MaintenanceWindowSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurrenceType":
            suggest = "recurrence_type"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end: str,
                 recurrence_type: str,
                 start: str,
                 zone_id: str,
                 recurrence: Optional['outputs.MaintenanceWindowScheduleRecurrence'] = None,
                 unknowns: Optional[str] = None):
        """
        :param str end: The end date and time of the maintenance window validity period in yyyy-mm-dd HH:mm format
        :param str recurrence_type: The type of the schedule recurrence. Possible values are `DAILY`, `MONTHLY`, `ONCE` and `WEEKLY`
        :param str start: The start date and time of the maintenance window validity period in yyyy-mm-dd HH:mm format
        :param str zone_id: The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
        :param 'MaintenanceWindowScheduleRecurrenceArgs' recurrence: The recurrence of the maintenance window
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "recurrence_type", recurrence_type)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "zone_id", zone_id)
        if recurrence is not None:
            pulumi.set(__self__, "recurrence", recurrence)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def end(self) -> str:
        """
        The end date and time of the maintenance window validity period in yyyy-mm-dd HH:mm format
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> str:
        """
        The type of the schedule recurrence. Possible values are `DAILY`, `MONTHLY`, `ONCE` and `WEEKLY`
        """
        return pulumi.get(self, "recurrence_type")

    @property
    @pulumi.getter
    def start(self) -> str:
        """
        The start date and time of the maintenance window validity period in yyyy-mm-dd HH:mm format
        """
        return pulumi.get(self, "start")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
        """
        return pulumi.get(self, "zone_id")

    @property
    @pulumi.getter
    def recurrence(self) -> Optional['outputs.MaintenanceWindowScheduleRecurrence']:
        """
        The recurrence of the maintenance window
        """
        return pulumi.get(self, "recurrence")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class MaintenanceWindowScheduleRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationMinutes":
            suggest = "duration_minutes"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "dayOfMonth":
            suggest = "day_of_month"
        elif key == "dayOfWeek":
            suggest = "day_of_week"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowScheduleRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowScheduleRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowScheduleRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_minutes: int,
                 start_time: str,
                 day_of_month: Optional[int] = None,
                 day_of_week: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "duration_minutes", duration_minutes)
        pulumi.set(__self__, "start_time", start_time)
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="durationMinutes")
    def duration_minutes(self) -> int:
        return pulumi.get(self, "duration_minutes")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[int]:
        return pulumi.get(self, "day_of_month")

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[str]:
        return pulumi.get(self, "day_of_week")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class MaintenanceWindowScope(dict):
    def __init__(__self__, *,
                 entities: Optional[Sequence[str]] = None,
                 matches: Optional[Sequence['outputs.MaintenanceWindowScopeMatch']] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence[str] entities: A list of Dynatrace entities (for example, hosts or services) to be included in the scope.  Allowed values are Dynatrace entity IDs
        :param Sequence['MaintenanceWindowScopeMatchArgs'] matches: A list of matching rules for dynamic scope formation.  If several rules are set, the OR logic applies
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence[str]]:
        """
        A list of Dynatrace entities (for example, hosts or services) to be included in the scope.  Allowed values are Dynatrace entity IDs
        """
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.MaintenanceWindowScopeMatch']]:
        """
        A list of matching rules for dynamic scope formation.  If several rules are set, the OR logic applies
        """
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class MaintenanceWindowScopeMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mzId":
            suggest = "mz_id"
        elif key == "tagCombination":
            suggest = "tag_combination"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowScopeMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowScopeMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowScopeMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mz_id: Optional[str] = None,
                 tag_combination: Optional[str] = None,
                 tags: Optional[Sequence['outputs.MaintenanceWindowScopeMatchTag']] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str type: The type of the maintenance: planned or unplanned
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if mz_id is not None:
            pulumi.set(__self__, "mz_id", mz_id)
        if tag_combination is not None:
            pulumi.set(__self__, "tag_combination", tag_combination)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="mzId")
    def mz_id(self) -> Optional[str]:
        return pulumi.get(self, "mz_id")

    @property
    @pulumi.getter(name="tagCombination")
    def tag_combination(self) -> Optional[str]:
        return pulumi.get(self, "tag_combination")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.MaintenanceWindowScopeMatchTag']]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the maintenance: planned or unplanned
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class MaintenanceWindowScopeMatchTag(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneDimensionalRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appliesTo":
            suggest = "applies_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneDimensionalRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneDimensionalRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneDimensionalRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applies_to: str,
                 conditions: Optional[Sequence['outputs.ManagementZoneDimensionalRuleCondition']] = None,
                 enabled: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "applies_to", applies_to)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="appliesTo")
    def applies_to(self) -> str:
        return pulumi.get(self, "applies_to")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ManagementZoneDimensionalRuleCondition']]:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneDimensionalRuleCondition(dict):
    def __init__(__self__, *,
                 key: str,
                 match: str,
                 type: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def match(self) -> str:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneEntitySelectorBasedRule(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 selector: Optional[str] = None,
                 unknowns: Optional[str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propagationTypes":
            suggest = "propagation_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.ManagementZoneRuleCondition']] = None,
                 enabled: Optional[bool] = None,
                 propagation_types: Optional[Sequence[str]] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if propagation_types is not None:
            pulumi.set(__self__, "propagation_types", propagation_types)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ManagementZoneRuleCondition']]:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propagationTypes")
    def propagation_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "propagation_types")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationTypeComparisons":
            suggest = "application_type_comparisons"
        elif key == "applicationTypes":
            suggest = "application_types"
        elif key == "azureComputeModeComparisons":
            suggest = "azure_compute_mode_comparisons"
        elif key == "azureComputeModes":
            suggest = "azure_compute_modes"
        elif key == "azureSkuComparisions":
            suggest = "azure_sku_comparisions"
        elif key == "azureSkus":
            suggest = "azure_skus"
        elif key == "baseComparisonBasics":
            suggest = "base_comparison_basics"
        elif key == "baseConditionKeys":
            suggest = "base_condition_keys"
        elif key == "bitnessComparisions":
            suggest = "bitness_comparisions"
        elif key == "cloudTypeComparisons":
            suggest = "cloud_type_comparisons"
        elif key == "cloudTypes":
            suggest = "cloud_types"
        elif key == "customApplicationTypeComparisons":
            suggest = "custom_application_type_comparisons"
        elif key == "customApplicationTypes":
            suggest = "custom_application_types"
        elif key == "customHostMetadataConditionKeys":
            suggest = "custom_host_metadata_condition_keys"
        elif key == "customHostMetadatas":
            suggest = "custom_host_metadatas"
        elif key == "customProcessMetadataConditionKeys":
            suggest = "custom_process_metadata_condition_keys"
        elif key == "customProcessMetadatas":
            suggest = "custom_process_metadatas"
        elif key == "databaseTopologies":
            suggest = "database_topologies"
        elif key == "databaseTopologyComparisons":
            suggest = "database_topology_comparisons"
        elif key == "dcrumDecoderComparisons":
            suggest = "dcrum_decoder_comparisons"
        elif key == "dcrumDecoders":
            suggest = "dcrum_decoders"
        elif key == "entityIdComparisons":
            suggest = "entity_id_comparisons"
        elif key == "hostTeches":
            suggest = "host_teches"
        elif key == "hypervisorTypeComparisions":
            suggest = "hypervisor_type_comparisions"
        elif key == "indexedNameComparisons":
            suggest = "indexed_name_comparisons"
        elif key == "indexedNames":
            suggest = "indexed_names"
        elif key == "indexedStringComparisons":
            suggest = "indexed_string_comparisons"
        elif key == "indexedStrings":
            suggest = "indexed_strings"
        elif key == "indexedTagComparisons":
            suggest = "indexed_tag_comparisons"
        elif key == "indexedTags":
            suggest = "indexed_tags"
        elif key == "integerComparisons":
            suggest = "integer_comparisons"
        elif key == "ipaddressComparisons":
            suggest = "ipaddress_comparisons"
        elif key == "mobilePlatformComparisons":
            suggest = "mobile_platform_comparisons"
        elif key == "mobilePlatforms":
            suggest = "mobile_platforms"
        elif key == "osArches":
            suggest = "os_arches"
        elif key == "osTypes":
            suggest = "os_types"
        elif key == "osarchitectureComparisons":
            suggest = "osarchitecture_comparisons"
        elif key == "ostypeComparisons":
            suggest = "ostype_comparisons"
        elif key == "paasTypeComparisons":
            suggest = "paas_type_comparisons"
        elif key == "paasTypes":
            suggest = "paas_types"
        elif key == "processMetadataConditionKeys":
            suggest = "process_metadata_condition_keys"
        elif key == "processMetadatas":
            suggest = "process_metadatas"
        elif key == "serviceTopologies":
            suggest = "service_topologies"
        elif key == "serviceTopologyComparisons":
            suggest = "service_topology_comparisons"
        elif key == "serviceTypeComparisons":
            suggest = "service_type_comparisons"
        elif key == "serviceTypes":
            suggest = "service_types"
        elif key == "simpleHostTechComparisons":
            suggest = "simple_host_tech_comparisons"
        elif key == "simpleTechComparisons":
            suggest = "simple_tech_comparisons"
        elif key == "stringComparisons":
            suggest = "string_comparisons"
        elif key == "stringConditionKeys":
            suggest = "string_condition_keys"
        elif key == "stringKeys":
            suggest = "string_keys"
        elif key == "syntheticEngineTypeComparisons":
            suggest = "synthetic_engine_type_comparisons"
        elif key == "syntheticEngines":
            suggest = "synthetic_engines"
        elif key == "tagComparisons":
            suggest = "tag_comparisons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_type_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionApplicationTypeComparison']] = None,
                 application_types: Optional[Sequence['outputs.ManagementZoneRuleConditionApplicationType']] = None,
                 azure_compute_mode_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionAzureComputeModeComparison']] = None,
                 azure_compute_modes: Optional[Sequence['outputs.ManagementZoneRuleConditionAzureComputeMode']] = None,
                 azure_sku_comparisions: Optional[Sequence['outputs.ManagementZoneRuleConditionAzureSkuComparision']] = None,
                 azure_skus: Optional[Sequence['outputs.ManagementZoneRuleConditionAzureSkus']] = None,
                 base_comparison_basics: Optional[Sequence['outputs.ManagementZoneRuleConditionBaseComparisonBasic']] = None,
                 base_condition_keys: Optional[Sequence['outputs.ManagementZoneRuleConditionBaseConditionKey']] = None,
                 bitness_comparisions: Optional[Sequence['outputs.ManagementZoneRuleConditionBitnessComparision']] = None,
                 bitnesses: Optional[Sequence['outputs.ManagementZoneRuleConditionBitness']] = None,
                 cloud_type_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionCloudTypeComparison']] = None,
                 cloud_types: Optional[Sequence['outputs.ManagementZoneRuleConditionCloudType']] = None,
                 comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionComparison']] = None,
                 custom_application_type_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionCustomApplicationTypeComparison']] = None,
                 custom_application_types: Optional[Sequence['outputs.ManagementZoneRuleConditionCustomApplicationType']] = None,
                 custom_host_metadata_condition_keys: Optional[Sequence['outputs.ManagementZoneRuleConditionCustomHostMetadataConditionKey']] = None,
                 custom_host_metadatas: Optional[Sequence['outputs.ManagementZoneRuleConditionCustomHostMetadata']] = None,
                 custom_process_metadata_condition_keys: Optional[Sequence['outputs.ManagementZoneRuleConditionCustomProcessMetadataConditionKey']] = None,
                 custom_process_metadatas: Optional[Sequence['outputs.ManagementZoneRuleConditionCustomProcessMetadata']] = None,
                 database_topologies: Optional[Sequence['outputs.ManagementZoneRuleConditionDatabaseTopology']] = None,
                 database_topology_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionDatabaseTopologyComparison']] = None,
                 dcrum_decoder_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionDcrumDecoderComparison']] = None,
                 dcrum_decoders: Optional[Sequence['outputs.ManagementZoneRuleConditionDcrumDecoder']] = None,
                 entities: Optional[Sequence['outputs.ManagementZoneRuleConditionEntity']] = None,
                 entity_id_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionEntityIdComparison']] = None,
                 host_teches: Optional[Sequence['outputs.ManagementZoneRuleConditionHostTech']] = None,
                 hypervisor_type_comparisions: Optional[Sequence['outputs.ManagementZoneRuleConditionHypervisorTypeComparision']] = None,
                 hypervisors: Optional[Sequence['outputs.ManagementZoneRuleConditionHypervisor']] = None,
                 indexed_name_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedNameComparison']] = None,
                 indexed_names: Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedName']] = None,
                 indexed_string_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedStringComparison']] = None,
                 indexed_strings: Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedString']] = None,
                 indexed_tag_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedTagComparison']] = None,
                 indexed_tags: Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedTag']] = None,
                 integer_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionIntegerComparison']] = None,
                 integers: Optional[Sequence['outputs.ManagementZoneRuleConditionInteger']] = None,
                 ipaddress_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionIpaddressComparison']] = None,
                 ipaddresses: Optional[Sequence['outputs.ManagementZoneRuleConditionIpaddress']] = None,
                 keys: Optional[Sequence['outputs.ManagementZoneRuleConditionKey']] = None,
                 mobile_platform_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionMobilePlatformComparison']] = None,
                 mobile_platforms: Optional[Sequence['outputs.ManagementZoneRuleConditionMobilePlatform']] = None,
                 os_arches: Optional[Sequence['outputs.ManagementZoneRuleConditionOsArch']] = None,
                 os_types: Optional[Sequence['outputs.ManagementZoneRuleConditionOsType']] = None,
                 osarchitecture_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionOsarchitectureComparison']] = None,
                 ostype_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionOstypeComparison']] = None,
                 paas_type_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionPaasTypeComparison']] = None,
                 paas_types: Optional[Sequence['outputs.ManagementZoneRuleConditionPaasType']] = None,
                 process_metadata_condition_keys: Optional[Sequence['outputs.ManagementZoneRuleConditionProcessMetadataConditionKey']] = None,
                 process_metadatas: Optional[Sequence['outputs.ManagementZoneRuleConditionProcessMetadata']] = None,
                 service_topologies: Optional[Sequence['outputs.ManagementZoneRuleConditionServiceTopology']] = None,
                 service_topology_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionServiceTopologyComparison']] = None,
                 service_type_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionServiceTypeComparison']] = None,
                 service_types: Optional[Sequence['outputs.ManagementZoneRuleConditionServiceType']] = None,
                 simple_host_tech_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionSimpleHostTechComparison']] = None,
                 simple_tech_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionSimpleTechComparison']] = None,
                 string_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionStringComparison']] = None,
                 string_condition_keys: Optional[Sequence['outputs.ManagementZoneRuleConditionStringConditionKey']] = None,
                 string_keys: Optional[Sequence['outputs.ManagementZoneRuleConditionStringKey']] = None,
                 strings: Optional[Sequence['outputs.ManagementZoneRuleConditionString']] = None,
                 synthetic_engine_type_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionSyntheticEngineTypeComparison']] = None,
                 synthetic_engines: Optional[Sequence['outputs.ManagementZoneRuleConditionSyntheticEngine']] = None,
                 tag_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionTagComparison']] = None,
                 tags: Optional[Sequence['outputs.ManagementZoneRuleConditionTag']] = None,
                 teches: Optional[Sequence['outputs.ManagementZoneRuleConditionTech']] = None,
                 unknowns: Optional[str] = None):
        if application_type_comparisons is not None:
            pulumi.set(__self__, "application_type_comparisons", application_type_comparisons)
        if application_types is not None:
            pulumi.set(__self__, "application_types", application_types)
        if azure_compute_mode_comparisons is not None:
            pulumi.set(__self__, "azure_compute_mode_comparisons", azure_compute_mode_comparisons)
        if azure_compute_modes is not None:
            pulumi.set(__self__, "azure_compute_modes", azure_compute_modes)
        if azure_sku_comparisions is not None:
            pulumi.set(__self__, "azure_sku_comparisions", azure_sku_comparisions)
        if azure_skus is not None:
            pulumi.set(__self__, "azure_skus", azure_skus)
        if base_comparison_basics is not None:
            pulumi.set(__self__, "base_comparison_basics", base_comparison_basics)
        if base_condition_keys is not None:
            pulumi.set(__self__, "base_condition_keys", base_condition_keys)
        if bitness_comparisions is not None:
            pulumi.set(__self__, "bitness_comparisions", bitness_comparisions)
        if bitnesses is not None:
            pulumi.set(__self__, "bitnesses", bitnesses)
        if cloud_type_comparisons is not None:
            pulumi.set(__self__, "cloud_type_comparisons", cloud_type_comparisons)
        if cloud_types is not None:
            pulumi.set(__self__, "cloud_types", cloud_types)
        if comparisons is not None:
            pulumi.set(__self__, "comparisons", comparisons)
        if custom_application_type_comparisons is not None:
            pulumi.set(__self__, "custom_application_type_comparisons", custom_application_type_comparisons)
        if custom_application_types is not None:
            pulumi.set(__self__, "custom_application_types", custom_application_types)
        if custom_host_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_host_metadata_condition_keys", custom_host_metadata_condition_keys)
        if custom_host_metadatas is not None:
            pulumi.set(__self__, "custom_host_metadatas", custom_host_metadatas)
        if custom_process_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_process_metadata_condition_keys", custom_process_metadata_condition_keys)
        if custom_process_metadatas is not None:
            pulumi.set(__self__, "custom_process_metadatas", custom_process_metadatas)
        if database_topologies is not None:
            pulumi.set(__self__, "database_topologies", database_topologies)
        if database_topology_comparisons is not None:
            pulumi.set(__self__, "database_topology_comparisons", database_topology_comparisons)
        if dcrum_decoder_comparisons is not None:
            pulumi.set(__self__, "dcrum_decoder_comparisons", dcrum_decoder_comparisons)
        if dcrum_decoders is not None:
            pulumi.set(__self__, "dcrum_decoders", dcrum_decoders)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if entity_id_comparisons is not None:
            pulumi.set(__self__, "entity_id_comparisons", entity_id_comparisons)
        if host_teches is not None:
            pulumi.set(__self__, "host_teches", host_teches)
        if hypervisor_type_comparisions is not None:
            pulumi.set(__self__, "hypervisor_type_comparisions", hypervisor_type_comparisions)
        if hypervisors is not None:
            pulumi.set(__self__, "hypervisors", hypervisors)
        if indexed_name_comparisons is not None:
            pulumi.set(__self__, "indexed_name_comparisons", indexed_name_comparisons)
        if indexed_names is not None:
            pulumi.set(__self__, "indexed_names", indexed_names)
        if indexed_string_comparisons is not None:
            pulumi.set(__self__, "indexed_string_comparisons", indexed_string_comparisons)
        if indexed_strings is not None:
            pulumi.set(__self__, "indexed_strings", indexed_strings)
        if indexed_tag_comparisons is not None:
            pulumi.set(__self__, "indexed_tag_comparisons", indexed_tag_comparisons)
        if indexed_tags is not None:
            pulumi.set(__self__, "indexed_tags", indexed_tags)
        if integer_comparisons is not None:
            pulumi.set(__self__, "integer_comparisons", integer_comparisons)
        if integers is not None:
            pulumi.set(__self__, "integers", integers)
        if ipaddress_comparisons is not None:
            pulumi.set(__self__, "ipaddress_comparisons", ipaddress_comparisons)
        if ipaddresses is not None:
            pulumi.set(__self__, "ipaddresses", ipaddresses)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if mobile_platform_comparisons is not None:
            pulumi.set(__self__, "mobile_platform_comparisons", mobile_platform_comparisons)
        if mobile_platforms is not None:
            pulumi.set(__self__, "mobile_platforms", mobile_platforms)
        if os_arches is not None:
            pulumi.set(__self__, "os_arches", os_arches)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if osarchitecture_comparisons is not None:
            pulumi.set(__self__, "osarchitecture_comparisons", osarchitecture_comparisons)
        if ostype_comparisons is not None:
            pulumi.set(__self__, "ostype_comparisons", ostype_comparisons)
        if paas_type_comparisons is not None:
            pulumi.set(__self__, "paas_type_comparisons", paas_type_comparisons)
        if paas_types is not None:
            pulumi.set(__self__, "paas_types", paas_types)
        if process_metadata_condition_keys is not None:
            pulumi.set(__self__, "process_metadata_condition_keys", process_metadata_condition_keys)
        if process_metadatas is not None:
            pulumi.set(__self__, "process_metadatas", process_metadatas)
        if service_topologies is not None:
            pulumi.set(__self__, "service_topologies", service_topologies)
        if service_topology_comparisons is not None:
            pulumi.set(__self__, "service_topology_comparisons", service_topology_comparisons)
        if service_type_comparisons is not None:
            pulumi.set(__self__, "service_type_comparisons", service_type_comparisons)
        if service_types is not None:
            pulumi.set(__self__, "service_types", service_types)
        if simple_host_tech_comparisons is not None:
            pulumi.set(__self__, "simple_host_tech_comparisons", simple_host_tech_comparisons)
        if simple_tech_comparisons is not None:
            pulumi.set(__self__, "simple_tech_comparisons", simple_tech_comparisons)
        if string_comparisons is not None:
            pulumi.set(__self__, "string_comparisons", string_comparisons)
        if string_condition_keys is not None:
            pulumi.set(__self__, "string_condition_keys", string_condition_keys)
        if string_keys is not None:
            pulumi.set(__self__, "string_keys", string_keys)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)
        if synthetic_engine_type_comparisons is not None:
            pulumi.set(__self__, "synthetic_engine_type_comparisons", synthetic_engine_type_comparisons)
        if synthetic_engines is not None:
            pulumi.set(__self__, "synthetic_engines", synthetic_engines)
        if tag_comparisons is not None:
            pulumi.set(__self__, "tag_comparisons", tag_comparisons)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if teches is not None:
            pulumi.set(__self__, "teches", teches)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="applicationTypeComparisons")
    def application_type_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionApplicationTypeComparison']]:
        return pulumi.get(self, "application_type_comparisons")

    @property
    @pulumi.getter(name="applicationTypes")
    def application_types(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionApplicationType']]:
        return pulumi.get(self, "application_types")

    @property
    @pulumi.getter(name="azureComputeModeComparisons")
    def azure_compute_mode_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionAzureComputeModeComparison']]:
        return pulumi.get(self, "azure_compute_mode_comparisons")

    @property
    @pulumi.getter(name="azureComputeModes")
    def azure_compute_modes(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionAzureComputeMode']]:
        return pulumi.get(self, "azure_compute_modes")

    @property
    @pulumi.getter(name="azureSkuComparisions")
    def azure_sku_comparisions(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionAzureSkuComparision']]:
        return pulumi.get(self, "azure_sku_comparisions")

    @property
    @pulumi.getter(name="azureSkus")
    def azure_skus(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionAzureSkus']]:
        return pulumi.get(self, "azure_skus")

    @property
    @pulumi.getter(name="baseComparisonBasics")
    def base_comparison_basics(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionBaseComparisonBasic']]:
        return pulumi.get(self, "base_comparison_basics")

    @property
    @pulumi.getter(name="baseConditionKeys")
    def base_condition_keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionBaseConditionKey']]:
        return pulumi.get(self, "base_condition_keys")

    @property
    @pulumi.getter(name="bitnessComparisions")
    def bitness_comparisions(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionBitnessComparision']]:
        return pulumi.get(self, "bitness_comparisions")

    @property
    @pulumi.getter
    def bitnesses(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionBitness']]:
        return pulumi.get(self, "bitnesses")

    @property
    @pulumi.getter(name="cloudTypeComparisons")
    def cloud_type_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCloudTypeComparison']]:
        return pulumi.get(self, "cloud_type_comparisons")

    @property
    @pulumi.getter(name="cloudTypes")
    def cloud_types(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCloudType']]:
        return pulumi.get(self, "cloud_types")

    @property
    @pulumi.getter
    def comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionComparison']]:
        return pulumi.get(self, "comparisons")

    @property
    @pulumi.getter(name="customApplicationTypeComparisons")
    def custom_application_type_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCustomApplicationTypeComparison']]:
        return pulumi.get(self, "custom_application_type_comparisons")

    @property
    @pulumi.getter(name="customApplicationTypes")
    def custom_application_types(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCustomApplicationType']]:
        return pulumi.get(self, "custom_application_types")

    @property
    @pulumi.getter(name="customHostMetadataConditionKeys")
    def custom_host_metadata_condition_keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCustomHostMetadataConditionKey']]:
        return pulumi.get(self, "custom_host_metadata_condition_keys")

    @property
    @pulumi.getter(name="customHostMetadatas")
    def custom_host_metadatas(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCustomHostMetadata']]:
        return pulumi.get(self, "custom_host_metadatas")

    @property
    @pulumi.getter(name="customProcessMetadataConditionKeys")
    def custom_process_metadata_condition_keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCustomProcessMetadataConditionKey']]:
        return pulumi.get(self, "custom_process_metadata_condition_keys")

    @property
    @pulumi.getter(name="customProcessMetadatas")
    def custom_process_metadatas(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCustomProcessMetadata']]:
        return pulumi.get(self, "custom_process_metadatas")

    @property
    @pulumi.getter(name="databaseTopologies")
    def database_topologies(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionDatabaseTopology']]:
        return pulumi.get(self, "database_topologies")

    @property
    @pulumi.getter(name="databaseTopologyComparisons")
    def database_topology_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionDatabaseTopologyComparison']]:
        return pulumi.get(self, "database_topology_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoderComparisons")
    def dcrum_decoder_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionDcrumDecoderComparison']]:
        return pulumi.get(self, "dcrum_decoder_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoders")
    def dcrum_decoders(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionDcrumDecoder']]:
        return pulumi.get(self, "dcrum_decoders")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionEntity']]:
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="entityIdComparisons")
    def entity_id_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionEntityIdComparison']]:
        return pulumi.get(self, "entity_id_comparisons")

    @property
    @pulumi.getter(name="hostTeches")
    def host_teches(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionHostTech']]:
        return pulumi.get(self, "host_teches")

    @property
    @pulumi.getter(name="hypervisorTypeComparisions")
    def hypervisor_type_comparisions(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionHypervisorTypeComparision']]:
        return pulumi.get(self, "hypervisor_type_comparisions")

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionHypervisor']]:
        return pulumi.get(self, "hypervisors")

    @property
    @pulumi.getter(name="indexedNameComparisons")
    def indexed_name_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedNameComparison']]:
        return pulumi.get(self, "indexed_name_comparisons")

    @property
    @pulumi.getter(name="indexedNames")
    def indexed_names(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedName']]:
        return pulumi.get(self, "indexed_names")

    @property
    @pulumi.getter(name="indexedStringComparisons")
    def indexed_string_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedStringComparison']]:
        return pulumi.get(self, "indexed_string_comparisons")

    @property
    @pulumi.getter(name="indexedStrings")
    def indexed_strings(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedString']]:
        return pulumi.get(self, "indexed_strings")

    @property
    @pulumi.getter(name="indexedTagComparisons")
    def indexed_tag_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedTagComparison']]:
        return pulumi.get(self, "indexed_tag_comparisons")

    @property
    @pulumi.getter(name="indexedTags")
    def indexed_tags(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedTag']]:
        return pulumi.get(self, "indexed_tags")

    @property
    @pulumi.getter(name="integerComparisons")
    def integer_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIntegerComparison']]:
        return pulumi.get(self, "integer_comparisons")

    @property
    @pulumi.getter
    def integers(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionInteger']]:
        return pulumi.get(self, "integers")

    @property
    @pulumi.getter(name="ipaddressComparisons")
    def ipaddress_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIpaddressComparison']]:
        return pulumi.get(self, "ipaddress_comparisons")

    @property
    @pulumi.getter
    def ipaddresses(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIpaddress']]:
        return pulumi.get(self, "ipaddresses")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionKey']]:
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter(name="mobilePlatformComparisons")
    def mobile_platform_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionMobilePlatformComparison']]:
        return pulumi.get(self, "mobile_platform_comparisons")

    @property
    @pulumi.getter(name="mobilePlatforms")
    def mobile_platforms(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionMobilePlatform']]:
        return pulumi.get(self, "mobile_platforms")

    @property
    @pulumi.getter(name="osArches")
    def os_arches(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionOsArch']]:
        return pulumi.get(self, "os_arches")

    @property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionOsType']]:
        return pulumi.get(self, "os_types")

    @property
    @pulumi.getter(name="osarchitectureComparisons")
    def osarchitecture_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionOsarchitectureComparison']]:
        return pulumi.get(self, "osarchitecture_comparisons")

    @property
    @pulumi.getter(name="ostypeComparisons")
    def ostype_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionOstypeComparison']]:
        return pulumi.get(self, "ostype_comparisons")

    @property
    @pulumi.getter(name="paasTypeComparisons")
    def paas_type_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionPaasTypeComparison']]:
        return pulumi.get(self, "paas_type_comparisons")

    @property
    @pulumi.getter(name="paasTypes")
    def paas_types(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionPaasType']]:
        return pulumi.get(self, "paas_types")

    @property
    @pulumi.getter(name="processMetadataConditionKeys")
    def process_metadata_condition_keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionProcessMetadataConditionKey']]:
        return pulumi.get(self, "process_metadata_condition_keys")

    @property
    @pulumi.getter(name="processMetadatas")
    def process_metadatas(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionProcessMetadata']]:
        return pulumi.get(self, "process_metadatas")

    @property
    @pulumi.getter(name="serviceTopologies")
    def service_topologies(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionServiceTopology']]:
        return pulumi.get(self, "service_topologies")

    @property
    @pulumi.getter(name="serviceTopologyComparisons")
    def service_topology_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionServiceTopologyComparison']]:
        return pulumi.get(self, "service_topology_comparisons")

    @property
    @pulumi.getter(name="serviceTypeComparisons")
    def service_type_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionServiceTypeComparison']]:
        return pulumi.get(self, "service_type_comparisons")

    @property
    @pulumi.getter(name="serviceTypes")
    def service_types(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionServiceType']]:
        return pulumi.get(self, "service_types")

    @property
    @pulumi.getter(name="simpleHostTechComparisons")
    def simple_host_tech_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionSimpleHostTechComparison']]:
        return pulumi.get(self, "simple_host_tech_comparisons")

    @property
    @pulumi.getter(name="simpleTechComparisons")
    def simple_tech_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionSimpleTechComparison']]:
        return pulumi.get(self, "simple_tech_comparisons")

    @property
    @pulumi.getter(name="stringComparisons")
    def string_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionStringComparison']]:
        return pulumi.get(self, "string_comparisons")

    @property
    @pulumi.getter(name="stringConditionKeys")
    def string_condition_keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionStringConditionKey']]:
        return pulumi.get(self, "string_condition_keys")

    @property
    @pulumi.getter(name="stringKeys")
    def string_keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionStringKey']]:
        return pulumi.get(self, "string_keys")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionString']]:
        return pulumi.get(self, "strings")

    @property
    @pulumi.getter(name="syntheticEngineTypeComparisons")
    def synthetic_engine_type_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionSyntheticEngineTypeComparison']]:
        return pulumi.get(self, "synthetic_engine_type_comparisons")

    @property
    @pulumi.getter(name="syntheticEngines")
    def synthetic_engines(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionSyntheticEngine']]:
        return pulumi.get(self, "synthetic_engines")

    @property
    @pulumi.getter(name="tagComparisons")
    def tag_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionTagComparison']]:
        return pulumi.get(self, "tag_comparisons")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionTag']]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def teches(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionTech']]:
        return pulumi.get(self, "teches")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionAzureComputeMode(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionAzureComputeModeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionAzureSkuComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionAzureSkus(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionBaseComparisonBasic(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionBaseConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionBitness(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionBitnessComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionCloudType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionCloudTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionComparison(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionCustomApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionCustomHostMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionCustomHostMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionCustomHostMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionCustomHostMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ManagementZoneRuleConditionCustomHostMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ManagementZoneRuleConditionCustomHostMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomHostMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionCustomHostMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ManagementZoneRuleConditionCustomHostMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ManagementZoneRuleConditionCustomHostMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomHostMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomHostMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionCustomProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionCustomProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionCustomProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ManagementZoneRuleConditionCustomProcessMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ManagementZoneRuleConditionCustomProcessMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionCustomProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ManagementZoneRuleConditionCustomProcessMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ManagementZoneRuleConditionCustomProcessMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomProcessMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomProcessMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionDatabaseTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionDatabaseTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionDcrumDecoder(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionDcrumDecoderComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionEntity(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionEntityIdComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionHostTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionHostTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionHostTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionHostTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionHostTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionHostTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionHostTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ManagementZoneRuleConditionHypervisor(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionHypervisorTypeComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedName(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedNameComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedString(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedStringComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionIndexedTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionIndexedTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionIndexedTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionIndexedTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionInteger(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIntegerComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIpaddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionIpaddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionIpaddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionIpaddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIpaddressComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionIpaddressComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionIpaddressComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionIpaddressComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionMobilePlatform(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionMobilePlatformComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionOsArch(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionOsType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionOsarchitectureComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionOstypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionPaasType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionPaasTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionServiceTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionServiceTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionServiceType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionServiceTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionSimpleHostTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionSimpleHostTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionSimpleHostTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionSimpleHostTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionSimpleHostTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ManagementZoneRuleConditionSimpleTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionSimpleTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionSimpleTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionSimpleTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionSimpleTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionSimpleTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionSimpleTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ManagementZoneRuleConditionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionStringComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionStringComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionStringComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionStringComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionStringConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionStringConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionStringConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionStringConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionStringKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionStringKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionStringKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionStringKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionSyntheticEngine(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionSyntheticEngineTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ManagementZoneV2Rules(dict):
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.ManagementZoneV2RulesRule']] = None):
        """
        :param Sequence['ManagementZoneV2RulesRuleArgs'] rules: A management zone rule
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.ManagementZoneV2RulesRule']]:
        """
        A management zone rule
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ManagementZoneV2RulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeRule":
            suggest = "attribute_rule"
        elif key == "dimensionRule":
            suggest = "dimension_rule"
        elif key == "entitySelector":
            suggest = "entity_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneV2RulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneV2RulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneV2RulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 type: str,
                 attribute_rule: Optional['outputs.ManagementZoneV2RulesRuleAttributeRule'] = None,
                 dimension_rule: Optional['outputs.ManagementZoneV2RulesRuleDimensionRule'] = None,
                 entity_selector: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "type", type)
        if attribute_rule is not None:
            pulumi.set(__self__, "attribute_rule", attribute_rule)
        if dimension_rule is not None:
            pulumi.set(__self__, "dimension_rule", dimension_rule)
        if entity_selector is not None:
            pulumi.set(__self__, "entity_selector", entity_selector)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="attributeRule")
    def attribute_rule(self) -> Optional['outputs.ManagementZoneV2RulesRuleAttributeRule']:
        return pulumi.get(self, "attribute_rule")

    @property
    @pulumi.getter(name="dimensionRule")
    def dimension_rule(self) -> Optional['outputs.ManagementZoneV2RulesRuleDimensionRule']:
        return pulumi.get(self, "dimension_rule")

    @property
    @pulumi.getter(name="entitySelector")
    def entity_selector(self) -> Optional[str]:
        return pulumi.get(self, "entity_selector")


@pulumi.output_type
class ManagementZoneV2RulesRuleAttributeRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeConditions":
            suggest = "attribute_conditions"
        elif key == "entityType":
            suggest = "entity_type"
        elif key == "azureToPgpropagation":
            suggest = "azure_to_pgpropagation"
        elif key == "azureToServicePropagation":
            suggest = "azure_to_service_propagation"
        elif key == "customDeviceGroupToCustomDevicePropagation":
            suggest = "custom_device_group_to_custom_device_propagation"
        elif key == "hostToPgpropagation":
            suggest = "host_to_pgpropagation"
        elif key == "pgToHostPropagation":
            suggest = "pg_to_host_propagation"
        elif key == "pgToServicePropagation":
            suggest = "pg_to_service_propagation"
        elif key == "serviceToHostPropagation":
            suggest = "service_to_host_propagation"
        elif key == "serviceToPgpropagation":
            suggest = "service_to_pgpropagation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneV2RulesRuleAttributeRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneV2RulesRuleAttributeRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneV2RulesRuleAttributeRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_conditions: 'outputs.ManagementZoneV2RulesRuleAttributeRuleAttributeConditions',
                 entity_type: str,
                 azure_to_pgpropagation: Optional[bool] = None,
                 azure_to_service_propagation: Optional[bool] = None,
                 custom_device_group_to_custom_device_propagation: Optional[bool] = None,
                 host_to_pgpropagation: Optional[bool] = None,
                 pg_to_host_propagation: Optional[bool] = None,
                 pg_to_service_propagation: Optional[bool] = None,
                 service_to_host_propagation: Optional[bool] = None,
                 service_to_pgpropagation: Optional[bool] = None):
        pulumi.set(__self__, "attribute_conditions", attribute_conditions)
        pulumi.set(__self__, "entity_type", entity_type)
        if azure_to_pgpropagation is not None:
            pulumi.set(__self__, "azure_to_pgpropagation", azure_to_pgpropagation)
        if azure_to_service_propagation is not None:
            pulumi.set(__self__, "azure_to_service_propagation", azure_to_service_propagation)
        if custom_device_group_to_custom_device_propagation is not None:
            pulumi.set(__self__, "custom_device_group_to_custom_device_propagation", custom_device_group_to_custom_device_propagation)
        if host_to_pgpropagation is not None:
            pulumi.set(__self__, "host_to_pgpropagation", host_to_pgpropagation)
        if pg_to_host_propagation is not None:
            pulumi.set(__self__, "pg_to_host_propagation", pg_to_host_propagation)
        if pg_to_service_propagation is not None:
            pulumi.set(__self__, "pg_to_service_propagation", pg_to_service_propagation)
        if service_to_host_propagation is not None:
            pulumi.set(__self__, "service_to_host_propagation", service_to_host_propagation)
        if service_to_pgpropagation is not None:
            pulumi.set(__self__, "service_to_pgpropagation", service_to_pgpropagation)

    @property
    @pulumi.getter(name="attributeConditions")
    def attribute_conditions(self) -> 'outputs.ManagementZoneV2RulesRuleAttributeRuleAttributeConditions':
        return pulumi.get(self, "attribute_conditions")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="azureToPgpropagation")
    def azure_to_pgpropagation(self) -> Optional[bool]:
        return pulumi.get(self, "azure_to_pgpropagation")

    @property
    @pulumi.getter(name="azureToServicePropagation")
    def azure_to_service_propagation(self) -> Optional[bool]:
        return pulumi.get(self, "azure_to_service_propagation")

    @property
    @pulumi.getter(name="customDeviceGroupToCustomDevicePropagation")
    def custom_device_group_to_custom_device_propagation(self) -> Optional[bool]:
        return pulumi.get(self, "custom_device_group_to_custom_device_propagation")

    @property
    @pulumi.getter(name="hostToPgpropagation")
    def host_to_pgpropagation(self) -> Optional[bool]:
        return pulumi.get(self, "host_to_pgpropagation")

    @property
    @pulumi.getter(name="pgToHostPropagation")
    def pg_to_host_propagation(self) -> Optional[bool]:
        return pulumi.get(self, "pg_to_host_propagation")

    @property
    @pulumi.getter(name="pgToServicePropagation")
    def pg_to_service_propagation(self) -> Optional[bool]:
        return pulumi.get(self, "pg_to_service_propagation")

    @property
    @pulumi.getter(name="serviceToHostPropagation")
    def service_to_host_propagation(self) -> Optional[bool]:
        return pulumi.get(self, "service_to_host_propagation")

    @property
    @pulumi.getter(name="serviceToPgpropagation")
    def service_to_pgpropagation(self) -> Optional[bool]:
        return pulumi.get(self, "service_to_pgpropagation")


@pulumi.output_type
class ManagementZoneV2RulesRuleAttributeRuleAttributeConditions(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.ManagementZoneV2RulesRuleAttributeRuleAttributeConditionsCondition']] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ManagementZoneV2RulesRuleAttributeRuleAttributeConditionsCondition']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ManagementZoneV2RulesRuleAttributeRuleAttributeConditionsCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "dynamicKey":
            suggest = "dynamic_key"
        elif key == "dynamicKeySource":
            suggest = "dynamic_key_source"
        elif key == "entityId":
            suggest = "entity_id"
        elif key == "enumValue":
            suggest = "enum_value"
        elif key == "integerValue":
            suggest = "integer_value"
        elif key == "stringValue":
            suggest = "string_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneV2RulesRuleAttributeRuleAttributeConditionsCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneV2RulesRuleAttributeRuleAttributeConditionsCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneV2RulesRuleAttributeRuleAttributeConditionsCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 dynamic_key: Optional[str] = None,
                 dynamic_key_source: Optional[str] = None,
                 entity_id: Optional[str] = None,
                 enum_value: Optional[str] = None,
                 integer_value: Optional[int] = None,
                 string_value: Optional[str] = None,
                 tag: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if dynamic_key is not None:
            pulumi.set(__self__, "dynamic_key", dynamic_key)
        if dynamic_key_source is not None:
            pulumi.set(__self__, "dynamic_key_source", dynamic_key_source)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if enum_value is not None:
            pulumi.set(__self__, "enum_value", enum_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> Optional[str]:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter(name="dynamicKeySource")
    def dynamic_key_source(self) -> Optional[str]:
        return pulumi.get(self, "dynamic_key_source")

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[str]:
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter(name="enumValue")
    def enum_value(self) -> Optional[str]:
        return pulumi.get(self, "enum_value")

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[int]:
        return pulumi.get(self, "integer_value")

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[str]:
        return pulumi.get(self, "string_value")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")


@pulumi.output_type
class ManagementZoneV2RulesRuleDimensionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appliesTo":
            suggest = "applies_to"
        elif key == "dimensionConditions":
            suggest = "dimension_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneV2RulesRuleDimensionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneV2RulesRuleDimensionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneV2RulesRuleDimensionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applies_to: str,
                 dimension_conditions: Optional['outputs.ManagementZoneV2RulesRuleDimensionRuleDimensionConditions'] = None):
        pulumi.set(__self__, "applies_to", applies_to)
        if dimension_conditions is not None:
            pulumi.set(__self__, "dimension_conditions", dimension_conditions)

    @property
    @pulumi.getter(name="appliesTo")
    def applies_to(self) -> str:
        return pulumi.get(self, "applies_to")

    @property
    @pulumi.getter(name="dimensionConditions")
    def dimension_conditions(self) -> Optional['outputs.ManagementZoneV2RulesRuleDimensionRuleDimensionConditions']:
        return pulumi.get(self, "dimension_conditions")


@pulumi.output_type
class ManagementZoneV2RulesRuleDimensionRuleDimensionConditions(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.ManagementZoneV2RulesRuleDimensionRuleDimensionConditionsCondition']] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ManagementZoneV2RulesRuleDimensionRuleDimensionConditionsCondition']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ManagementZoneV2RulesRuleDimensionRuleDimensionConditionsCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionType":
            suggest = "condition_type"
        elif key == "ruleMatcher":
            suggest = "rule_matcher"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneV2RulesRuleDimensionRuleDimensionConditionsCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneV2RulesRuleDimensionRuleDimensionConditionsCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneV2RulesRuleDimensionRuleDimensionConditionsCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_type: str,
                 rule_matcher: str,
                 value: str,
                 key: Optional[str] = None):
        pulumi.set(__self__, "condition_type", condition_type)
        pulumi.set(__self__, "rule_matcher", rule_matcher)
        pulumi.set(__self__, "value", value)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> str:
        return pulumi.get(self, "condition_type")

    @property
    @pulumi.getter(name="ruleMatcher")
    def rule_matcher(self) -> str:
        return pulumi.get(self, "rule_matcher")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")


@pulumi.output_type
class MetricEventsEventTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"
        elif key == "davisMerge":
            suggest = "davis_merge"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricEventsEventTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricEventsEventTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricEventsEventTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 event_type: str,
                 title: str,
                 davis_merge: Optional[bool] = None,
                 metadatas: Optional[Sequence['outputs.MetricEventsEventTemplateMetadata']] = None):
        """
        :param str description: The description of the event to trigger.
        :param str event_type: The event type to trigger.
        :param str title: The title of the event to trigger.
        :param bool davis_merge: Davis AI will try to merge this event into existing problems, otherwise a new problem will always be created.
        :param Sequence['MetricEventsEventTemplateMetadataArgs'] metadatas: Set of additional key-value properties to be attached to the triggered event.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "title", title)
        if davis_merge is not None:
            pulumi.set(__self__, "davis_merge", davis_merge)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the event to trigger.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> str:
        """
        The event type to trigger.
        """
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The title of the event to trigger.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="davisMerge")
    def davis_merge(self) -> Optional[bool]:
        """
        Davis AI will try to merge this event into existing problems, otherwise a new problem will always be created.
        """
        return pulumi.get(self, "davis_merge")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.MetricEventsEventTemplateMetadata']]:
        """
        Set of additional key-value properties to be attached to the triggered event.
        """
        return pulumi.get(self, "metadatas")


@pulumi.output_type
class MetricEventsEventTemplateMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataKey":
            suggest = "metadata_key"
        elif key == "metadataValue":
            suggest = "metadata_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricEventsEventTemplateMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricEventsEventTemplateMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricEventsEventTemplateMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_key: str,
                 metadata_value: str):
        pulumi.set(__self__, "metadata_key", metadata_key)
        pulumi.set(__self__, "metadata_value", metadata_value)

    @property
    @pulumi.getter(name="metadataKey")
    def metadata_key(self) -> str:
        return pulumi.get(self, "metadata_key")

    @property
    @pulumi.getter(name="metadataValue")
    def metadata_value(self) -> str:
        return pulumi.get(self, "metadata_value")


@pulumi.output_type
class MetricEventsModelProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertCondition":
            suggest = "alert_condition"
        elif key == "alertOnNoData":
            suggest = "alert_on_no_data"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingSamples":
            suggest = "violating_samples"
        elif key == "signalFluctuation":
            suggest = "signal_fluctuation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricEventsModelProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricEventsModelProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricEventsModelProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_condition: str,
                 alert_on_no_data: bool,
                 dealerting_samples: int,
                 samples: int,
                 type: str,
                 violating_samples: int,
                 signal_fluctuation: Optional[float] = None,
                 threshold: Optional[float] = None,
                 tolerance: Optional[float] = None):
        """
        :param str alert_condition: The alert condition of the model properties
        :param bool alert_on_no_data: The ability to set an alert on missing data in a metric. When enabled, missing data samples will contribute as violating samples defined in advanced model properties. We recommend to not alert on missing data for sparse timeseries as this leads to alert spam.
        :param int dealerting_samples: The number of one-minute samples within the evaluation window that must go back to normal to close the event.
        :param int samples: The number of one-minute samples that form the sliding evaluation window.
        :param str type: Metric-key-based query definitions only support static thresholds.
        :param int violating_samples: The number of one-minute samples within the evaluation window that must violate to trigger an event.
        :param float signal_fluctuation: Controls how many times the signal fluctuation is added to the baseline to produce the actual threshold for alerting
        :param float threshold: Raise an event if this value is violated
        :param float tolerance: Controls the width of the confidence band and larger values lead to a less sensitive model
        """
        pulumi.set(__self__, "alert_condition", alert_condition)
        pulumi.set(__self__, "alert_on_no_data", alert_on_no_data)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "samples", samples)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "violating_samples", violating_samples)
        if signal_fluctuation is not None:
            pulumi.set(__self__, "signal_fluctuation", signal_fluctuation)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if tolerance is not None:
            pulumi.set(__self__, "tolerance", tolerance)

    @property
    @pulumi.getter(name="alertCondition")
    def alert_condition(self) -> str:
        """
        The alert condition of the model properties
        """
        return pulumi.get(self, "alert_condition")

    @property
    @pulumi.getter(name="alertOnNoData")
    def alert_on_no_data(self) -> bool:
        """
        The ability to set an alert on missing data in a metric. When enabled, missing data samples will contribute as violating samples defined in advanced model properties. We recommend to not alert on missing data for sparse timeseries as this leads to alert spam.
        """
        return pulumi.get(self, "alert_on_no_data")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        """
        The number of one-minute samples within the evaluation window that must go back to normal to close the event.
        """
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter
    def samples(self) -> int:
        """
        The number of one-minute samples that form the sliding evaluation window.
        """
        return pulumi.get(self, "samples")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Metric-key-based query definitions only support static thresholds.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        """
        The number of one-minute samples within the evaluation window that must violate to trigger an event.
        """
        return pulumi.get(self, "violating_samples")

    @property
    @pulumi.getter(name="signalFluctuation")
    def signal_fluctuation(self) -> Optional[float]:
        """
        Controls how many times the signal fluctuation is added to the baseline to produce the actual threshold for alerting
        """
        return pulumi.get(self, "signal_fluctuation")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        """
        Raise an event if this value is violated
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def tolerance(self) -> Optional[float]:
        """
        Controls the width of the confidence band and larger values lead to a less sensitive model
        """
        return pulumi.get(self, "tolerance")


@pulumi.output_type
class MetricEventsQueryDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricKey":
            suggest = "metric_key"
        elif key == "dimensionFilter":
            suggest = "dimension_filter"
        elif key == "entityFilter":
            suggest = "entity_filter"
        elif key == "metricSelector":
            suggest = "metric_selector"
        elif key == "queryOffset":
            suggest = "query_offset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricEventsQueryDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricEventsQueryDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricEventsQueryDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_key: str,
                 type: str,
                 aggregation: Optional[str] = None,
                 dimension_filter: Optional['outputs.MetricEventsQueryDefinitionDimensionFilter'] = None,
                 entity_filter: Optional['outputs.MetricEventsQueryDefinitionEntityFilter'] = None,
                 metric_selector: Optional[str] = None,
                 query_offset: Optional[int] = None):
        """
        :param str metric_key: The metric key of the query definition
        :param str type: The type of query definition
        :param str aggregation: The aggregation of the query definition
        :param 'MetricEventsQueryDefinitionDimensionFilterArgs' dimension_filter: The dimension filters of the query definition
        :param 'MetricEventsQueryDefinitionEntityFilterArgs' entity_filter: Use rule-based filters to define the scope this event monitors.
        :param str metric_selector: To learn more, visit [Metric Selector](https://dt-url.net/metselad)
        :param int query_offset: Minute offset of sliding evaluation window for metrics with latency
        """
        pulumi.set(__self__, "metric_key", metric_key)
        pulumi.set(__self__, "type", type)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if dimension_filter is not None:
            pulumi.set(__self__, "dimension_filter", dimension_filter)
        if entity_filter is not None:
            pulumi.set(__self__, "entity_filter", entity_filter)
        if metric_selector is not None:
            pulumi.set(__self__, "metric_selector", metric_selector)
        if query_offset is not None:
            pulumi.set(__self__, "query_offset", query_offset)

    @property
    @pulumi.getter(name="metricKey")
    def metric_key(self) -> str:
        """
        The metric key of the query definition
        """
        return pulumi.get(self, "metric_key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of query definition
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        The aggregation of the query definition
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="dimensionFilter")
    def dimension_filter(self) -> Optional['outputs.MetricEventsQueryDefinitionDimensionFilter']:
        """
        The dimension filters of the query definition
        """
        return pulumi.get(self, "dimension_filter")

    @property
    @pulumi.getter(name="entityFilter")
    def entity_filter(self) -> Optional['outputs.MetricEventsQueryDefinitionEntityFilter']:
        """
        Use rule-based filters to define the scope this event monitors.
        """
        return pulumi.get(self, "entity_filter")

    @property
    @pulumi.getter(name="metricSelector")
    def metric_selector(self) -> Optional[str]:
        """
        To learn more, visit [Metric Selector](https://dt-url.net/metselad)
        """
        return pulumi.get(self, "metric_selector")

    @property
    @pulumi.getter(name="queryOffset")
    def query_offset(self) -> Optional[int]:
        """
        Minute offset of sliding evaluation window for metrics with latency
        """
        return pulumi.get(self, "query_offset")


@pulumi.output_type
class MetricEventsQueryDefinitionDimensionFilter(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.MetricEventsQueryDefinitionDimensionFilterFilter']] = None):
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.MetricEventsQueryDefinitionDimensionFilterFilter']]:
        return pulumi.get(self, "filters")


@pulumi.output_type
class MetricEventsQueryDefinitionDimensionFilterFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dimensionKey":
            suggest = "dimension_key"
        elif key == "dimensionValue":
            suggest = "dimension_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricEventsQueryDefinitionDimensionFilterFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricEventsQueryDefinitionDimensionFilterFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricEventsQueryDefinitionDimensionFilterFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension_key: str,
                 dimension_value: str):
        pulumi.set(__self__, "dimension_key", dimension_key)
        pulumi.set(__self__, "dimension_value", dimension_value)

    @property
    @pulumi.getter(name="dimensionKey")
    def dimension_key(self) -> str:
        return pulumi.get(self, "dimension_key")

    @property
    @pulumi.getter(name="dimensionValue")
    def dimension_value(self) -> str:
        return pulumi.get(self, "dimension_value")


@pulumi.output_type
class MetricEventsQueryDefinitionEntityFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dimensionKey":
            suggest = "dimension_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricEventsQueryDefinitionEntityFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricEventsQueryDefinitionEntityFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricEventsQueryDefinitionEntityFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.MetricEventsQueryDefinitionEntityFilterCondition']] = None,
                 dimension_key: Optional[str] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if dimension_key is not None:
            pulumi.set(__self__, "dimension_key", dimension_key)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.MetricEventsQueryDefinitionEntityFilterCondition']]:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="dimensionKey")
    def dimension_key(self) -> Optional[str]:
        return pulumi.get(self, "dimension_key")


@pulumi.output_type
class MetricEventsQueryDefinitionEntityFilterCondition(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.MetricEventsQueryDefinitionEntityFilterConditionCondition']] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.MetricEventsQueryDefinitionEntityFilterConditionCondition']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class MetricEventsQueryDefinitionEntityFilterConditionCondition(dict):
    def __init__(__self__, *,
                 operator: str,
                 type: str,
                 value: str):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class MetricMetadataDimensions(dict):
    def __init__(__self__, *,
                 dimensions: Sequence['outputs.MetricMetadataDimensionsDimension']):
        pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.MetricMetadataDimensionsDimension']:
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class MetricMetadataDimensionsDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricMetadataDimensionsDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricMetadataDimensionsDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricMetadataDimensionsDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 display_name: Optional[str] = None):
        """
        :param str display_name: Display name
        """
        pulumi.set(__self__, "key", key)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class MetricMetadataMetricProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueType":
            suggest = "value_type"
        elif key == "impactRelevant":
            suggest = "impact_relevant"
        elif key == "maxValue":
            suggest = "max_value"
        elif key == "minValue":
            suggest = "min_value"
        elif key == "rootCauseRelevant":
            suggest = "root_cause_relevant"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricMetadataMetricProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricMetadataMetricProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricMetadataMetricProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value_type: str,
                 impact_relevant: Optional[bool] = None,
                 latency: Optional[int] = None,
                 max_value: Optional[float] = None,
                 min_value: Optional[float] = None,
                 root_cause_relevant: Optional[bool] = None):
        """
        :param str value_type: Possible Values: `Error`, `Score`, `Unknown`
        :param bool impact_relevant: Whether (true or false) the metric is relevant to a problem's impact.
        """
        pulumi.set(__self__, "value_type", value_type)
        if impact_relevant is not None:
            pulumi.set(__self__, "impact_relevant", impact_relevant)
        if latency is not None:
            pulumi.set(__self__, "latency", latency)
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)
        if root_cause_relevant is not None:
            pulumi.set(__self__, "root_cause_relevant", root_cause_relevant)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> str:
        """
        Possible Values: `Error`, `Score`, `Unknown`
        """
        return pulumi.get(self, "value_type")

    @property
    @pulumi.getter(name="impactRelevant")
    def impact_relevant(self) -> Optional[bool]:
        """
        Whether (true or false) the metric is relevant to a problem's impact.
        """
        return pulumi.get(self, "impact_relevant")

    @property
    @pulumi.getter
    def latency(self) -> Optional[int]:
        return pulumi.get(self, "latency")

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[float]:
        return pulumi.get(self, "max_value")

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[float]:
        return pulumi.get(self, "min_value")

    @property
    @pulumi.getter(name="rootCauseRelevant")
    def root_cause_relevant(self) -> Optional[bool]:
        return pulumi.get(self, "root_cause_relevant")


@pulumi.output_type
class MobileAppAnomaliesErrorRateIncrease(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectionMode":
            suggest = "detection_mode"
        elif key == "errorRateIncreaseAuto":
            suggest = "error_rate_increase_auto"
        elif key == "errorRateIncreaseFixed":
            suggest = "error_rate_increase_fixed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesErrorRateIncrease. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesErrorRateIncrease.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesErrorRateIncrease.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 detection_mode: Optional[str] = None,
                 error_rate_increase_auto: Optional['outputs.MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto'] = None,
                 error_rate_increase_fixed: Optional['outputs.MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param str detection_mode: Possible Values: `Auto`, `Fixed`
        :param 'MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseAutoArgs' error_rate_increase_auto: Alert if the percentage of user actions affected by reported errors exceeds **both** the absolute threshold and the relative threshold
        :param 'MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixedArgs' error_rate_increase_fixed: Alert if the custom reported error rate threshold is exceeded during any 5-minute period
        """
        pulumi.set(__self__, "enabled", enabled)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if error_rate_increase_auto is not None:
            pulumi.set(__self__, "error_rate_increase_auto", error_rate_increase_auto)
        if error_rate_increase_fixed is not None:
            pulumi.set(__self__, "error_rate_increase_fixed", error_rate_increase_fixed)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Fixed`
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter(name="errorRateIncreaseAuto")
    def error_rate_increase_auto(self) -> Optional['outputs.MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto']:
        """
        Alert if the percentage of user actions affected by reported errors exceeds **both** the absolute threshold and the relative threshold
        """
        return pulumi.get(self, "error_rate_increase_auto")

    @property
    @pulumi.getter(name="errorRateIncreaseFixed")
    def error_rate_increase_fixed(self) -> Optional['outputs.MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed']:
        """
        Alert if the custom reported error rate threshold is exceeded during any 5-minute period
        """
        return pulumi.get(self, "error_rate_increase_fixed")


@pulumi.output_type
class MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdAbsolute":
            suggest = "threshold_absolute"
        elif key == "thresholdRelative":
            suggest = "threshold_relative"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 threshold_absolute: float,
                 threshold_relative: float):
        pulumi.set(__self__, "threshold_absolute", threshold_absolute)
        pulumi.set(__self__, "threshold_relative", threshold_relative)

    @property
    @pulumi.getter(name="thresholdAbsolute")
    def threshold_absolute(self) -> float:
        return pulumi.get(self, "threshold_absolute")

    @property
    @pulumi.getter(name="thresholdRelative")
    def threshold_relative(self) -> float:
        return pulumi.get(self, "threshold_relative")


@pulumi.output_type
class MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdAbsolute":
            suggest = "threshold_absolute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sensitivity: str,
                 threshold_absolute: float):
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold_absolute", threshold_absolute)

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter(name="thresholdAbsolute")
    def threshold_absolute(self) -> float:
        return pulumi.get(self, "threshold_absolute")


@pulumi.output_type
class MobileAppAnomaliesSlowUserActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectionMode":
            suggest = "detection_mode"
        elif key == "slowUserActionsAuto":
            suggest = "slow_user_actions_auto"
        elif key == "slowUserActionsFixed":
            suggest = "slow_user_actions_fixed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesSlowUserActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesSlowUserActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesSlowUserActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 detection_mode: Optional[str] = None,
                 slow_user_actions_auto: Optional['outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAuto'] = None,
                 slow_user_actions_fixed: Optional['outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixed'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param str detection_mode: Possible Values: `Auto`, `Fixed`
        :param 'MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoArgs' slow_user_actions_auto: no documentation available
        :param 'MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedArgs' slow_user_actions_fixed: no documentation available
        """
        pulumi.set(__self__, "enabled", enabled)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if slow_user_actions_auto is not None:
            pulumi.set(__self__, "slow_user_actions_auto", slow_user_actions_auto)
        if slow_user_actions_fixed is not None:
            pulumi.set(__self__, "slow_user_actions_fixed", slow_user_actions_fixed)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Fixed`
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter(name="slowUserActionsAuto")
    def slow_user_actions_auto(self) -> Optional['outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAuto']:
        """
        no documentation available
        """
        return pulumi.get(self, "slow_user_actions_auto")

    @property
    @pulumi.getter(name="slowUserActionsFixed")
    def slow_user_actions_fixed(self) -> Optional['outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixed']:
        """
        no documentation available
        """
        return pulumi.get(self, "slow_user_actions_fixed")


@pulumi.output_type
class MobileAppAnomaliesSlowUserActionsSlowUserActionsAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationAvoidOveralerting":
            suggest = "duration_avoid_overalerting"
        elif key == "durationThresholdAll":
            suggest = "duration_threshold_all"
        elif key == "durationThresholdSlowest":
            suggest = "duration_threshold_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesSlowUserActionsSlowUserActionsAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_avoid_overalerting: 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting',
                 duration_threshold_all: 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll',
                 duration_threshold_slowest: 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest'):
        pulumi.set(__self__, "duration_avoid_overalerting", duration_avoid_overalerting)
        pulumi.set(__self__, "duration_threshold_all", duration_threshold_all)
        pulumi.set(__self__, "duration_threshold_slowest", duration_threshold_slowest)

    @property
    @pulumi.getter(name="durationAvoidOveralerting")
    def duration_avoid_overalerting(self) -> 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting':
        return pulumi.get(self, "duration_avoid_overalerting")

    @property
    @pulumi.getter(name="durationThresholdAll")
    def duration_threshold_all(self) -> 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll':
        return pulumi.get(self, "duration_threshold_all")

    @property
    @pulumi.getter(name="durationThresholdSlowest")
    def duration_threshold_slowest(self) -> 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest':
        return pulumi.get(self, "duration_threshold_slowest")


@pulumi.output_type
class MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minActionRate":
            suggest = "min_action_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_action_rate: int):
        pulumi.set(__self__, "min_action_rate", min_action_rate)

    @property
    @pulumi.getter(name="minActionRate")
    def min_action_rate(self) -> int:
        return pulumi.get(self, "min_action_rate")


@pulumi.output_type
class MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationThreshold":
            suggest = "duration_threshold"
        elif key == "slowdownPercentage":
            suggest = "slowdown_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_threshold: float,
                 slowdown_percentage: float):
        pulumi.set(__self__, "duration_threshold", duration_threshold)
        pulumi.set(__self__, "slowdown_percentage", slowdown_percentage)

    @property
    @pulumi.getter(name="durationThreshold")
    def duration_threshold(self) -> float:
        return pulumi.get(self, "duration_threshold")

    @property
    @pulumi.getter(name="slowdownPercentage")
    def slowdown_percentage(self) -> float:
        return pulumi.get(self, "slowdown_percentage")


@pulumi.output_type
class MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationThreshold":
            suggest = "duration_threshold"
        elif key == "slowdownPercentage":
            suggest = "slowdown_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_threshold: float,
                 slowdown_percentage: float):
        pulumi.set(__self__, "duration_threshold", duration_threshold)
        pulumi.set(__self__, "slowdown_percentage", slowdown_percentage)

    @property
    @pulumi.getter(name="durationThreshold")
    def duration_threshold(self) -> float:
        return pulumi.get(self, "duration_threshold")

    @property
    @pulumi.getter(name="slowdownPercentage")
    def slowdown_percentage(self) -> float:
        return pulumi.get(self, "slowdown_percentage")


@pulumi.output_type
class MobileAppAnomaliesSlowUserActionsSlowUserActionsFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationAvoidOveralerting":
            suggest = "duration_avoid_overalerting"
        elif key == "durationThresholdAllFixed":
            suggest = "duration_threshold_all_fixed"
        elif key == "durationThresholdSlowest":
            suggest = "duration_threshold_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesSlowUserActionsSlowUserActionsFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_avoid_overalerting: 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting',
                 duration_threshold_all_fixed: 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed',
                 duration_threshold_slowest: 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest',
                 sensitivity: str):
        pulumi.set(__self__, "duration_avoid_overalerting", duration_avoid_overalerting)
        pulumi.set(__self__, "duration_threshold_all_fixed", duration_threshold_all_fixed)
        pulumi.set(__self__, "duration_threshold_slowest", duration_threshold_slowest)
        pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="durationAvoidOveralerting")
    def duration_avoid_overalerting(self) -> 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting':
        return pulumi.get(self, "duration_avoid_overalerting")

    @property
    @pulumi.getter(name="durationThresholdAllFixed")
    def duration_threshold_all_fixed(self) -> 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed':
        return pulumi.get(self, "duration_threshold_all_fixed")

    @property
    @pulumi.getter(name="durationThresholdSlowest")
    def duration_threshold_slowest(self) -> 'outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest':
        return pulumi.get(self, "duration_threshold_slowest")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minActionRate":
            suggest = "min_action_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_action_rate: int):
        pulumi.set(__self__, "min_action_rate", min_action_rate)

    @property
    @pulumi.getter(name="minActionRate")
    def min_action_rate(self) -> int:
        return pulumi.get(self, "min_action_rate")


@pulumi.output_type
class MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationThreshold":
            suggest = "duration_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_threshold: float):
        pulumi.set(__self__, "duration_threshold", duration_threshold)

    @property
    @pulumi.getter(name="durationThreshold")
    def duration_threshold(self) -> float:
        return pulumi.get(self, "duration_threshold")


@pulumi.output_type
class MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationThreshold":
            suggest = "duration_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_threshold: float):
        pulumi.set(__self__, "duration_threshold", duration_threshold)

    @property
    @pulumi.getter(name="durationThreshold")
    def duration_threshold(self) -> float:
        return pulumi.get(self, "duration_threshold")


@pulumi.output_type
class MobileAppAnomaliesUnexpectedHighLoad(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdPercentage":
            suggest = "threshold_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesUnexpectedHighLoad. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesUnexpectedHighLoad.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesUnexpectedHighLoad.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 threshold_percentage: Optional[float] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param float threshold_percentage: Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic spikes within your application.
        """
        pulumi.set(__self__, "enabled", enabled)
        if threshold_percentage is not None:
            pulumi.set(__self__, "threshold_percentage", threshold_percentage)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="thresholdPercentage")
    def threshold_percentage(self) -> Optional[float]:
        """
        Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic spikes within your application.
        """
        return pulumi.get(self, "threshold_percentage")


@pulumi.output_type
class MobileAppAnomaliesUnexpectedLowLoad(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdPercentage":
            suggest = "threshold_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppAnomaliesUnexpectedLowLoad. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppAnomaliesUnexpectedLowLoad.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppAnomaliesUnexpectedLowLoad.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 threshold_percentage: Optional[float] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param float threshold_percentage: Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic drops within your application.
        """
        pulumi.set(__self__, "enabled", enabled)
        if threshold_percentage is not None:
            pulumi.set(__self__, "threshold_percentage", threshold_percentage)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="thresholdPercentage")
    def threshold_percentage(self) -> Optional[float]:
        """
        Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic drops within your application.
        """
        return pulumi.get(self, "threshold_percentage")


@pulumi.output_type
class MobileAppCrashRateCrashRateIncrease(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crashRateIncreaseAuto":
            suggest = "crash_rate_increase_auto"
        elif key == "crashRateIncreaseFixed":
            suggest = "crash_rate_increase_fixed"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppCrashRateCrashRateIncrease. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppCrashRateCrashRateIncrease.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppCrashRateCrashRateIncrease.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 crash_rate_increase_auto: Optional['outputs.MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto'] = None,
                 crash_rate_increase_fixed: Optional['outputs.MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseAutoArgs' crash_rate_increase_auto: Alert crash rate increases when auto-detected baseline is exceeded by a certain number of users
        :param 'MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseFixedArgs' crash_rate_increase_fixed: Alert crash rate increases when the defined threshold is exceeded by a certain number of users
        :param str detection_mode: Possible Values: `Auto`, `Fixed`
        """
        pulumi.set(__self__, "enabled", enabled)
        if crash_rate_increase_auto is not None:
            pulumi.set(__self__, "crash_rate_increase_auto", crash_rate_increase_auto)
        if crash_rate_increase_fixed is not None:
            pulumi.set(__self__, "crash_rate_increase_fixed", crash_rate_increase_fixed)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="crashRateIncreaseAuto")
    def crash_rate_increase_auto(self) -> Optional['outputs.MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto']:
        """
        Alert crash rate increases when auto-detected baseline is exceeded by a certain number of users
        """
        return pulumi.get(self, "crash_rate_increase_auto")

    @property
    @pulumi.getter(name="crashRateIncreaseFixed")
    def crash_rate_increase_fixed(self) -> Optional['outputs.MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed']:
        """
        Alert crash rate increases when the defined threshold is exceeded by a certain number of users
        """
        return pulumi.get(self, "crash_rate_increase_fixed")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Fixed`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baselineViolationPercentage":
            suggest = "baseline_violation_percentage"
        elif key == "concurrentUsers":
            suggest = "concurrent_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 baseline_violation_percentage: float,
                 concurrent_users: float,
                 sensitivity: str):
        pulumi.set(__self__, "baseline_violation_percentage", baseline_violation_percentage)
        pulumi.set(__self__, "concurrent_users", concurrent_users)
        pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="baselineViolationPercentage")
    def baseline_violation_percentage(self) -> float:
        return pulumi.get(self, "baseline_violation_percentage")

    @property
    @pulumi.getter(name="concurrentUsers")
    def concurrent_users(self) -> float:
        return pulumi.get(self, "concurrent_users")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "absoluteCrashRate":
            suggest = "absolute_crash_rate"
        elif key == "concurrentUsers":
            suggest = "concurrent_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 absolute_crash_rate: float,
                 concurrent_users: int):
        pulumi.set(__self__, "absolute_crash_rate", absolute_crash_rate)
        pulumi.set(__self__, "concurrent_users", concurrent_users)

    @property
    @pulumi.getter(name="absoluteCrashRate")
    def absolute_crash_rate(self) -> float:
        return pulumi.get(self, "absolute_crash_rate")

    @property
    @pulumi.getter(name="concurrentUsers")
    def concurrent_users(self) -> int:
        return pulumi.get(self, "concurrent_users")


@pulumi.output_type
class MobileAppEnablementRum(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costAndTrafficControl":
            suggest = "cost_and_traffic_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppEnablementRum. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppEnablementRum.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppEnablementRum.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_and_traffic_control: int,
                 enabled: bool):
        """
        :param int cost_and_traffic_control: Percentage of user sessions captured and analyzed. By default, Dynatrace captures all user actions and user sessions for analysis. This approach ensures complete insight into your applications performance and customer experience. You can optionally reduce the granularity of user-action and user-session analysis by capturing a lower percentage of user sessions. While this approach can reduce monitoring costs, it also results in lower visibility into how your customers are using your applications. For example, a setting of 10% results in Dynatrace analyzing only every tenth user session.
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        """
        pulumi.set(__self__, "cost_and_traffic_control", cost_and_traffic_control)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="costAndTrafficControl")
    def cost_and_traffic_control(self) -> int:
        """
        Percentage of user sessions captured and analyzed. By default, Dynatrace captures all user actions and user sessions for analysis. This approach ensures complete insight into your applications performance and customer experience. You can optionally reduce the granularity of user-action and user-session analysis by capturing a lower percentage of user sessions. While this approach can reduce monitoring costs, it also results in lower visibility into how your customers are using your applications. For example, a setting of 10% results in Dynatrace analyzing only every tenth user session.
        """
        return pulumi.get(self, "cost_and_traffic_control")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class MobileAppEnablementSessionReplay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onCrash":
            suggest = "on_crash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppEnablementSessionReplay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppEnablementSessionReplay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppEnablementSessionReplay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_crash: bool):
        """
        :param bool on_crash: Before enabling, Dynatrace checks your system against the [prerequisites for Session Replay](https://dt-url.net/t23s0ppi).
        """
        pulumi.set(__self__, "on_crash", on_crash)

    @property
    @pulumi.getter(name="onCrash")
    def on_crash(self) -> bool:
        """
        Before enabling, Dynatrace checks your system against the [prerequisites for Session Replay](https://dt-url.net/t23s0ppi).
        """
        return pulumi.get(self, "on_crash")


@pulumi.output_type
class MobileAppRequestErrorsErrorRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorRules":
            suggest = "error_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppRequestErrorsErrorRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppRequestErrorsErrorRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppRequestErrorsErrorRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_rules: Sequence['outputs.MobileAppRequestErrorsErrorRulesErrorRule']):
        pulumi.set(__self__, "error_rules", error_rules)

    @property
    @pulumi.getter(name="errorRules")
    def error_rules(self) -> Sequence['outputs.MobileAppRequestErrorsErrorRulesErrorRule']:
        return pulumi.get(self, "error_rules")


@pulumi.output_type
class MobileAppRequestErrorsErrorRulesErrorRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorCodes":
            suggest = "error_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileAppRequestErrorsErrorRulesErrorRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileAppRequestErrorsErrorRulesErrorRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileAppRequestErrorsErrorRulesErrorRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_codes: str):
        pulumi.set(__self__, "error_codes", error_codes)

    @property
    @pulumi.getter(name="errorCodes")
    def error_codes(self) -> str:
        return pulumi.get(self, "error_codes")


@pulumi.output_type
class MobileApplicationApdex(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frustratedOnError":
            suggest = "frustrated_on_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileApplicationApdex. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileApplicationApdex.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileApplicationApdex.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frustrated: int,
                 tolerable: int,
                 frustrated_on_error: Optional[bool] = None):
        """
        :param int frustrated: Apdex **frustrated** threshold, in milliseconds: a duration greater than or equal to this value is considered frustrated
        :param int tolerable: Apdex **tolerable** threshold, in milliseconds: a duration greater than or equal to this value is considered tolerable
        :param bool frustrated_on_error: Apdex error condition: if `true` the user session is considered frustrated when an error is reported
        """
        pulumi.set(__self__, "frustrated", frustrated)
        pulumi.set(__self__, "tolerable", tolerable)
        if frustrated_on_error is not None:
            pulumi.set(__self__, "frustrated_on_error", frustrated_on_error)

    @property
    @pulumi.getter
    def frustrated(self) -> int:
        """
        Apdex **frustrated** threshold, in milliseconds: a duration greater than or equal to this value is considered frustrated
        """
        return pulumi.get(self, "frustrated")

    @property
    @pulumi.getter
    def tolerable(self) -> int:
        """
        Apdex **tolerable** threshold, in milliseconds: a duration greater than or equal to this value is considered tolerable
        """
        return pulumi.get(self, "tolerable")

    @property
    @pulumi.getter(name="frustratedOnError")
    def frustrated_on_error(self) -> Optional[bool]:
        """
        Apdex error condition: if `true` the user session is considered frustrated when an error is reported
        """
        return pulumi.get(self, "frustrated_on_error")


@pulumi.output_type
class MobileApplicationProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiValues":
            suggest = "api_values"
        elif key == "requestAttributes":
            suggest = "request_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileApplicationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileApplicationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileApplicationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_values: Optional[Sequence['outputs.MobileApplicationPropertiesApiValue']] = None,
                 request_attributes: Optional[Sequence['outputs.MobileApplicationPropertiesRequestAttribute']] = None):
        """
        :param Sequence['MobileApplicationPropertiesApiValueArgs'] api_values: A User Action / Session Property based on a value reported by the API
        :param Sequence['MobileApplicationPropertiesRequestAttributeArgs'] request_attributes: A User Action / Session Property based on a Server Side Request Attribute
        """
        if api_values is not None:
            pulumi.set(__self__, "api_values", api_values)
        if request_attributes is not None:
            pulumi.set(__self__, "request_attributes", request_attributes)

    @property
    @pulumi.getter(name="apiValues")
    def api_values(self) -> Optional[Sequence['outputs.MobileApplicationPropertiesApiValue']]:
        """
        A User Action / Session Property based on a value reported by the API
        """
        return pulumi.get(self, "api_values")

    @property
    @pulumi.getter(name="requestAttributes")
    def request_attributes(self) -> Optional[Sequence['outputs.MobileApplicationPropertiesRequestAttribute']]:
        """
        A User Action / Session Property based on a Server Side Request Attribute
        """
        return pulumi.get(self, "request_attributes")


@pulumi.output_type
class MobileApplicationPropertiesApiValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupRule":
            suggest = "cleanup_rule"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "storeAsSessionProperty":
            suggest = "store_as_session_property"
        elif key == "storeAsUserActionProperty":
            suggest = "store_as_user_action_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileApplicationPropertiesApiValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileApplicationPropertiesApiValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileApplicationPropertiesApiValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 type: str,
                 aggregation: Optional[str] = None,
                 cleanup_rule: Optional[str] = None,
                 display_name: Optional[str] = None,
                 name: Optional[str] = None,
                 store_as_session_property: Optional[bool] = None,
                 store_as_user_action_property: Optional[bool] = None):
        """
        :param str name: The name of the application
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if cleanup_rule is not None:
            pulumi.set(__self__, "cleanup_rule", cleanup_rule)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if store_as_session_property is not None:
            pulumi.set(__self__, "store_as_session_property", store_as_session_property)
        if store_as_user_action_property is not None:
            pulumi.set(__self__, "store_as_user_action_property", store_as_user_action_property)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="cleanupRule")
    def cleanup_rule(self) -> Optional[str]:
        return pulumi.get(self, "cleanup_rule")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the application
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="storeAsSessionProperty")
    def store_as_session_property(self) -> Optional[bool]:
        return pulumi.get(self, "store_as_session_property")

    @property
    @pulumi.getter(name="storeAsUserActionProperty")
    def store_as_user_action_property(self) -> Optional[bool]:
        return pulumi.get(self, "store_as_user_action_property")


@pulumi.output_type
class MobileApplicationPropertiesRequestAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupRule":
            suggest = "cleanup_rule"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "storeAsSessionProperty":
            suggest = "store_as_session_property"
        elif key == "storeAsUserActionProperty":
            suggest = "store_as_user_action_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileApplicationPropertiesRequestAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileApplicationPropertiesRequestAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileApplicationPropertiesRequestAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 key: str,
                 type: str,
                 aggregation: Optional[str] = None,
                 cleanup_rule: Optional[str] = None,
                 display_name: Optional[str] = None,
                 store_as_session_property: Optional[bool] = None,
                 store_as_user_action_property: Optional[bool] = None):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if cleanup_rule is not None:
            pulumi.set(__self__, "cleanup_rule", cleanup_rule)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if store_as_session_property is not None:
            pulumi.set(__self__, "store_as_session_property", store_as_session_property)
        if store_as_user_action_property is not None:
            pulumi.set(__self__, "store_as_user_action_property", store_as_user_action_property)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="cleanupRule")
    def cleanup_rule(self) -> Optional[str]:
        return pulumi.get(self, "cleanup_rule")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="storeAsSessionProperty")
    def store_as_session_property(self) -> Optional[bool]:
        return pulumi.get(self, "store_as_session_property")

    @property
    @pulumi.getter(name="storeAsUserActionProperty")
    def store_as_user_action_property(self) -> Optional[bool]:
        return pulumi.get(self, "store_as_user_action_property")


@pulumi.output_type
class NetworkTrafficExcludeIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddressForms":
            suggest = "ip_address_forms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkTrafficExcludeIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkTrafficExcludeIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkTrafficExcludeIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address_forms: Sequence['outputs.NetworkTrafficExcludeIpIpAddressForm']):
        pulumi.set(__self__, "ip_address_forms", ip_address_forms)

    @property
    @pulumi.getter(name="ipAddressForms")
    def ip_address_forms(self) -> Sequence['outputs.NetworkTrafficExcludeIpIpAddressForm']:
        return pulumi.get(self, "ip_address_forms")


@pulumi.output_type
class NetworkTrafficExcludeIpIpAddressForm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkTrafficExcludeIpIpAddressForm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkTrafficExcludeIpIpAddressForm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkTrafficExcludeIpIpAddressForm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: str):
        pulumi.set(__self__, "ip_address", ip_address)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")


@pulumi.output_type
class NetworkTrafficExcludeNic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nicForms":
            suggest = "nic_forms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkTrafficExcludeNic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkTrafficExcludeNic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkTrafficExcludeNic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nic_forms: Sequence['outputs.NetworkTrafficExcludeNicNicForm']):
        pulumi.set(__self__, "nic_forms", nic_forms)

    @property
    @pulumi.getter(name="nicForms")
    def nic_forms(self) -> Sequence['outputs.NetworkTrafficExcludeNicNicForm']:
        return pulumi.get(self, "nic_forms")


@pulumi.output_type
class NetworkTrafficExcludeNicNicForm(dict):
    def __init__(__self__, *,
                 interface: str,
                 os: str):
        pulumi.set(__self__, "interface", interface)
        pulumi.set(__self__, "os", os)

    @property
    @pulumi.getter
    def interface(self) -> str:
        return pulumi.get(self, "interface")

    @property
    @pulumi.getter
    def os(self) -> str:
        return pulumi.get(self, "os")


@pulumi.output_type
class NotificationAnsibleTower(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptAnyCertificate":
            suggest = "accept_any_certificate"
        elif key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "customMessage":
            suggest = "custom_message"
        elif key == "jobTemplateId":
            suggest = "job_template_id"
        elif key == "jobTemplateUrl":
            suggest = "job_template_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationAnsibleTower. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationAnsibleTower.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationAnsibleTower.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept_any_certificate: bool,
                 active: bool,
                 alerting_profile: str,
                 custom_message: str,
                 job_template_id: int,
                 job_template_url: str,
                 name: str,
                 username: str,
                 password: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool accept_any_certificate: Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str custom_message: The custom message of the notification.   This message will be displayed in the extra variables **Message** field of your job template.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param int job_template_id: The ID of the target Ansible Tower job template
        :param str job_template_url: The URL of the target Ansible Tower job template
        :param str name: The name of the notification configuration
        :param str username: The username of the Ansible Tower account
        :param str password: The password for the Ansible Tower account
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "accept_any_certificate", accept_any_certificate)
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "custom_message", custom_message)
        pulumi.set(__self__, "job_template_id", job_template_id)
        pulumi.set(__self__, "job_template_url", job_template_url)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "username", username)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="acceptAnyCertificate")
    def accept_any_certificate(self) -> bool:
        """
        Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
        """
        return pulumi.get(self, "accept_any_certificate")

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter(name="customMessage")
    def custom_message(self) -> str:
        """
        The custom message of the notification.   This message will be displayed in the extra variables **Message** field of your job template.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "custom_message")

    @property
    @pulumi.getter(name="jobTemplateId")
    def job_template_id(self) -> int:
        """
        The ID of the target Ansible Tower job template
        """
        return pulumi.get(self, "job_template_id")

    @property
    @pulumi.getter(name="jobTemplateUrl")
    def job_template_url(self) -> str:
        """
        The URL of the target Ansible Tower job template
        """
        return pulumi.get(self, "job_template_url")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username of the Ansible Tower account
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password for the Ansible Tower account
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 name: str,
                 type: str,
                 unknowns: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str name: The name of the notification configuration
        :param str type: Defines the actual set of fields depending on the value. See one of the following objects:  * `EMAIL` > EmailNotificationConfig  * `PAGER_DUTY` > PagerDutyNotificationConfig  * `WEBHOOK` > WebHookNotificationConfig  * `SLACK` > SlackNotificationConfig  * `HIPCHAT` > HipChatNotificationConfig  * `VICTOROPS` > VictorOpsNotificationConfig  * `SERVICE_NOW` > ServiceNowNotificationConfig  * `XMATTERS` > XMattersNotificationConfig  * `ANSIBLETOWER` > AnsibleTowerNotificationConfig  * `OPS_GENIE` > OpsGenieNotificationConfig  * `JIRA` > JiraNotificationConfig  * `TRELLO` > TrelloNotificationConfig
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines the actual set of fields depending on the value. See one of the following objects:  * `EMAIL` > EmailNotificationConfig  * `PAGER_DUTY` > PagerDutyNotificationConfig  * `WEBHOOK` > WebHookNotificationConfig  * `SLACK` > SlackNotificationConfig  * `HIPCHAT` > HipChatNotificationConfig  * `VICTOROPS` > VictorOpsNotificationConfig  * `SERVICE_NOW` > ServiceNowNotificationConfig  * `XMATTERS` > XMattersNotificationConfig  * `ANSIBLETOWER` > AnsibleTowerNotificationConfig  * `OPS_GENIE` > OpsGenieNotificationConfig  * `JIRA` > JiraNotificationConfig  * `TRELLO` > TrelloNotificationConfig
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "bccReceivers":
            suggest = "bcc_receivers"
        elif key == "ccReceivers":
            suggest = "cc_receivers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 body: str,
                 name: str,
                 subject: str,
                 bcc_receivers: Optional[Sequence[str]] = None,
                 cc_receivers: Optional[Sequence[str]] = None,
                 receivers: Optional[Sequence[str]] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str body: The template of the email notification.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str name: The name of the notification configuration
        :param str subject: The subject of the email notifications
        :param Sequence[str] bcc_receivers: The list of the email BCC-recipients
        :param Sequence[str] cc_receivers: The list of the email CC-recipients
        :param Sequence[str] receivers: The list of the email recipients
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject", subject)
        if bcc_receivers is not None:
            pulumi.set(__self__, "bcc_receivers", bcc_receivers)
        if cc_receivers is not None:
            pulumi.set(__self__, "cc_receivers", cc_receivers)
        if receivers is not None:
            pulumi.set(__self__, "receivers", receivers)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def body(self) -> str:
        """
        The template of the email notification.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        The subject of the email notifications
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="bccReceivers")
    def bcc_receivers(self) -> Optional[Sequence[str]]:
        """
        The list of the email BCC-recipients
        """
        return pulumi.get(self, "bcc_receivers")

    @property
    @pulumi.getter(name="ccReceivers")
    def cc_receivers(self) -> Optional[Sequence[str]]:
        """
        The list of the email CC-recipients
        """
        return pulumi.get(self, "cc_receivers")

    @property
    @pulumi.getter
    def receivers(self) -> Optional[Sequence[str]]:
        """
        The list of the email recipients
        """
        return pulumi.get(self, "receivers")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationJira(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "issueType":
            suggest = "issue_type"
        elif key == "projectKey":
            suggest = "project_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationJira. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationJira.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationJira.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 description: str,
                 issue_type: str,
                 name: str,
                 project_key: str,
                 summary: str,
                 url: str,
                 username: str,
                 password: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str description: The description of the Jira issue to be created by this notification.   You can use same placeholders as in issue summary
        :param str issue_type: The type of the Jira issue to be created by this notification
        :param str name: The name of the notification configuration
        :param str project_key: The project key of the Jira issue to be created by this notification
        :param str summary: The summary of the Jira issue to be created by this notification.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str url: The URL of the Jira API endpoint
        :param str username: The username of the Jira profile
        :param str password: The password for the Jira profile
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "issue_type", issue_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_key", project_key)
        pulumi.set(__self__, "summary", summary)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the Jira issue to be created by this notification.   You can use same placeholders as in issue summary
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="issueType")
    def issue_type(self) -> str:
        """
        The type of the Jira issue to be created by this notification
        """
        return pulumi.get(self, "issue_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> str:
        """
        The project key of the Jira issue to be created by this notification
        """
        return pulumi.get(self, "project_key")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The summary of the Jira issue to be created by this notification.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the Jira API endpoint
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username of the Jira profile
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password for the Jira profile
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationOpsGenie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationOpsGenie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationOpsGenie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationOpsGenie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 domain: str,
                 message: str,
                 name: str,
                 api_key: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str domain: The region domain of the OpsGenie
        :param str message: The content of the message.  You can use the following placeholders:  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem
        :param str name: The name of the notification configuration
        :param str api_key: The API key to access OpsGenie
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "name", name)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The region domain of the OpsGenie
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The content of the message.  You can use the following placeholders:  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[str]:
        """
        The API key to access OpsGenie
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationPagerDuty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "serviceApiKey":
            suggest = "service_api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPagerDuty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPagerDuty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPagerDuty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account: str,
                 active: bool,
                 alerting_profile: str,
                 name: str,
                 service_name: str,
                 service_api_key: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str account: The name of the PagerDuty account
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str name: The name of the notification configuration
        :param str service_name: The name of the service
        :param str service_api_key: The API key to access PagerDuty
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "account", account)
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_name", service_name)
        if service_api_key is not None:
            pulumi.set(__self__, "service_api_key", service_api_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def account(self) -> str:
        """
        The name of the PagerDuty account
        """
        return pulumi.get(self, "account")

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        The name of the service
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="serviceApiKey")
    def service_api_key(self) -> Optional[str]:
        """
        The API key to access PagerDuty
        """
        return pulumi.get(self, "service_api_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationServiceNow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "sendEvents":
            suggest = "send_events"
        elif key == "sendIncidents":
            suggest = "send_incidents"
        elif key == "instanceName":
            suggest = "instance_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationServiceNow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationServiceNow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationServiceNow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 message: str,
                 name: str,
                 send_events: bool,
                 send_incidents: bool,
                 username: str,
                 instance_name: Optional[str] = None,
                 password: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str message: The content of the ServiceNow description.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str name: The name of the notification configuration
        :param bool send_events: Send events into ServiceNow ITOM (`true`)
        :param bool send_incidents: Send incidents into ServiceNow ITSM (`true`)
        :param str username: The username of the ServiceNow account.   Make sure that your user account has the `rest_service`, `web_request_admin`, and `x_dynat_ruxit.Integration` roles
        :param str instance_name: The ServiceNow instance identifier. It refers to the first part of your own ServiceNow URL.   This field is mutually exclusive with the **url** field. You can only use one of them
        :param str password: The username to the ServiceNow account
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str url: The URL of the on-premise ServiceNow installation.   This field is mutually exclusive with the **instanceName** field. You can only use one of them
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "send_events", send_events)
        pulumi.set(__self__, "send_incidents", send_incidents)
        pulumi.set(__self__, "username", username)
        if instance_name is not None:
            pulumi.set(__self__, "instance_name", instance_name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The content of the ServiceNow description.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sendEvents")
    def send_events(self) -> bool:
        """
        Send events into ServiceNow ITOM (`true`)
        """
        return pulumi.get(self, "send_events")

    @property
    @pulumi.getter(name="sendIncidents")
    def send_incidents(self) -> bool:
        """
        Send incidents into ServiceNow ITSM (`true`)
        """
        return pulumi.get(self, "send_incidents")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username of the ServiceNow account.   Make sure that your user account has the `rest_service`, `web_request_admin`, and `x_dynat_ruxit.Integration` roles
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> Optional[str]:
        """
        The ServiceNow instance identifier. It refers to the first part of your own ServiceNow URL.   This field is mutually exclusive with the **url** field. You can only use one of them
        """
        return pulumi.get(self, "instance_name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The username to the ServiceNow account
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL of the on-premise ServiceNow installation.   This field is mutually exclusive with the **instanceName** field. You can only use one of them
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class NotificationSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 channel: str,
                 name: str,
                 title: str,
                 unknowns: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str channel: The channel (for example, `#general`) or the user (for example, `@john.smith`) to send the message to
        :param str name: The name of the notification configuration
        :param str title: The content of the message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str url: The URL of the Slack WebHook.  This is confidential information, therefore GET requests return this field with the `null` value, and it is optional for PUT requests
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "title", title)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def channel(self) -> str:
        """
        The channel (for example, `#general`) or the user (for example, `@john.smith`) to send the message to
        """
        return pulumi.get(self, "channel")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The content of the message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL of the Slack WebHook.  This is confidential information, therefore GET requests return this field with the `null` value, and it is optional for PUT requests
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class NotificationTrello(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "applicationKey":
            suggest = "application_key"
        elif key == "boardId":
            suggest = "board_id"
        elif key == "listId":
            suggest = "list_id"
        elif key == "resolvedListId":
            suggest = "resolved_list_id"
        elif key == "authorizationToken":
            suggest = "authorization_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationTrello. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationTrello.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationTrello.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 application_key: str,
                 board_id: str,
                 description: str,
                 list_id: str,
                 name: str,
                 resolved_list_id: str,
                 text: str,
                 authorization_token: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str application_key: The application key for the Trello account
        :param str board_id: The Trello board to which the card should be assigned
        :param str description: The description of the Trello card.   You can use same placeholders as in card text
        :param str list_id: The Trello list to which the card should be assigned
        :param str name: The name of the notification configuration
        :param str resolved_list_id: The Trello list to which the card of the resolved problem should be assigned
        :param str text: The text of the generated Trello card.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str authorization_token: The application token for the Trello account
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "application_key", application_key)
        pulumi.set(__self__, "board_id", board_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "list_id", list_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resolved_list_id", resolved_list_id)
        pulumi.set(__self__, "text", text)
        if authorization_token is not None:
            pulumi.set(__self__, "authorization_token", authorization_token)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter(name="applicationKey")
    def application_key(self) -> str:
        """
        The application key for the Trello account
        """
        return pulumi.get(self, "application_key")

    @property
    @pulumi.getter(name="boardId")
    def board_id(self) -> str:
        """
        The Trello board to which the card should be assigned
        """
        return pulumi.get(self, "board_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the Trello card.   You can use same placeholders as in card text
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="listId")
    def list_id(self) -> str:
        """
        The Trello list to which the card should be assigned
        """
        return pulumi.get(self, "list_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resolvedListId")
    def resolved_list_id(self) -> str:
        """
        The Trello list to which the card of the resolved problem should be assigned
        """
        return pulumi.get(self, "resolved_list_id")

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        The text of the generated Trello card.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "text")

    @property
    @pulumi.getter(name="authorizationToken")
    def authorization_token(self) -> Optional[str]:
        """
        The application token for the Trello account
        """
        return pulumi.get(self, "authorization_token")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationVictorOps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "routingKey":
            suggest = "routing_key"
        elif key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationVictorOps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationVictorOps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationVictorOps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 message: str,
                 name: str,
                 routing_key: str,
                 api_key: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str message: The content of the message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`
        :param str name: The name of the notification configuration
        :param str routing_key: The routing key, defining the group to be notified
        :param str api_key: The API key for the target VictorOps account
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "routing_key", routing_key)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The content of the message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> str:
        """
        The routing key, defining the group to be notified
        """
        return pulumi.get(self, "routing_key")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[str]:
        """
        The API key for the target VictorOps account
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationWebHook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptAnyCertificate":
            suggest = "accept_any_certificate"
        elif key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "notifyEventMerges":
            suggest = "notify_event_merges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationWebHook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationWebHook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationWebHook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept_any_certificate: bool,
                 active: bool,
                 alerting_profile: str,
                 name: str,
                 payload: str,
                 url: str,
                 headers: Optional[Sequence['outputs.NotificationWebHookHeader']] = None,
                 notify_event_merges: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool accept_any_certificate: Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str name: The name of the notification configuration
        :param str payload: The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str url: The URL of the WebHook endpoint
        :param Sequence['NotificationWebHookHeaderArgs'] headers: A list of the additional HTTP headers
        :param bool notify_event_merges: Call webhook if new events merge into existing problems
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "accept_any_certificate", accept_any_certificate)
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "payload", payload)
        pulumi.set(__self__, "url", url)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if notify_event_merges is not None:
            pulumi.set(__self__, "notify_event_merges", notify_event_merges)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="acceptAnyCertificate")
    def accept_any_certificate(self) -> bool:
        """
        Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
        """
        return pulumi.get(self, "accept_any_certificate")

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def payload(self) -> str:
        """
        The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the WebHook endpoint
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.NotificationWebHookHeader']]:
        """
        A list of the additional HTTP headers
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="notifyEventMerges")
    def notify_event_merges(self) -> Optional[bool]:
        """
        Call webhook if new events merge into existing problems
        """
        return pulumi.get(self, "notify_event_merges")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationWebHookHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class NotificationXmatters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptAnyCertificate":
            suggest = "accept_any_certificate"
        elif key == "alertingProfile":
            suggest = "alerting_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationXmatters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationXmatters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationXmatters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept_any_certificate: bool,
                 active: bool,
                 alerting_profile: str,
                 name: str,
                 payload: str,
                 url: str,
                 headers: Optional[Sequence['outputs.NotificationXmattersHeader']] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool accept_any_certificate: Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str name: The name of the notification configuration
        :param str payload: The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str url: The URL of the xMatters WebHook
        :param Sequence['NotificationXmattersHeaderArgs'] headers: A list of the additional HTTP headers
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "accept_any_certificate", accept_any_certificate)
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "payload", payload)
        pulumi.set(__self__, "url", url)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="acceptAnyCertificate")
    def accept_any_certificate(self) -> bool:
        """
        Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
        """
        return pulumi.get(self, "accept_any_certificate")

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def payload(self) -> str:
        """
        The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the xMatters WebHook
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.NotificationXmattersHeader']]:
        """
        A list of the additional HTTP headers
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationXmattersHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class OneagentUpdatesMaintenanceWindows(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceWindows":
            suggest = "maintenance_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OneagentUpdatesMaintenanceWindows. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OneagentUpdatesMaintenanceWindows.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OneagentUpdatesMaintenanceWindows.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maintenance_windows: Sequence['outputs.OneagentUpdatesMaintenanceWindowsMaintenanceWindow']):
        pulumi.set(__self__, "maintenance_windows", maintenance_windows)

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.OneagentUpdatesMaintenanceWindowsMaintenanceWindow']:
        return pulumi.get(self, "maintenance_windows")


@pulumi.output_type
class OneagentUpdatesMaintenanceWindowsMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceWindow":
            suggest = "maintenance_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OneagentUpdatesMaintenanceWindowsMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OneagentUpdatesMaintenanceWindowsMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OneagentUpdatesMaintenanceWindowsMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maintenance_window: str):
        pulumi.set(__self__, "maintenance_window", maintenance_window)

    @property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> str:
        return pulumi.get(self, "maintenance_window")


@pulumi.output_type
class OpentelemetryMetricsAdditionalAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalAttributes":
            suggest = "additional_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpentelemetryMetricsAdditionalAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpentelemetryMetricsAdditionalAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpentelemetryMetricsAdditionalAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_attributes: Sequence['outputs.OpentelemetryMetricsAdditionalAttributesAdditionalAttribute']):
        pulumi.set(__self__, "additional_attributes", additional_attributes)

    @property
    @pulumi.getter(name="additionalAttributes")
    def additional_attributes(self) -> Sequence['outputs.OpentelemetryMetricsAdditionalAttributesAdditionalAttribute']:
        return pulumi.get(self, "additional_attributes")


@pulumi.output_type
class OpentelemetryMetricsAdditionalAttributesAdditionalAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeKey":
            suggest = "attribute_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpentelemetryMetricsAdditionalAttributesAdditionalAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpentelemetryMetricsAdditionalAttributesAdditionalAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpentelemetryMetricsAdditionalAttributesAdditionalAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_key: str,
                 enabled: bool):
        pulumi.set(__self__, "attribute_key", attribute_key)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="attributeKey")
    def attribute_key(self) -> str:
        return pulumi.get(self, "attribute_key")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class OpentelemetryMetricsToDropAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toDropAttributes":
            suggest = "to_drop_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpentelemetryMetricsToDropAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpentelemetryMetricsToDropAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpentelemetryMetricsToDropAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 to_drop_attributes: Sequence['outputs.OpentelemetryMetricsToDropAttributesToDropAttribute']):
        pulumi.set(__self__, "to_drop_attributes", to_drop_attributes)

    @property
    @pulumi.getter(name="toDropAttributes")
    def to_drop_attributes(self) -> Sequence['outputs.OpentelemetryMetricsToDropAttributesToDropAttribute']:
        return pulumi.get(self, "to_drop_attributes")


@pulumi.output_type
class OpentelemetryMetricsToDropAttributesToDropAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeKey":
            suggest = "attribute_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpentelemetryMetricsToDropAttributesToDropAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpentelemetryMetricsToDropAttributesToDropAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpentelemetryMetricsToDropAttributesToDropAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_key: str,
                 enabled: bool):
        pulumi.set(__self__, "attribute_key", attribute_key)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="attributeKey")
    def attribute_key(self) -> str:
        return pulumi.get(self, "attribute_key")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class OsServicesDetectionConditionsLinux(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linuxDetectionConditions":
            suggest = "linux_detection_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OsServicesDetectionConditionsLinux. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OsServicesDetectionConditionsLinux.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OsServicesDetectionConditionsLinux.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linux_detection_conditions: Sequence['outputs.OsServicesDetectionConditionsLinuxLinuxDetectionCondition']):
        pulumi.set(__self__, "linux_detection_conditions", linux_detection_conditions)

    @property
    @pulumi.getter(name="linuxDetectionConditions")
    def linux_detection_conditions(self) -> Sequence['outputs.OsServicesDetectionConditionsLinuxLinuxDetectionCondition']:
        return pulumi.get(self, "linux_detection_conditions")


@pulumi.output_type
class OsServicesDetectionConditionsLinuxLinuxDetectionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startupCondition":
            suggest = "startup_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OsServicesDetectionConditionsLinuxLinuxDetectionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OsServicesDetectionConditionsLinuxLinuxDetectionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OsServicesDetectionConditionsLinuxLinuxDetectionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 property: str,
                 condition: Optional[str] = None,
                 startup_condition: Optional[str] = None):
        pulumi.set(__self__, "property", property)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if startup_condition is not None:
            pulumi.set(__self__, "startup_condition", startup_condition)

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="startupCondition")
    def startup_condition(self) -> Optional[str]:
        return pulumi.get(self, "startup_condition")

    @property
    @pulumi.getter
    def property(self) -> str:
        return pulumi.get(self, "property")


@pulumi.output_type
class OsServicesDetectionConditionsWindows(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectionConditionsWindows":
            suggest = "detection_conditions_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OsServicesDetectionConditionsWindows. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OsServicesDetectionConditionsWindows.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OsServicesDetectionConditionsWindows.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 detection_conditions_windows: Sequence['outputs.OsServicesDetectionConditionsWindowsDetectionConditionsWindow']):
        pulumi.set(__self__, "detection_conditions_windows", detection_conditions_windows)

    @property
    @pulumi.getter(name="detectionConditionsWindows")
    def detection_conditions_windows(self) -> Sequence['outputs.OsServicesDetectionConditionsWindowsDetectionConditionsWindow']:
        return pulumi.get(self, "detection_conditions_windows")


@pulumi.output_type
class OsServicesDetectionConditionsWindowsDetectionConditionsWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startupCondition":
            suggest = "startup_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OsServicesDetectionConditionsWindowsDetectionConditionsWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OsServicesDetectionConditionsWindowsDetectionConditionsWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OsServicesDetectionConditionsWindowsDetectionConditionsWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 property: str,
                 condition: Optional[str] = None,
                 startup_condition: Optional[str] = None):
        pulumi.set(__self__, "property", property)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if startup_condition is not None:
            pulumi.set(__self__, "startup_condition", startup_condition)

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="startupCondition")
    def startup_condition(self) -> Optional[str]:
        return pulumi.get(self, "startup_condition")

    @property
    @pulumi.getter
    def property(self) -> str:
        return pulumi.get(self, "property")


@pulumi.output_type
class OsServicesMetadata(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.OsServicesMetadataItem']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.OsServicesMetadataItem']:
        return pulumi.get(self, "items")


@pulumi.output_type
class OsServicesMetadataItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataKey":
            suggest = "metadata_key"
        elif key == "metadataValue":
            suggest = "metadata_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OsServicesMetadataItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OsServicesMetadataItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OsServicesMetadataItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_key: str,
                 metadata_value: str):
        pulumi.set(__self__, "metadata_key", metadata_key)
        pulumi.set(__self__, "metadata_value", metadata_value)

    @property
    @pulumi.getter(name="metadataKey")
    def metadata_key(self) -> str:
        return pulumi.get(self, "metadata_key")

    @property
    @pulumi.getter(name="metadataValue")
    def metadata_value(self) -> str:
        return pulumi.get(self, "metadata_value")


@pulumi.output_type
class OwnershipConfigOwnershipIdentifiers(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ownershipIdentifiers":
            suggest = "ownership_identifiers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipConfigOwnershipIdentifiers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipConfigOwnershipIdentifiers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipConfigOwnershipIdentifiers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ownership_identifiers: Sequence['outputs.OwnershipConfigOwnershipIdentifiersOwnershipIdentifier']):
        pulumi.set(__self__, "ownership_identifiers", ownership_identifiers)

    @property
    @pulumi.getter(name="ownershipIdentifiers")
    def ownership_identifiers(self) -> Sequence['outputs.OwnershipConfigOwnershipIdentifiersOwnershipIdentifier']:
        return pulumi.get(self, "ownership_identifiers")


@pulumi.output_type
class OwnershipConfigOwnershipIdentifiersOwnershipIdentifier(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 key: str):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")


@pulumi.output_type
class OwnershipTeamsAdditionalInformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalInformations":
            suggest = "additional_informations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipTeamsAdditionalInformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipTeamsAdditionalInformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipTeamsAdditionalInformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_informations: Sequence['outputs.OwnershipTeamsAdditionalInformationAdditionalInformation']):
        """
        :param Sequence['OwnershipTeamsAdditionalInformationAdditionalInformationArgs'] additional_informations: Define key/value pairs that further describe this team  for example, cost center, solution type, or business unit assignments.
        """
        pulumi.set(__self__, "additional_informations", additional_informations)

    @property
    @pulumi.getter(name="additionalInformations")
    def additional_informations(self) -> Sequence['outputs.OwnershipTeamsAdditionalInformationAdditionalInformation']:
        """
        Define key/value pairs that further describe this team  for example, cost center, solution type, or business unit assignments.
        """
        return pulumi.get(self, "additional_informations")


@pulumi.output_type
class OwnershipTeamsAdditionalInformationAdditionalInformation(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 url: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class OwnershipTeamsContactDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contactDetails":
            suggest = "contact_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipTeamsContactDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipTeamsContactDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipTeamsContactDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contact_details: Sequence['outputs.OwnershipTeamsContactDetailsContactDetail']):
        pulumi.set(__self__, "contact_details", contact_details)

    @property
    @pulumi.getter(name="contactDetails")
    def contact_details(self) -> Sequence['outputs.OwnershipTeamsContactDetailsContactDetail']:
        return pulumi.get(self, "contact_details")


@pulumi.output_type
class OwnershipTeamsContactDetailsContactDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "msTeams":
            suggest = "ms_teams"
        elif key == "slackChannel":
            suggest = "slack_channel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipTeamsContactDetailsContactDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipTeamsContactDetailsContactDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipTeamsContactDetailsContactDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 email: Optional[str] = None,
                 jira: Optional['outputs.OwnershipTeamsContactDetailsContactDetailJira'] = None,
                 ms_teams: Optional[str] = None,
                 slack_channel: Optional[str] = None,
                 url: Optional[str] = None):
        pulumi.set(__self__, "integration_type", integration_type)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if jira is not None:
            pulumi.set(__self__, "jira", jira)
        if ms_teams is not None:
            pulumi.set(__self__, "ms_teams", ms_teams)
        if slack_channel is not None:
            pulumi.set(__self__, "slack_channel", slack_channel)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def jira(self) -> Optional['outputs.OwnershipTeamsContactDetailsContactDetailJira']:
        return pulumi.get(self, "jira")

    @property
    @pulumi.getter(name="msTeams")
    def ms_teams(self) -> Optional[str]:
        return pulumi.get(self, "ms_teams")

    @property
    @pulumi.getter(name="slackChannel")
    def slack_channel(self) -> Optional[str]:
        return pulumi.get(self, "slack_channel")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class OwnershipTeamsContactDetailsContactDetailJira(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultAssignee":
            suggest = "default_assignee"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipTeamsContactDetailsContactDetailJira. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipTeamsContactDetailsContactDetailJira.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipTeamsContactDetailsContactDetailJira.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_assignee: str,
                 project: str):
        pulumi.set(__self__, "default_assignee", default_assignee)
        pulumi.set(__self__, "project", project)

    @property
    @pulumi.getter(name="defaultAssignee")
    def default_assignee(self) -> str:
        return pulumi.get(self, "default_assignee")

    @property
    @pulumi.getter
    def project(self) -> str:
        return pulumi.get(self, "project")


@pulumi.output_type
class OwnershipTeamsLinks(dict):
    def __init__(__self__, *,
                 links: Sequence['outputs.OwnershipTeamsLinksLink']):
        pulumi.set(__self__, "links", links)

    @property
    @pulumi.getter
    def links(self) -> Sequence['outputs.OwnershipTeamsLinksLink']:
        return pulumi.get(self, "links")


@pulumi.output_type
class OwnershipTeamsLinksLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkType":
            suggest = "link_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipTeamsLinksLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipTeamsLinksLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipTeamsLinksLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 link_type: str,
                 url: str):
        pulumi.set(__self__, "link_type", link_type)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="linkType")
    def link_type(self) -> str:
        return pulumi.get(self, "link_type")

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")


@pulumi.output_type
class OwnershipTeamsResponsibilities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lineOfBusiness":
            suggest = "line_of_business"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipTeamsResponsibilities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipTeamsResponsibilities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipTeamsResponsibilities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 development: bool,
                 infrastructure: bool,
                 line_of_business: bool,
                 operations: bool,
                 security: bool):
        """
        :param bool development: Responsible for developing and maintaining high quality software. Development teams are responsible for making code changes to address performance regressions, errors, or security vulnerabilities.
        :param bool infrastructure: Responsible for the administration, management, and support of the IT infrastructure including physical servers, virtualization, and cloud. Teams with infrastructure responsibility are responsible for addressing hardware issues, resource limits, and operating system vulnerabilities.
        :param bool line_of_business: Responsible for ensuring that applications in development align with business needs and meet the usability requirements of users, stakeholders, customers, and external partners. Teams with line of business responsibility are responsible for understanding the customer experience and how it affects business goals.
        :param bool operations: Responsible for deploying and managing software, with a focus on high availability and performance. Teams with operations responsibilities needs to understand the impact, priority, and team responsible for addressing problems detected by Dynatrace.
        :param bool security: Responsible for the security posture of the organization. Teams with security responsibility must understand the impact, priority, and team responsible for addressing security vulnerabilities.
        """
        pulumi.set(__self__, "development", development)
        pulumi.set(__self__, "infrastructure", infrastructure)
        pulumi.set(__self__, "line_of_business", line_of_business)
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "security", security)

    @property
    @pulumi.getter
    def development(self) -> bool:
        """
        Responsible for developing and maintaining high quality software. Development teams are responsible for making code changes to address performance regressions, errors, or security vulnerabilities.
        """
        return pulumi.get(self, "development")

    @property
    @pulumi.getter
    def infrastructure(self) -> bool:
        """
        Responsible for the administration, management, and support of the IT infrastructure including physical servers, virtualization, and cloud. Teams with infrastructure responsibility are responsible for addressing hardware issues, resource limits, and operating system vulnerabilities.
        """
        return pulumi.get(self, "infrastructure")

    @property
    @pulumi.getter(name="lineOfBusiness")
    def line_of_business(self) -> bool:
        """
        Responsible for ensuring that applications in development align with business needs and meet the usability requirements of users, stakeholders, customers, and external partners. Teams with line of business responsibility are responsible for understanding the customer experience and how it affects business goals.
        """
        return pulumi.get(self, "line_of_business")

    @property
    @pulumi.getter
    def operations(self) -> bool:
        """
        Responsible for deploying and managing software, with a focus on high availability and performance. Teams with operations responsibilities needs to understand the impact, priority, and team responsible for addressing problems detected by Dynatrace.
        """
        return pulumi.get(self, "operations")

    @property
    @pulumi.getter
    def security(self) -> bool:
        """
        Responsible for the security posture of the organization. Teams with security responsibility must understand the impact, priority, and team responsible for addressing security vulnerabilities.
        """
        return pulumi.get(self, "security")


@pulumi.output_type
class OwnershipTeamsSupplementaryIdentifiers(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "supplementaryIdentifiers":
            suggest = "supplementary_identifiers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipTeamsSupplementaryIdentifiers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipTeamsSupplementaryIdentifiers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipTeamsSupplementaryIdentifiers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 supplementary_identifiers: Sequence['outputs.OwnershipTeamsSupplementaryIdentifiersSupplementaryIdentifier']):
        pulumi.set(__self__, "supplementary_identifiers", supplementary_identifiers)

    @property
    @pulumi.getter(name="supplementaryIdentifiers")
    def supplementary_identifiers(self) -> Sequence['outputs.OwnershipTeamsSupplementaryIdentifiersSupplementaryIdentifier']:
        return pulumi.get(self, "supplementary_identifiers")


@pulumi.output_type
class OwnershipTeamsSupplementaryIdentifiersSupplementaryIdentifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "supplementaryIdentifier":
            suggest = "supplementary_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipTeamsSupplementaryIdentifiersSupplementaryIdentifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipTeamsSupplementaryIdentifiersSupplementaryIdentifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipTeamsSupplementaryIdentifiersSupplementaryIdentifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 supplementary_identifier: str):
        pulumi.set(__self__, "supplementary_identifier", supplementary_identifier)

    @property
    @pulumi.getter(name="supplementaryIdentifier")
    def supplementary_identifier(self) -> str:
        return pulumi.get(self, "supplementary_identifier")


@pulumi.output_type
class PgAnomaliesAvailability(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumThreshold":
            suggest = "minimum_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PgAnomaliesAvailability. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PgAnomaliesAvailability.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PgAnomaliesAvailability.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 minimum_threshold: Optional[int] = None):
        """
        :param str method: How to monitor the availability of the process group:  * `PROCESS_IMPACT`: Alert if any process of the group becomes unavailable.  * `MINIMUM_THRESHOLD`: Alert if the number of active processes in the group falls below the specified threshold.  * `OFF`: Availability monitoring is disabled.
        :param int minimum_threshold: Alert if the number of active processes in the group is lower than this value.
        """
        pulumi.set(__self__, "method", method)
        if minimum_threshold is not None:
            pulumi.set(__self__, "minimum_threshold", minimum_threshold)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        How to monitor the availability of the process group:  * `PROCESS_IMPACT`: Alert if any process of the group becomes unavailable.  * `MINIMUM_THRESHOLD`: Alert if the number of active processes in the group falls below the specified threshold.  * `OFF`: Availability monitoring is disabled.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="minimumThreshold")
    def minimum_threshold(self) -> Optional[int]:
        """
        Alert if the number of active processes in the group is lower than this value.
        """
        return pulumi.get(self, "minimum_threshold")


@pulumi.output_type
class ProcessAvailabilityMetadata(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.ProcessAvailabilityMetadataItem']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.ProcessAvailabilityMetadataItem']:
        return pulumi.get(self, "items")


@pulumi.output_type
class ProcessAvailabilityMetadataItem(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessAvailabilityRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.ProcessAvailabilityRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.ProcessAvailabilityRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class ProcessAvailabilityRulesRule(dict):
    def __init__(__self__, *,
                 condition: str,
                 property: str):
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "property", property)

    @property
    @pulumi.getter
    def condition(self) -> str:
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def property(self) -> str:
        return pulumi.get(self, "property")


@pulumi.output_type
class ProcessGroupDetectionGroupExtraction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "standaloneRule":
            suggest = "standalone_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessGroupDetectionGroupExtraction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessGroupDetectionGroupExtraction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessGroupDetectionGroupExtraction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: 'outputs.ProcessGroupDetectionGroupExtractionDelimiter',
                 property: str,
                 standalone_rule: Optional[bool] = None):
        """
        :param 'ProcessGroupDetectionGroupExtractionDelimiterArgs' delimiter: Optionally delimit this property between *From* and *To*.
        :param str property: Possible values: `DOTNET_COMMAND`, `DOTNET_COMMAND_PATH`, `ASP_NET_CORE_APPLICATION_PATH`, `AWS_ECR_ACCOUNT_ID`, `AWS_ECR_REGION`, `AWS_ECS_CLUSTER`, `AWS_ECS_CONTAINERNAME`, `AWS_ECS_FAMILY`, `AWS_ECS_REVISION`, `AWS_LAMBDA_FUNCTION_NAME`, `AWS_REGION`, `APACHE_SPARK_MASTER_IP_ADDRESS`, `APACHE_CONFIG_PATH`, `CATALINA_BASE`, `CATALINA_HOME`, `CLOUD_FOUNDRY_APP_NAME`, `CLOUD_FOUNDRY_APPLICATION_ID`, `CLOUD_FOUNDRY_INSTANCE_INDEX`, `CLOUD_FOUNDRY_SPACE_NAME`, `CLOUD_FOUNDRY_SPACE_ID`, `COLDFUSION_JVM_CONFIG_FILE`, `SERVICE_NAME`, `COMMAND_LINE_ARGS`, `CONTAINER_ID`, `CONTAINER_IMAGE_VERSION`, `CONTAINER_NAME`, `DECLARATIVE_ID`, `CONTAINER_IMAGE_NAME`, `RUXIT_CLUSTER_ID`, `RUXIT_NODE_ID`, `EXE_NAME`, `EXE_PATH`, `ELASTIC_SEARCH_CLUSTER_NAME`, `ELASTIC_SEARCH_NODE_NAME`, `EQUINOX_CONFIG_PATH`, `GLASSFISH_DOMAIN_NAME`, `GLASSFISH_INSTANCE_NAME`, `PG_ID_CALC_INPUT_KEY_LINKAGE`, `GAE_INSTANCE`, `GAE_SERVICE`, `GOOGLE_CLOUD_PROJECT`, `HYBRIS_BIN_DIR`, `HYBRIS_CONFIG_DIR`, `HYBRIS_DATA_DIR`, `IBM_CICS_REGION`, `IBM_CICS_IMS_APPLID`, `IBM_CICS_IMS_JOBNAME`, `IBM_CTG_NAME`, `IBM_IMS_CONNECT`, `IBM_IMS_CONTROL`, `IBM_IMS_MPR`, `IBM_IMS_SOAP_GW_NAME`, `IIB_BROKER_NAME`, `IIB_EXECUTION_GROUP_NAME`, `IIS_APP_POOL`, `IIS_ROLE_NAME`, `JBOSS_HOME`, `JBOSS_MODE`, `JBOSS_SERVER_NAME`, `JAVA_JAR_FILE`, `JAVA_JAR_PATH`, `JAVA_MAIN_CLASS`, `KUBERNETES_BASEPODNAME`, `KUBERNETES_CONTAINERNAME`, `KUBERNETES_FULLPODNAME`, `KUBERNETES_NAMESPACE`, `KUBERNETES_PODUID`, `MSSQL_INSTANCE_NAME`, `NODEJS_APP_NAME`, `NODEJS_APP_BASE_DIR`, `NODEJS_SCRIPT_NAME`, `ORACLE_SID`, `PHP_CLI_SCRIPT_PATH`, `PHP_CLI_WORKING_DIR`, `SOFTWAREAG_INSTALL_ROOT`, `SOFTWAREAG_PRODUCTPROPNAME`, `SPRINGBOOT_APP_NAME`, `SPRINGBOOT_PROFILE_NAME`, `SPRINGBOOT_STARTUP_CLASS`, `TIBCO_BUSINESSWORKS_CE_APP_NAME`, `TIBCO_BUSINESSWORKS_CE_VERSION`, `TIBCO_BUSINESSWORKS_APP_NODE_NAME`, `TIBCO_BUSINESSWORKS_APP_SPACE_NAME`, `TIBCO_BUSINESSWORKS_DOMAIN_NAME`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE_PATH`, `TIBCO_BUSINESSWORKS_HOME`, `VARNISH_INSTANCE_NAME`, `WEBLOGIC_NAME`, `WEBLOGIC_CLUSTER_NAME`, `WEBLOGIC_DOMAIN_NAME`, `WEBLOGIC_HOME`, `WEBSPHERE_LIBERTY_SERVER_NAME`, `WEBSPHERE_CELL_NAME`, `WEBSPHERE_CLUSTER_NAME`, `WEBSPHERE_NODE_NAME`, `WEBSPHERE_SERVER_NAME`
        :param bool standalone_rule: If this option is selected, the default Dynatrace behavior is disabled for these detected processes. Only this rule is used to separate the process group.
        """
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "property", property)
        if standalone_rule is not None:
            pulumi.set(__self__, "standalone_rule", standalone_rule)

    @property
    @pulumi.getter
    def delimiter(self) -> 'outputs.ProcessGroupDetectionGroupExtractionDelimiter':
        """
        Optionally delimit this property between *From* and *To*.
        """
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="standaloneRule")
    def standalone_rule(self) -> Optional[bool]:
        """
        If this option is selected, the default Dynatrace behavior is disabled for these detected processes. Only this rule is used to separate the process group.
        """
        return pulumi.get(self, "standalone_rule")

    @property
    @pulumi.getter
    def property(self) -> str:
        """
        Possible values: `DOTNET_COMMAND`, `DOTNET_COMMAND_PATH`, `ASP_NET_CORE_APPLICATION_PATH`, `AWS_ECR_ACCOUNT_ID`, `AWS_ECR_REGION`, `AWS_ECS_CLUSTER`, `AWS_ECS_CONTAINERNAME`, `AWS_ECS_FAMILY`, `AWS_ECS_REVISION`, `AWS_LAMBDA_FUNCTION_NAME`, `AWS_REGION`, `APACHE_SPARK_MASTER_IP_ADDRESS`, `APACHE_CONFIG_PATH`, `CATALINA_BASE`, `CATALINA_HOME`, `CLOUD_FOUNDRY_APP_NAME`, `CLOUD_FOUNDRY_APPLICATION_ID`, `CLOUD_FOUNDRY_INSTANCE_INDEX`, `CLOUD_FOUNDRY_SPACE_NAME`, `CLOUD_FOUNDRY_SPACE_ID`, `COLDFUSION_JVM_CONFIG_FILE`, `SERVICE_NAME`, `COMMAND_LINE_ARGS`, `CONTAINER_ID`, `CONTAINER_IMAGE_VERSION`, `CONTAINER_NAME`, `DECLARATIVE_ID`, `CONTAINER_IMAGE_NAME`, `RUXIT_CLUSTER_ID`, `RUXIT_NODE_ID`, `EXE_NAME`, `EXE_PATH`, `ELASTIC_SEARCH_CLUSTER_NAME`, `ELASTIC_SEARCH_NODE_NAME`, `EQUINOX_CONFIG_PATH`, `GLASSFISH_DOMAIN_NAME`, `GLASSFISH_INSTANCE_NAME`, `PG_ID_CALC_INPUT_KEY_LINKAGE`, `GAE_INSTANCE`, `GAE_SERVICE`, `GOOGLE_CLOUD_PROJECT`, `HYBRIS_BIN_DIR`, `HYBRIS_CONFIG_DIR`, `HYBRIS_DATA_DIR`, `IBM_CICS_REGION`, `IBM_CICS_IMS_APPLID`, `IBM_CICS_IMS_JOBNAME`, `IBM_CTG_NAME`, `IBM_IMS_CONNECT`, `IBM_IMS_CONTROL`, `IBM_IMS_MPR`, `IBM_IMS_SOAP_GW_NAME`, `IIB_BROKER_NAME`, `IIB_EXECUTION_GROUP_NAME`, `IIS_APP_POOL`, `IIS_ROLE_NAME`, `JBOSS_HOME`, `JBOSS_MODE`, `JBOSS_SERVER_NAME`, `JAVA_JAR_FILE`, `JAVA_JAR_PATH`, `JAVA_MAIN_CLASS`, `KUBERNETES_BASEPODNAME`, `KUBERNETES_CONTAINERNAME`, `KUBERNETES_FULLPODNAME`, `KUBERNETES_NAMESPACE`, `KUBERNETES_PODUID`, `MSSQL_INSTANCE_NAME`, `NODEJS_APP_NAME`, `NODEJS_APP_BASE_DIR`, `NODEJS_SCRIPT_NAME`, `ORACLE_SID`, `PHP_CLI_SCRIPT_PATH`, `PHP_CLI_WORKING_DIR`, `SOFTWAREAG_INSTALL_ROOT`, `SOFTWAREAG_PRODUCTPROPNAME`, `SPRINGBOOT_APP_NAME`, `SPRINGBOOT_PROFILE_NAME`, `SPRINGBOOT_STARTUP_CLASS`, `TIBCO_BUSINESSWORKS_CE_APP_NAME`, `TIBCO_BUSINESSWORKS_CE_VERSION`, `TIBCO_BUSINESSWORKS_APP_NODE_NAME`, `TIBCO_BUSINESSWORKS_APP_SPACE_NAME`, `TIBCO_BUSINESSWORKS_DOMAIN_NAME`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE_PATH`, `TIBCO_BUSINESSWORKS_HOME`, `VARNISH_INSTANCE_NAME`, `WEBLOGIC_NAME`, `WEBLOGIC_CLUSTER_NAME`, `WEBLOGIC_DOMAIN_NAME`, `WEBLOGIC_HOME`, `WEBSPHERE_LIBERTY_SERVER_NAME`, `WEBSPHERE_CELL_NAME`, `WEBSPHERE_CLUSTER_NAME`, `WEBSPHERE_NODE_NAME`, `WEBSPHERE_SERVER_NAME`
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class ProcessGroupDetectionGroupExtractionDelimiter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "removeIds":
            suggest = "remove_ids"
        elif key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessGroupDetectionGroupExtractionDelimiter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessGroupDetectionGroupExtractionDelimiter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessGroupDetectionGroupExtractionDelimiter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remove_ids: bool,
                 from_: Optional[str] = None,
                 to: Optional[str] = None):
        pulumi.set(__self__, "remove_ids", remove_ids)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="removeIds")
    def remove_ids(self) -> bool:
        return pulumi.get(self, "remove_ids")

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[str]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[str]:
        return pulumi.get(self, "to")


@pulumi.output_type
class ProcessGroupDetectionInstanceExtraction(dict):
    def __init__(__self__, *,
                 delimiter: Optional['outputs.ProcessGroupDetectionInstanceExtractionDelimiter'] = None,
                 property: Optional[str] = None):
        """
        :param 'ProcessGroupDetectionInstanceExtractionDelimiterArgs' delimiter: Optionally delimit this property between *From* and *To*.
        :param str property: Possible values: `DOTNET_COMMAND`, `DOTNET_COMMAND_PATH`, `ASP_NET_CORE_APPLICATION_PATH`, `AWS_ECR_ACCOUNT_ID`, `AWS_ECR_REGION`, `AWS_ECS_CLUSTER`, `AWS_ECS_CONTAINERNAME`, `AWS_ECS_FAMILY`, `AWS_ECS_REVISION`, `AWS_LAMBDA_FUNCTION_NAME`, `AWS_REGION`, `APACHE_SPARK_MASTER_IP_ADDRESS`, `APACHE_CONFIG_PATH`, `CATALINA_BASE`, `CATALINA_HOME`, `CLOUD_FOUNDRY_APP_NAME`, `CLOUD_FOUNDRY_APPLICATION_ID`, `CLOUD_FOUNDRY_INSTANCE_INDEX`, `CLOUD_FOUNDRY_SPACE_NAME`, `CLOUD_FOUNDRY_SPACE_ID`, `COLDFUSION_JVM_CONFIG_FILE`, `SERVICE_NAME`, `COMMAND_LINE_ARGS`, `CONTAINER_ID`, `CONTAINER_IMAGE_VERSION`, `CONTAINER_NAME`, `DECLARATIVE_ID`, `CONTAINER_IMAGE_NAME`, `RUXIT_CLUSTER_ID`, `RUXIT_NODE_ID`, `EXE_NAME`, `EXE_PATH`, `ELASTIC_SEARCH_CLUSTER_NAME`, `ELASTIC_SEARCH_NODE_NAME`, `EQUINOX_CONFIG_PATH`, `GLASSFISH_DOMAIN_NAME`, `GLASSFISH_INSTANCE_NAME`, `PG_ID_CALC_INPUT_KEY_LINKAGE`, `GAE_INSTANCE`, `GAE_SERVICE`, `GOOGLE_CLOUD_PROJECT`, `HYBRIS_BIN_DIR`, `HYBRIS_CONFIG_DIR`, `HYBRIS_DATA_DIR`, `IBM_CICS_REGION`, `IBM_CICS_IMS_APPLID`, `IBM_CICS_IMS_JOBNAME`, `IBM_CTG_NAME`, `IBM_IMS_CONNECT`, `IBM_IMS_CONTROL`, `IBM_IMS_MPR`, `IBM_IMS_SOAP_GW_NAME`, `IIB_BROKER_NAME`, `IIB_EXECUTION_GROUP_NAME`, `IIS_APP_POOL`, `IIS_ROLE_NAME`, `JBOSS_HOME`, `JBOSS_MODE`, `JBOSS_SERVER_NAME`, `JAVA_JAR_FILE`, `JAVA_JAR_PATH`, `JAVA_MAIN_CLASS`, `KUBERNETES_BASEPODNAME`, `KUBERNETES_CONTAINERNAME`, `KUBERNETES_FULLPODNAME`, `KUBERNETES_NAMESPACE`, `KUBERNETES_PODUID`, `MSSQL_INSTANCE_NAME`, `NODEJS_APP_NAME`, `NODEJS_APP_BASE_DIR`, `NODEJS_SCRIPT_NAME`, `ORACLE_SID`, `PHP_CLI_SCRIPT_PATH`, `PHP_CLI_WORKING_DIR`, `SOFTWAREAG_INSTALL_ROOT`, `SOFTWAREAG_PRODUCTPROPNAME`, `SPRINGBOOT_APP_NAME`, `SPRINGBOOT_PROFILE_NAME`, `SPRINGBOOT_STARTUP_CLASS`, `TIBCO_BUSINESSWORKS_CE_APP_NAME`, `TIBCO_BUSINESSWORKS_CE_VERSION`, `TIBCO_BUSINESSWORKS_APP_NODE_NAME`, `TIBCO_BUSINESSWORKS_APP_SPACE_NAME`, `TIBCO_BUSINESSWORKS_DOMAIN_NAME`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE_PATH`, `TIBCO_BUSINESSWORKS_HOME`, `VARNISH_INSTANCE_NAME`, `WEBLOGIC_NAME`, `WEBLOGIC_CLUSTER_NAME`, `WEBLOGIC_DOMAIN_NAME`, `WEBLOGIC_HOME`, `WEBSPHERE_LIBERTY_SERVER_NAME`, `WEBSPHERE_CELL_NAME`, `WEBSPHERE_CLUSTER_NAME`, `WEBSPHERE_NODE_NAME`, `WEBSPHERE_SERVER_NAME`
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if property is not None:
            pulumi.set(__self__, "property", property)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional['outputs.ProcessGroupDetectionInstanceExtractionDelimiter']:
        """
        Optionally delimit this property between *From* and *To*.
        """
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        """
        Possible values: `DOTNET_COMMAND`, `DOTNET_COMMAND_PATH`, `ASP_NET_CORE_APPLICATION_PATH`, `AWS_ECR_ACCOUNT_ID`, `AWS_ECR_REGION`, `AWS_ECS_CLUSTER`, `AWS_ECS_CONTAINERNAME`, `AWS_ECS_FAMILY`, `AWS_ECS_REVISION`, `AWS_LAMBDA_FUNCTION_NAME`, `AWS_REGION`, `APACHE_SPARK_MASTER_IP_ADDRESS`, `APACHE_CONFIG_PATH`, `CATALINA_BASE`, `CATALINA_HOME`, `CLOUD_FOUNDRY_APP_NAME`, `CLOUD_FOUNDRY_APPLICATION_ID`, `CLOUD_FOUNDRY_INSTANCE_INDEX`, `CLOUD_FOUNDRY_SPACE_NAME`, `CLOUD_FOUNDRY_SPACE_ID`, `COLDFUSION_JVM_CONFIG_FILE`, `SERVICE_NAME`, `COMMAND_LINE_ARGS`, `CONTAINER_ID`, `CONTAINER_IMAGE_VERSION`, `CONTAINER_NAME`, `DECLARATIVE_ID`, `CONTAINER_IMAGE_NAME`, `RUXIT_CLUSTER_ID`, `RUXIT_NODE_ID`, `EXE_NAME`, `EXE_PATH`, `ELASTIC_SEARCH_CLUSTER_NAME`, `ELASTIC_SEARCH_NODE_NAME`, `EQUINOX_CONFIG_PATH`, `GLASSFISH_DOMAIN_NAME`, `GLASSFISH_INSTANCE_NAME`, `PG_ID_CALC_INPUT_KEY_LINKAGE`, `GAE_INSTANCE`, `GAE_SERVICE`, `GOOGLE_CLOUD_PROJECT`, `HYBRIS_BIN_DIR`, `HYBRIS_CONFIG_DIR`, `HYBRIS_DATA_DIR`, `IBM_CICS_REGION`, `IBM_CICS_IMS_APPLID`, `IBM_CICS_IMS_JOBNAME`, `IBM_CTG_NAME`, `IBM_IMS_CONNECT`, `IBM_IMS_CONTROL`, `IBM_IMS_MPR`, `IBM_IMS_SOAP_GW_NAME`, `IIB_BROKER_NAME`, `IIB_EXECUTION_GROUP_NAME`, `IIS_APP_POOL`, `IIS_ROLE_NAME`, `JBOSS_HOME`, `JBOSS_MODE`, `JBOSS_SERVER_NAME`, `JAVA_JAR_FILE`, `JAVA_JAR_PATH`, `JAVA_MAIN_CLASS`, `KUBERNETES_BASEPODNAME`, `KUBERNETES_CONTAINERNAME`, `KUBERNETES_FULLPODNAME`, `KUBERNETES_NAMESPACE`, `KUBERNETES_PODUID`, `MSSQL_INSTANCE_NAME`, `NODEJS_APP_NAME`, `NODEJS_APP_BASE_DIR`, `NODEJS_SCRIPT_NAME`, `ORACLE_SID`, `PHP_CLI_SCRIPT_PATH`, `PHP_CLI_WORKING_DIR`, `SOFTWAREAG_INSTALL_ROOT`, `SOFTWAREAG_PRODUCTPROPNAME`, `SPRINGBOOT_APP_NAME`, `SPRINGBOOT_PROFILE_NAME`, `SPRINGBOOT_STARTUP_CLASS`, `TIBCO_BUSINESSWORKS_CE_APP_NAME`, `TIBCO_BUSINESSWORKS_CE_VERSION`, `TIBCO_BUSINESSWORKS_APP_NODE_NAME`, `TIBCO_BUSINESSWORKS_APP_SPACE_NAME`, `TIBCO_BUSINESSWORKS_DOMAIN_NAME`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE_PATH`, `TIBCO_BUSINESSWORKS_HOME`, `VARNISH_INSTANCE_NAME`, `WEBLOGIC_NAME`, `WEBLOGIC_CLUSTER_NAME`, `WEBLOGIC_DOMAIN_NAME`, `WEBLOGIC_HOME`, `WEBSPHERE_LIBERTY_SERVER_NAME`, `WEBSPHERE_CELL_NAME`, `WEBSPHERE_CLUSTER_NAME`, `WEBSPHERE_NODE_NAME`, `WEBSPHERE_SERVER_NAME`
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class ProcessGroupDetectionInstanceExtractionDelimiter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "removeIds":
            suggest = "remove_ids"
        elif key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessGroupDetectionInstanceExtractionDelimiter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessGroupDetectionInstanceExtractionDelimiter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessGroupDetectionInstanceExtractionDelimiter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remove_ids: bool,
                 from_: Optional[str] = None,
                 to: Optional[str] = None):
        pulumi.set(__self__, "remove_ids", remove_ids)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="removeIds")
    def remove_ids(self) -> bool:
        return pulumi.get(self, "remove_ids")

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[str]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[str]:
        return pulumi.get(self, "to")


@pulumi.output_type
class ProcessGroupDetectionProcessDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containedString":
            suggest = "contained_string"
        elif key == "restrictToProcessType":
            suggest = "restrict_to_process_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessGroupDetectionProcessDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessGroupDetectionProcessDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessGroupDetectionProcessDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contained_string: str,
                 property: str,
                 restrict_to_process_type: Optional[str] = None):
        """
        :param str contained_string: The substring to be contained in the value `property` refers to. Case Sensitive
        :param str property: Possible values: `DOTNET_COMMAND`, `DOTNET_COMMAND_PATH`, `ASP_NET_CORE_APPLICATION_PATH`, `AWS_ECR_ACCOUNT_ID`, `AWS_ECR_REGION`, `AWS_ECS_CLUSTER`, `AWS_ECS_CONTAINERNAME`, `AWS_ECS_FAMILY`, `AWS_ECS_REVISION`, `AWS_LAMBDA_FUNCTION_NAME`, `AWS_REGION`, `APACHE_SPARK_MASTER_IP_ADDRESS`, `APACHE_CONFIG_PATH`, `CATALINA_BASE`, `CATALINA_HOME`, `CLOUD_FOUNDRY_APP_NAME`, `CLOUD_FOUNDRY_APPLICATION_ID`, `CLOUD_FOUNDRY_INSTANCE_INDEX`, `CLOUD_FOUNDRY_SPACE_NAME`, `CLOUD_FOUNDRY_SPACE_ID`, `COLDFUSION_JVM_CONFIG_FILE`, `SERVICE_NAME`, `COMMAND_LINE_ARGS`, `CONTAINER_ID`, `CONTAINER_IMAGE_VERSION`, `CONTAINER_NAME`, `DECLARATIVE_ID`, `CONTAINER_IMAGE_NAME`, `RUXIT_CLUSTER_ID`, `RUXIT_NODE_ID`, `EXE_NAME`, `EXE_PATH`, `ELASTIC_SEARCH_CLUSTER_NAME`, `ELASTIC_SEARCH_NODE_NAME`, `EQUINOX_CONFIG_PATH`, `GLASSFISH_DOMAIN_NAME`, `GLASSFISH_INSTANCE_NAME`, `PG_ID_CALC_INPUT_KEY_LINKAGE`, `GAE_INSTANCE`, `GAE_SERVICE`, `GOOGLE_CLOUD_PROJECT`, `HYBRIS_BIN_DIR`, `HYBRIS_CONFIG_DIR`, `HYBRIS_DATA_DIR`, `IBM_CICS_REGION`, `IBM_CICS_IMS_APPLID`, `IBM_CICS_IMS_JOBNAME`, `IBM_CTG_NAME`, `IBM_IMS_CONNECT`, `IBM_IMS_CONTROL`, `IBM_IMS_MPR`, `IBM_IMS_SOAP_GW_NAME`, `IIB_BROKER_NAME`, `IIB_EXECUTION_GROUP_NAME`, `IIS_APP_POOL`, `IIS_ROLE_NAME`, `JBOSS_HOME`, `JBOSS_MODE`, `JBOSS_SERVER_NAME`, `JAVA_JAR_FILE`, `JAVA_JAR_PATH`, `JAVA_MAIN_CLASS`, `KUBERNETES_BASEPODNAME`, `KUBERNETES_CONTAINERNAME`, `KUBERNETES_FULLPODNAME`, `KUBERNETES_NAMESPACE`, `KUBERNETES_PODUID`, `MSSQL_INSTANCE_NAME`, `NODEJS_APP_NAME`, `NODEJS_APP_BASE_DIR`, `NODEJS_SCRIPT_NAME`, `ORACLE_SID`, `PHP_CLI_SCRIPT_PATH`, `PHP_CLI_WORKING_DIR`, `SOFTWAREAG_INSTALL_ROOT`, `SOFTWAREAG_PRODUCTPROPNAME`, `SPRINGBOOT_APP_NAME`, `SPRINGBOOT_PROFILE_NAME`, `SPRINGBOOT_STARTUP_CLASS`, `TIBCO_BUSINESSWORKS_CE_APP_NAME`, `TIBCO_BUSINESSWORKS_CE_VERSION`, `TIBCO_BUSINESSWORKS_APP_NODE_NAME`, `TIBCO_BUSINESSWORKS_APP_SPACE_NAME`, `TIBCO_BUSINESSWORKS_DOMAIN_NAME`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE_PATH`, `TIBCO_BUSINESSWORKS_HOME`, `VARNISH_INSTANCE_NAME`, `WEBLOGIC_NAME`, `WEBLOGIC_CLUSTER_NAME`, `WEBLOGIC_DOMAIN_NAME`, `WEBLOGIC_HOME`, `WEBSPHERE_LIBERTY_SERVER_NAME`, `WEBSPHERE_CELL_NAME`, `WEBSPHERE_CLUSTER_NAME`, `WEBSPHERE_NODE_NAME`, `WEBSPHERE_SERVER_NAME`
        :param str restrict_to_process_type: Restrict this rule to specific process types. Note: Not all types can be detected at startup. Possible values: `PROCESS_TYPE_APACHE_HTTPD`, `PROCESS_TYPE_GLASSFISH`, `PROCESS_TYPE_GO`, `PROCESS_TYPE_IIS_APP_POOL`, `PROCESS_TYPE_JBOSS`, `PROCESS_TYPE_JAVA`, `PROCESS_TYPE_NGINX`, `PROCESS_TYPE_NODE_JS`, `PROCESS_TYPE_PHP`, `PROCESS_TYPE_TOMCAT`, `PROCESS_TYPE_WEBLOGIC`, `PROCESS_TYPE_WEBSPHERE`
        """
        pulumi.set(__self__, "contained_string", contained_string)
        pulumi.set(__self__, "property", property)
        if restrict_to_process_type is not None:
            pulumi.set(__self__, "restrict_to_process_type", restrict_to_process_type)

    @property
    @pulumi.getter(name="containedString")
    def contained_string(self) -> str:
        """
        The substring to be contained in the value `property` refers to. Case Sensitive
        """
        return pulumi.get(self, "contained_string")

    @property
    @pulumi.getter(name="restrictToProcessType")
    def restrict_to_process_type(self) -> Optional[str]:
        """
        Restrict this rule to specific process types. Note: Not all types can be detected at startup. Possible values: `PROCESS_TYPE_APACHE_HTTPD`, `PROCESS_TYPE_GLASSFISH`, `PROCESS_TYPE_GO`, `PROCESS_TYPE_IIS_APP_POOL`, `PROCESS_TYPE_JBOSS`, `PROCESS_TYPE_JAVA`, `PROCESS_TYPE_NGINX`, `PROCESS_TYPE_NODE_JS`, `PROCESS_TYPE_PHP`, `PROCESS_TYPE_TOMCAT`, `PROCESS_TYPE_WEBLOGIC`, `PROCESS_TYPE_WEBSPHERE`
        """
        return pulumi.get(self, "restrict_to_process_type")

    @property
    @pulumi.getter
    def property(self) -> str:
        """
        Possible values: `DOTNET_COMMAND`, `DOTNET_COMMAND_PATH`, `ASP_NET_CORE_APPLICATION_PATH`, `AWS_ECR_ACCOUNT_ID`, `AWS_ECR_REGION`, `AWS_ECS_CLUSTER`, `AWS_ECS_CONTAINERNAME`, `AWS_ECS_FAMILY`, `AWS_ECS_REVISION`, `AWS_LAMBDA_FUNCTION_NAME`, `AWS_REGION`, `APACHE_SPARK_MASTER_IP_ADDRESS`, `APACHE_CONFIG_PATH`, `CATALINA_BASE`, `CATALINA_HOME`, `CLOUD_FOUNDRY_APP_NAME`, `CLOUD_FOUNDRY_APPLICATION_ID`, `CLOUD_FOUNDRY_INSTANCE_INDEX`, `CLOUD_FOUNDRY_SPACE_NAME`, `CLOUD_FOUNDRY_SPACE_ID`, `COLDFUSION_JVM_CONFIG_FILE`, `SERVICE_NAME`, `COMMAND_LINE_ARGS`, `CONTAINER_ID`, `CONTAINER_IMAGE_VERSION`, `CONTAINER_NAME`, `DECLARATIVE_ID`, `CONTAINER_IMAGE_NAME`, `RUXIT_CLUSTER_ID`, `RUXIT_NODE_ID`, `EXE_NAME`, `EXE_PATH`, `ELASTIC_SEARCH_CLUSTER_NAME`, `ELASTIC_SEARCH_NODE_NAME`, `EQUINOX_CONFIG_PATH`, `GLASSFISH_DOMAIN_NAME`, `GLASSFISH_INSTANCE_NAME`, `PG_ID_CALC_INPUT_KEY_LINKAGE`, `GAE_INSTANCE`, `GAE_SERVICE`, `GOOGLE_CLOUD_PROJECT`, `HYBRIS_BIN_DIR`, `HYBRIS_CONFIG_DIR`, `HYBRIS_DATA_DIR`, `IBM_CICS_REGION`, `IBM_CICS_IMS_APPLID`, `IBM_CICS_IMS_JOBNAME`, `IBM_CTG_NAME`, `IBM_IMS_CONNECT`, `IBM_IMS_CONTROL`, `IBM_IMS_MPR`, `IBM_IMS_SOAP_GW_NAME`, `IIB_BROKER_NAME`, `IIB_EXECUTION_GROUP_NAME`, `IIS_APP_POOL`, `IIS_ROLE_NAME`, `JBOSS_HOME`, `JBOSS_MODE`, `JBOSS_SERVER_NAME`, `JAVA_JAR_FILE`, `JAVA_JAR_PATH`, `JAVA_MAIN_CLASS`, `KUBERNETES_BASEPODNAME`, `KUBERNETES_CONTAINERNAME`, `KUBERNETES_FULLPODNAME`, `KUBERNETES_NAMESPACE`, `KUBERNETES_PODUID`, `MSSQL_INSTANCE_NAME`, `NODEJS_APP_NAME`, `NODEJS_APP_BASE_DIR`, `NODEJS_SCRIPT_NAME`, `ORACLE_SID`, `PHP_CLI_SCRIPT_PATH`, `PHP_CLI_WORKING_DIR`, `SOFTWAREAG_INSTALL_ROOT`, `SOFTWAREAG_PRODUCTPROPNAME`, `SPRINGBOOT_APP_NAME`, `SPRINGBOOT_PROFILE_NAME`, `SPRINGBOOT_STARTUP_CLASS`, `TIBCO_BUSINESSWORKS_CE_APP_NAME`, `TIBCO_BUSINESSWORKS_CE_VERSION`, `TIBCO_BUSINESSWORKS_APP_NODE_NAME`, `TIBCO_BUSINESSWORKS_APP_SPACE_NAME`, `TIBCO_BUSINESSWORKS_DOMAIN_NAME`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE_PATH`, `TIBCO_BUSINESSWORKS_HOME`, `VARNISH_INSTANCE_NAME`, `WEBLOGIC_NAME`, `WEBLOGIC_CLUSTER_NAME`, `WEBLOGIC_DOMAIN_NAME`, `WEBLOGIC_HOME`, `WEBSPHERE_LIBERTY_SERVER_NAME`, `WEBSPHERE_CELL_NAME`, `WEBSPHERE_CLUSTER_NAME`, `WEBSPHERE_NODE_NAME`, `WEBSPHERE_SERVER_NAME`
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class ProcessMonitoringRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "envVar":
            suggest = "env_var"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessMonitoringRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessMonitoringRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessMonitoringRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 item: str,
                 operator: str,
                 env_var: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str item: Condition target
        :param str operator: Condition operator
        :param str env_var: supported only with OneAgent 1.167+
        :param str value: Condition value
        """
        pulumi.set(__self__, "item", item)
        pulumi.set(__self__, "operator", operator)
        if env_var is not None:
            pulumi.set(__self__, "env_var", env_var)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def item(self) -> str:
        """
        Condition target
        """
        return pulumi.get(self, "item")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Condition operator
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="envVar")
    def env_var(self) -> Optional[str]:
        """
        supported only with OneAgent 1.167+
        """
        return pulumi.get(self, "env_var")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Condition value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingCondition(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.ProcessgroupNamingConditionCondition']] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionCondition']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ProcessgroupNamingConditionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationTypeComparisons":
            suggest = "application_type_comparisons"
        elif key == "applicationTypes":
            suggest = "application_types"
        elif key == "azureComputeModeComparisons":
            suggest = "azure_compute_mode_comparisons"
        elif key == "azureComputeModes":
            suggest = "azure_compute_modes"
        elif key == "azureSkuComparisions":
            suggest = "azure_sku_comparisions"
        elif key == "azureSkus":
            suggest = "azure_skus"
        elif key == "baseComparisonBasics":
            suggest = "base_comparison_basics"
        elif key == "baseConditionKeys":
            suggest = "base_condition_keys"
        elif key == "bitnessComparisions":
            suggest = "bitness_comparisions"
        elif key == "cloudTypeComparisons":
            suggest = "cloud_type_comparisons"
        elif key == "cloudTypes":
            suggest = "cloud_types"
        elif key == "customApplicationTypeComparisons":
            suggest = "custom_application_type_comparisons"
        elif key == "customApplicationTypes":
            suggest = "custom_application_types"
        elif key == "customHostMetadataConditionKeys":
            suggest = "custom_host_metadata_condition_keys"
        elif key == "customHostMetadatas":
            suggest = "custom_host_metadatas"
        elif key == "customProcessMetadataConditionKeys":
            suggest = "custom_process_metadata_condition_keys"
        elif key == "customProcessMetadatas":
            suggest = "custom_process_metadatas"
        elif key == "databaseTopologies":
            suggest = "database_topologies"
        elif key == "databaseTopologyComparisons":
            suggest = "database_topology_comparisons"
        elif key == "dcrumDecoderComparisons":
            suggest = "dcrum_decoder_comparisons"
        elif key == "dcrumDecoders":
            suggest = "dcrum_decoders"
        elif key == "entityIdComparisons":
            suggest = "entity_id_comparisons"
        elif key == "hostTeches":
            suggest = "host_teches"
        elif key == "hypervisorTypeComparisions":
            suggest = "hypervisor_type_comparisions"
        elif key == "indexedNameComparisons":
            suggest = "indexed_name_comparisons"
        elif key == "indexedNames":
            suggest = "indexed_names"
        elif key == "indexedStringComparisons":
            suggest = "indexed_string_comparisons"
        elif key == "indexedStrings":
            suggest = "indexed_strings"
        elif key == "indexedTagComparisons":
            suggest = "indexed_tag_comparisons"
        elif key == "indexedTags":
            suggest = "indexed_tags"
        elif key == "integerComparisons":
            suggest = "integer_comparisons"
        elif key == "ipaddressComparisons":
            suggest = "ipaddress_comparisons"
        elif key == "mobilePlatformComparisons":
            suggest = "mobile_platform_comparisons"
        elif key == "mobilePlatforms":
            suggest = "mobile_platforms"
        elif key == "osArches":
            suggest = "os_arches"
        elif key == "osTypes":
            suggest = "os_types"
        elif key == "osarchitectureComparisons":
            suggest = "osarchitecture_comparisons"
        elif key == "ostypeComparisons":
            suggest = "ostype_comparisons"
        elif key == "paasTypeComparisons":
            suggest = "paas_type_comparisons"
        elif key == "paasTypes":
            suggest = "paas_types"
        elif key == "processMetadataConditionKeys":
            suggest = "process_metadata_condition_keys"
        elif key == "processMetadatas":
            suggest = "process_metadatas"
        elif key == "serviceTopologies":
            suggest = "service_topologies"
        elif key == "serviceTopologyComparisons":
            suggest = "service_topology_comparisons"
        elif key == "serviceTypeComparisons":
            suggest = "service_type_comparisons"
        elif key == "serviceTypes":
            suggest = "service_types"
        elif key == "simpleHostTechComparisons":
            suggest = "simple_host_tech_comparisons"
        elif key == "simpleTechComparisons":
            suggest = "simple_tech_comparisons"
        elif key == "stringComparisons":
            suggest = "string_comparisons"
        elif key == "stringConditionKeys":
            suggest = "string_condition_keys"
        elif key == "stringKeys":
            suggest = "string_keys"
        elif key == "syntheticEngineTypeComparisons":
            suggest = "synthetic_engine_type_comparisons"
        elif key == "syntheticEngines":
            suggest = "synthetic_engines"
        elif key == "tagComparisons":
            suggest = "tag_comparisons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_type_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionApplicationTypeComparison']] = None,
                 application_types: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionApplicationType']] = None,
                 azure_compute_mode_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureComputeModeComparison']] = None,
                 azure_compute_modes: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureComputeMode']] = None,
                 azure_sku_comparisions: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureSkuComparision']] = None,
                 azure_skus: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureSkus']] = None,
                 base_comparison_basics: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBaseComparisonBasic']] = None,
                 base_condition_keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBaseConditionKey']] = None,
                 bitness_comparisions: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBitnessComparision']] = None,
                 bitnesses: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBitness']] = None,
                 cloud_type_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCloudTypeComparison']] = None,
                 cloud_types: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCloudType']] = None,
                 comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionComparison']] = None,
                 custom_application_type_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomApplicationTypeComparison']] = None,
                 custom_application_types: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomApplicationType']] = None,
                 custom_host_metadata_condition_keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey']] = None,
                 custom_host_metadatas: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomHostMetadata']] = None,
                 custom_process_metadata_condition_keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey']] = None,
                 custom_process_metadatas: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomProcessMetadata']] = None,
                 database_topologies: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDatabaseTopology']] = None,
                 database_topology_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDatabaseTopologyComparison']] = None,
                 dcrum_decoder_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDcrumDecoderComparison']] = None,
                 dcrum_decoders: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDcrumDecoder']] = None,
                 entities: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionEntity']] = None,
                 entity_id_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionEntityIdComparison']] = None,
                 host_teches: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionHostTech']] = None,
                 hypervisor_type_comparisions: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionHypervisorTypeComparision']] = None,
                 hypervisors: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionHypervisor']] = None,
                 indexed_name_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedNameComparison']] = None,
                 indexed_names: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedName']] = None,
                 indexed_string_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedStringComparison']] = None,
                 indexed_strings: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedString']] = None,
                 indexed_tag_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedTagComparison']] = None,
                 indexed_tags: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedTag']] = None,
                 integer_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIntegerComparison']] = None,
                 integers: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionInteger']] = None,
                 ipaddress_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIpaddressComparison']] = None,
                 ipaddresses: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIpaddress']] = None,
                 keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionKey']] = None,
                 mobile_platform_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionMobilePlatformComparison']] = None,
                 mobile_platforms: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionMobilePlatform']] = None,
                 os_arches: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOsArch']] = None,
                 os_types: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOsType']] = None,
                 osarchitecture_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOsarchitectureComparison']] = None,
                 ostype_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOstypeComparison']] = None,
                 paas_type_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionPaasTypeComparison']] = None,
                 paas_types: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionPaasType']] = None,
                 process_metadata_condition_keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionProcessMetadataConditionKey']] = None,
                 process_metadatas: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionProcessMetadata']] = None,
                 service_topologies: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceTopology']] = None,
                 service_topology_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceTopologyComparison']] = None,
                 service_type_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceTypeComparison']] = None,
                 service_types: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceType']] = None,
                 simple_host_tech_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSimpleHostTechComparison']] = None,
                 simple_tech_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSimpleTechComparison']] = None,
                 string_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionStringComparison']] = None,
                 string_condition_keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionStringConditionKey']] = None,
                 string_keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionStringKey']] = None,
                 strings: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionString']] = None,
                 synthetic_engine_type_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSyntheticEngineTypeComparison']] = None,
                 synthetic_engines: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSyntheticEngine']] = None,
                 tag_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionTagComparison']] = None,
                 tags: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionTag']] = None,
                 teches: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionTech']] = None,
                 unknowns: Optional[str] = None):
        if application_type_comparisons is not None:
            pulumi.set(__self__, "application_type_comparisons", application_type_comparisons)
        if application_types is not None:
            pulumi.set(__self__, "application_types", application_types)
        if azure_compute_mode_comparisons is not None:
            pulumi.set(__self__, "azure_compute_mode_comparisons", azure_compute_mode_comparisons)
        if azure_compute_modes is not None:
            pulumi.set(__self__, "azure_compute_modes", azure_compute_modes)
        if azure_sku_comparisions is not None:
            pulumi.set(__self__, "azure_sku_comparisions", azure_sku_comparisions)
        if azure_skus is not None:
            pulumi.set(__self__, "azure_skus", azure_skus)
        if base_comparison_basics is not None:
            pulumi.set(__self__, "base_comparison_basics", base_comparison_basics)
        if base_condition_keys is not None:
            pulumi.set(__self__, "base_condition_keys", base_condition_keys)
        if bitness_comparisions is not None:
            pulumi.set(__self__, "bitness_comparisions", bitness_comparisions)
        if bitnesses is not None:
            pulumi.set(__self__, "bitnesses", bitnesses)
        if cloud_type_comparisons is not None:
            pulumi.set(__self__, "cloud_type_comparisons", cloud_type_comparisons)
        if cloud_types is not None:
            pulumi.set(__self__, "cloud_types", cloud_types)
        if comparisons is not None:
            pulumi.set(__self__, "comparisons", comparisons)
        if custom_application_type_comparisons is not None:
            pulumi.set(__self__, "custom_application_type_comparisons", custom_application_type_comparisons)
        if custom_application_types is not None:
            pulumi.set(__self__, "custom_application_types", custom_application_types)
        if custom_host_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_host_metadata_condition_keys", custom_host_metadata_condition_keys)
        if custom_host_metadatas is not None:
            pulumi.set(__self__, "custom_host_metadatas", custom_host_metadatas)
        if custom_process_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_process_metadata_condition_keys", custom_process_metadata_condition_keys)
        if custom_process_metadatas is not None:
            pulumi.set(__self__, "custom_process_metadatas", custom_process_metadatas)
        if database_topologies is not None:
            pulumi.set(__self__, "database_topologies", database_topologies)
        if database_topology_comparisons is not None:
            pulumi.set(__self__, "database_topology_comparisons", database_topology_comparisons)
        if dcrum_decoder_comparisons is not None:
            pulumi.set(__self__, "dcrum_decoder_comparisons", dcrum_decoder_comparisons)
        if dcrum_decoders is not None:
            pulumi.set(__self__, "dcrum_decoders", dcrum_decoders)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if entity_id_comparisons is not None:
            pulumi.set(__self__, "entity_id_comparisons", entity_id_comparisons)
        if host_teches is not None:
            pulumi.set(__self__, "host_teches", host_teches)
        if hypervisor_type_comparisions is not None:
            pulumi.set(__self__, "hypervisor_type_comparisions", hypervisor_type_comparisions)
        if hypervisors is not None:
            pulumi.set(__self__, "hypervisors", hypervisors)
        if indexed_name_comparisons is not None:
            pulumi.set(__self__, "indexed_name_comparisons", indexed_name_comparisons)
        if indexed_names is not None:
            pulumi.set(__self__, "indexed_names", indexed_names)
        if indexed_string_comparisons is not None:
            pulumi.set(__self__, "indexed_string_comparisons", indexed_string_comparisons)
        if indexed_strings is not None:
            pulumi.set(__self__, "indexed_strings", indexed_strings)
        if indexed_tag_comparisons is not None:
            pulumi.set(__self__, "indexed_tag_comparisons", indexed_tag_comparisons)
        if indexed_tags is not None:
            pulumi.set(__self__, "indexed_tags", indexed_tags)
        if integer_comparisons is not None:
            pulumi.set(__self__, "integer_comparisons", integer_comparisons)
        if integers is not None:
            pulumi.set(__self__, "integers", integers)
        if ipaddress_comparisons is not None:
            pulumi.set(__self__, "ipaddress_comparisons", ipaddress_comparisons)
        if ipaddresses is not None:
            pulumi.set(__self__, "ipaddresses", ipaddresses)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if mobile_platform_comparisons is not None:
            pulumi.set(__self__, "mobile_platform_comparisons", mobile_platform_comparisons)
        if mobile_platforms is not None:
            pulumi.set(__self__, "mobile_platforms", mobile_platforms)
        if os_arches is not None:
            pulumi.set(__self__, "os_arches", os_arches)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if osarchitecture_comparisons is not None:
            pulumi.set(__self__, "osarchitecture_comparisons", osarchitecture_comparisons)
        if ostype_comparisons is not None:
            pulumi.set(__self__, "ostype_comparisons", ostype_comparisons)
        if paas_type_comparisons is not None:
            pulumi.set(__self__, "paas_type_comparisons", paas_type_comparisons)
        if paas_types is not None:
            pulumi.set(__self__, "paas_types", paas_types)
        if process_metadata_condition_keys is not None:
            pulumi.set(__self__, "process_metadata_condition_keys", process_metadata_condition_keys)
        if process_metadatas is not None:
            pulumi.set(__self__, "process_metadatas", process_metadatas)
        if service_topologies is not None:
            pulumi.set(__self__, "service_topologies", service_topologies)
        if service_topology_comparisons is not None:
            pulumi.set(__self__, "service_topology_comparisons", service_topology_comparisons)
        if service_type_comparisons is not None:
            pulumi.set(__self__, "service_type_comparisons", service_type_comparisons)
        if service_types is not None:
            pulumi.set(__self__, "service_types", service_types)
        if simple_host_tech_comparisons is not None:
            pulumi.set(__self__, "simple_host_tech_comparisons", simple_host_tech_comparisons)
        if simple_tech_comparisons is not None:
            pulumi.set(__self__, "simple_tech_comparisons", simple_tech_comparisons)
        if string_comparisons is not None:
            pulumi.set(__self__, "string_comparisons", string_comparisons)
        if string_condition_keys is not None:
            pulumi.set(__self__, "string_condition_keys", string_condition_keys)
        if string_keys is not None:
            pulumi.set(__self__, "string_keys", string_keys)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)
        if synthetic_engine_type_comparisons is not None:
            pulumi.set(__self__, "synthetic_engine_type_comparisons", synthetic_engine_type_comparisons)
        if synthetic_engines is not None:
            pulumi.set(__self__, "synthetic_engines", synthetic_engines)
        if tag_comparisons is not None:
            pulumi.set(__self__, "tag_comparisons", tag_comparisons)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if teches is not None:
            pulumi.set(__self__, "teches", teches)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="applicationTypeComparisons")
    def application_type_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionApplicationTypeComparison']]:
        return pulumi.get(self, "application_type_comparisons")

    @property
    @pulumi.getter(name="applicationTypes")
    def application_types(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionApplicationType']]:
        return pulumi.get(self, "application_types")

    @property
    @pulumi.getter(name="azureComputeModeComparisons")
    def azure_compute_mode_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureComputeModeComparison']]:
        return pulumi.get(self, "azure_compute_mode_comparisons")

    @property
    @pulumi.getter(name="azureComputeModes")
    def azure_compute_modes(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureComputeMode']]:
        return pulumi.get(self, "azure_compute_modes")

    @property
    @pulumi.getter(name="azureSkuComparisions")
    def azure_sku_comparisions(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureSkuComparision']]:
        return pulumi.get(self, "azure_sku_comparisions")

    @property
    @pulumi.getter(name="azureSkus")
    def azure_skus(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureSkus']]:
        return pulumi.get(self, "azure_skus")

    @property
    @pulumi.getter(name="baseComparisonBasics")
    def base_comparison_basics(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBaseComparisonBasic']]:
        return pulumi.get(self, "base_comparison_basics")

    @property
    @pulumi.getter(name="baseConditionKeys")
    def base_condition_keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBaseConditionKey']]:
        return pulumi.get(self, "base_condition_keys")

    @property
    @pulumi.getter(name="bitnessComparisions")
    def bitness_comparisions(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBitnessComparision']]:
        return pulumi.get(self, "bitness_comparisions")

    @property
    @pulumi.getter
    def bitnesses(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBitness']]:
        return pulumi.get(self, "bitnesses")

    @property
    @pulumi.getter(name="cloudTypeComparisons")
    def cloud_type_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCloudTypeComparison']]:
        return pulumi.get(self, "cloud_type_comparisons")

    @property
    @pulumi.getter(name="cloudTypes")
    def cloud_types(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCloudType']]:
        return pulumi.get(self, "cloud_types")

    @property
    @pulumi.getter
    def comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionComparison']]:
        return pulumi.get(self, "comparisons")

    @property
    @pulumi.getter(name="customApplicationTypeComparisons")
    def custom_application_type_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomApplicationTypeComparison']]:
        return pulumi.get(self, "custom_application_type_comparisons")

    @property
    @pulumi.getter(name="customApplicationTypes")
    def custom_application_types(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomApplicationType']]:
        return pulumi.get(self, "custom_application_types")

    @property
    @pulumi.getter(name="customHostMetadataConditionKeys")
    def custom_host_metadata_condition_keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey']]:
        return pulumi.get(self, "custom_host_metadata_condition_keys")

    @property
    @pulumi.getter(name="customHostMetadatas")
    def custom_host_metadatas(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomHostMetadata']]:
        return pulumi.get(self, "custom_host_metadatas")

    @property
    @pulumi.getter(name="customProcessMetadataConditionKeys")
    def custom_process_metadata_condition_keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey']]:
        return pulumi.get(self, "custom_process_metadata_condition_keys")

    @property
    @pulumi.getter(name="customProcessMetadatas")
    def custom_process_metadatas(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomProcessMetadata']]:
        return pulumi.get(self, "custom_process_metadatas")

    @property
    @pulumi.getter(name="databaseTopologies")
    def database_topologies(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDatabaseTopology']]:
        return pulumi.get(self, "database_topologies")

    @property
    @pulumi.getter(name="databaseTopologyComparisons")
    def database_topology_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDatabaseTopologyComparison']]:
        return pulumi.get(self, "database_topology_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoderComparisons")
    def dcrum_decoder_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDcrumDecoderComparison']]:
        return pulumi.get(self, "dcrum_decoder_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoders")
    def dcrum_decoders(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDcrumDecoder']]:
        return pulumi.get(self, "dcrum_decoders")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionEntity']]:
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="entityIdComparisons")
    def entity_id_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionEntityIdComparison']]:
        return pulumi.get(self, "entity_id_comparisons")

    @property
    @pulumi.getter(name="hostTeches")
    def host_teches(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionHostTech']]:
        return pulumi.get(self, "host_teches")

    @property
    @pulumi.getter(name="hypervisorTypeComparisions")
    def hypervisor_type_comparisions(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionHypervisorTypeComparision']]:
        return pulumi.get(self, "hypervisor_type_comparisions")

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionHypervisor']]:
        return pulumi.get(self, "hypervisors")

    @property
    @pulumi.getter(name="indexedNameComparisons")
    def indexed_name_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedNameComparison']]:
        return pulumi.get(self, "indexed_name_comparisons")

    @property
    @pulumi.getter(name="indexedNames")
    def indexed_names(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedName']]:
        return pulumi.get(self, "indexed_names")

    @property
    @pulumi.getter(name="indexedStringComparisons")
    def indexed_string_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedStringComparison']]:
        return pulumi.get(self, "indexed_string_comparisons")

    @property
    @pulumi.getter(name="indexedStrings")
    def indexed_strings(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedString']]:
        return pulumi.get(self, "indexed_strings")

    @property
    @pulumi.getter(name="indexedTagComparisons")
    def indexed_tag_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedTagComparison']]:
        return pulumi.get(self, "indexed_tag_comparisons")

    @property
    @pulumi.getter(name="indexedTags")
    def indexed_tags(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedTag']]:
        return pulumi.get(self, "indexed_tags")

    @property
    @pulumi.getter(name="integerComparisons")
    def integer_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIntegerComparison']]:
        return pulumi.get(self, "integer_comparisons")

    @property
    @pulumi.getter
    def integers(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionInteger']]:
        return pulumi.get(self, "integers")

    @property
    @pulumi.getter(name="ipaddressComparisons")
    def ipaddress_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIpaddressComparison']]:
        return pulumi.get(self, "ipaddress_comparisons")

    @property
    @pulumi.getter
    def ipaddresses(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIpaddress']]:
        return pulumi.get(self, "ipaddresses")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionKey']]:
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter(name="mobilePlatformComparisons")
    def mobile_platform_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionMobilePlatformComparison']]:
        return pulumi.get(self, "mobile_platform_comparisons")

    @property
    @pulumi.getter(name="mobilePlatforms")
    def mobile_platforms(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionMobilePlatform']]:
        return pulumi.get(self, "mobile_platforms")

    @property
    @pulumi.getter(name="osArches")
    def os_arches(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOsArch']]:
        return pulumi.get(self, "os_arches")

    @property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOsType']]:
        return pulumi.get(self, "os_types")

    @property
    @pulumi.getter(name="osarchitectureComparisons")
    def osarchitecture_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOsarchitectureComparison']]:
        return pulumi.get(self, "osarchitecture_comparisons")

    @property
    @pulumi.getter(name="ostypeComparisons")
    def ostype_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOstypeComparison']]:
        return pulumi.get(self, "ostype_comparisons")

    @property
    @pulumi.getter(name="paasTypeComparisons")
    def paas_type_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionPaasTypeComparison']]:
        return pulumi.get(self, "paas_type_comparisons")

    @property
    @pulumi.getter(name="paasTypes")
    def paas_types(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionPaasType']]:
        return pulumi.get(self, "paas_types")

    @property
    @pulumi.getter(name="processMetadataConditionKeys")
    def process_metadata_condition_keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionProcessMetadataConditionKey']]:
        return pulumi.get(self, "process_metadata_condition_keys")

    @property
    @pulumi.getter(name="processMetadatas")
    def process_metadatas(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionProcessMetadata']]:
        return pulumi.get(self, "process_metadatas")

    @property
    @pulumi.getter(name="serviceTopologies")
    def service_topologies(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceTopology']]:
        return pulumi.get(self, "service_topologies")

    @property
    @pulumi.getter(name="serviceTopologyComparisons")
    def service_topology_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceTopologyComparison']]:
        return pulumi.get(self, "service_topology_comparisons")

    @property
    @pulumi.getter(name="serviceTypeComparisons")
    def service_type_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceTypeComparison']]:
        return pulumi.get(self, "service_type_comparisons")

    @property
    @pulumi.getter(name="serviceTypes")
    def service_types(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceType']]:
        return pulumi.get(self, "service_types")

    @property
    @pulumi.getter(name="simpleHostTechComparisons")
    def simple_host_tech_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSimpleHostTechComparison']]:
        return pulumi.get(self, "simple_host_tech_comparisons")

    @property
    @pulumi.getter(name="simpleTechComparisons")
    def simple_tech_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSimpleTechComparison']]:
        return pulumi.get(self, "simple_tech_comparisons")

    @property
    @pulumi.getter(name="stringComparisons")
    def string_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionStringComparison']]:
        return pulumi.get(self, "string_comparisons")

    @property
    @pulumi.getter(name="stringConditionKeys")
    def string_condition_keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionStringConditionKey']]:
        return pulumi.get(self, "string_condition_keys")

    @property
    @pulumi.getter(name="stringKeys")
    def string_keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionStringKey']]:
        return pulumi.get(self, "string_keys")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionString']]:
        return pulumi.get(self, "strings")

    @property
    @pulumi.getter(name="syntheticEngineTypeComparisons")
    def synthetic_engine_type_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSyntheticEngineTypeComparison']]:
        return pulumi.get(self, "synthetic_engine_type_comparisons")

    @property
    @pulumi.getter(name="syntheticEngines")
    def synthetic_engines(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSyntheticEngine']]:
        return pulumi.get(self, "synthetic_engines")

    @property
    @pulumi.getter(name="tagComparisons")
    def tag_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionTagComparison']]:
        return pulumi.get(self, "tag_comparisons")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionTag']]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def teches(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionTech']]:
        return pulumi.get(self, "teches")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionAzureComputeMode(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionAzureComputeModeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionAzureSkuComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionAzureSkus(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionBaseComparisonBasic(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionBaseConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionBitness(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionBitnessComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCloudType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCloudTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionComparison(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomHostMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionCustomHostMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionCustomHostMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionCustomHostMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ProcessgroupNamingConditionConditionCustomHostMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ProcessgroupNamingConditionConditionCustomHostMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ProcessgroupNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ProcessgroupNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomHostMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionCustomProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionCustomProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionCustomProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomProcessMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionDatabaseTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionDatabaseTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionDcrumDecoder(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionDcrumDecoderComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionEntity(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionEntityIdComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionHostTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionHostTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionHostTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionHostTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionHostTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionHostTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionHostTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ProcessgroupNamingConditionConditionHypervisor(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionHypervisorTypeComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedName(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedNameComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedString(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedStringComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionIndexedTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionIndexedTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionIndexedTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionIndexedTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionInteger(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIntegerComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIpaddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionIpaddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionIpaddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionIpaddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIpaddressComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionIpaddressComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionIpaddressComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionIpaddressComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionMobilePlatform(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionMobilePlatformComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionOsArch(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionOsType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionOsarchitectureComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionOstypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionPaasType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionPaasTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionServiceTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionServiceTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionServiceType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionServiceTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionSimpleHostTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ProcessgroupNamingConditionConditionSimpleTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionSimpleTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionSimpleTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionSimpleTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionSimpleTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionSimpleTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionSimpleTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ProcessgroupNamingConditionConditionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionStringComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionStringComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionStringComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionStringComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionStringConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionStringConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionStringConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionStringConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionStringKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionStringKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionStringKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionStringKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionSyntheticEngine(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionSyntheticEngineTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class QueueManagerAliasQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasQueues":
            suggest = "alias_queues"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueManagerAliasQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueManagerAliasQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueManagerAliasQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias_queues: Optional[Sequence['outputs.QueueManagerAliasQueueAliasQueue']] = None):
        """
        :param Sequence['QueueManagerAliasQueueAliasQueueArgs'] alias_queues: Alias queue definitions for queue manager
        """
        if alias_queues is not None:
            pulumi.set(__self__, "alias_queues", alias_queues)

    @property
    @pulumi.getter(name="aliasQueues")
    def alias_queues(self) -> Optional[Sequence['outputs.QueueManagerAliasQueueAliasQueue']]:
        """
        Alias queue definitions for queue manager
        """
        return pulumi.get(self, "alias_queues")


@pulumi.output_type
class QueueManagerAliasQueueAliasQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasQueueName":
            suggest = "alias_queue_name"
        elif key == "baseQueueName":
            suggest = "base_queue_name"
        elif key == "clusterVisibilities":
            suggest = "cluster_visibilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueManagerAliasQueueAliasQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueManagerAliasQueueAliasQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueManagerAliasQueueAliasQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias_queue_name: str,
                 base_queue_name: str,
                 cluster_visibilities: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "alias_queue_name", alias_queue_name)
        pulumi.set(__self__, "base_queue_name", base_queue_name)
        if cluster_visibilities is not None:
            pulumi.set(__self__, "cluster_visibilities", cluster_visibilities)

    @property
    @pulumi.getter(name="aliasQueueName")
    def alias_queue_name(self) -> str:
        return pulumi.get(self, "alias_queue_name")

    @property
    @pulumi.getter(name="baseQueueName")
    def base_queue_name(self) -> str:
        return pulumi.get(self, "base_queue_name")

    @property
    @pulumi.getter(name="clusterVisibilities")
    def cluster_visibilities(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cluster_visibilities")


@pulumi.output_type
class QueueManagerClusterQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterQueues":
            suggest = "cluster_queues"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueManagerClusterQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueManagerClusterQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueManagerClusterQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_queues: Optional[Sequence['outputs.QueueManagerClusterQueueClusterQueue']] = None):
        """
        :param Sequence['QueueManagerClusterQueueClusterQueueArgs'] cluster_queues: Cluster queue definitions for queue manager
        """
        if cluster_queues is not None:
            pulumi.set(__self__, "cluster_queues", cluster_queues)

    @property
    @pulumi.getter(name="clusterQueues")
    def cluster_queues(self) -> Optional[Sequence['outputs.QueueManagerClusterQueueClusterQueue']]:
        """
        Cluster queue definitions for queue manager
        """
        return pulumi.get(self, "cluster_queues")


@pulumi.output_type
class QueueManagerClusterQueueClusterQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localQueueName":
            suggest = "local_queue_name"
        elif key == "clusterVisibilities":
            suggest = "cluster_visibilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueManagerClusterQueueClusterQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueManagerClusterQueueClusterQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueManagerClusterQueueClusterQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_queue_name: str,
                 cluster_visibilities: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "local_queue_name", local_queue_name)
        if cluster_visibilities is not None:
            pulumi.set(__self__, "cluster_visibilities", cluster_visibilities)

    @property
    @pulumi.getter(name="localQueueName")
    def local_queue_name(self) -> str:
        return pulumi.get(self, "local_queue_name")

    @property
    @pulumi.getter(name="clusterVisibilities")
    def cluster_visibilities(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cluster_visibilities")


@pulumi.output_type
class QueueManagerRemoteQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remoteQueues":
            suggest = "remote_queues"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueManagerRemoteQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueManagerRemoteQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueManagerRemoteQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remote_queues: Optional[Sequence['outputs.QueueManagerRemoteQueueRemoteQueue']] = None):
        """
        :param Sequence['QueueManagerRemoteQueueRemoteQueueArgs'] remote_queues: Remote queue definitions for queue manager
        """
        if remote_queues is not None:
            pulumi.set(__self__, "remote_queues", remote_queues)

    @property
    @pulumi.getter(name="remoteQueues")
    def remote_queues(self) -> Optional[Sequence['outputs.QueueManagerRemoteQueueRemoteQueue']]:
        """
        Remote queue definitions for queue manager
        """
        return pulumi.get(self, "remote_queues")


@pulumi.output_type
class QueueManagerRemoteQueueRemoteQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localQueueName":
            suggest = "local_queue_name"
        elif key == "remoteQueueManager":
            suggest = "remote_queue_manager"
        elif key == "remoteQueueName":
            suggest = "remote_queue_name"
        elif key == "clusterVisibilities":
            suggest = "cluster_visibilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueManagerRemoteQueueRemoteQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueManagerRemoteQueueRemoteQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueManagerRemoteQueueRemoteQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_queue_name: str,
                 remote_queue_manager: str,
                 remote_queue_name: str,
                 cluster_visibilities: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "local_queue_name", local_queue_name)
        pulumi.set(__self__, "remote_queue_manager", remote_queue_manager)
        pulumi.set(__self__, "remote_queue_name", remote_queue_name)
        if cluster_visibilities is not None:
            pulumi.set(__self__, "cluster_visibilities", cluster_visibilities)

    @property
    @pulumi.getter(name="localQueueName")
    def local_queue_name(self) -> str:
        return pulumi.get(self, "local_queue_name")

    @property
    @pulumi.getter(name="remoteQueueManager")
    def remote_queue_manager(self) -> str:
        return pulumi.get(self, "remote_queue_manager")

    @property
    @pulumi.getter(name="remoteQueueName")
    def remote_queue_name(self) -> str:
        return pulumi.get(self, "remote_queue_name")

    @property
    @pulumi.getter(name="clusterVisibilities")
    def cluster_visibilities(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cluster_visibilities")


@pulumi.output_type
class RequestAttributeDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capturingAndStorageLocation":
            suggest = "capturing_and_storage_location"
        elif key == "cicsSdkMethodNodeCondition":
            suggest = "cics_sdk_method_node_condition"
        elif key == "iibLabelMethodNodeCondition":
            suggest = "iib_label_method_node_condition"
        elif key == "iibMethodNodeCondition":
            suggest = "iib_method_node_condition"
        elif key == "iibNodeType":
            suggest = "iib_node_type"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "sessionAttributeTechnology":
            suggest = "session_attribute_technology"
        elif key == "valueProcessing":
            suggest = "value_processing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestAttributeDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestAttributeDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestAttributeDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 source: str,
                 capturing_and_storage_location: Optional[str] = None,
                 cics_sdk_method_node_condition: Optional['outputs.RequestAttributeDataSourceCicsSdkMethodNodeCondition'] = None,
                 iib_label_method_node_condition: Optional['outputs.RequestAttributeDataSourceIibLabelMethodNodeCondition'] = None,
                 iib_method_node_condition: Optional['outputs.RequestAttributeDataSourceIibMethodNodeCondition'] = None,
                 iib_node_type: Optional[str] = None,
                 methods: Optional[Sequence['outputs.RequestAttributeDataSourceMethod']] = None,
                 parameter_name: Optional[str] = None,
                 scope: Optional['outputs.RequestAttributeDataSourceScope'] = None,
                 session_attribute_technology: Optional[str] = None,
                 technology: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value_processing: Optional['outputs.RequestAttributeDataSourceValueProcessing'] = None):
        """
        :param bool enabled: The data source is enabled (`true`) or disabled (`false`)
        :param str source: The source of the attribute to capture. Works in conjunction with **parameterName** or **methods** and **technology**
        :param str capturing_and_storage_location: Specifies the location where the values are captured and stored.  Required if the **source** is one of the following: `GET_PARAMETER`, `URI`, `REQUEST_HEADER`, `RESPONSE_HEADER`.   Not applicable in other cases.   If the **source** value is `REQUEST_HEADER` or `RESPONSE_HEADER`, the `CAPTURE_AND_STORE_ON_BOTH` location is not allowed
        :param 'RequestAttributeDataSourceCicsSdkMethodNodeConditionArgs' cics_sdk_method_node_condition: IBM integration bus label node name condition for which the value is captured
        :param 'RequestAttributeDataSourceIibLabelMethodNodeConditionArgs' iib_label_method_node_condition: IBM integration bus label node name condition for which the value is captured
        :param 'RequestAttributeDataSourceIibMethodNodeConditionArgs' iib_method_node_condition: IBM integration bus label node name condition for which the value is captured
        :param str iib_node_type: The IBM integration bus node type for which the value is captured.  This or `iibMethodNodeCondition` is required if the **source** is: `IIB_NODE`.  Not applicable in other cases
        :param Sequence['RequestAttributeDataSourceMethodArgs'] methods: The method specification if the **source** value is `METHOD_PARAM`.   Not applicable in other cases
        :param str parameter_name: The name of the web request parameter to capture.  Required if the **source** is one of the following: `POST_PARAMETER`, `GET_PARAMETER`, `REQUEST_HEADER`, `RESPONSE_HEADER`, `CUSTOM_ATTRIBUTE`.  Not applicable in other cases
        :param 'RequestAttributeDataSourceScopeArgs' scope: Conditions for data capturing
        :param str session_attribute_technology: The technology of the session attribute to capture if the **source** value is `SESSION_ATTRIBUTE`.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "source", source)
        if capturing_and_storage_location is not None:
            pulumi.set(__self__, "capturing_and_storage_location", capturing_and_storage_location)
        if cics_sdk_method_node_condition is not None:
            pulumi.set(__self__, "cics_sdk_method_node_condition", cics_sdk_method_node_condition)
        if iib_label_method_node_condition is not None:
            pulumi.set(__self__, "iib_label_method_node_condition", iib_label_method_node_condition)
        if iib_method_node_condition is not None:
            pulumi.set(__self__, "iib_method_node_condition", iib_method_node_condition)
        if iib_node_type is not None:
            pulumi.set(__self__, "iib_node_type", iib_node_type)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if parameter_name is not None:
            pulumi.set(__self__, "parameter_name", parameter_name)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if session_attribute_technology is not None:
            pulumi.set(__self__, "session_attribute_technology", session_attribute_technology)
        if technology is not None:
            pulumi.set(__self__, "technology", technology)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value_processing is not None:
            pulumi.set(__self__, "value_processing", value_processing)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The data source is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the attribute to capture. Works in conjunction with **parameterName** or **methods** and **technology**
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="capturingAndStorageLocation")
    def capturing_and_storage_location(self) -> Optional[str]:
        """
        Specifies the location where the values are captured and stored.  Required if the **source** is one of the following: `GET_PARAMETER`, `URI`, `REQUEST_HEADER`, `RESPONSE_HEADER`.   Not applicable in other cases.   If the **source** value is `REQUEST_HEADER` or `RESPONSE_HEADER`, the `CAPTURE_AND_STORE_ON_BOTH` location is not allowed
        """
        return pulumi.get(self, "capturing_and_storage_location")

    @property
    @pulumi.getter(name="cicsSdkMethodNodeCondition")
    def cics_sdk_method_node_condition(self) -> Optional['outputs.RequestAttributeDataSourceCicsSdkMethodNodeCondition']:
        """
        IBM integration bus label node name condition for which the value is captured
        """
        return pulumi.get(self, "cics_sdk_method_node_condition")

    @property
    @pulumi.getter(name="iibLabelMethodNodeCondition")
    def iib_label_method_node_condition(self) -> Optional['outputs.RequestAttributeDataSourceIibLabelMethodNodeCondition']:
        """
        IBM integration bus label node name condition for which the value is captured
        """
        return pulumi.get(self, "iib_label_method_node_condition")

    @property
    @pulumi.getter(name="iibMethodNodeCondition")
    def iib_method_node_condition(self) -> Optional['outputs.RequestAttributeDataSourceIibMethodNodeCondition']:
        """
        IBM integration bus label node name condition for which the value is captured
        """
        return pulumi.get(self, "iib_method_node_condition")

    @property
    @pulumi.getter(name="iibNodeType")
    def iib_node_type(self) -> Optional[str]:
        """
        The IBM integration bus node type for which the value is captured.  This or `iibMethodNodeCondition` is required if the **source** is: `IIB_NODE`.  Not applicable in other cases
        """
        return pulumi.get(self, "iib_node_type")

    @property
    @pulumi.getter
    def methods(self) -> Optional[Sequence['outputs.RequestAttributeDataSourceMethod']]:
        """
        The method specification if the **source** value is `METHOD_PARAM`.   Not applicable in other cases
        """
        return pulumi.get(self, "methods")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        """
        The name of the web request parameter to capture.  Required if the **source** is one of the following: `POST_PARAMETER`, `GET_PARAMETER`, `REQUEST_HEADER`, `RESPONSE_HEADER`, `CUSTOM_ATTRIBUTE`.  Not applicable in other cases
        """
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter
    def scope(self) -> Optional['outputs.RequestAttributeDataSourceScope']:
        """
        Conditions for data capturing
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="sessionAttributeTechnology")
    def session_attribute_technology(self) -> Optional[str]:
        """
        The technology of the session attribute to capture if the **source** value is `SESSION_ATTRIBUTE`.
        """
        return pulumi.get(self, "session_attribute_technology")

    @property
    @pulumi.getter
    def technology(self) -> Optional[str]:
        return pulumi.get(self, "technology")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="valueProcessing")
    def value_processing(self) -> Optional['outputs.RequestAttributeDataSourceValueProcessing']:
        return pulumi.get(self, "value_processing")


@pulumi.output_type
class RequestAttributeDataSourceCicsSdkMethodNodeCondition(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceIibLabelMethodNodeCondition(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceIibMethodNodeCondition(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "argumentIndex":
            suggest = "argument_index"
        elif key == "deepObjectAccess":
            suggest = "deep_object_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestAttributeDataSourceMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestAttributeDataSourceMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestAttributeDataSourceMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture: str,
                 argument_index: Optional[int] = None,
                 deep_object_access: Optional[str] = None,
                 method: Optional['outputs.RequestAttributeDataSourceMethodMethod'] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "capture", capture)
        if argument_index is not None:
            pulumi.set(__self__, "argument_index", argument_index)
        if deep_object_access is not None:
            pulumi.set(__self__, "deep_object_access", deep_object_access)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def capture(self) -> str:
        return pulumi.get(self, "capture")

    @property
    @pulumi.getter(name="argumentIndex")
    def argument_index(self) -> Optional[int]:
        return pulumi.get(self, "argument_index")

    @property
    @pulumi.getter(name="deepObjectAccess")
    def deep_object_access(self) -> Optional[str]:
        return pulumi.get(self, "deep_object_access")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.RequestAttributeDataSourceMethodMethod']:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceMethodMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "methodName":
            suggest = "method_name"
        elif key == "returnType":
            suggest = "return_type"
        elif key == "argumentTypes":
            suggest = "argument_types"
        elif key == "className":
            suggest = "class_name"
        elif key == "fileName":
            suggest = "file_name"
        elif key == "fileNameMatcher":
            suggest = "file_name_matcher"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestAttributeDataSourceMethodMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestAttributeDataSourceMethodMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestAttributeDataSourceMethodMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method_name: str,
                 return_type: str,
                 visibility: str,
                 argument_types: Optional[Sequence[str]] = None,
                 class_name: Optional[str] = None,
                 file_name: Optional[str] = None,
                 file_name_matcher: Optional[str] = None,
                 modifiers: Optional[Sequence[str]] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "method_name", method_name)
        pulumi.set(__self__, "return_type", return_type)
        pulumi.set(__self__, "visibility", visibility)
        if argument_types is not None:
            pulumi.set(__self__, "argument_types", argument_types)
        if class_name is not None:
            pulumi.set(__self__, "class_name", class_name)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if file_name_matcher is not None:
            pulumi.set(__self__, "file_name_matcher", file_name_matcher)
        if modifiers is not None:
            pulumi.set(__self__, "modifiers", modifiers)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="methodName")
    def method_name(self) -> str:
        return pulumi.get(self, "method_name")

    @property
    @pulumi.getter(name="returnType")
    def return_type(self) -> str:
        return pulumi.get(self, "return_type")

    @property
    @pulumi.getter
    def visibility(self) -> str:
        return pulumi.get(self, "visibility")

    @property
    @pulumi.getter(name="argumentTypes")
    def argument_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "argument_types")

    @property
    @pulumi.getter(name="className")
    def class_name(self) -> Optional[str]:
        return pulumi.get(self, "class_name")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[str]:
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter(name="fileNameMatcher")
    def file_name_matcher(self) -> Optional[str]:
        return pulumi.get(self, "file_name_matcher")

    @property
    @pulumi.getter
    def modifiers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "modifiers")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostGroup":
            suggest = "host_group"
        elif key == "processGroup":
            suggest = "process_group"
        elif key == "serviceTechnology":
            suggest = "service_technology"
        elif key == "tagOfProcessGroup":
            suggest = "tag_of_process_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestAttributeDataSourceScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestAttributeDataSourceScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestAttributeDataSourceScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_group: Optional[str] = None,
                 process_group: Optional[str] = None,
                 service_technology: Optional[str] = None,
                 tag_of_process_group: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if host_group is not None:
            pulumi.set(__self__, "host_group", host_group)
        if process_group is not None:
            pulumi.set(__self__, "process_group", process_group)
        if service_technology is not None:
            pulumi.set(__self__, "service_technology", service_technology)
        if tag_of_process_group is not None:
            pulumi.set(__self__, "tag_of_process_group", tag_of_process_group)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="hostGroup")
    def host_group(self) -> Optional[str]:
        return pulumi.get(self, "host_group")

    @property
    @pulumi.getter(name="processGroup")
    def process_group(self) -> Optional[str]:
        return pulumi.get(self, "process_group")

    @property
    @pulumi.getter(name="serviceTechnology")
    def service_technology(self) -> Optional[str]:
        return pulumi.get(self, "service_technology")

    @property
    @pulumi.getter(name="tagOfProcessGroup")
    def tag_of_process_group(self) -> Optional[str]:
        return pulumi.get(self, "tag_of_process_group")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceValueProcessing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extractSubstring":
            suggest = "extract_substring"
        elif key == "splitAt":
            suggest = "split_at"
        elif key == "valueCondition":
            suggest = "value_condition"
        elif key == "valueExtractorRegex":
            suggest = "value_extractor_regex"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestAttributeDataSourceValueProcessing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestAttributeDataSourceValueProcessing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestAttributeDataSourceValueProcessing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extract_substring: Optional['outputs.RequestAttributeDataSourceValueProcessingExtractSubstring'] = None,
                 split_at: Optional[str] = None,
                 trim: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value_condition: Optional['outputs.RequestAttributeDataSourceValueProcessingValueCondition'] = None,
                 value_extractor_regex: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if extract_substring is not None:
            pulumi.set(__self__, "extract_substring", extract_substring)
        if split_at is not None:
            pulumi.set(__self__, "split_at", split_at)
        if trim is not None:
            pulumi.set(__self__, "trim", trim)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value_condition is not None:
            pulumi.set(__self__, "value_condition", value_condition)
        if value_extractor_regex is not None:
            pulumi.set(__self__, "value_extractor_regex", value_extractor_regex)

    @property
    @pulumi.getter(name="extractSubstring")
    def extract_substring(self) -> Optional['outputs.RequestAttributeDataSourceValueProcessingExtractSubstring']:
        return pulumi.get(self, "extract_substring")

    @property
    @pulumi.getter(name="splitAt")
    def split_at(self) -> Optional[str]:
        return pulumi.get(self, "split_at")

    @property
    @pulumi.getter
    def trim(self) -> Optional[bool]:
        return pulumi.get(self, "trim")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="valueCondition")
    def value_condition(self) -> Optional['outputs.RequestAttributeDataSourceValueProcessingValueCondition']:
        return pulumi.get(self, "value_condition")

    @property
    @pulumi.getter(name="valueExtractorRegex")
    def value_extractor_regex(self) -> Optional[str]:
        return pulumi.get(self, "value_extractor_regex")


@pulumi.output_type
class RequestAttributeDataSourceValueProcessingExtractSubstring(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDelimiter":
            suggest = "end_delimiter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestAttributeDataSourceValueProcessingExtractSubstring. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestAttributeDataSourceValueProcessingExtractSubstring.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestAttributeDataSourceValueProcessingExtractSubstring.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: str,
                 position: str,
                 end_delimiter: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "position", position)
        if end_delimiter is not None:
            pulumi.set(__self__, "end_delimiter", end_delimiter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def delimiter(self) -> str:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter
    def position(self) -> str:
        return pulumi.get(self, "position")

    @property
    @pulumi.getter(name="endDelimiter")
    def end_delimiter(self) -> Optional[str]:
        return pulumi.get(self, "end_delimiter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceValueProcessingValueCondition(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestNamingConditions(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.RequestNamingConditionsCondition']] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.RequestNamingConditionsCondition']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class RequestNamingConditionsCondition(dict):
    def __init__(__self__, *,
                 attribute: str,
                 comparison: 'outputs.RequestNamingConditionsConditionComparison',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "comparison", comparison)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def comparison(self) -> 'outputs.RequestNamingConditionsConditionComparison':
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestNamingConditionsConditionComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "esbInputNodeType":
            suggest = "esb_input_node_type"
        elif key == "failedState":
            suggest = "failed_state"
        elif key == "failureReason":
            suggest = "failure_reason"
        elif key == "fastString":
            suggest = "fast_string"
        elif key == "flawState":
            suggest = "flaw_state"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "httpStatusClass":
            suggest = "http_status_class"
        elif key == "iibInputNodeType":
            suggest = "iib_input_node_type"
        elif key == "numberRequestAttribute":
            suggest = "number_request_attribute"
        elif key == "serviceType":
            suggest = "service_type"
        elif key == "stringRequestAttribute":
            suggest = "string_request_attribute"
        elif key == "zosCallType":
            suggest = "zos_call_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boolean: Optional['outputs.RequestNamingConditionsConditionComparisonBoolean'] = None,
                 esb_input_node_type: Optional['outputs.RequestNamingConditionsConditionComparisonEsbInputNodeType'] = None,
                 failed_state: Optional['outputs.RequestNamingConditionsConditionComparisonFailedState'] = None,
                 failure_reason: Optional['outputs.RequestNamingConditionsConditionComparisonFailureReason'] = None,
                 fast_string: Optional['outputs.RequestNamingConditionsConditionComparisonFastString'] = None,
                 flaw_state: Optional['outputs.RequestNamingConditionsConditionComparisonFlawState'] = None,
                 generic: Optional['outputs.RequestNamingConditionsConditionComparisonGeneric'] = None,
                 http_method: Optional['outputs.RequestNamingConditionsConditionComparisonHttpMethod'] = None,
                 http_status_class: Optional['outputs.RequestNamingConditionsConditionComparisonHttpStatusClass'] = None,
                 iib_input_node_type: Optional['outputs.RequestNamingConditionsConditionComparisonIibInputNodeType'] = None,
                 negate: Optional[bool] = None,
                 number: Optional['outputs.RequestNamingConditionsConditionComparisonNumber'] = None,
                 number_request_attribute: Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttribute'] = None,
                 service_type: Optional['outputs.RequestNamingConditionsConditionComparisonServiceType'] = None,
                 string: Optional['outputs.RequestNamingConditionsConditionComparisonString'] = None,
                 string_request_attribute: Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttribute'] = None,
                 tag: Optional['outputs.RequestNamingConditionsConditionComparisonTag'] = None,
                 zos_call_type: Optional['outputs.RequestNamingConditionsConditionComparisonZosCallType'] = None):
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if esb_input_node_type is not None:
            pulumi.set(__self__, "esb_input_node_type", esb_input_node_type)
        if failed_state is not None:
            pulumi.set(__self__, "failed_state", failed_state)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if fast_string is not None:
            pulumi.set(__self__, "fast_string", fast_string)
        if flaw_state is not None:
            pulumi.set(__self__, "flaw_state", flaw_state)
        if generic is not None:
            pulumi.set(__self__, "generic", generic)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if http_status_class is not None:
            pulumi.set(__self__, "http_status_class", http_status_class)
        if iib_input_node_type is not None:
            pulumi.set(__self__, "iib_input_node_type", iib_input_node_type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if number_request_attribute is not None:
            pulumi.set(__self__, "number_request_attribute", number_request_attribute)
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_request_attribute is not None:
            pulumi.set(__self__, "string_request_attribute", string_request_attribute)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if zos_call_type is not None:
            pulumi.set(__self__, "zos_call_type", zos_call_type)

    @property
    @pulumi.getter
    def boolean(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonBoolean']:
        return pulumi.get(self, "boolean")

    @property
    @pulumi.getter(name="esbInputNodeType")
    def esb_input_node_type(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonEsbInputNodeType']:
        return pulumi.get(self, "esb_input_node_type")

    @property
    @pulumi.getter(name="failedState")
    def failed_state(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonFailedState']:
        return pulumi.get(self, "failed_state")

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonFailureReason']:
        return pulumi.get(self, "failure_reason")

    @property
    @pulumi.getter(name="fastString")
    def fast_string(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonFastString']:
        return pulumi.get(self, "fast_string")

    @property
    @pulumi.getter(name="flawState")
    def flaw_state(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonFlawState']:
        return pulumi.get(self, "flaw_state")

    @property
    @pulumi.getter
    def generic(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonGeneric']:
        return pulumi.get(self, "generic")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonHttpMethod']:
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter(name="httpStatusClass")
    def http_status_class(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonHttpStatusClass']:
        return pulumi.get(self, "http_status_class")

    @property
    @pulumi.getter(name="iibInputNodeType")
    def iib_input_node_type(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonIibInputNodeType']:
        return pulumi.get(self, "iib_input_node_type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def number(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonNumber']:
        return pulumi.get(self, "number")

    @property
    @pulumi.getter(name="numberRequestAttribute")
    def number_request_attribute(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttribute']:
        return pulumi.get(self, "number_request_attribute")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonServiceType']:
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def string(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonString']:
        return pulumi.get(self, "string")

    @property
    @pulumi.getter(name="stringRequestAttribute")
    def string_request_attribute(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttribute']:
        return pulumi.get(self, "string_request_attribute")

    @property
    @pulumi.getter
    def tag(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonTag']:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="zosCallType")
    def zos_call_type(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonZosCallType']:
        return pulumi.get(self, "zos_call_type")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonBoolean(dict):
    def __init__(__self__, *,
                 value: bool,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 values: Optional[Sequence[bool]] = None):
        pulumi.set(__self__, "value", value)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[bool]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonEsbInputNodeType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonFailedState(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonFailureReason(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonFastString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonFastString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonFastString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonFastString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonFlawState(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonGeneric(dict):
    def __init__(__self__, *,
                 type: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonHttpMethod(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonHttpStatusClass(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonIibInputNodeType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonNumber(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[float] = None,
                 values: Optional[Sequence[float]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonNumberRequestAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"
        elif key == "matchOnChildCalls":
            suggest = "match_on_child_calls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonNumberRequestAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonNumberRequestAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonNumberRequestAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_attribute: str,
                 match_on_child_calls: Optional[bool] = None,
                 operator: Optional[str] = None,
                 source: Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSource'] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[float] = None,
                 values: Optional[Sequence[float]] = None):
        pulumi.set(__self__, "request_attribute", request_attribute)
        if match_on_child_calls is not None:
            pulumi.set(__self__, "match_on_child_calls", match_on_child_calls)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> str:
        return pulumi.get(self, "request_attribute")

    @property
    @pulumi.getter(name="matchOnChildCalls")
    def match_on_child_calls(self) -> Optional[bool]:
        return pulumi.get(self, "match_on_child_calls")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSource']:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonNumberRequestAttributeSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZone":
            suggest = "management_zone"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonNumberRequestAttributeSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonNumberRequestAttributeSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonNumberRequestAttributeSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zone: Optional[str] = None,
                 service_tag: Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag'] = None,
                 unknowns: Optional[str] = None):
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag']:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 tag_key: Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey'] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey']:
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey(dict):
    def __init__(__self__, *,
                 context: Optional[str] = None,
                 key: Optional[str] = None):
        if context is not None:
            pulumi.set(__self__, "context", context)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonServiceType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonStringRequestAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchOnChildCalls":
            suggest = "match_on_child_calls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonStringRequestAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonStringRequestAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonStringRequestAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_attribute: str,
                 case_sensitive: Optional[bool] = None,
                 match_on_child_calls: Optional[bool] = None,
                 operator: Optional[str] = None,
                 source: Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSource'] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "request_attribute", request_attribute)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_on_child_calls is not None:
            pulumi.set(__self__, "match_on_child_calls", match_on_child_calls)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> str:
        return pulumi.get(self, "request_attribute")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchOnChildCalls")
    def match_on_child_calls(self) -> Optional[bool]:
        return pulumi.get(self, "match_on_child_calls")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSource']:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonStringRequestAttributeSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZone":
            suggest = "management_zone"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonStringRequestAttributeSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonStringRequestAttributeSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonStringRequestAttributeSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zone: Optional[str] = None,
                 service_tag: Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag'] = None,
                 unknowns: Optional[str] = None):
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag']:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 tag_key: Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey'] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey']:
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey(dict):
    def __init__(__self__, *,
                 context: Optional[str] = None,
                 key: Optional[str] = None):
        if context is not None:
            pulumi.set(__self__, "context", context)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonTag(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.RequestNamingConditionsConditionComparisonTagValue'] = None,
                 values: Optional['outputs.RequestNamingConditionsConditionComparisonTagValues'] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonTagValue']:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonTagValues']:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonTagValues(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence['outputs.RequestNamingConditionsConditionComparisonTagValuesValue']] = None):
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.RequestNamingConditionsConditionComparisonTagValuesValue']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonTagValuesValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonZosCallType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingPlaceholders(dict):
    def __init__(__self__, *,
                 placeholders: Optional[Sequence['outputs.RequestNamingPlaceholdersPlaceholder']] = None):
        if placeholders is not None:
            pulumi.set(__self__, "placeholders", placeholders)

    @property
    @pulumi.getter
    def placeholders(self) -> Optional[Sequence['outputs.RequestNamingPlaceholdersPlaceholder']]:
        return pulumi.get(self, "placeholders")


@pulumi.output_type
class RequestNamingPlaceholdersPlaceholder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delimiterOrRegex":
            suggest = "delimiter_or_regex"
        elif key == "endDelimiter":
            suggest = "end_delimiter"
        elif key == "requestAttribute":
            suggest = "request_attribute"
        elif key == "useFromChildCalls":
            suggest = "use_from_child_calls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingPlaceholdersPlaceholder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingPlaceholdersPlaceholder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingPlaceholdersPlaceholder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 kind: str,
                 name: str,
                 aggregation: Optional[str] = None,
                 delimiter_or_regex: Optional[str] = None,
                 end_delimiter: Optional[str] = None,
                 normalization: Optional[str] = None,
                 request_attribute: Optional[str] = None,
                 source: Optional['outputs.RequestNamingPlaceholdersPlaceholderSource'] = None,
                 unknowns: Optional[str] = None,
                 use_from_child_calls: Optional[bool] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if delimiter_or_regex is not None:
            pulumi.set(__self__, "delimiter_or_regex", delimiter_or_regex)
        if end_delimiter is not None:
            pulumi.set(__self__, "end_delimiter", end_delimiter)
        if normalization is not None:
            pulumi.set(__self__, "normalization", normalization)
        if request_attribute is not None:
            pulumi.set(__self__, "request_attribute", request_attribute)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if use_from_child_calls is not None:
            pulumi.set(__self__, "use_from_child_calls", use_from_child_calls)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def kind(self) -> str:
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="delimiterOrRegex")
    def delimiter_or_regex(self) -> Optional[str]:
        return pulumi.get(self, "delimiter_or_regex")

    @property
    @pulumi.getter(name="endDelimiter")
    def end_delimiter(self) -> Optional[str]:
        return pulumi.get(self, "end_delimiter")

    @property
    @pulumi.getter
    def normalization(self) -> Optional[str]:
        return pulumi.get(self, "normalization")

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> Optional[str]:
        return pulumi.get(self, "request_attribute")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.RequestNamingPlaceholdersPlaceholderSource']:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="useFromChildCalls")
    def use_from_child_calls(self) -> Optional[bool]:
        return pulumi.get(self, "use_from_child_calls")


@pulumi.output_type
class RequestNamingPlaceholdersPlaceholderSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZone":
            suggest = "management_zone"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingPlaceholdersPlaceholderSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingPlaceholdersPlaceholderSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingPlaceholdersPlaceholderSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zone: Optional[str] = None,
                 service_tag: Optional['outputs.RequestNamingPlaceholdersPlaceholderSourceServiceTag'] = None,
                 unknowns: Optional[str] = None):
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional['outputs.RequestNamingPlaceholdersPlaceholderSourceServiceTag']:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestNamingPlaceholdersPlaceholderSourceServiceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingPlaceholdersPlaceholderSourceServiceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingPlaceholdersPlaceholderSourceServiceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingPlaceholdersPlaceholderSourceServiceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 tag_key: Optional['outputs.RequestNamingPlaceholdersPlaceholderSourceServiceTagTagKey'] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional['outputs.RequestNamingPlaceholdersPlaceholderSourceServiceTagTagKey']:
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RequestNamingPlaceholdersPlaceholderSourceServiceTagTagKey(dict):
    def __init__(__self__, *,
                 context: Optional[str] = None,
                 key: Optional[str] = None):
        if context is not None:
            pulumi.set(__self__, "context", context)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")


@pulumi.output_type
class ResourceAttributesKeys(dict):
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.ResourceAttributesKeysRule']] = None):
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.ResourceAttributesKeysRule']]:
        return pulumi.get(self, "rules")


@pulumi.output_type
class ResourceAttributesKeysRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeKey":
            suggest = "attribute_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAttributesKeysRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAttributesKeysRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAttributesKeysRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_key: str,
                 enabled: bool,
                 masking: str):
        pulumi.set(__self__, "attribute_key", attribute_key)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "masking", masking)

    @property
    @pulumi.getter(name="attributeKey")
    def attribute_key(self) -> str:
        return pulumi.get(self, "attribute_key")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def masking(self) -> str:
        return pulumi.get(self, "masking")


@pulumi.output_type
class RumProviderBreakdownDomainNamePatternList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainNamePatterns":
            suggest = "domain_name_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RumProviderBreakdownDomainNamePatternList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RumProviderBreakdownDomainNamePatternList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RumProviderBreakdownDomainNamePatternList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name_patterns: Sequence['outputs.RumProviderBreakdownDomainNamePatternListDomainNamePattern']):
        pulumi.set(__self__, "domain_name_patterns", domain_name_patterns)

    @property
    @pulumi.getter(name="domainNamePatterns")
    def domain_name_patterns(self) -> Sequence['outputs.RumProviderBreakdownDomainNamePatternListDomainNamePattern']:
        return pulumi.get(self, "domain_name_patterns")


@pulumi.output_type
class RumProviderBreakdownDomainNamePatternListDomainNamePattern(dict):
    def __init__(__self__, *,
                 pattern: str):
        pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def pattern(self) -> str:
        return pulumi.get(self, "pattern")


@pulumi.output_type
class ServiceAnomaliesFailureRates(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.ServiceAnomaliesFailureRatesAuto'] = None,
                 thresholds: Optional['outputs.ServiceAnomaliesFailureRatesThresholds'] = None):
        """
        :param 'ServiceAnomaliesFailureRatesAutoArgs' auto: Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
        :param 'ServiceAnomaliesFailureRatesThresholdsArgs' thresholds: Fixed thresholds for failure rate increase detection
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.ServiceAnomaliesFailureRatesAuto']:
        """
        Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.ServiceAnomaliesFailureRatesThresholds']:
        """
        Fixed thresholds for failure rate increase detection
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class ServiceAnomaliesFailureRatesAuto(dict):
    def __init__(__self__, *,
                 absolute: int,
                 relative: int,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "absolute", absolute)
        pulumi.set(__self__, "relative", relative)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def absolute(self) -> int:
        return pulumi.get(self, "absolute")

    @property
    @pulumi.getter
    def relative(self) -> int:
        return pulumi.get(self, "relative")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceAnomaliesFailureRatesThresholds(dict):
    def __init__(__self__, *,
                 sensitivity: str,
                 threshold: int,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold", threshold)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceAnomaliesLoad(dict):
    def __init__(__self__, *,
                 drops: Optional['outputs.ServiceAnomaliesLoadDrops'] = None,
                 spikes: Optional['outputs.ServiceAnomaliesLoadSpikes'] = None):
        """
        :param 'ServiceAnomaliesLoadDropsArgs' drops: The configuration of traffic drops detection
        :param 'ServiceAnomaliesLoadSpikesArgs' spikes: The configuration of traffic spikes detection
        """
        if drops is not None:
            pulumi.set(__self__, "drops", drops)
        if spikes is not None:
            pulumi.set(__self__, "spikes", spikes)

    @property
    @pulumi.getter
    def drops(self) -> Optional['outputs.ServiceAnomaliesLoadDrops']:
        """
        The configuration of traffic drops detection
        """
        return pulumi.get(self, "drops")

    @property
    @pulumi.getter
    def spikes(self) -> Optional['outputs.ServiceAnomaliesLoadSpikes']:
        """
        The configuration of traffic spikes detection
        """
        return pulumi.get(self, "spikes")


@pulumi.output_type
class ServiceAnomaliesLoadDrops(dict):
    def __init__(__self__, *,
                 minutes: Optional[int] = None,
                 percent: Optional[int] = None):
        """
        :param int minutes: Alert if the service stays in abnormal state for at least *X* minutes
        :param int percent: Alert if the observed load is more than *X* % of the expected value
        """
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        Alert if the service stays in abnormal state for at least *X* minutes
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        """
        Alert if the observed load is more than *X* % of the expected value
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class ServiceAnomaliesLoadSpikes(dict):
    def __init__(__self__, *,
                 minutes: Optional[int] = None,
                 percent: Optional[int] = None,
                 unknowns: Optional[str] = None):
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        return pulumi.get(self, "percent")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceAnomaliesResponseTimes(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.ServiceAnomaliesResponseTimesAuto'] = None,
                 thresholds: Optional['outputs.ServiceAnomaliesResponseTimesThresholds'] = None):
        """
        :param 'ServiceAnomaliesResponseTimesAutoArgs' auto: Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
        :param 'ServiceAnomaliesResponseTimesThresholdsArgs' thresholds: Fixed thresholds for response time degradation detection
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.ServiceAnomaliesResponseTimesAuto']:
        """
        Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.ServiceAnomaliesResponseTimesThresholds']:
        """
        Fixed thresholds for response time degradation detection
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class ServiceAnomaliesResponseTimesAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestMilliseconds":
            suggest = "slowest_milliseconds"
        elif key == "slowestPercent":
            suggest = "slowest_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesResponseTimesAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesResponseTimesAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesResponseTimesAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load: str,
                 milliseconds: int,
                 percent: int,
                 slowest_milliseconds: int,
                 slowest_percent: int,
                 unknowns: Optional[str] = None):
        """
        :param str load: The configuration of load spikes detection. Detecting load spikes will be disabled if this block is omitted.
        """
        pulumi.set(__self__, "load", load)
        pulumi.set(__self__, "milliseconds", milliseconds)
        pulumi.set(__self__, "percent", percent)
        pulumi.set(__self__, "slowest_milliseconds", slowest_milliseconds)
        pulumi.set(__self__, "slowest_percent", slowest_percent)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def load(self) -> str:
        """
        The configuration of load spikes detection. Detecting load spikes will be disabled if this block is omitted.
        """
        return pulumi.get(self, "load")

    @property
    @pulumi.getter
    def milliseconds(self) -> int:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def percent(self) -> int:
        return pulumi.get(self, "percent")

    @property
    @pulumi.getter(name="slowestMilliseconds")
    def slowest_milliseconds(self) -> int:
        return pulumi.get(self, "slowest_milliseconds")

    @property
    @pulumi.getter(name="slowestPercent")
    def slowest_percent(self) -> int:
        return pulumi.get(self, "slowest_percent")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceAnomaliesResponseTimesThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestMilliseconds":
            suggest = "slowest_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesResponseTimesThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesResponseTimesThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesResponseTimesThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load: str,
                 milliseconds: int,
                 sensitivity: str,
                 slowest_milliseconds: int,
                 unknowns: Optional[str] = None):
        """
        :param str load: The configuration of load spikes detection. Detecting load spikes will be disabled if this block is omitted.
        """
        pulumi.set(__self__, "load", load)
        pulumi.set(__self__, "milliseconds", milliseconds)
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "slowest_milliseconds", slowest_milliseconds)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def load(self) -> str:
        """
        The configuration of load spikes detection. Detecting load spikes will be disabled if this block is omitted.
        """
        return pulumi.get(self, "load")

    @property
    @pulumi.getter
    def milliseconds(self) -> int:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter(name="slowestMilliseconds")
    def slowest_milliseconds(self) -> int:
        return pulumi.get(self, "slowest_milliseconds")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceAnomaliesV2FailureRate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDetection":
            suggest = "auto_detection"
        elif key == "detectionMode":
            suggest = "detection_mode"
        elif key == "fixedDetection":
            suggest = "fixed_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2FailureRate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2FailureRate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2FailureRate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 auto_detection: Optional['outputs.ServiceAnomaliesV2FailureRateAutoDetection'] = None,
                 detection_mode: Optional[str] = None,
                 fixed_detection: Optional['outputs.ServiceAnomaliesV2FailureRateFixedDetection'] = None):
        """
        :param bool enabled: Detect increases in failure rate
        :param 'ServiceAnomaliesV2FailureRateAutoDetectionArgs' auto_detection: . Alert if the percentage of failing service calls increases by **both** the absolute and relative thresholds:
        :param str detection_mode: Detection mode for increases in failure rate
        :param 'ServiceAnomaliesV2FailureRateFixedDetectionArgs' fixed_detection: . Alert if a given failure rate is exceeded during any 5-minute-period
        """
        pulumi.set(__self__, "enabled", enabled)
        if auto_detection is not None:
            pulumi.set(__self__, "auto_detection", auto_detection)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if fixed_detection is not None:
            pulumi.set(__self__, "fixed_detection", fixed_detection)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect increases in failure rate
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="autoDetection")
    def auto_detection(self) -> Optional['outputs.ServiceAnomaliesV2FailureRateAutoDetection']:
        """
        . Alert if the percentage of failing service calls increases by **both** the absolute and relative thresholds:
        """
        return pulumi.get(self, "auto_detection")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for increases in failure rate
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter(name="fixedDetection")
    def fixed_detection(self) -> Optional['outputs.ServiceAnomaliesV2FailureRateFixedDetection']:
        """
        . Alert if a given failure rate is exceeded during any 5-minute-period
        """
        return pulumi.get(self, "fixed_detection")


@pulumi.output_type
class ServiceAnomaliesV2FailureRateAutoDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "absoluteIncrease":
            suggest = "absolute_increase"
        elif key == "overAlertingProtection":
            suggest = "over_alerting_protection"
        elif key == "relativeIncrease":
            suggest = "relative_increase"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2FailureRateAutoDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2FailureRateAutoDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2FailureRateAutoDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 absolute_increase: float,
                 over_alerting_protection: 'outputs.ServiceAnomaliesV2FailureRateAutoDetectionOverAlertingProtection',
                 relative_increase: float):
        pulumi.set(__self__, "absolute_increase", absolute_increase)
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "relative_increase", relative_increase)

    @property
    @pulumi.getter(name="absoluteIncrease")
    def absolute_increase(self) -> float:
        return pulumi.get(self, "absolute_increase")

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.ServiceAnomaliesV2FailureRateAutoDetectionOverAlertingProtection':
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter(name="relativeIncrease")
    def relative_increase(self) -> float:
        return pulumi.get(self, "relative_increase")


@pulumi.output_type
class ServiceAnomaliesV2FailureRateAutoDetectionOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"
        elif key == "requestsPerMinute":
            suggest = "requests_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2FailureRateAutoDetectionOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2FailureRateAutoDetectionOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2FailureRateAutoDetectionOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_abnormal_state: int,
                 requests_per_minute: float):
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)
        pulumi.set(__self__, "requests_per_minute", requests_per_minute)

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> int:
        return pulumi.get(self, "minutes_abnormal_state")

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> float:
        return pulumi.get(self, "requests_per_minute")


@pulumi.output_type
class ServiceAnomaliesV2FailureRateFixedDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overAlertingProtection":
            suggest = "over_alerting_protection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2FailureRateFixedDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2FailureRateFixedDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2FailureRateFixedDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 over_alerting_protection: 'outputs.ServiceAnomaliesV2FailureRateFixedDetectionOverAlertingProtection',
                 sensitivity: str,
                 threshold: float):
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.ServiceAnomaliesV2FailureRateFixedDetectionOverAlertingProtection':
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class ServiceAnomaliesV2FailureRateFixedDetectionOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"
        elif key == "requestsPerMinute":
            suggest = "requests_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2FailureRateFixedDetectionOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2FailureRateFixedDetectionOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2FailureRateFixedDetectionOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_abnormal_state: int,
                 requests_per_minute: float):
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)
        pulumi.set(__self__, "requests_per_minute", requests_per_minute)

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> int:
        return pulumi.get(self, "minutes_abnormal_state")

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> float:
        return pulumi.get(self, "requests_per_minute")


@pulumi.output_type
class ServiceAnomaliesV2LoadDrops(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadDropPercent":
            suggest = "load_drop_percent"
        elif key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2LoadDrops. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2LoadDrops.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2LoadDrops.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 load_drop_percent: Optional[float] = None,
                 minutes_abnormal_state: Optional[int] = None):
        """
        :param bool enabled: Detect service load drops
        :param float load_drop_percent: Threshold
        :param int minutes_abnormal_state: Time span
        """
        pulumi.set(__self__, "enabled", enabled)
        if load_drop_percent is not None:
            pulumi.set(__self__, "load_drop_percent", load_drop_percent)
        if minutes_abnormal_state is not None:
            pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect service load drops
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="loadDropPercent")
    def load_drop_percent(self) -> Optional[float]:
        """
        Threshold
        """
        return pulumi.get(self, "load_drop_percent")

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> Optional[int]:
        """
        Time span
        """
        return pulumi.get(self, "minutes_abnormal_state")


@pulumi.output_type
class ServiceAnomaliesV2LoadSpikes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadSpikePercent":
            suggest = "load_spike_percent"
        elif key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2LoadSpikes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2LoadSpikes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2LoadSpikes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 load_spike_percent: Optional[float] = None,
                 minutes_abnormal_state: Optional[int] = None):
        """
        :param bool enabled: Detect service load spikes
        :param float load_spike_percent: Threshold
        :param int minutes_abnormal_state: Time span
        """
        pulumi.set(__self__, "enabled", enabled)
        if load_spike_percent is not None:
            pulumi.set(__self__, "load_spike_percent", load_spike_percent)
        if minutes_abnormal_state is not None:
            pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect service load spikes
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="loadSpikePercent")
    def load_spike_percent(self) -> Optional[float]:
        """
        Threshold
        """
        return pulumi.get(self, "load_spike_percent")

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> Optional[int]:
        """
        Time span
        """
        return pulumi.get(self, "minutes_abnormal_state")


@pulumi.output_type
class ServiceAnomaliesV2ResponseTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDetection":
            suggest = "auto_detection"
        elif key == "detectionMode":
            suggest = "detection_mode"
        elif key == "fixedDetection":
            suggest = "fixed_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2ResponseTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2ResponseTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2ResponseTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 auto_detection: Optional['outputs.ServiceAnomaliesV2ResponseTimeAutoDetection'] = None,
                 detection_mode: Optional[str] = None,
                 fixed_detection: Optional['outputs.ServiceAnomaliesV2ResponseTimeFixedDetection'] = None):
        """
        :param bool enabled: Detect response time degradations
        :param 'ServiceAnomaliesV2ResponseTimeAutoDetectionArgs' auto_detection: No documentation available
        :param str detection_mode: Detection mode for response time degradations
        :param 'ServiceAnomaliesV2ResponseTimeFixedDetectionArgs' fixed_detection: No documentation available
        """
        pulumi.set(__self__, "enabled", enabled)
        if auto_detection is not None:
            pulumi.set(__self__, "auto_detection", auto_detection)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if fixed_detection is not None:
            pulumi.set(__self__, "fixed_detection", fixed_detection)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Detect response time degradations
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="autoDetection")
    def auto_detection(self) -> Optional['outputs.ServiceAnomaliesV2ResponseTimeAutoDetection']:
        """
        No documentation available
        """
        return pulumi.get(self, "auto_detection")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Detection mode for response time degradations
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter(name="fixedDetection")
    def fixed_detection(self) -> Optional['outputs.ServiceAnomaliesV2ResponseTimeFixedDetection']:
        """
        No documentation available
        """
        return pulumi.get(self, "fixed_detection")


@pulumi.output_type
class ServiceAnomaliesV2ResponseTimeAutoDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overAlertingProtection":
            suggest = "over_alerting_protection"
        elif key == "responseTimeAll":
            suggest = "response_time_all"
        elif key == "responseTimeSlowest":
            suggest = "response_time_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2ResponseTimeAutoDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2ResponseTimeAutoDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2ResponseTimeAutoDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 over_alerting_protection: 'outputs.ServiceAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection',
                 response_time_all: 'outputs.ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll',
                 response_time_slowest: 'outputs.ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest'):
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "response_time_all", response_time_all)
        pulumi.set(__self__, "response_time_slowest", response_time_slowest)

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.ServiceAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection':
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter(name="responseTimeAll")
    def response_time_all(self) -> 'outputs.ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll':
        return pulumi.get(self, "response_time_all")

    @property
    @pulumi.getter(name="responseTimeSlowest")
    def response_time_slowest(self) -> 'outputs.ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest':
        return pulumi.get(self, "response_time_slowest")


@pulumi.output_type
class ServiceAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"
        elif key == "requestsPerMinute":
            suggest = "requests_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_abnormal_state: int,
                 requests_per_minute: float):
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)
        pulumi.set(__self__, "requests_per_minute", requests_per_minute)

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> int:
        return pulumi.get(self, "minutes_abnormal_state")

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> float:
        return pulumi.get(self, "requests_per_minute")


@pulumi.output_type
class ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "degradationMilliseconds":
            suggest = "degradation_milliseconds"
        elif key == "degradationPercent":
            suggest = "degradation_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 degradation_milliseconds: float,
                 degradation_percent: float):
        pulumi.set(__self__, "degradation_milliseconds", degradation_milliseconds)
        pulumi.set(__self__, "degradation_percent", degradation_percent)

    @property
    @pulumi.getter(name="degradationMilliseconds")
    def degradation_milliseconds(self) -> float:
        return pulumi.get(self, "degradation_milliseconds")

    @property
    @pulumi.getter(name="degradationPercent")
    def degradation_percent(self) -> float:
        return pulumi.get(self, "degradation_percent")


@pulumi.output_type
class ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestDegradationMilliseconds":
            suggest = "slowest_degradation_milliseconds"
        elif key == "slowestDegradationPercent":
            suggest = "slowest_degradation_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slowest_degradation_milliseconds: float,
                 slowest_degradation_percent: float):
        pulumi.set(__self__, "slowest_degradation_milliseconds", slowest_degradation_milliseconds)
        pulumi.set(__self__, "slowest_degradation_percent", slowest_degradation_percent)

    @property
    @pulumi.getter(name="slowestDegradationMilliseconds")
    def slowest_degradation_milliseconds(self) -> float:
        return pulumi.get(self, "slowest_degradation_milliseconds")

    @property
    @pulumi.getter(name="slowestDegradationPercent")
    def slowest_degradation_percent(self) -> float:
        return pulumi.get(self, "slowest_degradation_percent")


@pulumi.output_type
class ServiceAnomaliesV2ResponseTimeFixedDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overAlertingProtection":
            suggest = "over_alerting_protection"
        elif key == "responseTimeAll":
            suggest = "response_time_all"
        elif key == "responseTimeSlowest":
            suggest = "response_time_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2ResponseTimeFixedDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2ResponseTimeFixedDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2ResponseTimeFixedDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 over_alerting_protection: 'outputs.ServiceAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection',
                 response_time_all: 'outputs.ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll',
                 response_time_slowest: 'outputs.ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest',
                 sensitivity: str):
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "response_time_all", response_time_all)
        pulumi.set(__self__, "response_time_slowest", response_time_slowest)
        pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.ServiceAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection':
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter(name="responseTimeAll")
    def response_time_all(self) -> 'outputs.ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll':
        return pulumi.get(self, "response_time_all")

    @property
    @pulumi.getter(name="responseTimeSlowest")
    def response_time_slowest(self) -> 'outputs.ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest':
        return pulumi.get(self, "response_time_slowest")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class ServiceAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"
        elif key == "requestsPerMinute":
            suggest = "requests_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_abnormal_state: int,
                 requests_per_minute: float):
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)
        pulumi.set(__self__, "requests_per_minute", requests_per_minute)

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> int:
        return pulumi.get(self, "minutes_abnormal_state")

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> float:
        return pulumi.get(self, "requests_per_minute")


@pulumi.output_type
class ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "degradationMilliseconds":
            suggest = "degradation_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 degradation_milliseconds: float):
        pulumi.set(__self__, "degradation_milliseconds", degradation_milliseconds)

    @property
    @pulumi.getter(name="degradationMilliseconds")
    def degradation_milliseconds(self) -> float:
        return pulumi.get(self, "degradation_milliseconds")


@pulumi.output_type
class ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestDegradationMilliseconds":
            suggest = "slowest_degradation_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slowest_degradation_milliseconds: float):
        pulumi.set(__self__, "slowest_degradation_milliseconds", slowest_degradation_milliseconds)

    @property
    @pulumi.getter(name="slowestDegradationMilliseconds")
    def slowest_degradation_milliseconds(self) -> float:
        return pulumi.get(self, "slowest_degradation_milliseconds")


@pulumi.output_type
class ServiceExternalWebRequestConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.ServiceExternalWebRequestConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.ServiceExternalWebRequestConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ServiceExternalWebRequestConditionsCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compareOperationType":
            suggest = "compare_operation_type"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "intValue":
            suggest = "int_value"
        elif key == "intValues":
            suggest = "int_values"
        elif key == "ipRangeFrom":
            suggest = "ip_range_from"
        elif key == "ipRangeTo":
            suggest = "ip_range_to"
        elif key == "tagValues":
            suggest = "tag_values"
        elif key == "textValues":
            suggest = "text_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestConditionsCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestConditionsCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestConditionsCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 compare_operation_type: str,
                 frameworks: Optional[Sequence[str]] = None,
                 ignore_case: Optional[bool] = None,
                 int_value: Optional[int] = None,
                 int_values: Optional[Sequence[int]] = None,
                 ip_range_from: Optional[str] = None,
                 ip_range_to: Optional[str] = None,
                 tag_values: Optional[Sequence[str]] = None,
                 text_values: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "compare_operation_type", compare_operation_type)
        if frameworks is not None:
            pulumi.set(__self__, "frameworks", frameworks)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if int_value is not None:
            pulumi.set(__self__, "int_value", int_value)
        if int_values is not None:
            pulumi.set(__self__, "int_values", int_values)
        if ip_range_from is not None:
            pulumi.set(__self__, "ip_range_from", ip_range_from)
        if ip_range_to is not None:
            pulumi.set(__self__, "ip_range_to", ip_range_to)
        if tag_values is not None:
            pulumi.set(__self__, "tag_values", tag_values)
        if text_values is not None:
            pulumi.set(__self__, "text_values", text_values)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="compareOperationType")
    def compare_operation_type(self) -> str:
        return pulumi.get(self, "compare_operation_type")

    @property
    @pulumi.getter
    def frameworks(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "frameworks")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="intValue")
    def int_value(self) -> Optional[int]:
        return pulumi.get(self, "int_value")

    @property
    @pulumi.getter(name="intValues")
    def int_values(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "int_values")

    @property
    @pulumi.getter(name="ipRangeFrom")
    def ip_range_from(self) -> Optional[str]:
        return pulumi.get(self, "ip_range_from")

    @property
    @pulumi.getter(name="ipRangeTo")
    def ip_range_to(self) -> Optional[str]:
        return pulumi.get(self, "ip_range_to")

    @property
    @pulumi.getter(name="tagValues")
    def tag_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tag_values")

    @property
    @pulumi.getter(name="textValues")
    def text_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "text_values")


@pulumi.output_type
class ServiceExternalWebRequestIdContributors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "contextRoot":
            suggest = "context_root"
        elif key == "portForServiceId":
            suggest = "port_for_service_id"
        elif key == "publicDomainName":
            suggest = "public_domain_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: 'outputs.ServiceExternalWebRequestIdContributorsApplicationId',
                 context_root: 'outputs.ServiceExternalWebRequestIdContributorsContextRoot',
                 port_for_service_id: bool,
                 public_domain_name: 'outputs.ServiceExternalWebRequestIdContributorsPublicDomainName'):
        """
        :param 'ServiceExternalWebRequestIdContributorsApplicationIdArgs' application_id: Application identifier
        :param 'ServiceExternalWebRequestIdContributorsContextRootArgs' context_root: URL context root
        :param bool port_for_service_id: Let the Port contribute to the Service Id
        :param 'ServiceExternalWebRequestIdContributorsPublicDomainNameArgs' public_domain_name: Public domain name
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "context_root", context_root)
        pulumi.set(__self__, "port_for_service_id", port_for_service_id)
        pulumi.set(__self__, "public_domain_name", public_domain_name)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> 'outputs.ServiceExternalWebRequestIdContributorsApplicationId':
        """
        Application identifier
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="contextRoot")
    def context_root(self) -> 'outputs.ServiceExternalWebRequestIdContributorsContextRoot':
        """
        URL context root
        """
        return pulumi.get(self, "context_root")

    @property
    @pulumi.getter(name="portForServiceId")
    def port_for_service_id(self) -> bool:
        """
        Let the Port contribute to the Service Id
        """
        return pulumi.get(self, "port_for_service_id")

    @property
    @pulumi.getter(name="publicDomainName")
    def public_domain_name(self) -> 'outputs.ServiceExternalWebRequestIdContributorsPublicDomainName':
        """
        Public domain name
        """
        return pulumi.get(self, "public_domain_name")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsApplicationId(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributorsApplicationId. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributorsApplicationId.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributorsApplicationId.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributor'] = None):
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributor']:
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 transformations: Optional['outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride'] = None):
        pulumi.set(__self__, "contribution_type", contribution_type)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformations']:
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride']:
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "selectIndex":
            suggest = "select_index"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "takeFromEnd":
            suggest = "take_from_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 segment_count: Optional[int] = None,
                 select_index: Optional[int] = None,
                 split_delimiter: Optional[str] = None,
                 suffix: Optional[str] = None,
                 take_from_end: Optional[bool] = None):
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if select_index is not None:
            pulumi.set(__self__, "select_index", select_index)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if take_from_end is not None:
            pulumi.set(__self__, "take_from_end", take_from_end)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter(name="selectIndex")
    def select_index(self) -> Optional[int]:
        return pulumi.get(self, "select_index")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="takeFromEnd")
    def take_from_end(self) -> Optional[bool]:
        return pulumi.get(self, "take_from_end")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsContextRoot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributorsContextRoot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributorsContextRoot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributorsContextRoot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributor'] = None):
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributor']:
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsContextRootServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributorsContextRootServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributorsContextRootServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributorsContextRootServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 segment_count: Optional[int] = None,
                 transformations: Optional['outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorValueOverride'] = None):
        pulumi.set(__self__, "contribution_type", contribution_type)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformations']:
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorValueOverride']:
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 suffix: Optional[str] = None):
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsPublicDomainName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributorsPublicDomainName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributorsPublicDomainName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributorsPublicDomainName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributor'] = None):
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributor']:
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "copyFromHostName":
            suggest = "copy_from_host_name"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 copy_from_host_name: Optional[bool] = None,
                 transformations: Optional['outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorValueOverride'] = None):
        pulumi.set(__self__, "contribution_type", contribution_type)
        if copy_from_host_name is not None:
            pulumi.set(__self__, "copy_from_host_name", copy_from_host_name)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter(name="copyFromHostName")
    def copy_from_host_name(self) -> Optional[bool]:
        return pulumi.get(self, "copy_from_host_name")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformations']:
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorValueOverride']:
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "selectIndex":
            suggest = "select_index"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "takeFromEnd":
            suggest = "take_from_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 segment_count: Optional[int] = None,
                 select_index: Optional[int] = None,
                 split_delimiter: Optional[str] = None,
                 suffix: Optional[str] = None,
                 take_from_end: Optional[bool] = None):
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if select_index is not None:
            pulumi.set(__self__, "select_index", select_index)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if take_from_end is not None:
            pulumi.set(__self__, "take_from_end", take_from_end)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter(name="selectIndex")
    def select_index(self) -> Optional[int]:
        return pulumi.get(self, "select_index")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="takeFromEnd")
    def take_from_end(self) -> Optional[bool]:
        return pulumi.get(self, "take_from_end")


@pulumi.output_type
class ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceExternalWebServiceConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.ServiceExternalWebServiceConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.ServiceExternalWebServiceConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ServiceExternalWebServiceConditionsCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compareOperationType":
            suggest = "compare_operation_type"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "intValue":
            suggest = "int_value"
        elif key == "intValues":
            suggest = "int_values"
        elif key == "ipRangeFrom":
            suggest = "ip_range_from"
        elif key == "ipRangeTo":
            suggest = "ip_range_to"
        elif key == "tagValues":
            suggest = "tag_values"
        elif key == "textValues":
            suggest = "text_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebServiceConditionsCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebServiceConditionsCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebServiceConditionsCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 compare_operation_type: str,
                 frameworks: Optional[Sequence[str]] = None,
                 ignore_case: Optional[bool] = None,
                 int_value: Optional[int] = None,
                 int_values: Optional[Sequence[int]] = None,
                 ip_range_from: Optional[str] = None,
                 ip_range_to: Optional[str] = None,
                 tag_values: Optional[Sequence[str]] = None,
                 text_values: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "compare_operation_type", compare_operation_type)
        if frameworks is not None:
            pulumi.set(__self__, "frameworks", frameworks)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if int_value is not None:
            pulumi.set(__self__, "int_value", int_value)
        if int_values is not None:
            pulumi.set(__self__, "int_values", int_values)
        if ip_range_from is not None:
            pulumi.set(__self__, "ip_range_from", ip_range_from)
        if ip_range_to is not None:
            pulumi.set(__self__, "ip_range_to", ip_range_to)
        if tag_values is not None:
            pulumi.set(__self__, "tag_values", tag_values)
        if text_values is not None:
            pulumi.set(__self__, "text_values", text_values)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="compareOperationType")
    def compare_operation_type(self) -> str:
        return pulumi.get(self, "compare_operation_type")

    @property
    @pulumi.getter
    def frameworks(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "frameworks")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="intValue")
    def int_value(self) -> Optional[int]:
        return pulumi.get(self, "int_value")

    @property
    @pulumi.getter(name="intValues")
    def int_values(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "int_values")

    @property
    @pulumi.getter(name="ipRangeFrom")
    def ip_range_from(self) -> Optional[str]:
        return pulumi.get(self, "ip_range_from")

    @property
    @pulumi.getter(name="ipRangeTo")
    def ip_range_to(self) -> Optional[str]:
        return pulumi.get(self, "ip_range_to")

    @property
    @pulumi.getter(name="tagValues")
    def tag_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tag_values")

    @property
    @pulumi.getter(name="textValues")
    def text_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "text_values")


@pulumi.output_type
class ServiceExternalWebServiceIdContributors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectAsWebRequestService":
            suggest = "detect_as_web_request_service"
        elif key == "portForServiceId":
            suggest = "port_for_service_id"
        elif key == "urlPath":
            suggest = "url_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebServiceIdContributors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebServiceIdContributors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebServiceIdContributors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 detect_as_web_request_service: bool,
                 port_for_service_id: Optional[bool] = None,
                 url_path: Optional['outputs.ServiceExternalWebServiceIdContributorsUrlPath'] = None):
        """
        :param bool detect_as_web_request_service: Detect the matching requests as web request services instead of web services.
        """
        pulumi.set(__self__, "detect_as_web_request_service", detect_as_web_request_service)
        if port_for_service_id is not None:
            pulumi.set(__self__, "port_for_service_id", port_for_service_id)
        if url_path is not None:
            pulumi.set(__self__, "url_path", url_path)

    @property
    @pulumi.getter(name="detectAsWebRequestService")
    def detect_as_web_request_service(self) -> bool:
        """
        Detect the matching requests as web request services instead of web services.
        """
        return pulumi.get(self, "detect_as_web_request_service")

    @property
    @pulumi.getter(name="portForServiceId")
    def port_for_service_id(self) -> Optional[bool]:
        return pulumi.get(self, "port_for_service_id")

    @property
    @pulumi.getter(name="urlPath")
    def url_path(self) -> Optional['outputs.ServiceExternalWebServiceIdContributorsUrlPath']:
        return pulumi.get(self, "url_path")


@pulumi.output_type
class ServiceExternalWebServiceIdContributorsUrlPath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebServiceIdContributorsUrlPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebServiceIdContributorsUrlPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebServiceIdContributorsUrlPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributor'] = None):
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributor']:
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 transformations: Optional['outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorValueOverride'] = None):
        pulumi.set(__self__, "contribution_type", contribution_type)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformations']:
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorValueOverride']:
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "selectIndex":
            suggest = "select_index"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "takeFromEnd":
            suggest = "take_from_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 segment_count: Optional[int] = None,
                 select_index: Optional[int] = None,
                 split_delimiter: Optional[str] = None,
                 suffix: Optional[str] = None,
                 take_from_end: Optional[bool] = None):
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if select_index is not None:
            pulumi.set(__self__, "select_index", select_index)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if take_from_end is not None:
            pulumi.set(__self__, "take_from_end", take_from_end)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter(name="selectIndex")
    def select_index(self) -> Optional[int]:
        return pulumi.get(self, "select_index")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="takeFromEnd")
    def take_from_end(self) -> Optional[bool]:
        return pulumi.get(self, "take_from_end")


@pulumi.output_type
class ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceFailureExceptionRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreAllExceptions":
            suggest = "ignore_all_exceptions"
        elif key == "ignoreSpanFailureDetection":
            suggest = "ignore_span_failure_detection"
        elif key == "customErrorRules":
            suggest = "custom_error_rules"
        elif key == "customHandledExceptions":
            suggest = "custom_handled_exceptions"
        elif key == "ignoredExceptions":
            suggest = "ignored_exceptions"
        elif key == "successForcingExceptions":
            suggest = "success_forcing_exceptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ignore_all_exceptions: bool,
                 ignore_span_failure_detection: bool,
                 custom_error_rules: Optional['outputs.ServiceFailureExceptionRulesCustomErrorRules'] = None,
                 custom_handled_exceptions: Optional['outputs.ServiceFailureExceptionRulesCustomHandledExceptions'] = None,
                 ignored_exceptions: Optional['outputs.ServiceFailureExceptionRulesIgnoredExceptions'] = None,
                 success_forcing_exceptions: Optional['outputs.ServiceFailureExceptionRulesSuccessForcingExceptions'] = None):
        """
        :param bool ignore_all_exceptions: Ignore all exceptions
        :param bool ignore_span_failure_detection: Ignore span failure detection
        :param 'ServiceFailureExceptionRulesCustomErrorRulesArgs' custom_error_rules: Some custom error situations are only detectable via a return value or other means. To support such cases, [define a request attribute](https://dt-url.net/ys5k0p4y) that captures the required data. Then define a custom error rule that determines if the request has failed based on the value of the request attribute.
        :param 'ServiceFailureExceptionRulesCustomHandledExceptionsArgs' custom_handled_exceptions: There may be situations where your application code handles exceptions gracefully in a manner that these failures aren't detected by Dynatrace. Use this setting to define specific gracefully-handled exceptions that should be treated as service failures.
        :param 'ServiceFailureExceptionRulesIgnoredExceptionsArgs' ignored_exceptions: Some exceptions that are thrown by legacy or 3rd-party code indicate a specific response, not an error. Use this setting to instruct Dynatrace to treat such exceptions as non-failed requests.. If an exception matching any of the defined patterns occurs in a request, it will not be considered as a failure. Other exceptions occurring at the same request might still mark the request as failed.
        :param 'ServiceFailureExceptionRulesSuccessForcingExceptionsArgs' success_forcing_exceptions: Define exceptions which indicate that a service call should not be considered as failed. E.g. an exception indicating that the client aborted the operation.. If an exception matching any of the defined patterns occurs on the entry node of the service, it will be considered successful. Compared to ignored exceptions, the request will be considered successful even if other exceptions occur in the same request.
        """
        pulumi.set(__self__, "ignore_all_exceptions", ignore_all_exceptions)
        pulumi.set(__self__, "ignore_span_failure_detection", ignore_span_failure_detection)
        if custom_error_rules is not None:
            pulumi.set(__self__, "custom_error_rules", custom_error_rules)
        if custom_handled_exceptions is not None:
            pulumi.set(__self__, "custom_handled_exceptions", custom_handled_exceptions)
        if ignored_exceptions is not None:
            pulumi.set(__self__, "ignored_exceptions", ignored_exceptions)
        if success_forcing_exceptions is not None:
            pulumi.set(__self__, "success_forcing_exceptions", success_forcing_exceptions)

    @property
    @pulumi.getter(name="ignoreAllExceptions")
    def ignore_all_exceptions(self) -> bool:
        """
        Ignore all exceptions
        """
        return pulumi.get(self, "ignore_all_exceptions")

    @property
    @pulumi.getter(name="ignoreSpanFailureDetection")
    def ignore_span_failure_detection(self) -> bool:
        """
        Ignore span failure detection
        """
        return pulumi.get(self, "ignore_span_failure_detection")

    @property
    @pulumi.getter(name="customErrorRules")
    def custom_error_rules(self) -> Optional['outputs.ServiceFailureExceptionRulesCustomErrorRules']:
        """
        Some custom error situations are only detectable via a return value or other means. To support such cases, [define a request attribute](https://dt-url.net/ys5k0p4y) that captures the required data. Then define a custom error rule that determines if the request has failed based on the value of the request attribute.
        """
        return pulumi.get(self, "custom_error_rules")

    @property
    @pulumi.getter(name="customHandledExceptions")
    def custom_handled_exceptions(self) -> Optional['outputs.ServiceFailureExceptionRulesCustomHandledExceptions']:
        """
        There may be situations where your application code handles exceptions gracefully in a manner that these failures aren't detected by Dynatrace. Use this setting to define specific gracefully-handled exceptions that should be treated as service failures.
        """
        return pulumi.get(self, "custom_handled_exceptions")

    @property
    @pulumi.getter(name="ignoredExceptions")
    def ignored_exceptions(self) -> Optional['outputs.ServiceFailureExceptionRulesIgnoredExceptions']:
        """
        Some exceptions that are thrown by legacy or 3rd-party code indicate a specific response, not an error. Use this setting to instruct Dynatrace to treat such exceptions as non-failed requests.. If an exception matching any of the defined patterns occurs in a request, it will not be considered as a failure. Other exceptions occurring at the same request might still mark the request as failed.
        """
        return pulumi.get(self, "ignored_exceptions")

    @property
    @pulumi.getter(name="successForcingExceptions")
    def success_forcing_exceptions(self) -> Optional['outputs.ServiceFailureExceptionRulesSuccessForcingExceptions']:
        """
        Define exceptions which indicate that a service call should not be considered as failed. E.g. an exception indicating that the client aborted the operation.. If an exception matching any of the defined patterns occurs on the entry node of the service, it will be considered successful. Compared to ignored exceptions, the request will be considered successful even if other exceptions occur in the same request.
        """
        return pulumi.get(self, "success_forcing_exceptions")


@pulumi.output_type
class ServiceFailureExceptionRulesCustomErrorRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customErrorRules":
            suggest = "custom_error_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRulesCustomErrorRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRulesCustomErrorRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRulesCustomErrorRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_error_rules: Sequence['outputs.ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRule']):
        pulumi.set(__self__, "custom_error_rules", custom_error_rules)

    @property
    @pulumi.getter(name="customErrorRules")
    def custom_error_rules(self) -> Sequence['outputs.ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRule']:
        return pulumi.get(self, "custom_error_rules")


@pulumi.output_type
class ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: 'outputs.ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRuleCondition',
                 request_attribute: str):
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "request_attribute", request_attribute)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRuleCondition':
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> str:
        return pulumi.get(self, "request_attribute")


@pulumi.output_type
class ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compareOperationType":
            suggest = "compare_operation_type"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "doubleValue":
            suggest = "double_value"
        elif key == "intValue":
            suggest = "int_value"
        elif key == "textValue":
            suggest = "text_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compare_operation_type: str,
                 case_sensitive: Optional[bool] = None,
                 double_value: Optional[float] = None,
                 int_value: Optional[int] = None,
                 text_value: Optional[str] = None):
        pulumi.set(__self__, "compare_operation_type", compare_operation_type)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int_value is not None:
            pulumi.set(__self__, "int_value", int_value)
        if text_value is not None:
            pulumi.set(__self__, "text_value", text_value)

    @property
    @pulumi.getter(name="compareOperationType")
    def compare_operation_type(self) -> str:
        return pulumi.get(self, "compare_operation_type")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[float]:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="intValue")
    def int_value(self) -> Optional[int]:
        return pulumi.get(self, "int_value")

    @property
    @pulumi.getter(name="textValue")
    def text_value(self) -> Optional[str]:
        return pulumi.get(self, "text_value")


@pulumi.output_type
class ServiceFailureExceptionRulesCustomHandledExceptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHandledExceptions":
            suggest = "custom_handled_exceptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRulesCustomHandledExceptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRulesCustomHandledExceptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRulesCustomHandledExceptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_handled_exceptions: Sequence['outputs.ServiceFailureExceptionRulesCustomHandledExceptionsCustomHandledException']):
        pulumi.set(__self__, "custom_handled_exceptions", custom_handled_exceptions)

    @property
    @pulumi.getter(name="customHandledExceptions")
    def custom_handled_exceptions(self) -> Sequence['outputs.ServiceFailureExceptionRulesCustomHandledExceptionsCustomHandledException']:
        return pulumi.get(self, "custom_handled_exceptions")


@pulumi.output_type
class ServiceFailureExceptionRulesCustomHandledExceptionsCustomHandledException(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPattern":
            suggest = "class_pattern"
        elif key == "messagePattern":
            suggest = "message_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRulesCustomHandledExceptionsCustomHandledException. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRulesCustomHandledExceptionsCustomHandledException.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRulesCustomHandledExceptionsCustomHandledException.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_pattern: Optional[str] = None,
                 message_pattern: Optional[str] = None):
        if class_pattern is not None:
            pulumi.set(__self__, "class_pattern", class_pattern)
        if message_pattern is not None:
            pulumi.set(__self__, "message_pattern", message_pattern)

    @property
    @pulumi.getter(name="classPattern")
    def class_pattern(self) -> Optional[str]:
        return pulumi.get(self, "class_pattern")

    @property
    @pulumi.getter(name="messagePattern")
    def message_pattern(self) -> Optional[str]:
        return pulumi.get(self, "message_pattern")


@pulumi.output_type
class ServiceFailureExceptionRulesIgnoredExceptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHandledExceptions":
            suggest = "custom_handled_exceptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRulesIgnoredExceptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRulesIgnoredExceptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRulesIgnoredExceptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_handled_exceptions: Sequence['outputs.ServiceFailureExceptionRulesIgnoredExceptionsCustomHandledException']):
        pulumi.set(__self__, "custom_handled_exceptions", custom_handled_exceptions)

    @property
    @pulumi.getter(name="customHandledExceptions")
    def custom_handled_exceptions(self) -> Sequence['outputs.ServiceFailureExceptionRulesIgnoredExceptionsCustomHandledException']:
        return pulumi.get(self, "custom_handled_exceptions")


@pulumi.output_type
class ServiceFailureExceptionRulesIgnoredExceptionsCustomHandledException(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPattern":
            suggest = "class_pattern"
        elif key == "messagePattern":
            suggest = "message_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRulesIgnoredExceptionsCustomHandledException. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRulesIgnoredExceptionsCustomHandledException.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRulesIgnoredExceptionsCustomHandledException.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_pattern: Optional[str] = None,
                 message_pattern: Optional[str] = None):
        if class_pattern is not None:
            pulumi.set(__self__, "class_pattern", class_pattern)
        if message_pattern is not None:
            pulumi.set(__self__, "message_pattern", message_pattern)

    @property
    @pulumi.getter(name="classPattern")
    def class_pattern(self) -> Optional[str]:
        return pulumi.get(self, "class_pattern")

    @property
    @pulumi.getter(name="messagePattern")
    def message_pattern(self) -> Optional[str]:
        return pulumi.get(self, "message_pattern")


@pulumi.output_type
class ServiceFailureExceptionRulesSuccessForcingExceptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHandledExceptions":
            suggest = "custom_handled_exceptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRulesSuccessForcingExceptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRulesSuccessForcingExceptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRulesSuccessForcingExceptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_handled_exceptions: Sequence['outputs.ServiceFailureExceptionRulesSuccessForcingExceptionsCustomHandledException']):
        pulumi.set(__self__, "custom_handled_exceptions", custom_handled_exceptions)

    @property
    @pulumi.getter(name="customHandledExceptions")
    def custom_handled_exceptions(self) -> Sequence['outputs.ServiceFailureExceptionRulesSuccessForcingExceptionsCustomHandledException']:
        return pulumi.get(self, "custom_handled_exceptions")


@pulumi.output_type
class ServiceFailureExceptionRulesSuccessForcingExceptionsCustomHandledException(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPattern":
            suggest = "class_pattern"
        elif key == "messagePattern":
            suggest = "message_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFailureExceptionRulesSuccessForcingExceptionsCustomHandledException. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFailureExceptionRulesSuccessForcingExceptionsCustomHandledException.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFailureExceptionRulesSuccessForcingExceptionsCustomHandledException.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_pattern: Optional[str] = None,
                 message_pattern: Optional[str] = None):
        if class_pattern is not None:
            pulumi.set(__self__, "class_pattern", class_pattern)
        if message_pattern is not None:
            pulumi.set(__self__, "message_pattern", message_pattern)

    @property
    @pulumi.getter(name="classPattern")
    def class_pattern(self) -> Optional[str]:
        return pulumi.get(self, "class_pattern")

    @property
    @pulumi.getter(name="messagePattern")
    def message_pattern(self) -> Optional[str]:
        return pulumi.get(self, "message_pattern")


@pulumi.output_type
class ServiceFullWebRequestConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.ServiceFullWebRequestConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.ServiceFullWebRequestConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ServiceFullWebRequestConditionsCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compareOperationType":
            suggest = "compare_operation_type"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "intValue":
            suggest = "int_value"
        elif key == "intValues":
            suggest = "int_values"
        elif key == "ipRangeFrom":
            suggest = "ip_range_from"
        elif key == "ipRangeTo":
            suggest = "ip_range_to"
        elif key == "tagValues":
            suggest = "tag_values"
        elif key == "textValues":
            suggest = "text_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestConditionsCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestConditionsCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestConditionsCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 compare_operation_type: str,
                 frameworks: Optional[Sequence[str]] = None,
                 ignore_case: Optional[bool] = None,
                 int_value: Optional[int] = None,
                 int_values: Optional[Sequence[int]] = None,
                 ip_range_from: Optional[str] = None,
                 ip_range_to: Optional[str] = None,
                 tag_values: Optional[Sequence[str]] = None,
                 text_values: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "compare_operation_type", compare_operation_type)
        if frameworks is not None:
            pulumi.set(__self__, "frameworks", frameworks)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if int_value is not None:
            pulumi.set(__self__, "int_value", int_value)
        if int_values is not None:
            pulumi.set(__self__, "int_values", int_values)
        if ip_range_from is not None:
            pulumi.set(__self__, "ip_range_from", ip_range_from)
        if ip_range_to is not None:
            pulumi.set(__self__, "ip_range_to", ip_range_to)
        if tag_values is not None:
            pulumi.set(__self__, "tag_values", tag_values)
        if text_values is not None:
            pulumi.set(__self__, "text_values", text_values)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="compareOperationType")
    def compare_operation_type(self) -> str:
        return pulumi.get(self, "compare_operation_type")

    @property
    @pulumi.getter
    def frameworks(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "frameworks")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="intValue")
    def int_value(self) -> Optional[int]:
        return pulumi.get(self, "int_value")

    @property
    @pulumi.getter(name="intValues")
    def int_values(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "int_values")

    @property
    @pulumi.getter(name="ipRangeFrom")
    def ip_range_from(self) -> Optional[str]:
        return pulumi.get(self, "ip_range_from")

    @property
    @pulumi.getter(name="ipRangeTo")
    def ip_range_to(self) -> Optional[str]:
        return pulumi.get(self, "ip_range_to")

    @property
    @pulumi.getter(name="tagValues")
    def tag_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tag_values")

    @property
    @pulumi.getter(name="textValues")
    def text_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "text_values")


@pulumi.output_type
class ServiceFullWebRequestIdContributors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "contextRoot":
            suggest = "context_root"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: 'outputs.ServiceFullWebRequestIdContributorsApplicationId',
                 context_root: 'outputs.ServiceFullWebRequestIdContributorsContextRoot',
                 server_name: 'outputs.ServiceFullWebRequestIdContributorsServerName'):
        """
        :param 'ServiceFullWebRequestIdContributorsApplicationIdArgs' application_id: Application identifier
        :param 'ServiceFullWebRequestIdContributorsContextRootArgs' context_root: The context root is the first segment of the request URL after the Server name. For example, in the `www.dynatrace.com/support/help/dynatrace-api/` URL the context root is `/support`. The context root value can be found on the Service screen under **Properties and tags**.
        :param 'ServiceFullWebRequestIdContributorsServerNameArgs' server_name: Server Name
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "context_root", context_root)
        pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> 'outputs.ServiceFullWebRequestIdContributorsApplicationId':
        """
        Application identifier
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="contextRoot")
    def context_root(self) -> 'outputs.ServiceFullWebRequestIdContributorsContextRoot':
        """
        The context root is the first segment of the request URL after the Server name. For example, in the `www.dynatrace.com/support/help/dynatrace-api/` URL the context root is `/support`. The context root value can be found on the Service screen under **Properties and tags**.
        """
        return pulumi.get(self, "context_root")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> 'outputs.ServiceFullWebRequestIdContributorsServerName':
        """
        Server Name
        """
        return pulumi.get(self, "server_name")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsApplicationId(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributorsApplicationId. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributorsApplicationId.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributorsApplicationId.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributor'] = None):
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributor']:
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 transformations: Optional['outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride'] = None):
        pulumi.set(__self__, "contribution_type", contribution_type)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformations']:
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride']:
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "selectIndex":
            suggest = "select_index"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "takeFromEnd":
            suggest = "take_from_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 segment_count: Optional[int] = None,
                 select_index: Optional[int] = None,
                 split_delimiter: Optional[str] = None,
                 suffix: Optional[str] = None,
                 take_from_end: Optional[bool] = None):
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if select_index is not None:
            pulumi.set(__self__, "select_index", select_index)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if take_from_end is not None:
            pulumi.set(__self__, "take_from_end", take_from_end)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter(name="selectIndex")
    def select_index(self) -> Optional[int]:
        return pulumi.get(self, "select_index")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="takeFromEnd")
    def take_from_end(self) -> Optional[bool]:
        return pulumi.get(self, "take_from_end")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsContextRoot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributorsContextRoot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributorsContextRoot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributorsContextRoot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributor'] = None):
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributor']:
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsContextRootServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributorsContextRootServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributorsContextRootServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributorsContextRootServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 segment_count: Optional[int] = None,
                 transformations: Optional['outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributorValueOverride'] = None):
        pulumi.set(__self__, "contribution_type", contribution_type)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformations']:
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributorValueOverride']:
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 suffix: Optional[str] = None):
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsContextRootServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsServerName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributorsServerName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributorsServerName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributorsServerName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributor'] = None):
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributor']:
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsServerNameServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributorsServerNameServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributorsServerNameServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributorsServerNameServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 transformations: Optional['outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributorValueOverride'] = None):
        pulumi.set(__self__, "contribution_type", contribution_type)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformations']:
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributorValueOverride']:
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "selectIndex":
            suggest = "select_index"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "takeFromEnd":
            suggest = "take_from_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 segment_count: Optional[int] = None,
                 select_index: Optional[int] = None,
                 split_delimiter: Optional[str] = None,
                 suffix: Optional[str] = None,
                 take_from_end: Optional[bool] = None):
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if select_index is not None:
            pulumi.set(__self__, "select_index", select_index)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if take_from_end is not None:
            pulumi.set(__self__, "take_from_end", take_from_end)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter(name="selectIndex")
    def select_index(self) -> Optional[int]:
        return pulumi.get(self, "select_index")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="takeFromEnd")
    def take_from_end(self) -> Optional[bool]:
        return pulumi.get(self, "take_from_end")


@pulumi.output_type
class ServiceFullWebRequestIdContributorsServerNameServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceFullWebServiceConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.ServiceFullWebServiceConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.ServiceFullWebServiceConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ServiceFullWebServiceConditionsCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compareOperationType":
            suggest = "compare_operation_type"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "intValue":
            suggest = "int_value"
        elif key == "intValues":
            suggest = "int_values"
        elif key == "ipRangeFrom":
            suggest = "ip_range_from"
        elif key == "ipRangeTo":
            suggest = "ip_range_to"
        elif key == "tagValues":
            suggest = "tag_values"
        elif key == "textValues":
            suggest = "text_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceConditionsCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceConditionsCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceConditionsCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 compare_operation_type: str,
                 frameworks: Optional[Sequence[str]] = None,
                 ignore_case: Optional[bool] = None,
                 int_value: Optional[int] = None,
                 int_values: Optional[Sequence[int]] = None,
                 ip_range_from: Optional[str] = None,
                 ip_range_to: Optional[str] = None,
                 tag_values: Optional[Sequence[str]] = None,
                 text_values: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "compare_operation_type", compare_operation_type)
        if frameworks is not None:
            pulumi.set(__self__, "frameworks", frameworks)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if int_value is not None:
            pulumi.set(__self__, "int_value", int_value)
        if int_values is not None:
            pulumi.set(__self__, "int_values", int_values)
        if ip_range_from is not None:
            pulumi.set(__self__, "ip_range_from", ip_range_from)
        if ip_range_to is not None:
            pulumi.set(__self__, "ip_range_to", ip_range_to)
        if tag_values is not None:
            pulumi.set(__self__, "tag_values", tag_values)
        if text_values is not None:
            pulumi.set(__self__, "text_values", text_values)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="compareOperationType")
    def compare_operation_type(self) -> str:
        return pulumi.get(self, "compare_operation_type")

    @property
    @pulumi.getter
    def frameworks(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "frameworks")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="intValue")
    def int_value(self) -> Optional[int]:
        return pulumi.get(self, "int_value")

    @property
    @pulumi.getter(name="intValues")
    def int_values(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "int_values")

    @property
    @pulumi.getter(name="ipRangeFrom")
    def ip_range_from(self) -> Optional[str]:
        return pulumi.get(self, "ip_range_from")

    @property
    @pulumi.getter(name="ipRangeTo")
    def ip_range_to(self) -> Optional[str]:
        return pulumi.get(self, "ip_range_to")

    @property
    @pulumi.getter(name="tagValues")
    def tag_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tag_values")

    @property
    @pulumi.getter(name="textValues")
    def text_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "text_values")


@pulumi.output_type
class ServiceFullWebServiceIdContributors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectAsWebRequestService":
            suggest = "detect_as_web_request_service"
        elif key == "applicationId":
            suggest = "application_id"
        elif key == "contextRoot":
            suggest = "context_root"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "webServiceName":
            suggest = "web_service_name"
        elif key == "webServiceNamespace":
            suggest = "web_service_namespace"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 detect_as_web_request_service: bool,
                 application_id: Optional['outputs.ServiceFullWebServiceIdContributorsApplicationId'] = None,
                 context_root: Optional['outputs.ServiceFullWebServiceIdContributorsContextRoot'] = None,
                 server_name: Optional['outputs.ServiceFullWebServiceIdContributorsServerName'] = None,
                 web_service_name: Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceName'] = None,
                 web_service_namespace: Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespace'] = None):
        """
        :param bool detect_as_web_request_service: Detect the matching requests as full web services (false) or web request services (true).
        """
        pulumi.set(__self__, "detect_as_web_request_service", detect_as_web_request_service)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if context_root is not None:
            pulumi.set(__self__, "context_root", context_root)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if web_service_name is not None:
            pulumi.set(__self__, "web_service_name", web_service_name)
        if web_service_namespace is not None:
            pulumi.set(__self__, "web_service_namespace", web_service_namespace)

    @property
    @pulumi.getter(name="detectAsWebRequestService")
    def detect_as_web_request_service(self) -> bool:
        """
        Detect the matching requests as full web services (false) or web request services (true).
        """
        return pulumi.get(self, "detect_as_web_request_service")

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsApplicationId']:
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="contextRoot")
    def context_root(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsContextRoot']:
        return pulumi.get(self, "context_root")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsServerName']:
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter(name="webServiceName")
    def web_service_name(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceName']:
        return pulumi.get(self, "web_service_name")

    @property
    @pulumi.getter(name="webServiceNamespace")
    def web_service_namespace(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespace']:
        return pulumi.get(self, "web_service_namespace")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsApplicationId(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsApplicationId. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsApplicationId.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsApplicationId.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributor'] = None):
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributor']:
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 transformations: Optional['outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorValueOverride'] = None):
        pulumi.set(__self__, "contribution_type", contribution_type)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformations']:
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorValueOverride']:
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "selectIndex":
            suggest = "select_index"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "takeFromEnd":
            suggest = "take_from_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 segment_count: Optional[int] = None,
                 select_index: Optional[int] = None,
                 split_delimiter: Optional[str] = None,
                 suffix: Optional[str] = None,
                 take_from_end: Optional[bool] = None):
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if select_index is not None:
            pulumi.set(__self__, "select_index", select_index)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if take_from_end is not None:
            pulumi.set(__self__, "take_from_end", take_from_end)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter(name="selectIndex")
    def select_index(self) -> Optional[int]:
        return pulumi.get(self, "select_index")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="takeFromEnd")
    def take_from_end(self) -> Optional[bool]:
        return pulumi.get(self, "take_from_end")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsContextRoot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsContextRoot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsContextRoot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsContextRoot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributor'] = None):
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributor']:
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsContextRootServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsContextRootServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsContextRootServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsContextRootServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 segment_count: Optional[int] = None,
                 transformations: Optional['outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributorValueOverride'] = None):
        pulumi.set(__self__, "contribution_type", contribution_type)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformations']:
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributorValueOverride']:
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 suffix: Optional[str] = None):
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsContextRootServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsServerName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsServerName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsServerName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsServerName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributor'] = None):
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributor']:
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsServerNameServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsServerNameServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsServerNameServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsServerNameServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 transformations: Optional['outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributorValueOverride'] = None):
        pulumi.set(__self__, "contribution_type", contribution_type)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformations']:
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributorValueOverride']:
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "selectIndex":
            suggest = "select_index"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "takeFromEnd":
            suggest = "take_from_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 segment_count: Optional[int] = None,
                 select_index: Optional[int] = None,
                 split_delimiter: Optional[str] = None,
                 suffix: Optional[str] = None,
                 take_from_end: Optional[bool] = None):
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if select_index is not None:
            pulumi.set(__self__, "select_index", select_index)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if take_from_end is not None:
            pulumi.set(__self__, "take_from_end", take_from_end)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter(name="selectIndex")
    def select_index(self) -> Optional[int]:
        return pulumi.get(self, "select_index")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="takeFromEnd")
    def take_from_end(self) -> Optional[bool]:
        return pulumi.get(self, "take_from_end")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsServerNameServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsWebServiceName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributor'] = None):
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributor']:
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 transformations: Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorValueOverride'] = None):
        pulumi.set(__self__, "contribution_type", contribution_type)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformations']:
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorValueOverride']:
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "selectIndex":
            suggest = "select_index"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "takeFromEnd":
            suggest = "take_from_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 segment_count: Optional[int] = None,
                 select_index: Optional[int] = None,
                 split_delimiter: Optional[str] = None,
                 suffix: Optional[str] = None,
                 take_from_end: Optional[bool] = None):
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if select_index is not None:
            pulumi.set(__self__, "select_index", select_index)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if take_from_end is not None:
            pulumi.set(__self__, "take_from_end", take_from_end)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter(name="selectIndex")
    def select_index(self) -> Optional[int]:
        return pulumi.get(self, "select_index")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="takeFromEnd")
    def take_from_end(self) -> Optional[bool]:
        return pulumi.get(self, "take_from_end")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceNamespace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIdContributor":
            suggest = "enable_id_contributor"
        elif key == "serviceIdContributor":
            suggest = "service_id_contributor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsWebServiceNamespace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNamespace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNamespace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_id_contributor: bool,
                 service_id_contributor: Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributor'] = None):
        pulumi.set(__self__, "enable_id_contributor", enable_id_contributor)
        if service_id_contributor is not None:
            pulumi.set(__self__, "service_id_contributor", service_id_contributor)

    @property
    @pulumi.getter(name="enableIdContributor")
    def enable_id_contributor(self) -> bool:
        return pulumi.get(self, "enable_id_contributor")

    @property
    @pulumi.getter(name="serviceIdContributor")
    def service_id_contributor(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributor']:
        return pulumi.get(self, "service_id_contributor")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributionType":
            suggest = "contribution_type"
        elif key == "valueOverride":
            suggest = "value_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contribution_type: str,
                 transformations: Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformations'] = None,
                 value_override: Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorValueOverride'] = None):
        pulumi.set(__self__, "contribution_type", contribution_type)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if value_override is not None:
            pulumi.set(__self__, "value_override", value_override)

    @property
    @pulumi.getter(name="contributionType")
    def contribution_type(self) -> str:
        return pulumi.get(self, "contribution_type")

    @property
    @pulumi.getter
    def transformations(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformations']:
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter(name="valueOverride")
    def value_override(self) -> Optional['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorValueOverride']:
        return pulumi.get(self, "value_override")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformations(dict):
    def __init__(__self__, *,
                 transformations: Sequence['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformationsTransformation']):
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformationsTransformation']:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformationsTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationType":
            suggest = "transformation_type"
        elif key == "includeHexNumbers":
            suggest = "include_hex_numbers"
        elif key == "minDigitCount":
            suggest = "min_digit_count"
        elif key == "replacementValue":
            suggest = "replacement_value"
        elif key == "segmentCount":
            suggest = "segment_count"
        elif key == "selectIndex":
            suggest = "select_index"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "takeFromEnd":
            suggest = "take_from_end"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformationsTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformationsTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_type: str,
                 include_hex_numbers: Optional[bool] = None,
                 min_digit_count: Optional[int] = None,
                 prefix: Optional[str] = None,
                 replacement_value: Optional[str] = None,
                 segment_count: Optional[int] = None,
                 select_index: Optional[int] = None,
                 split_delimiter: Optional[str] = None,
                 suffix: Optional[str] = None,
                 take_from_end: Optional[bool] = None):
        pulumi.set(__self__, "transformation_type", transformation_type)
        if include_hex_numbers is not None:
            pulumi.set(__self__, "include_hex_numbers", include_hex_numbers)
        if min_digit_count is not None:
            pulumi.set(__self__, "min_digit_count", min_digit_count)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if replacement_value is not None:
            pulumi.set(__self__, "replacement_value", replacement_value)
        if segment_count is not None:
            pulumi.set(__self__, "segment_count", segment_count)
        if select_index is not None:
            pulumi.set(__self__, "select_index", select_index)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if take_from_end is not None:
            pulumi.set(__self__, "take_from_end", take_from_end)

    @property
    @pulumi.getter(name="transformationType")
    def transformation_type(self) -> str:
        return pulumi.get(self, "transformation_type")

    @property
    @pulumi.getter(name="includeHexNumbers")
    def include_hex_numbers(self) -> Optional[bool]:
        return pulumi.get(self, "include_hex_numbers")

    @property
    @pulumi.getter(name="minDigitCount")
    def min_digit_count(self) -> Optional[int]:
        return pulumi.get(self, "min_digit_count")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> Optional[str]:
        return pulumi.get(self, "replacement_value")

    @property
    @pulumi.getter(name="segmentCount")
    def segment_count(self) -> Optional[int]:
        return pulumi.get(self, "segment_count")

    @property
    @pulumi.getter(name="selectIndex")
    def select_index(self) -> Optional[int]:
        return pulumi.get(self, "select_index")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="takeFromEnd")
    def take_from_end(self) -> Optional[bool]:
        return pulumi.get(self, "take_from_end")


@pulumi.output_type
class ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorValueOverride(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceHttpFailureBrokenLinks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "http404NotFoundFailures":
            suggest = "http404_not_found_failures"
        elif key == "brokenLinkDomains":
            suggest = "broken_link_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceHttpFailureBrokenLinks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceHttpFailureBrokenLinks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceHttpFailureBrokenLinks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http404_not_found_failures: bool,
                 broken_link_domains: Optional[Sequence[str]] = None):
        """
        :param bool http404_not_found_failures: Consider 404 HTTP response codes as failures
        :param Sequence[str] broken_link_domains: If your application relies on other hosts at other domains, add the associated domain names here. Once configured, Dynatrace will consider 404s thrown by hosts at these domains to be service failures related to your application.
        """
        pulumi.set(__self__, "http404_not_found_failures", http404_not_found_failures)
        if broken_link_domains is not None:
            pulumi.set(__self__, "broken_link_domains", broken_link_domains)

    @property
    @pulumi.getter(name="http404NotFoundFailures")
    def http404_not_found_failures(self) -> bool:
        """
        Consider 404 HTTP response codes as failures
        """
        return pulumi.get(self, "http404_not_found_failures")

    @property
    @pulumi.getter(name="brokenLinkDomains")
    def broken_link_domains(self) -> Optional[Sequence[str]]:
        """
        If your application relies on other hosts at other domains, add the associated domain names here. Once configured, Dynatrace will consider 404s thrown by hosts at these domains to be service failures related to your application.
        """
        return pulumi.get(self, "broken_link_domains")


@pulumi.output_type
class ServiceHttpFailureHttpResponseCodes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientSideErrors":
            suggest = "client_side_errors"
        elif key == "failOnMissingResponseCodeClientSide":
            suggest = "fail_on_missing_response_code_client_side"
        elif key == "failOnMissingResponseCodeServerSide":
            suggest = "fail_on_missing_response_code_server_side"
        elif key == "serverSideErrors":
            suggest = "server_side_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceHttpFailureHttpResponseCodes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceHttpFailureHttpResponseCodes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceHttpFailureHttpResponseCodes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_side_errors: str,
                 fail_on_missing_response_code_client_side: bool,
                 fail_on_missing_response_code_server_side: bool,
                 server_side_errors: str):
        """
        :param str client_side_errors: HTTP response codes which indicate client side errors
        :param bool fail_on_missing_response_code_client_side: Treat missing HTTP response code as client side error
        :param bool fail_on_missing_response_code_server_side: Treat missing HTTP response code as server side errors
        :param str server_side_errors: HTTP response codes which indicate an error on the server side
        """
        pulumi.set(__self__, "client_side_errors", client_side_errors)
        pulumi.set(__self__, "fail_on_missing_response_code_client_side", fail_on_missing_response_code_client_side)
        pulumi.set(__self__, "fail_on_missing_response_code_server_side", fail_on_missing_response_code_server_side)
        pulumi.set(__self__, "server_side_errors", server_side_errors)

    @property
    @pulumi.getter(name="clientSideErrors")
    def client_side_errors(self) -> str:
        """
        HTTP response codes which indicate client side errors
        """
        return pulumi.get(self, "client_side_errors")

    @property
    @pulumi.getter(name="failOnMissingResponseCodeClientSide")
    def fail_on_missing_response_code_client_side(self) -> bool:
        """
        Treat missing HTTP response code as client side error
        """
        return pulumi.get(self, "fail_on_missing_response_code_client_side")

    @property
    @pulumi.getter(name="failOnMissingResponseCodeServerSide")
    def fail_on_missing_response_code_server_side(self) -> bool:
        """
        Treat missing HTTP response code as server side errors
        """
        return pulumi.get(self, "fail_on_missing_response_code_server_side")

    @property
    @pulumi.getter(name="serverSideErrors")
    def server_side_errors(self) -> str:
        """
        HTTP response codes which indicate an error on the server side
        """
        return pulumi.get(self, "server_side_errors")


@pulumi.output_type
class ServiceNamingCondition(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.ServiceNamingConditionCondition']] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ServiceNamingConditionCondition']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ServiceNamingConditionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationTypeComparisons":
            suggest = "application_type_comparisons"
        elif key == "applicationTypes":
            suggest = "application_types"
        elif key == "azureComputeModeComparisons":
            suggest = "azure_compute_mode_comparisons"
        elif key == "azureComputeModes":
            suggest = "azure_compute_modes"
        elif key == "azureSkuComparisions":
            suggest = "azure_sku_comparisions"
        elif key == "azureSkus":
            suggest = "azure_skus"
        elif key == "baseComparisonBasics":
            suggest = "base_comparison_basics"
        elif key == "baseConditionKeys":
            suggest = "base_condition_keys"
        elif key == "bitnessComparisions":
            suggest = "bitness_comparisions"
        elif key == "cloudTypeComparisons":
            suggest = "cloud_type_comparisons"
        elif key == "cloudTypes":
            suggest = "cloud_types"
        elif key == "customApplicationTypeComparisons":
            suggest = "custom_application_type_comparisons"
        elif key == "customApplicationTypes":
            suggest = "custom_application_types"
        elif key == "customHostMetadataConditionKeys":
            suggest = "custom_host_metadata_condition_keys"
        elif key == "customHostMetadatas":
            suggest = "custom_host_metadatas"
        elif key == "customProcessMetadataConditionKeys":
            suggest = "custom_process_metadata_condition_keys"
        elif key == "customProcessMetadatas":
            suggest = "custom_process_metadatas"
        elif key == "databaseTopologies":
            suggest = "database_topologies"
        elif key == "databaseTopologyComparisons":
            suggest = "database_topology_comparisons"
        elif key == "dcrumDecoderComparisons":
            suggest = "dcrum_decoder_comparisons"
        elif key == "dcrumDecoders":
            suggest = "dcrum_decoders"
        elif key == "entityIdComparisons":
            suggest = "entity_id_comparisons"
        elif key == "hostTeches":
            suggest = "host_teches"
        elif key == "hypervisorTypeComparisions":
            suggest = "hypervisor_type_comparisions"
        elif key == "indexedNameComparisons":
            suggest = "indexed_name_comparisons"
        elif key == "indexedNames":
            suggest = "indexed_names"
        elif key == "indexedStringComparisons":
            suggest = "indexed_string_comparisons"
        elif key == "indexedStrings":
            suggest = "indexed_strings"
        elif key == "indexedTagComparisons":
            suggest = "indexed_tag_comparisons"
        elif key == "indexedTags":
            suggest = "indexed_tags"
        elif key == "integerComparisons":
            suggest = "integer_comparisons"
        elif key == "ipaddressComparisons":
            suggest = "ipaddress_comparisons"
        elif key == "mobilePlatformComparisons":
            suggest = "mobile_platform_comparisons"
        elif key == "mobilePlatforms":
            suggest = "mobile_platforms"
        elif key == "osArches":
            suggest = "os_arches"
        elif key == "osTypes":
            suggest = "os_types"
        elif key == "osarchitectureComparisons":
            suggest = "osarchitecture_comparisons"
        elif key == "ostypeComparisons":
            suggest = "ostype_comparisons"
        elif key == "paasTypeComparisons":
            suggest = "paas_type_comparisons"
        elif key == "paasTypes":
            suggest = "paas_types"
        elif key == "processMetadataConditionKeys":
            suggest = "process_metadata_condition_keys"
        elif key == "processMetadatas":
            suggest = "process_metadatas"
        elif key == "serviceTopologies":
            suggest = "service_topologies"
        elif key == "serviceTopologyComparisons":
            suggest = "service_topology_comparisons"
        elif key == "serviceTypeComparisons":
            suggest = "service_type_comparisons"
        elif key == "serviceTypes":
            suggest = "service_types"
        elif key == "simpleHostTechComparisons":
            suggest = "simple_host_tech_comparisons"
        elif key == "simpleTechComparisons":
            suggest = "simple_tech_comparisons"
        elif key == "stringComparisons":
            suggest = "string_comparisons"
        elif key == "stringConditionKeys":
            suggest = "string_condition_keys"
        elif key == "stringKeys":
            suggest = "string_keys"
        elif key == "syntheticEngineTypeComparisons":
            suggest = "synthetic_engine_type_comparisons"
        elif key == "syntheticEngines":
            suggest = "synthetic_engines"
        elif key == "tagComparisons":
            suggest = "tag_comparisons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_type_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionApplicationTypeComparison']] = None,
                 application_types: Optional[Sequence['outputs.ServiceNamingConditionConditionApplicationType']] = None,
                 azure_compute_mode_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionAzureComputeModeComparison']] = None,
                 azure_compute_modes: Optional[Sequence['outputs.ServiceNamingConditionConditionAzureComputeMode']] = None,
                 azure_sku_comparisions: Optional[Sequence['outputs.ServiceNamingConditionConditionAzureSkuComparision']] = None,
                 azure_skus: Optional[Sequence['outputs.ServiceNamingConditionConditionAzureSkus']] = None,
                 base_comparison_basics: Optional[Sequence['outputs.ServiceNamingConditionConditionBaseComparisonBasic']] = None,
                 base_condition_keys: Optional[Sequence['outputs.ServiceNamingConditionConditionBaseConditionKey']] = None,
                 bitness_comparisions: Optional[Sequence['outputs.ServiceNamingConditionConditionBitnessComparision']] = None,
                 bitnesses: Optional[Sequence['outputs.ServiceNamingConditionConditionBitness']] = None,
                 cloud_type_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionCloudTypeComparison']] = None,
                 cloud_types: Optional[Sequence['outputs.ServiceNamingConditionConditionCloudType']] = None,
                 comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionComparison']] = None,
                 custom_application_type_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionCustomApplicationTypeComparison']] = None,
                 custom_application_types: Optional[Sequence['outputs.ServiceNamingConditionConditionCustomApplicationType']] = None,
                 custom_host_metadata_condition_keys: Optional[Sequence['outputs.ServiceNamingConditionConditionCustomHostMetadataConditionKey']] = None,
                 custom_host_metadatas: Optional[Sequence['outputs.ServiceNamingConditionConditionCustomHostMetadata']] = None,
                 custom_process_metadata_condition_keys: Optional[Sequence['outputs.ServiceNamingConditionConditionCustomProcessMetadataConditionKey']] = None,
                 custom_process_metadatas: Optional[Sequence['outputs.ServiceNamingConditionConditionCustomProcessMetadata']] = None,
                 database_topologies: Optional[Sequence['outputs.ServiceNamingConditionConditionDatabaseTopology']] = None,
                 database_topology_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionDatabaseTopologyComparison']] = None,
                 dcrum_decoder_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionDcrumDecoderComparison']] = None,
                 dcrum_decoders: Optional[Sequence['outputs.ServiceNamingConditionConditionDcrumDecoder']] = None,
                 entities: Optional[Sequence['outputs.ServiceNamingConditionConditionEntity']] = None,
                 entity_id_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionEntityIdComparison']] = None,
                 host_teches: Optional[Sequence['outputs.ServiceNamingConditionConditionHostTech']] = None,
                 hypervisor_type_comparisions: Optional[Sequence['outputs.ServiceNamingConditionConditionHypervisorTypeComparision']] = None,
                 hypervisors: Optional[Sequence['outputs.ServiceNamingConditionConditionHypervisor']] = None,
                 indexed_name_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedNameComparison']] = None,
                 indexed_names: Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedName']] = None,
                 indexed_string_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedStringComparison']] = None,
                 indexed_strings: Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedString']] = None,
                 indexed_tag_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedTagComparison']] = None,
                 indexed_tags: Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedTag']] = None,
                 integer_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionIntegerComparison']] = None,
                 integers: Optional[Sequence['outputs.ServiceNamingConditionConditionInteger']] = None,
                 ipaddress_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionIpaddressComparison']] = None,
                 ipaddresses: Optional[Sequence['outputs.ServiceNamingConditionConditionIpaddress']] = None,
                 keys: Optional[Sequence['outputs.ServiceNamingConditionConditionKey']] = None,
                 mobile_platform_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionMobilePlatformComparison']] = None,
                 mobile_platforms: Optional[Sequence['outputs.ServiceNamingConditionConditionMobilePlatform']] = None,
                 os_arches: Optional[Sequence['outputs.ServiceNamingConditionConditionOsArch']] = None,
                 os_types: Optional[Sequence['outputs.ServiceNamingConditionConditionOsType']] = None,
                 osarchitecture_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionOsarchitectureComparison']] = None,
                 ostype_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionOstypeComparison']] = None,
                 paas_type_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionPaasTypeComparison']] = None,
                 paas_types: Optional[Sequence['outputs.ServiceNamingConditionConditionPaasType']] = None,
                 process_metadata_condition_keys: Optional[Sequence['outputs.ServiceNamingConditionConditionProcessMetadataConditionKey']] = None,
                 process_metadatas: Optional[Sequence['outputs.ServiceNamingConditionConditionProcessMetadata']] = None,
                 service_topologies: Optional[Sequence['outputs.ServiceNamingConditionConditionServiceTopology']] = None,
                 service_topology_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionServiceTopologyComparison']] = None,
                 service_type_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionServiceTypeComparison']] = None,
                 service_types: Optional[Sequence['outputs.ServiceNamingConditionConditionServiceType']] = None,
                 simple_host_tech_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionSimpleHostTechComparison']] = None,
                 simple_tech_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionSimpleTechComparison']] = None,
                 string_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionStringComparison']] = None,
                 string_condition_keys: Optional[Sequence['outputs.ServiceNamingConditionConditionStringConditionKey']] = None,
                 string_keys: Optional[Sequence['outputs.ServiceNamingConditionConditionStringKey']] = None,
                 strings: Optional[Sequence['outputs.ServiceNamingConditionConditionString']] = None,
                 synthetic_engine_type_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionSyntheticEngineTypeComparison']] = None,
                 synthetic_engines: Optional[Sequence['outputs.ServiceNamingConditionConditionSyntheticEngine']] = None,
                 tag_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionTagComparison']] = None,
                 tags: Optional[Sequence['outputs.ServiceNamingConditionConditionTag']] = None,
                 teches: Optional[Sequence['outputs.ServiceNamingConditionConditionTech']] = None,
                 unknowns: Optional[str] = None):
        if application_type_comparisons is not None:
            pulumi.set(__self__, "application_type_comparisons", application_type_comparisons)
        if application_types is not None:
            pulumi.set(__self__, "application_types", application_types)
        if azure_compute_mode_comparisons is not None:
            pulumi.set(__self__, "azure_compute_mode_comparisons", azure_compute_mode_comparisons)
        if azure_compute_modes is not None:
            pulumi.set(__self__, "azure_compute_modes", azure_compute_modes)
        if azure_sku_comparisions is not None:
            pulumi.set(__self__, "azure_sku_comparisions", azure_sku_comparisions)
        if azure_skus is not None:
            pulumi.set(__self__, "azure_skus", azure_skus)
        if base_comparison_basics is not None:
            pulumi.set(__self__, "base_comparison_basics", base_comparison_basics)
        if base_condition_keys is not None:
            pulumi.set(__self__, "base_condition_keys", base_condition_keys)
        if bitness_comparisions is not None:
            pulumi.set(__self__, "bitness_comparisions", bitness_comparisions)
        if bitnesses is not None:
            pulumi.set(__self__, "bitnesses", bitnesses)
        if cloud_type_comparisons is not None:
            pulumi.set(__self__, "cloud_type_comparisons", cloud_type_comparisons)
        if cloud_types is not None:
            pulumi.set(__self__, "cloud_types", cloud_types)
        if comparisons is not None:
            pulumi.set(__self__, "comparisons", comparisons)
        if custom_application_type_comparisons is not None:
            pulumi.set(__self__, "custom_application_type_comparisons", custom_application_type_comparisons)
        if custom_application_types is not None:
            pulumi.set(__self__, "custom_application_types", custom_application_types)
        if custom_host_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_host_metadata_condition_keys", custom_host_metadata_condition_keys)
        if custom_host_metadatas is not None:
            pulumi.set(__self__, "custom_host_metadatas", custom_host_metadatas)
        if custom_process_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_process_metadata_condition_keys", custom_process_metadata_condition_keys)
        if custom_process_metadatas is not None:
            pulumi.set(__self__, "custom_process_metadatas", custom_process_metadatas)
        if database_topologies is not None:
            pulumi.set(__self__, "database_topologies", database_topologies)
        if database_topology_comparisons is not None:
            pulumi.set(__self__, "database_topology_comparisons", database_topology_comparisons)
        if dcrum_decoder_comparisons is not None:
            pulumi.set(__self__, "dcrum_decoder_comparisons", dcrum_decoder_comparisons)
        if dcrum_decoders is not None:
            pulumi.set(__self__, "dcrum_decoders", dcrum_decoders)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if entity_id_comparisons is not None:
            pulumi.set(__self__, "entity_id_comparisons", entity_id_comparisons)
        if host_teches is not None:
            pulumi.set(__self__, "host_teches", host_teches)
        if hypervisor_type_comparisions is not None:
            pulumi.set(__self__, "hypervisor_type_comparisions", hypervisor_type_comparisions)
        if hypervisors is not None:
            pulumi.set(__self__, "hypervisors", hypervisors)
        if indexed_name_comparisons is not None:
            pulumi.set(__self__, "indexed_name_comparisons", indexed_name_comparisons)
        if indexed_names is not None:
            pulumi.set(__self__, "indexed_names", indexed_names)
        if indexed_string_comparisons is not None:
            pulumi.set(__self__, "indexed_string_comparisons", indexed_string_comparisons)
        if indexed_strings is not None:
            pulumi.set(__self__, "indexed_strings", indexed_strings)
        if indexed_tag_comparisons is not None:
            pulumi.set(__self__, "indexed_tag_comparisons", indexed_tag_comparisons)
        if indexed_tags is not None:
            pulumi.set(__self__, "indexed_tags", indexed_tags)
        if integer_comparisons is not None:
            pulumi.set(__self__, "integer_comparisons", integer_comparisons)
        if integers is not None:
            pulumi.set(__self__, "integers", integers)
        if ipaddress_comparisons is not None:
            pulumi.set(__self__, "ipaddress_comparisons", ipaddress_comparisons)
        if ipaddresses is not None:
            pulumi.set(__self__, "ipaddresses", ipaddresses)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if mobile_platform_comparisons is not None:
            pulumi.set(__self__, "mobile_platform_comparisons", mobile_platform_comparisons)
        if mobile_platforms is not None:
            pulumi.set(__self__, "mobile_platforms", mobile_platforms)
        if os_arches is not None:
            pulumi.set(__self__, "os_arches", os_arches)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if osarchitecture_comparisons is not None:
            pulumi.set(__self__, "osarchitecture_comparisons", osarchitecture_comparisons)
        if ostype_comparisons is not None:
            pulumi.set(__self__, "ostype_comparisons", ostype_comparisons)
        if paas_type_comparisons is not None:
            pulumi.set(__self__, "paas_type_comparisons", paas_type_comparisons)
        if paas_types is not None:
            pulumi.set(__self__, "paas_types", paas_types)
        if process_metadata_condition_keys is not None:
            pulumi.set(__self__, "process_metadata_condition_keys", process_metadata_condition_keys)
        if process_metadatas is not None:
            pulumi.set(__self__, "process_metadatas", process_metadatas)
        if service_topologies is not None:
            pulumi.set(__self__, "service_topologies", service_topologies)
        if service_topology_comparisons is not None:
            pulumi.set(__self__, "service_topology_comparisons", service_topology_comparisons)
        if service_type_comparisons is not None:
            pulumi.set(__self__, "service_type_comparisons", service_type_comparisons)
        if service_types is not None:
            pulumi.set(__self__, "service_types", service_types)
        if simple_host_tech_comparisons is not None:
            pulumi.set(__self__, "simple_host_tech_comparisons", simple_host_tech_comparisons)
        if simple_tech_comparisons is not None:
            pulumi.set(__self__, "simple_tech_comparisons", simple_tech_comparisons)
        if string_comparisons is not None:
            pulumi.set(__self__, "string_comparisons", string_comparisons)
        if string_condition_keys is not None:
            pulumi.set(__self__, "string_condition_keys", string_condition_keys)
        if string_keys is not None:
            pulumi.set(__self__, "string_keys", string_keys)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)
        if synthetic_engine_type_comparisons is not None:
            pulumi.set(__self__, "synthetic_engine_type_comparisons", synthetic_engine_type_comparisons)
        if synthetic_engines is not None:
            pulumi.set(__self__, "synthetic_engines", synthetic_engines)
        if tag_comparisons is not None:
            pulumi.set(__self__, "tag_comparisons", tag_comparisons)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if teches is not None:
            pulumi.set(__self__, "teches", teches)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="applicationTypeComparisons")
    def application_type_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionApplicationTypeComparison']]:
        return pulumi.get(self, "application_type_comparisons")

    @property
    @pulumi.getter(name="applicationTypes")
    def application_types(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionApplicationType']]:
        return pulumi.get(self, "application_types")

    @property
    @pulumi.getter(name="azureComputeModeComparisons")
    def azure_compute_mode_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionAzureComputeModeComparison']]:
        return pulumi.get(self, "azure_compute_mode_comparisons")

    @property
    @pulumi.getter(name="azureComputeModes")
    def azure_compute_modes(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionAzureComputeMode']]:
        return pulumi.get(self, "azure_compute_modes")

    @property
    @pulumi.getter(name="azureSkuComparisions")
    def azure_sku_comparisions(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionAzureSkuComparision']]:
        return pulumi.get(self, "azure_sku_comparisions")

    @property
    @pulumi.getter(name="azureSkus")
    def azure_skus(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionAzureSkus']]:
        return pulumi.get(self, "azure_skus")

    @property
    @pulumi.getter(name="baseComparisonBasics")
    def base_comparison_basics(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionBaseComparisonBasic']]:
        return pulumi.get(self, "base_comparison_basics")

    @property
    @pulumi.getter(name="baseConditionKeys")
    def base_condition_keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionBaseConditionKey']]:
        return pulumi.get(self, "base_condition_keys")

    @property
    @pulumi.getter(name="bitnessComparisions")
    def bitness_comparisions(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionBitnessComparision']]:
        return pulumi.get(self, "bitness_comparisions")

    @property
    @pulumi.getter
    def bitnesses(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionBitness']]:
        return pulumi.get(self, "bitnesses")

    @property
    @pulumi.getter(name="cloudTypeComparisons")
    def cloud_type_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCloudTypeComparison']]:
        return pulumi.get(self, "cloud_type_comparisons")

    @property
    @pulumi.getter(name="cloudTypes")
    def cloud_types(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCloudType']]:
        return pulumi.get(self, "cloud_types")

    @property
    @pulumi.getter
    def comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionComparison']]:
        return pulumi.get(self, "comparisons")

    @property
    @pulumi.getter(name="customApplicationTypeComparisons")
    def custom_application_type_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCustomApplicationTypeComparison']]:
        return pulumi.get(self, "custom_application_type_comparisons")

    @property
    @pulumi.getter(name="customApplicationTypes")
    def custom_application_types(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCustomApplicationType']]:
        return pulumi.get(self, "custom_application_types")

    @property
    @pulumi.getter(name="customHostMetadataConditionKeys")
    def custom_host_metadata_condition_keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCustomHostMetadataConditionKey']]:
        return pulumi.get(self, "custom_host_metadata_condition_keys")

    @property
    @pulumi.getter(name="customHostMetadatas")
    def custom_host_metadatas(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCustomHostMetadata']]:
        return pulumi.get(self, "custom_host_metadatas")

    @property
    @pulumi.getter(name="customProcessMetadataConditionKeys")
    def custom_process_metadata_condition_keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCustomProcessMetadataConditionKey']]:
        return pulumi.get(self, "custom_process_metadata_condition_keys")

    @property
    @pulumi.getter(name="customProcessMetadatas")
    def custom_process_metadatas(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCustomProcessMetadata']]:
        return pulumi.get(self, "custom_process_metadatas")

    @property
    @pulumi.getter(name="databaseTopologies")
    def database_topologies(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionDatabaseTopology']]:
        return pulumi.get(self, "database_topologies")

    @property
    @pulumi.getter(name="databaseTopologyComparisons")
    def database_topology_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionDatabaseTopologyComparison']]:
        return pulumi.get(self, "database_topology_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoderComparisons")
    def dcrum_decoder_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionDcrumDecoderComparison']]:
        return pulumi.get(self, "dcrum_decoder_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoders")
    def dcrum_decoders(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionDcrumDecoder']]:
        return pulumi.get(self, "dcrum_decoders")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionEntity']]:
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="entityIdComparisons")
    def entity_id_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionEntityIdComparison']]:
        return pulumi.get(self, "entity_id_comparisons")

    @property
    @pulumi.getter(name="hostTeches")
    def host_teches(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionHostTech']]:
        return pulumi.get(self, "host_teches")

    @property
    @pulumi.getter(name="hypervisorTypeComparisions")
    def hypervisor_type_comparisions(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionHypervisorTypeComparision']]:
        return pulumi.get(self, "hypervisor_type_comparisions")

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionHypervisor']]:
        return pulumi.get(self, "hypervisors")

    @property
    @pulumi.getter(name="indexedNameComparisons")
    def indexed_name_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedNameComparison']]:
        return pulumi.get(self, "indexed_name_comparisons")

    @property
    @pulumi.getter(name="indexedNames")
    def indexed_names(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedName']]:
        return pulumi.get(self, "indexed_names")

    @property
    @pulumi.getter(name="indexedStringComparisons")
    def indexed_string_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedStringComparison']]:
        return pulumi.get(self, "indexed_string_comparisons")

    @property
    @pulumi.getter(name="indexedStrings")
    def indexed_strings(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedString']]:
        return pulumi.get(self, "indexed_strings")

    @property
    @pulumi.getter(name="indexedTagComparisons")
    def indexed_tag_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedTagComparison']]:
        return pulumi.get(self, "indexed_tag_comparisons")

    @property
    @pulumi.getter(name="indexedTags")
    def indexed_tags(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedTag']]:
        return pulumi.get(self, "indexed_tags")

    @property
    @pulumi.getter(name="integerComparisons")
    def integer_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIntegerComparison']]:
        return pulumi.get(self, "integer_comparisons")

    @property
    @pulumi.getter
    def integers(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionInteger']]:
        return pulumi.get(self, "integers")

    @property
    @pulumi.getter(name="ipaddressComparisons")
    def ipaddress_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIpaddressComparison']]:
        return pulumi.get(self, "ipaddress_comparisons")

    @property
    @pulumi.getter
    def ipaddresses(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIpaddress']]:
        return pulumi.get(self, "ipaddresses")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionKey']]:
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter(name="mobilePlatformComparisons")
    def mobile_platform_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionMobilePlatformComparison']]:
        return pulumi.get(self, "mobile_platform_comparisons")

    @property
    @pulumi.getter(name="mobilePlatforms")
    def mobile_platforms(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionMobilePlatform']]:
        return pulumi.get(self, "mobile_platforms")

    @property
    @pulumi.getter(name="osArches")
    def os_arches(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionOsArch']]:
        return pulumi.get(self, "os_arches")

    @property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionOsType']]:
        return pulumi.get(self, "os_types")

    @property
    @pulumi.getter(name="osarchitectureComparisons")
    def osarchitecture_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionOsarchitectureComparison']]:
        return pulumi.get(self, "osarchitecture_comparisons")

    @property
    @pulumi.getter(name="ostypeComparisons")
    def ostype_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionOstypeComparison']]:
        return pulumi.get(self, "ostype_comparisons")

    @property
    @pulumi.getter(name="paasTypeComparisons")
    def paas_type_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionPaasTypeComparison']]:
        return pulumi.get(self, "paas_type_comparisons")

    @property
    @pulumi.getter(name="paasTypes")
    def paas_types(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionPaasType']]:
        return pulumi.get(self, "paas_types")

    @property
    @pulumi.getter(name="processMetadataConditionKeys")
    def process_metadata_condition_keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionProcessMetadataConditionKey']]:
        return pulumi.get(self, "process_metadata_condition_keys")

    @property
    @pulumi.getter(name="processMetadatas")
    def process_metadatas(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionProcessMetadata']]:
        return pulumi.get(self, "process_metadatas")

    @property
    @pulumi.getter(name="serviceTopologies")
    def service_topologies(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionServiceTopology']]:
        return pulumi.get(self, "service_topologies")

    @property
    @pulumi.getter(name="serviceTopologyComparisons")
    def service_topology_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionServiceTopologyComparison']]:
        return pulumi.get(self, "service_topology_comparisons")

    @property
    @pulumi.getter(name="serviceTypeComparisons")
    def service_type_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionServiceTypeComparison']]:
        return pulumi.get(self, "service_type_comparisons")

    @property
    @pulumi.getter(name="serviceTypes")
    def service_types(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionServiceType']]:
        return pulumi.get(self, "service_types")

    @property
    @pulumi.getter(name="simpleHostTechComparisons")
    def simple_host_tech_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionSimpleHostTechComparison']]:
        return pulumi.get(self, "simple_host_tech_comparisons")

    @property
    @pulumi.getter(name="simpleTechComparisons")
    def simple_tech_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionSimpleTechComparison']]:
        return pulumi.get(self, "simple_tech_comparisons")

    @property
    @pulumi.getter(name="stringComparisons")
    def string_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionStringComparison']]:
        return pulumi.get(self, "string_comparisons")

    @property
    @pulumi.getter(name="stringConditionKeys")
    def string_condition_keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionStringConditionKey']]:
        return pulumi.get(self, "string_condition_keys")

    @property
    @pulumi.getter(name="stringKeys")
    def string_keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionStringKey']]:
        return pulumi.get(self, "string_keys")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionString']]:
        return pulumi.get(self, "strings")

    @property
    @pulumi.getter(name="syntheticEngineTypeComparisons")
    def synthetic_engine_type_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionSyntheticEngineTypeComparison']]:
        return pulumi.get(self, "synthetic_engine_type_comparisons")

    @property
    @pulumi.getter(name="syntheticEngines")
    def synthetic_engines(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionSyntheticEngine']]:
        return pulumi.get(self, "synthetic_engines")

    @property
    @pulumi.getter(name="tagComparisons")
    def tag_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionTagComparison']]:
        return pulumi.get(self, "tag_comparisons")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionTag']]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def teches(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionTech']]:
        return pulumi.get(self, "teches")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionAzureComputeMode(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionAzureComputeModeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionAzureSkuComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionAzureSkus(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionBaseComparisonBasic(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionBaseConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionBitness(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionBitnessComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionCloudType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionCloudTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionComparison(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionCustomApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionCustomHostMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionCustomHostMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionCustomHostMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionCustomHostMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ServiceNamingConditionConditionCustomHostMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ServiceNamingConditionConditionCustomHostMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomHostMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionCustomHostMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ServiceNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ServiceNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomHostMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionCustomProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionCustomProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionCustomProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ServiceNamingConditionConditionCustomProcessMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ServiceNamingConditionConditionCustomProcessMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionCustomProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ServiceNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ServiceNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomProcessMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionDatabaseTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionDatabaseTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionDcrumDecoder(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionDcrumDecoderComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionEntity(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionEntityIdComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionHostTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionHostTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionHostTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionHostTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionHostTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionHostTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionHostTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ServiceNamingConditionConditionHypervisor(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionHypervisorTypeComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedName(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedNameComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedString(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedStringComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionIndexedTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionIndexedTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionIndexedTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionIndexedTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionInteger(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIntegerComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIpaddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionIpaddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionIpaddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionIpaddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIpaddressComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionIpaddressComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionIpaddressComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionIpaddressComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionMobilePlatform(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionMobilePlatformComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionOsArch(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionOsType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionOsarchitectureComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionOstypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionPaasType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionPaasTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionServiceTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionServiceTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionServiceType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionServiceTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionSimpleHostTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionSimpleHostTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionSimpleHostTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionSimpleHostTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionSimpleHostTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ServiceNamingConditionConditionSimpleTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionSimpleTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionSimpleTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionSimpleTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionSimpleTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionSimpleTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionSimpleTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ServiceNamingConditionConditionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionStringComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionStringComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionStringComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionStringComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionStringConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionStringConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionStringConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionStringConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionStringKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionStringKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionStringKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionStringKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionSyntheticEngine(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionSyntheticEngineTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class SessionReplayWebPrivacyMaskingPresets(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "playbackMaskingPreset":
            suggest = "playback_masking_preset"
        elif key == "recordingMaskingPreset":
            suggest = "recording_masking_preset"
        elif key == "playbackMaskingAllowListRules":
            suggest = "playback_masking_allow_list_rules"
        elif key == "playbackMaskingBlockListRules":
            suggest = "playback_masking_block_list_rules"
        elif key == "recordingMaskingAllowListRules":
            suggest = "recording_masking_allow_list_rules"
        elif key == "recordingMaskingBlockListRules":
            suggest = "recording_masking_block_list_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionReplayWebPrivacyMaskingPresets. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionReplayWebPrivacyMaskingPresets.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionReplayWebPrivacyMaskingPresets.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 playback_masking_preset: str,
                 recording_masking_preset: str,
                 playback_masking_allow_list_rules: Optional['outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRules'] = None,
                 playback_masking_block_list_rules: Optional['outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRules'] = None,
                 recording_masking_allow_list_rules: Optional['outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRules'] = None,
                 recording_masking_block_list_rules: Optional['outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRules'] = None):
        """
        :param str playback_masking_preset: (Field has overlap with `ApplicationDataPrivacy`) Possible Values: `MASK_ALL`, `MASK_USER_INPUT`, `ALLOW_LIST`, `BLOCK_LIST`
        :param str recording_masking_preset: (Field has overlap with `ApplicationDataPrivacy`) Possible Values: `MASK_USER_INPUT`, `ALLOW_LIST`, `BLOCK_LIST`, `MASK_ALL`
        :param 'SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRulesArgs' playback_masking_allow_list_rules: (Field has overlap with `ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
        :param 'SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRulesArgs' playback_masking_block_list_rules: (Field has overlap with `ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
        :param 'SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRulesArgs' recording_masking_allow_list_rules: (Field has overlap with `ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
        :param 'SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRulesArgs' recording_masking_block_list_rules: (Field has overlap with `ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
        """
        pulumi.set(__self__, "playback_masking_preset", playback_masking_preset)
        pulumi.set(__self__, "recording_masking_preset", recording_masking_preset)
        if playback_masking_allow_list_rules is not None:
            pulumi.set(__self__, "playback_masking_allow_list_rules", playback_masking_allow_list_rules)
        if playback_masking_block_list_rules is not None:
            pulumi.set(__self__, "playback_masking_block_list_rules", playback_masking_block_list_rules)
        if recording_masking_allow_list_rules is not None:
            pulumi.set(__self__, "recording_masking_allow_list_rules", recording_masking_allow_list_rules)
        if recording_masking_block_list_rules is not None:
            pulumi.set(__self__, "recording_masking_block_list_rules", recording_masking_block_list_rules)

    @property
    @pulumi.getter(name="playbackMaskingPreset")
    def playback_masking_preset(self) -> str:
        """
        (Field has overlap with `ApplicationDataPrivacy`) Possible Values: `MASK_ALL`, `MASK_USER_INPUT`, `ALLOW_LIST`, `BLOCK_LIST`
        """
        return pulumi.get(self, "playback_masking_preset")

    @property
    @pulumi.getter(name="recordingMaskingPreset")
    def recording_masking_preset(self) -> str:
        """
        (Field has overlap with `ApplicationDataPrivacy`) Possible Values: `MASK_USER_INPUT`, `ALLOW_LIST`, `BLOCK_LIST`, `MASK_ALL`
        """
        return pulumi.get(self, "recording_masking_preset")

    @property
    @pulumi.getter(name="playbackMaskingAllowListRules")
    def playback_masking_allow_list_rules(self) -> Optional['outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRules']:
        """
        (Field has overlap with `ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
        """
        return pulumi.get(self, "playback_masking_allow_list_rules")

    @property
    @pulumi.getter(name="playbackMaskingBlockListRules")
    def playback_masking_block_list_rules(self) -> Optional['outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRules']:
        """
        (Field has overlap with `ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
        """
        return pulumi.get(self, "playback_masking_block_list_rules")

    @property
    @pulumi.getter(name="recordingMaskingAllowListRules")
    def recording_masking_allow_list_rules(self) -> Optional['outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRules']:
        """
        (Field has overlap with `ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
        """
        return pulumi.get(self, "recording_masking_allow_list_rules")

    @property
    @pulumi.getter(name="recordingMaskingBlockListRules")
    def recording_masking_block_list_rules(self) -> Optional['outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRules']:
        """
        (Field has overlap with `ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
        """
        return pulumi.get(self, "recording_masking_block_list_rules")


@pulumi.output_type
class SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowListRules":
            suggest = "allow_list_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_list_rules: Sequence['outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRulesAllowListRule']):
        pulumi.set(__self__, "allow_list_rules", allow_list_rules)

    @property
    @pulumi.getter(name="allowListRules")
    def allow_list_rules(self) -> Sequence['outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRulesAllowListRule']:
        return pulumi.get(self, "allow_list_rules")


@pulumi.output_type
class SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRulesAllowListRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeExpression":
            suggest = "attribute_expression"
        elif key == "cssExpression":
            suggest = "css_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRulesAllowListRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRulesAllowListRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRulesAllowListRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: str,
                 attribute_expression: Optional[str] = None,
                 css_expression: Optional[str] = None):
        pulumi.set(__self__, "target", target)
        if attribute_expression is not None:
            pulumi.set(__self__, "attribute_expression", attribute_expression)
        if css_expression is not None:
            pulumi.set(__self__, "css_expression", css_expression)

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="attributeExpression")
    def attribute_expression(self) -> Optional[str]:
        return pulumi.get(self, "attribute_expression")

    @property
    @pulumi.getter(name="cssExpression")
    def css_expression(self) -> Optional[str]:
        return pulumi.get(self, "css_expression")


@pulumi.output_type
class SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockListRules":
            suggest = "block_list_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_list_rules: Sequence['outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRulesBlockListRule']):
        pulumi.set(__self__, "block_list_rules", block_list_rules)

    @property
    @pulumi.getter(name="blockListRules")
    def block_list_rules(self) -> Sequence['outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRulesBlockListRule']:
        return pulumi.get(self, "block_list_rules")


@pulumi.output_type
class SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRulesBlockListRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeExpression":
            suggest = "attribute_expression"
        elif key == "cssExpression":
            suggest = "css_expression"
        elif key == "hideUserInteraction":
            suggest = "hide_user_interaction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRulesBlockListRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRulesBlockListRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRulesBlockListRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: str,
                 attribute_expression: Optional[str] = None,
                 css_expression: Optional[str] = None,
                 hide_user_interaction: Optional[bool] = None):
        pulumi.set(__self__, "target", target)
        if attribute_expression is not None:
            pulumi.set(__self__, "attribute_expression", attribute_expression)
        if css_expression is not None:
            pulumi.set(__self__, "css_expression", css_expression)
        if hide_user_interaction is not None:
            pulumi.set(__self__, "hide_user_interaction", hide_user_interaction)

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="attributeExpression")
    def attribute_expression(self) -> Optional[str]:
        return pulumi.get(self, "attribute_expression")

    @property
    @pulumi.getter(name="cssExpression")
    def css_expression(self) -> Optional[str]:
        return pulumi.get(self, "css_expression")

    @property
    @pulumi.getter(name="hideUserInteraction")
    def hide_user_interaction(self) -> Optional[bool]:
        return pulumi.get(self, "hide_user_interaction")


@pulumi.output_type
class SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowListRules":
            suggest = "allow_list_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_list_rules: Sequence['outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRulesAllowListRule']):
        pulumi.set(__self__, "allow_list_rules", allow_list_rules)

    @property
    @pulumi.getter(name="allowListRules")
    def allow_list_rules(self) -> Sequence['outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRulesAllowListRule']:
        return pulumi.get(self, "allow_list_rules")


@pulumi.output_type
class SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRulesAllowListRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeExpression":
            suggest = "attribute_expression"
        elif key == "cssExpression":
            suggest = "css_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRulesAllowListRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRulesAllowListRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRulesAllowListRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: str,
                 attribute_expression: Optional[str] = None,
                 css_expression: Optional[str] = None):
        pulumi.set(__self__, "target", target)
        if attribute_expression is not None:
            pulumi.set(__self__, "attribute_expression", attribute_expression)
        if css_expression is not None:
            pulumi.set(__self__, "css_expression", css_expression)

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="attributeExpression")
    def attribute_expression(self) -> Optional[str]:
        return pulumi.get(self, "attribute_expression")

    @property
    @pulumi.getter(name="cssExpression")
    def css_expression(self) -> Optional[str]:
        return pulumi.get(self, "css_expression")


@pulumi.output_type
class SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockListRules":
            suggest = "block_list_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_list_rules: Sequence['outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRulesBlockListRule']):
        pulumi.set(__self__, "block_list_rules", block_list_rules)

    @property
    @pulumi.getter(name="blockListRules")
    def block_list_rules(self) -> Sequence['outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRulesBlockListRule']:
        return pulumi.get(self, "block_list_rules")


@pulumi.output_type
class SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRulesBlockListRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeExpression":
            suggest = "attribute_expression"
        elif key == "cssExpression":
            suggest = "css_expression"
        elif key == "hideUserInteraction":
            suggest = "hide_user_interaction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRulesBlockListRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRulesBlockListRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRulesBlockListRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: str,
                 attribute_expression: Optional[str] = None,
                 css_expression: Optional[str] = None,
                 hide_user_interaction: Optional[bool] = None):
        pulumi.set(__self__, "target", target)
        if attribute_expression is not None:
            pulumi.set(__self__, "attribute_expression", attribute_expression)
        if css_expression is not None:
            pulumi.set(__self__, "css_expression", css_expression)
        if hide_user_interaction is not None:
            pulumi.set(__self__, "hide_user_interaction", hide_user_interaction)

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="attributeExpression")
    def attribute_expression(self) -> Optional[str]:
        return pulumi.get(self, "attribute_expression")

    @property
    @pulumi.getter(name="cssExpression")
    def css_expression(self) -> Optional[str]:
        return pulumi.get(self, "css_expression")

    @property
    @pulumi.getter(name="hideUserInteraction")
    def hide_user_interaction(self) -> Optional[bool]:
        return pulumi.get(self, "hide_user_interaction")


@pulumi.output_type
class SloV2ErrorBudgetBurnRate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "burnRateVisualizationEnabled":
            suggest = "burn_rate_visualization_enabled"
        elif key == "fastBurnThreshold":
            suggest = "fast_burn_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloV2ErrorBudgetBurnRate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloV2ErrorBudgetBurnRate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloV2ErrorBudgetBurnRate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 burn_rate_visualization_enabled: bool,
                 fast_burn_threshold: Optional[float] = None):
        """
        :param bool burn_rate_visualization_enabled: Burn rate visualization enabled
        :param float fast_burn_threshold: The threshold defines when a burn rate is marked as fast-burning (high-emergency). Burn rates lower than this threshold (and greater than 1) are highlighted as slow-burn (low-emergency).
        """
        pulumi.set(__self__, "burn_rate_visualization_enabled", burn_rate_visualization_enabled)
        if fast_burn_threshold is not None:
            pulumi.set(__self__, "fast_burn_threshold", fast_burn_threshold)

    @property
    @pulumi.getter(name="burnRateVisualizationEnabled")
    def burn_rate_visualization_enabled(self) -> bool:
        """
        Burn rate visualization enabled
        """
        return pulumi.get(self, "burn_rate_visualization_enabled")

    @property
    @pulumi.getter(name="fastBurnThreshold")
    def fast_burn_threshold(self) -> Optional[float]:
        """
        The threshold defines when a burn rate is marked as fast-burning (high-emergency). Burn rates lower than this threshold (and greater than 1) are highlighted as slow-burn (low-emergency).
        """
        return pulumi.get(self, "fast_burn_threshold")


@pulumi.output_type
class SpanCaptureRuleMatches(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.SpanCaptureRuleMatchesMatch']):
        """
        :param Sequence['SpanCaptureRuleMatchesMatchArgs'] matches: Matching strategies for the Span
        """
        pulumi.set(__self__, "matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.SpanCaptureRuleMatchesMatch']:
        """
        Matching strategies for the Span
        """
        return pulumi.get(self, "matches")


@pulumi.output_type
class SpanCaptureRuleMatchesMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpanCaptureRuleMatchesMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpanCaptureRuleMatchesMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpanCaptureRuleMatchesMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison: str,
                 source: str,
                 case_sensitive: Optional[bool] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "source", source)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparison(self) -> str:
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class SpanContextPropagationMatches(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.SpanContextPropagationMatchesMatch']):
        """
        :param Sequence['SpanContextPropagationMatchesMatchArgs'] matches: Matching strategies for the Span
        """
        pulumi.set(__self__, "matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.SpanContextPropagationMatchesMatch']:
        """
        Matching strategies for the Span
        """
        return pulumi.get(self, "matches")


@pulumi.output_type
class SpanContextPropagationMatchesMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpanContextPropagationMatchesMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpanContextPropagationMatchesMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpanContextPropagationMatchesMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison: str,
                 source: str,
                 case_sensitive: Optional[bool] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "source", source)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparison(self) -> str:
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class SpanEntryPointMatches(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.SpanEntryPointMatchesMatch']):
        """
        :param Sequence['SpanEntryPointMatchesMatchArgs'] matches: Matching strategies for the Span
        """
        pulumi.set(__self__, "matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.SpanEntryPointMatchesMatch']:
        """
        Matching strategies for the Span
        """
        return pulumi.get(self, "matches")


@pulumi.output_type
class SpanEntryPointMatchesMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpanEntryPointMatchesMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpanEntryPointMatchesMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpanEntryPointMatchesMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison: str,
                 source: str,
                 case_sensitive: Optional[bool] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "source", source)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparison(self) -> str:
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class UpdateWindowsDailyRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurrenceRange":
            suggest = "recurrence_range"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateWindowsDailyRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateWindowsDailyRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateWindowsDailyRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 every: int,
                 recurrence_range: 'outputs.UpdateWindowsDailyRecurrenceRecurrenceRange',
                 update_time: 'outputs.UpdateWindowsDailyRecurrenceUpdateTime'):
        pulumi.set(__self__, "every", every)
        pulumi.set(__self__, "recurrence_range", recurrence_range)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def every(self) -> int:
        return pulumi.get(self, "every")

    @property
    @pulumi.getter(name="recurrenceRange")
    def recurrence_range(self) -> 'outputs.UpdateWindowsDailyRecurrenceRecurrenceRange':
        return pulumi.get(self, "recurrence_range")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> 'outputs.UpdateWindowsDailyRecurrenceUpdateTime':
        return pulumi.get(self, "update_time")


@pulumi.output_type
class UpdateWindowsDailyRecurrenceRecurrenceRange(dict):
    def __init__(__self__, *,
                 end: str,
                 start: str):
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> str:
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> str:
        return pulumi.get(self, "start")


@pulumi.output_type
class UpdateWindowsDailyRecurrenceUpdateTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateWindowsDailyRecurrenceUpdateTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateWindowsDailyRecurrenceUpdateTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateWindowsDailyRecurrenceUpdateTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: int,
                 start_time: str,
                 time_zone: str):
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def duration(self) -> int:
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class UpdateWindowsMonthlyRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurrenceRange":
            suggest = "recurrence_range"
        elif key == "selectedMonthDay":
            suggest = "selected_month_day"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateWindowsMonthlyRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateWindowsMonthlyRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateWindowsMonthlyRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 every: int,
                 recurrence_range: 'outputs.UpdateWindowsMonthlyRecurrenceRecurrenceRange',
                 selected_month_day: int,
                 update_time: 'outputs.UpdateWindowsMonthlyRecurrenceUpdateTime'):
        pulumi.set(__self__, "every", every)
        pulumi.set(__self__, "recurrence_range", recurrence_range)
        pulumi.set(__self__, "selected_month_day", selected_month_day)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def every(self) -> int:
        return pulumi.get(self, "every")

    @property
    @pulumi.getter(name="recurrenceRange")
    def recurrence_range(self) -> 'outputs.UpdateWindowsMonthlyRecurrenceRecurrenceRange':
        return pulumi.get(self, "recurrence_range")

    @property
    @pulumi.getter(name="selectedMonthDay")
    def selected_month_day(self) -> int:
        return pulumi.get(self, "selected_month_day")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> 'outputs.UpdateWindowsMonthlyRecurrenceUpdateTime':
        return pulumi.get(self, "update_time")


@pulumi.output_type
class UpdateWindowsMonthlyRecurrenceRecurrenceRange(dict):
    def __init__(__self__, *,
                 end: str,
                 start: str):
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> str:
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> str:
        return pulumi.get(self, "start")


@pulumi.output_type
class UpdateWindowsMonthlyRecurrenceUpdateTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateWindowsMonthlyRecurrenceUpdateTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateWindowsMonthlyRecurrenceUpdateTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateWindowsMonthlyRecurrenceUpdateTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: int,
                 start_time: str,
                 time_zone: str):
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def duration(self) -> int:
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class UpdateWindowsOnceRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurrenceRange":
            suggest = "recurrence_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateWindowsOnceRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateWindowsOnceRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateWindowsOnceRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recurrence_range: 'outputs.UpdateWindowsOnceRecurrenceRecurrenceRange'):
        pulumi.set(__self__, "recurrence_range", recurrence_range)

    @property
    @pulumi.getter(name="recurrenceRange")
    def recurrence_range(self) -> 'outputs.UpdateWindowsOnceRecurrenceRecurrenceRange':
        return pulumi.get(self, "recurrence_range")


@pulumi.output_type
class UpdateWindowsOnceRecurrenceRecurrenceRange(dict):
    def __init__(__self__, *,
                 end: str,
                 start: str):
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> str:
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> str:
        return pulumi.get(self, "start")


@pulumi.output_type
class UpdateWindowsWeeklyRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurrenceRange":
            suggest = "recurrence_range"
        elif key == "selectedWeekDays":
            suggest = "selected_week_days"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateWindowsWeeklyRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateWindowsWeeklyRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateWindowsWeeklyRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 every: int,
                 recurrence_range: 'outputs.UpdateWindowsWeeklyRecurrenceRecurrenceRange',
                 selected_week_days: 'outputs.UpdateWindowsWeeklyRecurrenceSelectedWeekDays',
                 update_time: 'outputs.UpdateWindowsWeeklyRecurrenceUpdateTime'):
        pulumi.set(__self__, "every", every)
        pulumi.set(__self__, "recurrence_range", recurrence_range)
        pulumi.set(__self__, "selected_week_days", selected_week_days)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def every(self) -> int:
        return pulumi.get(self, "every")

    @property
    @pulumi.getter(name="recurrenceRange")
    def recurrence_range(self) -> 'outputs.UpdateWindowsWeeklyRecurrenceRecurrenceRange':
        return pulumi.get(self, "recurrence_range")

    @property
    @pulumi.getter(name="selectedWeekDays")
    def selected_week_days(self) -> 'outputs.UpdateWindowsWeeklyRecurrenceSelectedWeekDays':
        return pulumi.get(self, "selected_week_days")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> 'outputs.UpdateWindowsWeeklyRecurrenceUpdateTime':
        return pulumi.get(self, "update_time")


@pulumi.output_type
class UpdateWindowsWeeklyRecurrenceRecurrenceRange(dict):
    def __init__(__self__, *,
                 end: str,
                 start: str):
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> str:
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> str:
        return pulumi.get(self, "start")


@pulumi.output_type
class UpdateWindowsWeeklyRecurrenceSelectedWeekDays(dict):
    def __init__(__self__, *,
                 friday: bool,
                 monday: bool,
                 saturday: bool,
                 sunday: bool,
                 thursday: bool,
                 tuesday: bool,
                 wednesday: bool):
        pulumi.set(__self__, "friday", friday)
        pulumi.set(__self__, "monday", monday)
        pulumi.set(__self__, "saturday", saturday)
        pulumi.set(__self__, "sunday", sunday)
        pulumi.set(__self__, "thursday", thursday)
        pulumi.set(__self__, "tuesday", tuesday)
        pulumi.set(__self__, "wednesday", wednesday)

    @property
    @pulumi.getter
    def friday(self) -> bool:
        return pulumi.get(self, "friday")

    @property
    @pulumi.getter
    def monday(self) -> bool:
        return pulumi.get(self, "monday")

    @property
    @pulumi.getter
    def saturday(self) -> bool:
        return pulumi.get(self, "saturday")

    @property
    @pulumi.getter
    def sunday(self) -> bool:
        return pulumi.get(self, "sunday")

    @property
    @pulumi.getter
    def thursday(self) -> bool:
        return pulumi.get(self, "thursday")

    @property
    @pulumi.getter
    def tuesday(self) -> bool:
        return pulumi.get(self, "tuesday")

    @property
    @pulumi.getter
    def wednesday(self) -> bool:
        return pulumi.get(self, "wednesday")


@pulumi.output_type
class UpdateWindowsWeeklyRecurrenceUpdateTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateWindowsWeeklyRecurrenceUpdateTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateWindowsWeeklyRecurrenceUpdateTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateWindowsWeeklyRecurrenceUpdateTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: int,
                 start_time: str,
                 time_zone: str):
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def duration(self) -> int:
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class UserActionMetricsFilters(dict):
    def __init__(__self__, *,
                 filters: Sequence['outputs.UserActionMetricsFiltersFilter']):
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.UserActionMetricsFiltersFilter']:
        return pulumi.get(self, "filters")


@pulumi.output_type
class UserActionMetricsFiltersFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "valueIns":
            suggest = "value_ins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserActionMetricsFiltersFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserActionMetricsFiltersFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserActionMetricsFiltersFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 operator: str,
                 value: Optional[str] = None,
                 value_ins: Optional[Sequence[str]] = None):
        """
        :param str value: Defines the type of value to be extracted from the user action. When using **user action counter**, the number of user actions is counted (similar to count(*) when using USQL). When using **user action field value**, the value of a user action field is extracted.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_ins is not None:
            pulumi.set(__self__, "value_ins", value_ins)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Defines the type of value to be extracted from the user action. When using **user action counter**, the number of user actions is counted (similar to count(*) when using USQL). When using **user action field value**, the value of a user action field is extracted.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueIns")
    def value_ins(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "value_ins")


@pulumi.output_type
class UserActionMetricsValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserActionMetricsValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserActionMetricsValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserActionMetricsValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 field_name: Optional[str] = None):
        """
        :param str type: Possible Values: `COUNTER`, `FIELD`
        :param str field_name: Field name
        """
        pulumi.set(__self__, "type", type)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `COUNTER`, `FIELD`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[str]:
        """
        Field name
        """
        return pulumi.get(self, "field_name")


@pulumi.output_type
class UserGroupPermissions(dict):
    def __init__(__self__, *,
                 grants: Sequence['outputs.UserGroupPermissionsGrant']):
        """
        :param Sequence['UserGroupPermissionsGrantArgs'] grants: A permission granted to one or multiple environments
        """
        pulumi.set(__self__, "grants", grants)

    @property
    @pulumi.getter
    def grants(self) -> Sequence['outputs.UserGroupPermissionsGrant']:
        """
        A permission granted to one or multiple environments
        """
        return pulumi.get(self, "grants")


@pulumi.output_type
class UserGroupPermissionsGrant(dict):
    def __init__(__self__, *,
                 permission: str,
                 environments: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "permission", permission)
        if environments is not None:
            pulumi.set(__self__, "environments", environments)

    @property
    @pulumi.getter
    def permission(self) -> str:
        return pulumi.get(self, "permission")

    @property
    @pulumi.getter
    def environments(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "environments")


@pulumi.output_type
class UserSessionMetricsFilters(dict):
    def __init__(__self__, *,
                 filters: Sequence['outputs.UserSessionMetricsFiltersFilter']):
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.UserSessionMetricsFiltersFilter']:
        return pulumi.get(self, "filters")


@pulumi.output_type
class UserSessionMetricsFiltersFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "valueIns":
            suggest = "value_ins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserSessionMetricsFiltersFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserSessionMetricsFiltersFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserSessionMetricsFiltersFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 operator: str,
                 value: Optional[str] = None,
                 value_ins: Optional[Sequence[str]] = None):
        """
        :param str value: Defines the type of value to be extracted from the user session. When using **User session counter**, the number of user sessions is counted (similar to count(*) when using USQL). When using **User session field value**, the value of a user session field is extracted.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_ins is not None:
            pulumi.set(__self__, "value_ins", value_ins)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Defines the type of value to be extracted from the user session. When using **User session counter**, the number of user sessions is counted (similar to count(*) when using USQL). When using **User session field value**, the value of a user session field is extracted.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueIns")
    def value_ins(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "value_ins")


@pulumi.output_type
class UserSessionMetricsValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserSessionMetricsValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserSessionMetricsValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserSessionMetricsValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 field_name: Optional[str] = None):
        """
        :param str type: Possible Values: `COUNTER`, `FIELD`
        :param str field_name: Field name
        """
        pulumi.set(__self__, "type", type)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Possible Values: `COUNTER`, `FIELD`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[str]:
        """
        Field name
        """
        return pulumi.get(self, "field_name")


@pulumi.output_type
class VmwareAnomaliesDroppedPacketsDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesDroppedPacketsDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesDroppedPacketsDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesDroppedPacketsDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.VmwareAnomaliesDroppedPacketsDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'VmwareAnomaliesDroppedPacketsDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.VmwareAnomaliesDroppedPacketsDetectionCustomThresholds']:
        """
        Alert if the condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class VmwareAnomaliesDroppedPacketsDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "droppedPacketsPerSecond":
            suggest = "dropped_packets_per_second"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesDroppedPacketsDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesDroppedPacketsDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesDroppedPacketsDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dropped_packets_per_second: int):
        pulumi.set(__self__, "dropped_packets_per_second", dropped_packets_per_second)

    @property
    @pulumi.getter(name="droppedPacketsPerSecond")
    def dropped_packets_per_second(self) -> int:
        return pulumi.get(self, "dropped_packets_per_second")


@pulumi.output_type
class VmwareAnomaliesEsxiHighCpuDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesEsxiHighCpuDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesEsxiHighCpuDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesEsxiHighCpuDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.VmwareAnomaliesEsxiHighCpuDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'VmwareAnomaliesEsxiHighCpuDetectionCustomThresholdsArgs' custom_thresholds: Alert if **all three** conditions are met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.VmwareAnomaliesEsxiHighCpuDetectionCustomThresholds']:
        """
        Alert if **all three** conditions are met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class VmwareAnomaliesEsxiHighCpuDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuPeakPercentage":
            suggest = "cpu_peak_percentage"
        elif key == "cpuUsagePercentage":
            suggest = "cpu_usage_percentage"
        elif key == "vmCpuReadyPercentage":
            suggest = "vm_cpu_ready_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesEsxiHighCpuDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesEsxiHighCpuDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesEsxiHighCpuDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_peak_percentage: int,
                 cpu_usage_percentage: int,
                 vm_cpu_ready_percentage: int):
        pulumi.set(__self__, "cpu_peak_percentage", cpu_peak_percentage)
        pulumi.set(__self__, "cpu_usage_percentage", cpu_usage_percentage)
        pulumi.set(__self__, "vm_cpu_ready_percentage", vm_cpu_ready_percentage)

    @property
    @pulumi.getter(name="cpuPeakPercentage")
    def cpu_peak_percentage(self) -> int:
        return pulumi.get(self, "cpu_peak_percentage")

    @property
    @pulumi.getter(name="cpuUsagePercentage")
    def cpu_usage_percentage(self) -> int:
        return pulumi.get(self, "cpu_usage_percentage")

    @property
    @pulumi.getter(name="vmCpuReadyPercentage")
    def vm_cpu_ready_percentage(self) -> int:
        return pulumi.get(self, "vm_cpu_ready_percentage")


@pulumi.output_type
class VmwareAnomaliesEsxiHighMemoryDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesEsxiHighMemoryDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesEsxiHighMemoryDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesEsxiHighMemoryDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.VmwareAnomaliesEsxiHighMemoryDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'VmwareAnomaliesEsxiHighMemoryDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.VmwareAnomaliesEsxiHighMemoryDetectionCustomThresholds']:
        """
        Alert if the condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class VmwareAnomaliesEsxiHighMemoryDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionDecompressionRate":
            suggest = "compression_decompression_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesEsxiHighMemoryDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesEsxiHighMemoryDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesEsxiHighMemoryDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_decompression_rate: float):
        pulumi.set(__self__, "compression_decompression_rate", compression_decompression_rate)

    @property
    @pulumi.getter(name="compressionDecompressionRate")
    def compression_decompression_rate(self) -> float:
        return pulumi.get(self, "compression_decompression_rate")


@pulumi.output_type
class VmwareAnomaliesGuestCpuLimitDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesGuestCpuLimitDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesGuestCpuLimitDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesGuestCpuLimitDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.VmwareAnomaliesGuestCpuLimitDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'VmwareAnomaliesGuestCpuLimitDetectionCustomThresholdsArgs' custom_thresholds: Alert if **all three** conditions are met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.VmwareAnomaliesGuestCpuLimitDetectionCustomThresholds']:
        """
        Alert if **all three** conditions are met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class VmwareAnomaliesGuestCpuLimitDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostCpuUsagePercentage":
            suggest = "host_cpu_usage_percentage"
        elif key == "vmCpuReadyPercentage":
            suggest = "vm_cpu_ready_percentage"
        elif key == "vmCpuUsagePercentage":
            suggest = "vm_cpu_usage_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesGuestCpuLimitDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesGuestCpuLimitDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesGuestCpuLimitDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_cpu_usage_percentage: int,
                 vm_cpu_ready_percentage: int,
                 vm_cpu_usage_percentage: int):
        pulumi.set(__self__, "host_cpu_usage_percentage", host_cpu_usage_percentage)
        pulumi.set(__self__, "vm_cpu_ready_percentage", vm_cpu_ready_percentage)
        pulumi.set(__self__, "vm_cpu_usage_percentage", vm_cpu_usage_percentage)

    @property
    @pulumi.getter(name="hostCpuUsagePercentage")
    def host_cpu_usage_percentage(self) -> int:
        return pulumi.get(self, "host_cpu_usage_percentage")

    @property
    @pulumi.getter(name="vmCpuReadyPercentage")
    def vm_cpu_ready_percentage(self) -> int:
        return pulumi.get(self, "vm_cpu_ready_percentage")

    @property
    @pulumi.getter(name="vmCpuUsagePercentage")
    def vm_cpu_usage_percentage(self) -> int:
        return pulumi.get(self, "vm_cpu_usage_percentage")


@pulumi.output_type
class VmwareAnomaliesLowDatastoreSpaceDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesLowDatastoreSpaceDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesLowDatastoreSpaceDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesLowDatastoreSpaceDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.VmwareAnomaliesLowDatastoreSpaceDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'VmwareAnomaliesLowDatastoreSpaceDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 1 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.VmwareAnomaliesLowDatastoreSpaceDetectionCustomThresholds']:
        """
        Alert if the condition is met in 1 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class VmwareAnomaliesLowDatastoreSpaceDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "freeSpacePercentage":
            suggest = "free_space_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesLowDatastoreSpaceDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesLowDatastoreSpaceDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesLowDatastoreSpaceDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 free_space_percentage: int):
        pulumi.set(__self__, "free_space_percentage", free_space_percentage)

    @property
    @pulumi.getter(name="freeSpacePercentage")
    def free_space_percentage(self) -> int:
        return pulumi.get(self, "free_space_percentage")


@pulumi.output_type
class VmwareAnomaliesOverloadedStorageDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesOverloadedStorageDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesOverloadedStorageDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesOverloadedStorageDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.VmwareAnomaliesOverloadedStorageDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'VmwareAnomaliesOverloadedStorageDetectionCustomThresholdsArgs' custom_thresholds: Alert if the condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.VmwareAnomaliesOverloadedStorageDetectionCustomThresholds']:
        """
        Alert if the condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class VmwareAnomaliesOverloadedStorageDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commandAbortsNumber":
            suggest = "command_aborts_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesOverloadedStorageDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesOverloadedStorageDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesOverloadedStorageDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command_aborts_number: int):
        pulumi.set(__self__, "command_aborts_number", command_aborts_number)

    @property
    @pulumi.getter(name="commandAbortsNumber")
    def command_aborts_number(self) -> int:
        return pulumi.get(self, "command_aborts_number")


@pulumi.output_type
class VmwareAnomaliesSlowPhysicalStorageDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesSlowPhysicalStorageDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesSlowPhysicalStorageDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesSlowPhysicalStorageDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.VmwareAnomaliesSlowPhysicalStorageDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'VmwareAnomaliesSlowPhysicalStorageDetectionCustomThresholdsArgs' custom_thresholds: Alert if **any** condition is met in 4 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.VmwareAnomaliesSlowPhysicalStorageDetectionCustomThresholds']:
        """
        Alert if **any** condition is met in 4 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class VmwareAnomaliesSlowPhysicalStorageDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avgReadWriteLatency":
            suggest = "avg_read_write_latency"
        elif key == "peakReadWriteLatency":
            suggest = "peak_read_write_latency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesSlowPhysicalStorageDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesSlowPhysicalStorageDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesSlowPhysicalStorageDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avg_read_write_latency: int,
                 peak_read_write_latency: int):
        pulumi.set(__self__, "avg_read_write_latency", avg_read_write_latency)
        pulumi.set(__self__, "peak_read_write_latency", peak_read_write_latency)

    @property
    @pulumi.getter(name="avgReadWriteLatency")
    def avg_read_write_latency(self) -> int:
        return pulumi.get(self, "avg_read_write_latency")

    @property
    @pulumi.getter(name="peakReadWriteLatency")
    def peak_read_write_latency(self) -> int:
        return pulumi.get(self, "peak_read_write_latency")


@pulumi.output_type
class VmwareAnomaliesUndersizedStorageDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customThresholds":
            suggest = "custom_thresholds"
        elif key == "detectionMode":
            suggest = "detection_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesUndersizedStorageDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesUndersizedStorageDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesUndersizedStorageDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 custom_thresholds: Optional['outputs.VmwareAnomaliesUndersizedStorageDetectionCustomThresholds'] = None,
                 detection_mode: Optional[str] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'VmwareAnomaliesUndersizedStorageDetectionCustomThresholdsArgs' custom_thresholds: Alert if **any** condition is met in 3 out of 5 samples
        :param str detection_mode: Possible Values: `Auto`, `Custom`
        """
        pulumi.set(__self__, "enabled", enabled)
        if custom_thresholds is not None:
            pulumi.set(__self__, "custom_thresholds", custom_thresholds)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="customThresholds")
    def custom_thresholds(self) -> Optional['outputs.VmwareAnomaliesUndersizedStorageDetectionCustomThresholds']:
        """
        Alert if **any** condition is met in 3 out of 5 samples
        """
        return pulumi.get(self, "custom_thresholds")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Custom`
        """
        return pulumi.get(self, "detection_mode")


@pulumi.output_type
class VmwareAnomaliesUndersizedStorageDetectionCustomThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "averageQueueCommandLatency":
            suggest = "average_queue_command_latency"
        elif key == "peakQueueCommandLatency":
            suggest = "peak_queue_command_latency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAnomaliesUndersizedStorageDetectionCustomThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAnomaliesUndersizedStorageDetectionCustomThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAnomaliesUndersizedStorageDetectionCustomThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 average_queue_command_latency: int,
                 peak_queue_command_latency: int):
        pulumi.set(__self__, "average_queue_command_latency", average_queue_command_latency)
        pulumi.set(__self__, "peak_queue_command_latency", peak_queue_command_latency)

    @property
    @pulumi.getter(name="averageQueueCommandLatency")
    def average_queue_command_latency(self) -> int:
        return pulumi.get(self, "average_queue_command_latency")

    @property
    @pulumi.getter(name="peakQueueCommandLatency")
    def peak_queue_command_latency(self) -> int:
        return pulumi.get(self, "peak_queue_command_latency")


@pulumi.output_type
class WebAppAnomaliesErrorRate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorRateAuto":
            suggest = "error_rate_auto"
        elif key == "errorRateDetectionMode":
            suggest = "error_rate_detection_mode"
        elif key == "errorRateFixed":
            suggest = "error_rate_fixed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesErrorRate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesErrorRate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesErrorRate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 error_rate_auto: Optional['outputs.WebAppAnomaliesErrorRateErrorRateAuto'] = None,
                 error_rate_detection_mode: Optional[str] = None,
                 error_rate_fixed: Optional['outputs.WebAppAnomaliesErrorRateErrorRateFixed'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'WebAppAnomaliesErrorRateErrorRateAutoArgs' error_rate_auto: Alert if the percentage of failing user actions increases by **both** the absolute and relative thresholds:
        :param str error_rate_detection_mode: Possible Values: `Auto`, `Fixed`
        :param 'WebAppAnomaliesErrorRateErrorRateFixedArgs' error_rate_fixed: no documentation available
        """
        pulumi.set(__self__, "enabled", enabled)
        if error_rate_auto is not None:
            pulumi.set(__self__, "error_rate_auto", error_rate_auto)
        if error_rate_detection_mode is not None:
            pulumi.set(__self__, "error_rate_detection_mode", error_rate_detection_mode)
        if error_rate_fixed is not None:
            pulumi.set(__self__, "error_rate_fixed", error_rate_fixed)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="errorRateAuto")
    def error_rate_auto(self) -> Optional['outputs.WebAppAnomaliesErrorRateErrorRateAuto']:
        """
        Alert if the percentage of failing user actions increases by **both** the absolute and relative thresholds:
        """
        return pulumi.get(self, "error_rate_auto")

    @property
    @pulumi.getter(name="errorRateDetectionMode")
    def error_rate_detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Fixed`
        """
        return pulumi.get(self, "error_rate_detection_mode")

    @property
    @pulumi.getter(name="errorRateFixed")
    def error_rate_fixed(self) -> Optional['outputs.WebAppAnomaliesErrorRateErrorRateFixed']:
        """
        no documentation available
        """
        return pulumi.get(self, "error_rate_fixed")


@pulumi.output_type
class WebAppAnomaliesErrorRateErrorRateAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "absoluteIncrease":
            suggest = "absolute_increase"
        elif key == "overAlertingProtection":
            suggest = "over_alerting_protection"
        elif key == "relativeIncrease":
            suggest = "relative_increase"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesErrorRateErrorRateAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesErrorRateErrorRateAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesErrorRateErrorRateAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 absolute_increase: float,
                 over_alerting_protection: 'outputs.WebAppAnomaliesErrorRateErrorRateAutoOverAlertingProtection',
                 relative_increase: float):
        pulumi.set(__self__, "absolute_increase", absolute_increase)
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "relative_increase", relative_increase)

    @property
    @pulumi.getter(name="absoluteIncrease")
    def absolute_increase(self) -> float:
        return pulumi.get(self, "absolute_increase")

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.WebAppAnomaliesErrorRateErrorRateAutoOverAlertingProtection':
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter(name="relativeIncrease")
    def relative_increase(self) -> float:
        return pulumi.get(self, "relative_increase")


@pulumi.output_type
class WebAppAnomaliesErrorRateErrorRateAutoOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsPerMinute":
            suggest = "actions_per_minute"
        elif key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesErrorRateErrorRateAutoOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesErrorRateErrorRateAutoOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesErrorRateErrorRateAutoOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_per_minute: float,
                 minutes_abnormal_state: float):
        pulumi.set(__self__, "actions_per_minute", actions_per_minute)
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)

    @property
    @pulumi.getter(name="actionsPerMinute")
    def actions_per_minute(self) -> float:
        return pulumi.get(self, "actions_per_minute")

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> float:
        return pulumi.get(self, "minutes_abnormal_state")


@pulumi.output_type
class WebAppAnomaliesErrorRateErrorRateFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorRateReqPerMin":
            suggest = "error_rate_req_per_min"
        elif key == "errorRateSensitivity":
            suggest = "error_rate_sensitivity"
        elif key == "maxFailureRateIncrease":
            suggest = "max_failure_rate_increase"
        elif key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesErrorRateErrorRateFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesErrorRateErrorRateFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesErrorRateErrorRateFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_rate_req_per_min: float,
                 error_rate_sensitivity: str,
                 max_failure_rate_increase: float,
                 minutes_abnormal_state: float):
        pulumi.set(__self__, "error_rate_req_per_min", error_rate_req_per_min)
        pulumi.set(__self__, "error_rate_sensitivity", error_rate_sensitivity)
        pulumi.set(__self__, "max_failure_rate_increase", max_failure_rate_increase)
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)

    @property
    @pulumi.getter(name="errorRateReqPerMin")
    def error_rate_req_per_min(self) -> float:
        return pulumi.get(self, "error_rate_req_per_min")

    @property
    @pulumi.getter(name="errorRateSensitivity")
    def error_rate_sensitivity(self) -> str:
        return pulumi.get(self, "error_rate_sensitivity")

    @property
    @pulumi.getter(name="maxFailureRateIncrease")
    def max_failure_rate_increase(self) -> float:
        return pulumi.get(self, "max_failure_rate_increase")

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> float:
        return pulumi.get(self, "minutes_abnormal_state")


@pulumi.output_type
class WebAppAnomaliesResponseTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectionMode":
            suggest = "detection_mode"
        elif key == "responseTimeAuto":
            suggest = "response_time_auto"
        elif key == "responseTimeFixed":
            suggest = "response_time_fixed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesResponseTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesResponseTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesResponseTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 detection_mode: Optional[str] = None,
                 response_time_auto: Optional['outputs.WebAppAnomaliesResponseTimeResponseTimeAuto'] = None,
                 response_time_fixed: Optional['outputs.WebAppAnomaliesResponseTimeResponseTimeFixed'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param str detection_mode: Possible Values: `Auto`, `Fixed`
        :param 'WebAppAnomaliesResponseTimeResponseTimeAutoArgs' response_time_auto: no documentation available
        :param 'WebAppAnomaliesResponseTimeResponseTimeFixedArgs' response_time_fixed: no documentation available
        """
        pulumi.set(__self__, "enabled", enabled)
        if detection_mode is not None:
            pulumi.set(__self__, "detection_mode", detection_mode)
        if response_time_auto is not None:
            pulumi.set(__self__, "response_time_auto", response_time_auto)
        if response_time_fixed is not None:
            pulumi.set(__self__, "response_time_fixed", response_time_fixed)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="detectionMode")
    def detection_mode(self) -> Optional[str]:
        """
        Possible Values: `Auto`, `Fixed`
        """
        return pulumi.get(self, "detection_mode")

    @property
    @pulumi.getter(name="responseTimeAuto")
    def response_time_auto(self) -> Optional['outputs.WebAppAnomaliesResponseTimeResponseTimeAuto']:
        """
        no documentation available
        """
        return pulumi.get(self, "response_time_auto")

    @property
    @pulumi.getter(name="responseTimeFixed")
    def response_time_fixed(self) -> Optional['outputs.WebAppAnomaliesResponseTimeResponseTimeFixed']:
        """
        no documentation available
        """
        return pulumi.get(self, "response_time_fixed")


@pulumi.output_type
class WebAppAnomaliesResponseTimeResponseTimeAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overAlertingProtection":
            suggest = "over_alerting_protection"
        elif key == "responseTimeAll":
            suggest = "response_time_all"
        elif key == "responseTimeSlowest":
            suggest = "response_time_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesResponseTimeResponseTimeAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 over_alerting_protection: 'outputs.WebAppAnomaliesResponseTimeResponseTimeAutoOverAlertingProtection',
                 response_time_all: 'outputs.WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeAll',
                 response_time_slowest: 'outputs.WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeSlowest'):
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "response_time_all", response_time_all)
        pulumi.set(__self__, "response_time_slowest", response_time_slowest)

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.WebAppAnomaliesResponseTimeResponseTimeAutoOverAlertingProtection':
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter(name="responseTimeAll")
    def response_time_all(self) -> 'outputs.WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeAll':
        return pulumi.get(self, "response_time_all")

    @property
    @pulumi.getter(name="responseTimeSlowest")
    def response_time_slowest(self) -> 'outputs.WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeSlowest':
        return pulumi.get(self, "response_time_slowest")


@pulumi.output_type
class WebAppAnomaliesResponseTimeResponseTimeAutoOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsPerMinute":
            suggest = "actions_per_minute"
        elif key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesResponseTimeResponseTimeAutoOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeAutoOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeAutoOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_per_minute: float,
                 minutes_abnormal_state: float):
        pulumi.set(__self__, "actions_per_minute", actions_per_minute)
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)

    @property
    @pulumi.getter(name="actionsPerMinute")
    def actions_per_minute(self) -> float:
        return pulumi.get(self, "actions_per_minute")

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> float:
        return pulumi.get(self, "minutes_abnormal_state")


@pulumi.output_type
class WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeAll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "degradationMilliseconds":
            suggest = "degradation_milliseconds"
        elif key == "degradationPercent":
            suggest = "degradation_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeAll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeAll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeAll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 degradation_milliseconds: float,
                 degradation_percent: float):
        pulumi.set(__self__, "degradation_milliseconds", degradation_milliseconds)
        pulumi.set(__self__, "degradation_percent", degradation_percent)

    @property
    @pulumi.getter(name="degradationMilliseconds")
    def degradation_milliseconds(self) -> float:
        return pulumi.get(self, "degradation_milliseconds")

    @property
    @pulumi.getter(name="degradationPercent")
    def degradation_percent(self) -> float:
        return pulumi.get(self, "degradation_percent")


@pulumi.output_type
class WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestDegradationMilliseconds":
            suggest = "slowest_degradation_milliseconds"
        elif key == "slowestDegradationPercent":
            suggest = "slowest_degradation_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slowest_degradation_milliseconds: float,
                 slowest_degradation_percent: float):
        pulumi.set(__self__, "slowest_degradation_milliseconds", slowest_degradation_milliseconds)
        pulumi.set(__self__, "slowest_degradation_percent", slowest_degradation_percent)

    @property
    @pulumi.getter(name="slowestDegradationMilliseconds")
    def slowest_degradation_milliseconds(self) -> float:
        return pulumi.get(self, "slowest_degradation_milliseconds")

    @property
    @pulumi.getter(name="slowestDegradationPercent")
    def slowest_degradation_percent(self) -> float:
        return pulumi.get(self, "slowest_degradation_percent")


@pulumi.output_type
class WebAppAnomaliesResponseTimeResponseTimeFixed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overAlertingProtection":
            suggest = "over_alerting_protection"
        elif key == "responseTimeAll":
            suggest = "response_time_all"
        elif key == "responseTimeSlowest":
            suggest = "response_time_slowest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesResponseTimeResponseTimeFixed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeFixed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeFixed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 over_alerting_protection: 'outputs.WebAppAnomaliesResponseTimeResponseTimeFixedOverAlertingProtection',
                 response_time_all: 'outputs.WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeAll',
                 response_time_slowest: 'outputs.WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeSlowest',
                 sensitivity: str):
        pulumi.set(__self__, "over_alerting_protection", over_alerting_protection)
        pulumi.set(__self__, "response_time_all", response_time_all)
        pulumi.set(__self__, "response_time_slowest", response_time_slowest)
        pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="overAlertingProtection")
    def over_alerting_protection(self) -> 'outputs.WebAppAnomaliesResponseTimeResponseTimeFixedOverAlertingProtection':
        return pulumi.get(self, "over_alerting_protection")

    @property
    @pulumi.getter(name="responseTimeAll")
    def response_time_all(self) -> 'outputs.WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeAll':
        return pulumi.get(self, "response_time_all")

    @property
    @pulumi.getter(name="responseTimeSlowest")
    def response_time_slowest(self) -> 'outputs.WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeSlowest':
        return pulumi.get(self, "response_time_slowest")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class WebAppAnomaliesResponseTimeResponseTimeFixedOverAlertingProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsPerMinute":
            suggest = "actions_per_minute"
        elif key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesResponseTimeResponseTimeFixedOverAlertingProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeFixedOverAlertingProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeFixedOverAlertingProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_per_minute: float,
                 minutes_abnormal_state: float):
        pulumi.set(__self__, "actions_per_minute", actions_per_minute)
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)

    @property
    @pulumi.getter(name="actionsPerMinute")
    def actions_per_minute(self) -> float:
        return pulumi.get(self, "actions_per_minute")

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> float:
        return pulumi.get(self, "minutes_abnormal_state")


@pulumi.output_type
class WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeAll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "degradationMilliseconds":
            suggest = "degradation_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeAll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeAll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeAll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 degradation_milliseconds: float):
        pulumi.set(__self__, "degradation_milliseconds", degradation_milliseconds)

    @property
    @pulumi.getter(name="degradationMilliseconds")
    def degradation_milliseconds(self) -> float:
        return pulumi.get(self, "degradation_milliseconds")


@pulumi.output_type
class WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeSlowest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestDegradationMilliseconds":
            suggest = "slowest_degradation_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeSlowest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeSlowest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeSlowest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slowest_degradation_milliseconds: float):
        pulumi.set(__self__, "slowest_degradation_milliseconds", slowest_degradation_milliseconds)

    @property
    @pulumi.getter(name="slowestDegradationMilliseconds")
    def slowest_degradation_milliseconds(self) -> float:
        return pulumi.get(self, "slowest_degradation_milliseconds")


@pulumi.output_type
class WebAppAnomaliesTrafficDrops(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trafficDrops":
            suggest = "traffic_drops"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesTrafficDrops. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesTrafficDrops.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesTrafficDrops.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 traffic_drops: Optional['outputs.WebAppAnomaliesTrafficDropsTrafficDrops'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'WebAppAnomaliesTrafficDropsTrafficDropsArgs' traffic_drops: Dynatrace learns your typical application traffic over an observation period of one week.
        """
        pulumi.set(__self__, "enabled", enabled)
        if traffic_drops is not None:
            pulumi.set(__self__, "traffic_drops", traffic_drops)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="trafficDrops")
    def traffic_drops(self) -> Optional['outputs.WebAppAnomaliesTrafficDropsTrafficDrops']:
        """
        Dynatrace learns your typical application traffic over an observation period of one week.
        """
        return pulumi.get(self, "traffic_drops")


@pulumi.output_type
class WebAppAnomaliesTrafficDropsTrafficDrops(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "abnormalStateAbnormalState":
            suggest = "abnormal_state_abnormal_state"
        elif key == "trafficDropPercentage":
            suggest = "traffic_drop_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesTrafficDropsTrafficDrops. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesTrafficDropsTrafficDrops.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesTrafficDropsTrafficDrops.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 abnormal_state_abnormal_state: float,
                 traffic_drop_percentage: float):
        pulumi.set(__self__, "abnormal_state_abnormal_state", abnormal_state_abnormal_state)
        pulumi.set(__self__, "traffic_drop_percentage", traffic_drop_percentage)

    @property
    @pulumi.getter(name="abnormalStateAbnormalState")
    def abnormal_state_abnormal_state(self) -> float:
        return pulumi.get(self, "abnormal_state_abnormal_state")

    @property
    @pulumi.getter(name="trafficDropPercentage")
    def traffic_drop_percentage(self) -> float:
        return pulumi.get(self, "traffic_drop_percentage")


@pulumi.output_type
class WebAppAnomaliesTrafficSpikes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trafficSpikes":
            suggest = "traffic_spikes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesTrafficSpikes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesTrafficSpikes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesTrafficSpikes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 traffic_spikes: Optional['outputs.WebAppAnomaliesTrafficSpikesTrafficSpikes'] = None):
        """
        :param bool enabled: This setting is enabled (`true`) or disabled (`false`)
        :param 'WebAppAnomaliesTrafficSpikesTrafficSpikesArgs' traffic_spikes: Dynatrace learns your typical application traffic over an observation period of one week.
        """
        pulumi.set(__self__, "enabled", enabled)
        if traffic_spikes is not None:
            pulumi.set(__self__, "traffic_spikes", traffic_spikes)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="trafficSpikes")
    def traffic_spikes(self) -> Optional['outputs.WebAppAnomaliesTrafficSpikesTrafficSpikes']:
        """
        Dynatrace learns your typical application traffic over an observation period of one week.
        """
        return pulumi.get(self, "traffic_spikes")


@pulumi.output_type
class WebAppAnomaliesTrafficSpikesTrafficSpikes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minutesAbnormalState":
            suggest = "minutes_abnormal_state"
        elif key == "trafficSpikePercentage":
            suggest = "traffic_spike_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppAnomaliesTrafficSpikesTrafficSpikes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppAnomaliesTrafficSpikesTrafficSpikes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppAnomaliesTrafficSpikesTrafficSpikes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minutes_abnormal_state: float,
                 traffic_spike_percentage: float):
        pulumi.set(__self__, "minutes_abnormal_state", minutes_abnormal_state)
        pulumi.set(__self__, "traffic_spike_percentage", traffic_spike_percentage)

    @property
    @pulumi.getter(name="minutesAbnormalState")
    def minutes_abnormal_state(self) -> float:
        return pulumi.get(self, "minutes_abnormal_state")

    @property
    @pulumi.getter(name="trafficSpikePercentage")
    def traffic_spike_percentage(self) -> float:
        return pulumi.get(self, "traffic_spike_percentage")


@pulumi.output_type
class WebAppCustomErrorsErrorRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorRules":
            suggest = "error_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppCustomErrorsErrorRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppCustomErrorsErrorRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppCustomErrorsErrorRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_rules: Sequence['outputs.WebAppCustomErrorsErrorRulesErrorRule']):
        pulumi.set(__self__, "error_rules", error_rules)

    @property
    @pulumi.getter(name="errorRules")
    def error_rules(self) -> Sequence['outputs.WebAppCustomErrorsErrorRulesErrorRule']:
        return pulumi.get(self, "error_rules")


@pulumi.output_type
class WebAppCustomErrorsErrorRulesErrorRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "captureSettings":
            suggest = "capture_settings"
        elif key == "keyMatcher":
            suggest = "key_matcher"
        elif key == "valueMatcher":
            suggest = "value_matcher"
        elif key == "keyPattern":
            suggest = "key_pattern"
        elif key == "valuePattern":
            suggest = "value_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppCustomErrorsErrorRulesErrorRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppCustomErrorsErrorRulesErrorRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppCustomErrorsErrorRulesErrorRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture_settings: 'outputs.WebAppCustomErrorsErrorRulesErrorRuleCaptureSettings',
                 key_matcher: str,
                 value_matcher: str,
                 key_pattern: Optional[str] = None,
                 value_pattern: Optional[str] = None):
        pulumi.set(__self__, "capture_settings", capture_settings)
        pulumi.set(__self__, "key_matcher", key_matcher)
        pulumi.set(__self__, "value_matcher", value_matcher)
        if key_pattern is not None:
            pulumi.set(__self__, "key_pattern", key_pattern)
        if value_pattern is not None:
            pulumi.set(__self__, "value_pattern", value_pattern)

    @property
    @pulumi.getter(name="captureSettings")
    def capture_settings(self) -> 'outputs.WebAppCustomErrorsErrorRulesErrorRuleCaptureSettings':
        return pulumi.get(self, "capture_settings")

    @property
    @pulumi.getter(name="keyMatcher")
    def key_matcher(self) -> str:
        return pulumi.get(self, "key_matcher")

    @property
    @pulumi.getter(name="valueMatcher")
    def value_matcher(self) -> str:
        return pulumi.get(self, "value_matcher")

    @property
    @pulumi.getter(name="keyPattern")
    def key_pattern(self) -> Optional[str]:
        return pulumi.get(self, "key_pattern")

    @property
    @pulumi.getter(name="valuePattern")
    def value_pattern(self) -> Optional[str]:
        return pulumi.get(self, "value_pattern")


@pulumi.output_type
class WebAppCustomErrorsErrorRulesErrorRuleCaptureSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "considerForAi":
            suggest = "consider_for_ai"
        elif key == "impactApdex":
            suggest = "impact_apdex"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppCustomErrorsErrorRulesErrorRuleCaptureSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppCustomErrorsErrorRulesErrorRuleCaptureSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppCustomErrorsErrorRulesErrorRuleCaptureSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture: bool,
                 consider_for_ai: Optional[bool] = None,
                 impact_apdex: Optional[bool] = None):
        pulumi.set(__self__, "capture", capture)
        if consider_for_ai is not None:
            pulumi.set(__self__, "consider_for_ai", consider_for_ai)
        if impact_apdex is not None:
            pulumi.set(__self__, "impact_apdex", impact_apdex)

    @property
    @pulumi.getter
    def capture(self) -> bool:
        return pulumi.get(self, "capture")

    @property
    @pulumi.getter(name="considerForAi")
    def consider_for_ai(self) -> Optional[bool]:
        return pulumi.get(self, "consider_for_ai")

    @property
    @pulumi.getter(name="impactApdex")
    def impact_apdex(self) -> Optional[bool]:
        return pulumi.get(self, "impact_apdex")


@pulumi.output_type
class WebAppEnablementRum(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costAndTrafficControl":
            suggest = "cost_and_traffic_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppEnablementRum. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppEnablementRum.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppEnablementRum.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_and_traffic_control: int,
                 enabled: bool):
        """
        :param int cost_and_traffic_control: (Field has overlap with `WebApplication`) Percentage of user sessions captured and analyzed
        :param bool enabled: (Field has overlap with `WebApplication`) This setting is enabled (`true`) or disabled (`false`)
        """
        pulumi.set(__self__, "cost_and_traffic_control", cost_and_traffic_control)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="costAndTrafficControl")
    def cost_and_traffic_control(self) -> int:
        """
        (Field has overlap with `WebApplication`) Percentage of user sessions captured and analyzed
        """
        return pulumi.get(self, "cost_and_traffic_control")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        (Field has overlap with `WebApplication`) This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WebAppEnablementSessionReplay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costAndTrafficControl":
            suggest = "cost_and_traffic_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppEnablementSessionReplay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppEnablementSessionReplay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppEnablementSessionReplay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_and_traffic_control: int,
                 enabled: bool):
        """
        :param int cost_and_traffic_control: (Field has overlap with `WebApplication`) [Percentage of user sessions recorded with Session Replay](https://dt-url.net/sr-cost-traffic-control). For example, if you have 50% for RUM and 50% for Session Replay, it results in 25% of sessions recorded with Session Replay.
        :param bool enabled: (Field has overlap with `WebApplication`) This setting is enabled (`true`) or disabled (`false`)
        """
        pulumi.set(__self__, "cost_and_traffic_control", cost_and_traffic_control)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="costAndTrafficControl")
    def cost_and_traffic_control(self) -> int:
        """
        (Field has overlap with `WebApplication`) [Percentage of user sessions recorded with Session Replay](https://dt-url.net/sr-cost-traffic-control). For example, if you have 50% for RUM and 50% for Session Replay, it results in 25% of sessions recorded with Session Replay.
        """
        return pulumi.get(self, "cost_and_traffic_control")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        (Field has overlap with `WebApplication`) This setting is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WebAppRequestErrorsErrorRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorRules":
            suggest = "error_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppRequestErrorsErrorRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppRequestErrorsErrorRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppRequestErrorsErrorRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_rules: Sequence['outputs.WebAppRequestErrorsErrorRulesErrorRule']):
        pulumi.set(__self__, "error_rules", error_rules)

    @property
    @pulumi.getter(name="errorRules")
    def error_rules(self) -> Sequence['outputs.WebAppRequestErrorsErrorRulesErrorRule']:
        return pulumi.get(self, "error_rules")


@pulumi.output_type
class WebAppRequestErrorsErrorRulesErrorRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "captureSettings":
            suggest = "capture_settings"
        elif key == "considerCspViolations":
            suggest = "consider_csp_violations"
        elif key == "considerFailedImages":
            suggest = "consider_failed_images"
        elif key == "filterSettings":
            suggest = "filter_settings"
        elif key == "errorCodes":
            suggest = "error_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppRequestErrorsErrorRulesErrorRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppRequestErrorsErrorRulesErrorRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppRequestErrorsErrorRulesErrorRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture_settings: 'outputs.WebAppRequestErrorsErrorRulesErrorRuleCaptureSettings',
                 consider_csp_violations: bool,
                 consider_failed_images: bool,
                 filter_settings: 'outputs.WebAppRequestErrorsErrorRulesErrorRuleFilterSettings',
                 error_codes: Optional[str] = None):
        pulumi.set(__self__, "capture_settings", capture_settings)
        pulumi.set(__self__, "consider_csp_violations", consider_csp_violations)
        pulumi.set(__self__, "consider_failed_images", consider_failed_images)
        pulumi.set(__self__, "filter_settings", filter_settings)
        if error_codes is not None:
            pulumi.set(__self__, "error_codes", error_codes)

    @property
    @pulumi.getter(name="captureSettings")
    def capture_settings(self) -> 'outputs.WebAppRequestErrorsErrorRulesErrorRuleCaptureSettings':
        return pulumi.get(self, "capture_settings")

    @property
    @pulumi.getter(name="considerCspViolations")
    def consider_csp_violations(self) -> bool:
        return pulumi.get(self, "consider_csp_violations")

    @property
    @pulumi.getter(name="considerFailedImages")
    def consider_failed_images(self) -> bool:
        return pulumi.get(self, "consider_failed_images")

    @property
    @pulumi.getter(name="filterSettings")
    def filter_settings(self) -> 'outputs.WebAppRequestErrorsErrorRulesErrorRuleFilterSettings':
        return pulumi.get(self, "filter_settings")

    @property
    @pulumi.getter(name="errorCodes")
    def error_codes(self) -> Optional[str]:
        return pulumi.get(self, "error_codes")


@pulumi.output_type
class WebAppRequestErrorsErrorRulesErrorRuleCaptureSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "considerForAi":
            suggest = "consider_for_ai"
        elif key == "impactApdex":
            suggest = "impact_apdex"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAppRequestErrorsErrorRulesErrorRuleCaptureSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAppRequestErrorsErrorRulesErrorRuleCaptureSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAppRequestErrorsErrorRulesErrorRuleCaptureSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture: bool,
                 consider_for_ai: Optional[bool] = None,
                 impact_apdex: Optional[bool] = None):
        pulumi.set(__self__, "capture", capture)
        if consider_for_ai is not None:
            pulumi.set(__self__, "consider_for_ai", consider_for_ai)
        if impact_apdex is not None:
            pulumi.set(__self__, "impact_apdex", impact_apdex)

    @property
    @pulumi.getter
    def capture(self) -> bool:
        return pulumi.get(self, "capture")

    @property
    @pulumi.getter(name="considerForAi")
    def consider_for_ai(self) -> Optional[bool]:
        return pulumi.get(self, "consider_for_ai")

    @property
    @pulumi.getter(name="impactApdex")
    def impact_apdex(self) -> Optional[bool]:
        return pulumi.get(self, "impact_apdex")


@pulumi.output_type
class WebAppRequestErrorsErrorRulesErrorRuleFilterSettings(dict):
    def __init__(__self__, *,
                 filter: Optional[str] = None,
                 url: Optional[str] = None):
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class WebApplicationConversionGoals(dict):
    def __init__(__self__, *,
                 goals: Sequence['outputs.WebApplicationConversionGoalsGoal']):
        """
        :param Sequence['WebApplicationConversionGoalsGoalArgs'] goals: A conversion goal of the application
        """
        pulumi.set(__self__, "goals", goals)

    @property
    @pulumi.getter
    def goals(self) -> Sequence['outputs.WebApplicationConversionGoalsGoal']:
        """
        A conversion goal of the application
        """
        return pulumi.get(self, "goals")


@pulumi.output_type
class WebApplicationConversionGoalsGoal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userAction":
            suggest = "user_action"
        elif key == "visitDuration":
            suggest = "visit_duration"
        elif key == "visitNumAction":
            suggest = "visit_num_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationConversionGoalsGoal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationConversionGoalsGoal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationConversionGoalsGoal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 destination: Optional['outputs.WebApplicationConversionGoalsGoalDestination'] = None,
                 id: Optional[str] = None,
                 type: Optional[str] = None,
                 user_action: Optional['outputs.WebApplicationConversionGoalsGoalUserAction'] = None,
                 visit_duration: Optional['outputs.WebApplicationConversionGoalsGoalVisitDuration'] = None,
                 visit_num_action: Optional['outputs.WebApplicationConversionGoalsGoalVisitNumAction'] = None):
        """
        :param str name: The name of the web application, displayed in the UI
        :param str id: The ID of this resource.
        :param str type: The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        pulumi.set(__self__, "name", name)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_action is not None:
            pulumi.set(__self__, "user_action", user_action)
        if visit_duration is not None:
            pulumi.set(__self__, "visit_duration", visit_duration)
        if visit_num_action is not None:
            pulumi.set(__self__, "visit_num_action", visit_num_action)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the web application, displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.WebApplicationConversionGoalsGoalDestination']:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAction")
    def user_action(self) -> Optional['outputs.WebApplicationConversionGoalsGoalUserAction']:
        return pulumi.get(self, "user_action")

    @property
    @pulumi.getter(name="visitDuration")
    def visit_duration(self) -> Optional['outputs.WebApplicationConversionGoalsGoalVisitDuration']:
        return pulumi.get(self, "visit_duration")

    @property
    @pulumi.getter(name="visitNumAction")
    def visit_num_action(self) -> Optional['outputs.WebApplicationConversionGoalsGoalVisitNumAction']:
        return pulumi.get(self, "visit_num_action")


@pulumi.output_type
class WebApplicationConversionGoalsGoalDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlOrPath":
            suggest = "url_or_path"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchType":
            suggest = "match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationConversionGoalsGoalDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationConversionGoalsGoalDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationConversionGoalsGoalDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url_or_path: str,
                 case_sensitive: Optional[bool] = None,
                 match_type: Optional[str] = None):
        pulumi.set(__self__, "url_or_path", url_or_path)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)

    @property
    @pulumi.getter(name="urlOrPath")
    def url_or_path(self) -> str:
        return pulumi.get(self, "url_or_path")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        return pulumi.get(self, "match_type")


@pulumi.output_type
class WebApplicationConversionGoalsGoalUserAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchEntity":
            suggest = "match_entity"
        elif key == "matchType":
            suggest = "match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationConversionGoalsGoalUserAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationConversionGoalsGoalUserAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationConversionGoalsGoalUserAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: Optional[str] = None,
                 case_sensitive: Optional[bool] = None,
                 match_entity: Optional[str] = None,
                 match_type: Optional[str] = None,
                 value: Optional[str] = None):
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_entity is not None:
            pulumi.set(__self__, "match_entity", match_entity)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchEntity")
    def match_entity(self) -> Optional[str]:
        return pulumi.get(self, "match_entity")

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebApplicationConversionGoalsGoalVisitDuration(dict):
    def __init__(__self__, *,
                 duration: int):
        pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter
    def duration(self) -> int:
        return pulumi.get(self, "duration")


@pulumi.output_type
class WebApplicationConversionGoalsGoalVisitNumAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numUserActions":
            suggest = "num_user_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationConversionGoalsGoalVisitNumAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationConversionGoalsGoalVisitNumAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationConversionGoalsGoalVisitNumAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_user_actions: Optional[int] = None):
        if num_user_actions is not None:
            pulumi.set(__self__, "num_user_actions", num_user_actions)

    @property
    @pulumi.getter(name="numUserActions")
    def num_user_actions(self) -> Optional[int]:
        return pulumi.get(self, "num_user_actions")


@pulumi.output_type
class WebApplicationCustomActionApdexSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frustratingFallbackThreshold":
            suggest = "frustrating_fallback_threshold"
        elif key == "frustratingThreshold":
            suggest = "frustrating_threshold"
        elif key == "toleratedFallbackThreshold":
            suggest = "tolerated_fallback_threshold"
        elif key == "toleratedThreshold":
            suggest = "tolerated_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationCustomActionApdexSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationCustomActionApdexSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationCustomActionApdexSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frustrating_fallback_threshold: Optional[int] = None,
                 frustrating_threshold: Optional[int] = None,
                 threshold: Optional[int] = None,
                 tolerated_fallback_threshold: Optional[int] = None,
                 tolerated_threshold: Optional[int] = None):
        """
        :param int frustrating_fallback_threshold: Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
        :param int frustrating_threshold: Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
        :param int threshold: no documentation available
        :param int tolerated_fallback_threshold: Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
        :param int tolerated_threshold: Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
        """
        if frustrating_fallback_threshold is not None:
            pulumi.set(__self__, "frustrating_fallback_threshold", frustrating_fallback_threshold)
        if frustrating_threshold is not None:
            pulumi.set(__self__, "frustrating_threshold", frustrating_threshold)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if tolerated_fallback_threshold is not None:
            pulumi.set(__self__, "tolerated_fallback_threshold", tolerated_fallback_threshold)
        if tolerated_threshold is not None:
            pulumi.set(__self__, "tolerated_threshold", tolerated_threshold)

    @property
    @pulumi.getter(name="frustratingFallbackThreshold")
    def frustrating_fallback_threshold(self) -> Optional[int]:
        """
        Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
        """
        return pulumi.get(self, "frustrating_fallback_threshold")

    @property
    @pulumi.getter(name="frustratingThreshold")
    def frustrating_threshold(self) -> Optional[int]:
        """
        Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
        """
        return pulumi.get(self, "frustrating_threshold")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[int]:
        """
        no documentation available
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="toleratedFallbackThreshold")
    def tolerated_fallback_threshold(self) -> Optional[int]:
        """
        Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
        """
        return pulumi.get(self, "tolerated_fallback_threshold")

    @property
    @pulumi.getter(name="toleratedThreshold")
    def tolerated_threshold(self) -> Optional[int]:
        """
        Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
        """
        return pulumi.get(self, "tolerated_threshold")


@pulumi.output_type
class WebApplicationKeyUserAction(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.WebApplicationKeyUserActionAction']):
        """
        :param Sequence['WebApplicationKeyUserActionActionArgs'] actions: Configuration of the key user action
        """
        pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.WebApplicationKeyUserActionAction']:
        """
        Configuration of the key user action
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class WebApplicationKeyUserActionAction(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 domain: Optional[str] = None):
        """
        :param str name: The name of the web application, displayed in the UI
        :param str type: The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the web application, displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        return pulumi.get(self, "domain")


@pulumi.output_type
class WebApplicationLoadActionApdexSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frustratingFallbackThreshold":
            suggest = "frustrating_fallback_threshold"
        elif key == "frustratingThreshold":
            suggest = "frustrating_threshold"
        elif key == "toleratedFallbackThreshold":
            suggest = "tolerated_fallback_threshold"
        elif key == "toleratedThreshold":
            suggest = "tolerated_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationLoadActionApdexSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationLoadActionApdexSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationLoadActionApdexSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frustrating_fallback_threshold: Optional[int] = None,
                 frustrating_threshold: Optional[int] = None,
                 threshold: Optional[int] = None,
                 tolerated_fallback_threshold: Optional[int] = None,
                 tolerated_threshold: Optional[int] = None):
        """
        :param int frustrating_fallback_threshold: Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
        :param int frustrating_threshold: Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
        :param int threshold: no documentation available
        :param int tolerated_fallback_threshold: Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
        :param int tolerated_threshold: Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
        """
        if frustrating_fallback_threshold is not None:
            pulumi.set(__self__, "frustrating_fallback_threshold", frustrating_fallback_threshold)
        if frustrating_threshold is not None:
            pulumi.set(__self__, "frustrating_threshold", frustrating_threshold)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if tolerated_fallback_threshold is not None:
            pulumi.set(__self__, "tolerated_fallback_threshold", tolerated_fallback_threshold)
        if tolerated_threshold is not None:
            pulumi.set(__self__, "tolerated_threshold", tolerated_threshold)

    @property
    @pulumi.getter(name="frustratingFallbackThreshold")
    def frustrating_fallback_threshold(self) -> Optional[int]:
        """
        Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
        """
        return pulumi.get(self, "frustrating_fallback_threshold")

    @property
    @pulumi.getter(name="frustratingThreshold")
    def frustrating_threshold(self) -> Optional[int]:
        """
        Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
        """
        return pulumi.get(self, "frustrating_threshold")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[int]:
        """
        no documentation available
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="toleratedFallbackThreshold")
    def tolerated_fallback_threshold(self) -> Optional[int]:
        """
        Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
        """
        return pulumi.get(self, "tolerated_fallback_threshold")

    @property
    @pulumi.getter(name="toleratedThreshold")
    def tolerated_threshold(self) -> Optional[int]:
        """
        Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
        """
        return pulumi.get(self, "tolerated_threshold")


@pulumi.output_type
class WebApplicationMetaDataCaptureSettings(dict):
    def __init__(__self__, *,
                 captures: Optional[Sequence['outputs.WebApplicationMetaDataCaptureSettingsCapture']] = None):
        """
        :param Sequence['WebApplicationMetaDataCaptureSettingsCaptureArgs'] captures: Java script agent meta data capture settings
        """
        if captures is not None:
            pulumi.set(__self__, "captures", captures)

    @property
    @pulumi.getter
    def captures(self) -> Optional[Sequence['outputs.WebApplicationMetaDataCaptureSettingsCapture']]:
        """
        Java script agent meta data capture settings
        """
        return pulumi.get(self, "captures")


@pulumi.output_type
class WebApplicationMetaDataCaptureSettingsCapture(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capturingName":
            suggest = "capturing_name"
        elif key == "publicMetadata":
            suggest = "public_metadata"
        elif key == "uniqueId":
            suggest = "unique_id"
        elif key == "useLastValue":
            suggest = "use_last_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMetaDataCaptureSettingsCapture. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMetaDataCaptureSettingsCapture.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMetaDataCaptureSettingsCapture.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capturing_name: str,
                 name: str,
                 type: str,
                 public_metadata: Optional[bool] = None,
                 unique_id: Optional[int] = None,
                 use_last_value: Optional[bool] = None):
        """
        :param str name: The name of the web application, displayed in the UI
        :param str type: The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        pulumi.set(__self__, "capturing_name", capturing_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if public_metadata is not None:
            pulumi.set(__self__, "public_metadata", public_metadata)
        if unique_id is not None:
            pulumi.set(__self__, "unique_id", unique_id)
        if use_last_value is not None:
            pulumi.set(__self__, "use_last_value", use_last_value)

    @property
    @pulumi.getter(name="capturingName")
    def capturing_name(self) -> str:
        return pulumi.get(self, "capturing_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the web application, displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="publicMetadata")
    def public_metadata(self) -> Optional[bool]:
        return pulumi.get(self, "public_metadata")

    @property
    @pulumi.getter(name="uniqueId")
    def unique_id(self) -> Optional[int]:
        return pulumi.get(self, "unique_id")

    @property
    @pulumi.getter(name="useLastValue")
    def use_last_value(self) -> Optional[bool]:
        return pulumi.get(self, "use_last_value")


@pulumi.output_type
class WebApplicationMonitoringSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentCapture":
            suggest = "content_capture"
        elif key == "injectionMode":
            suggest = "injection_mode"
        elif key == "addCrossOriginAnonymousAttribute":
            suggest = "add_cross_origin_anonymous_attribute"
        elif key == "advancedJavascriptTagSettings":
            suggest = "advanced_javascript_tag_settings"
        elif key == "angularPackageName":
            suggest = "angular_package_name"
        elif key == "browserRestrictionSettings":
            suggest = "browser_restriction_settings"
        elif key == "cacheControlHeaderOptimizations":
            suggest = "cache_control_header_optimizations"
        elif key == "cookiePlacementDomain":
            suggest = "cookie_placement_domain"
        elif key == "correlationHeaderInclusionRegex":
            suggest = "correlation_header_inclusion_regex"
        elif key == "customConfigurationProperties":
            suggest = "custom_configuration_properties"
        elif key == "excludeXhrRegex":
            suggest = "exclude_xhr_regex"
        elif key == "fetchRequests":
            suggest = "fetch_requests"
        elif key == "ipAddressRestrictionSettings":
            suggest = "ip_address_restriction_settings"
        elif key == "javascriptFrameworkSupport":
            suggest = "javascript_framework_support"
        elif key == "javascriptInjectionRules":
            suggest = "javascript_injection_rules"
        elif key == "libraryFileLocation":
            suggest = "library_file_location"
        elif key == "monitoringDataPath":
            suggest = "monitoring_data_path"
        elif key == "scriptTagCacheDurationInHours":
            suggest = "script_tag_cache_duration_in_hours"
        elif key == "secureCookieAttribute":
            suggest = "secure_cookie_attribute"
        elif key == "serverRequestPathId":
            suggest = "server_request_path_id"
        elif key == "xmlHttpRequest":
            suggest = "xml_http_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_capture: 'outputs.WebApplicationMonitoringSettingsContentCapture',
                 injection_mode: str,
                 add_cross_origin_anonymous_attribute: Optional[bool] = None,
                 advanced_javascript_tag_settings: Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings'] = None,
                 angular_package_name: Optional[str] = None,
                 browser_restriction_settings: Optional['outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettings'] = None,
                 cache_control_header_optimizations: Optional[bool] = None,
                 cookie_placement_domain: Optional[str] = None,
                 correlation_header_inclusion_regex: Optional[str] = None,
                 custom_configuration_properties: Optional[str] = None,
                 exclude_xhr_regex: Optional[str] = None,
                 fetch_requests: Optional[bool] = None,
                 ip_address_restriction_settings: Optional['outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettings'] = None,
                 javascript_framework_support: Optional['outputs.WebApplicationMonitoringSettingsJavascriptFrameworkSupport'] = None,
                 javascript_injection_rules: Optional['outputs.WebApplicationMonitoringSettingsJavascriptInjectionRules'] = None,
                 library_file_location: Optional[str] = None,
                 monitoring_data_path: Optional[str] = None,
                 script_tag_cache_duration_in_hours: Optional[int] = None,
                 secure_cookie_attribute: Optional[bool] = None,
                 server_request_path_id: Optional[str] = None,
                 xml_http_request: Optional[bool] = None):
        """
        :param 'WebApplicationMonitoringSettingsContentCaptureArgs' content_capture: Settings for content capture
        :param str injection_mode: Possible valures are `CODE_SNIPPET`, `CODE_SNIPPET_ASYNC`, `INLINE_CODE` and `JAVASCRIPT_TAG`.
        :param bool add_cross_origin_anonymous_attribute: Add the cross origin = anonymous attribute to capture JavaScript error messages and W3C resource timings
        :param 'WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsArgs' advanced_javascript_tag_settings: Advanced JavaScript tag settings
        :param str angular_package_name: The name of the angular package
        :param 'WebApplicationMonitoringSettingsBrowserRestrictionSettingsArgs' browser_restriction_settings: Settings for restricting certain browser type, version, platform and, comparator. It also restricts the mode
        :param bool cache_control_header_optimizations: Optimize the value of cache control headers for use with Dynatrace real user monitoring enabled/disabled
        :param str cookie_placement_domain: Domain for cookie placement. Maximum 150 characters.
        :param str correlation_header_inclusion_regex: To enable RUM for XHR calls to AWS Lambda, define a regular expression matching these calls, Dynatrace can then automatically add a custom header (`x-dtc`) to each such request to the respective endpoints in AWS.
        """
        pulumi.set(__self__, "content_capture", content_capture)
        pulumi.set(__self__, "injection_mode", injection_mode)
        if add_cross_origin_anonymous_attribute is not None:
            pulumi.set(__self__, "add_cross_origin_anonymous_attribute", add_cross_origin_anonymous_attribute)
        if advanced_javascript_tag_settings is not None:
            pulumi.set(__self__, "advanced_javascript_tag_settings", advanced_javascript_tag_settings)
        if angular_package_name is not None:
            pulumi.set(__self__, "angular_package_name", angular_package_name)
        if browser_restriction_settings is not None:
            pulumi.set(__self__, "browser_restriction_settings", browser_restriction_settings)
        if cache_control_header_optimizations is not None:
            pulumi.set(__self__, "cache_control_header_optimizations", cache_control_header_optimizations)
        if cookie_placement_domain is not None:
            pulumi.set(__self__, "cookie_placement_domain", cookie_placement_domain)
        if correlation_header_inclusion_regex is not None:
            pulumi.set(__self__, "correlation_header_inclusion_regex", correlation_header_inclusion_regex)
        if custom_configuration_properties is not None:
            pulumi.set(__self__, "custom_configuration_properties", custom_configuration_properties)
        if exclude_xhr_regex is not None:
            pulumi.set(__self__, "exclude_xhr_regex", exclude_xhr_regex)
        if fetch_requests is not None:
            pulumi.set(__self__, "fetch_requests", fetch_requests)
        if ip_address_restriction_settings is not None:
            pulumi.set(__self__, "ip_address_restriction_settings", ip_address_restriction_settings)
        if javascript_framework_support is not None:
            pulumi.set(__self__, "javascript_framework_support", javascript_framework_support)
        if javascript_injection_rules is not None:
            pulumi.set(__self__, "javascript_injection_rules", javascript_injection_rules)
        if library_file_location is not None:
            pulumi.set(__self__, "library_file_location", library_file_location)
        if monitoring_data_path is not None:
            pulumi.set(__self__, "monitoring_data_path", monitoring_data_path)
        if script_tag_cache_duration_in_hours is not None:
            pulumi.set(__self__, "script_tag_cache_duration_in_hours", script_tag_cache_duration_in_hours)
        if secure_cookie_attribute is not None:
            pulumi.set(__self__, "secure_cookie_attribute", secure_cookie_attribute)
        if server_request_path_id is not None:
            pulumi.set(__self__, "server_request_path_id", server_request_path_id)
        if xml_http_request is not None:
            pulumi.set(__self__, "xml_http_request", xml_http_request)

    @property
    @pulumi.getter(name="contentCapture")
    def content_capture(self) -> 'outputs.WebApplicationMonitoringSettingsContentCapture':
        """
        Settings for content capture
        """
        return pulumi.get(self, "content_capture")

    @property
    @pulumi.getter(name="injectionMode")
    def injection_mode(self) -> str:
        """
        Possible valures are `CODE_SNIPPET`, `CODE_SNIPPET_ASYNC`, `INLINE_CODE` and `JAVASCRIPT_TAG`.
        """
        return pulumi.get(self, "injection_mode")

    @property
    @pulumi.getter(name="addCrossOriginAnonymousAttribute")
    def add_cross_origin_anonymous_attribute(self) -> Optional[bool]:
        """
        Add the cross origin = anonymous attribute to capture JavaScript error messages and W3C resource timings
        """
        return pulumi.get(self, "add_cross_origin_anonymous_attribute")

    @property
    @pulumi.getter(name="advancedJavascriptTagSettings")
    def advanced_javascript_tag_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings']:
        """
        Advanced JavaScript tag settings
        """
        return pulumi.get(self, "advanced_javascript_tag_settings")

    @property
    @pulumi.getter(name="angularPackageName")
    def angular_package_name(self) -> Optional[str]:
        """
        The name of the angular package
        """
        return pulumi.get(self, "angular_package_name")

    @property
    @pulumi.getter(name="browserRestrictionSettings")
    def browser_restriction_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettings']:
        """
        Settings for restricting certain browser type, version, platform and, comparator. It also restricts the mode
        """
        return pulumi.get(self, "browser_restriction_settings")

    @property
    @pulumi.getter(name="cacheControlHeaderOptimizations")
    def cache_control_header_optimizations(self) -> Optional[bool]:
        """
        Optimize the value of cache control headers for use with Dynatrace real user monitoring enabled/disabled
        """
        return pulumi.get(self, "cache_control_header_optimizations")

    @property
    @pulumi.getter(name="cookiePlacementDomain")
    def cookie_placement_domain(self) -> Optional[str]:
        """
        Domain for cookie placement. Maximum 150 characters.
        """
        return pulumi.get(self, "cookie_placement_domain")

    @property
    @pulumi.getter(name="correlationHeaderInclusionRegex")
    def correlation_header_inclusion_regex(self) -> Optional[str]:
        """
        To enable RUM for XHR calls to AWS Lambda, define a regular expression matching these calls, Dynatrace can then automatically add a custom header (`x-dtc`) to each such request to the respective endpoints in AWS.
        """
        return pulumi.get(self, "correlation_header_inclusion_regex")

    @property
    @pulumi.getter(name="customConfigurationProperties")
    def custom_configuration_properties(self) -> Optional[str]:
        return pulumi.get(self, "custom_configuration_properties")

    @property
    @pulumi.getter(name="excludeXhrRegex")
    def exclude_xhr_regex(self) -> Optional[str]:
        return pulumi.get(self, "exclude_xhr_regex")

    @property
    @pulumi.getter(name="fetchRequests")
    def fetch_requests(self) -> Optional[bool]:
        return pulumi.get(self, "fetch_requests")

    @property
    @pulumi.getter(name="ipAddressRestrictionSettings")
    def ip_address_restriction_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettings']:
        return pulumi.get(self, "ip_address_restriction_settings")

    @property
    @pulumi.getter(name="javascriptFrameworkSupport")
    def javascript_framework_support(self) -> Optional['outputs.WebApplicationMonitoringSettingsJavascriptFrameworkSupport']:
        return pulumi.get(self, "javascript_framework_support")

    @property
    @pulumi.getter(name="javascriptInjectionRules")
    def javascript_injection_rules(self) -> Optional['outputs.WebApplicationMonitoringSettingsJavascriptInjectionRules']:
        return pulumi.get(self, "javascript_injection_rules")

    @property
    @pulumi.getter(name="libraryFileLocation")
    def library_file_location(self) -> Optional[str]:
        return pulumi.get(self, "library_file_location")

    @property
    @pulumi.getter(name="monitoringDataPath")
    def monitoring_data_path(self) -> Optional[str]:
        return pulumi.get(self, "monitoring_data_path")

    @property
    @pulumi.getter(name="scriptTagCacheDurationInHours")
    def script_tag_cache_duration_in_hours(self) -> Optional[int]:
        return pulumi.get(self, "script_tag_cache_duration_in_hours")

    @property
    @pulumi.getter(name="secureCookieAttribute")
    def secure_cookie_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "secure_cookie_attribute")

    @property
    @pulumi.getter(name="serverRequestPathId")
    def server_request_path_id(self) -> Optional[str]:
        return pulumi.get(self, "server_request_path_id")

    @property
    @pulumi.getter(name="xmlHttpRequest")
    def xml_http_request(self) -> Optional[bool]:
        return pulumi.get(self, "xml_http_request")


@pulumi.output_type
class WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxActionNameLength":
            suggest = "max_action_name_length"
        elif key == "maxErrorsToCapture":
            suggest = "max_errors_to_capture"
        elif key == "additionalEventHandlers":
            suggest = "additional_event_handlers"
        elif key == "eventWrapperSettings":
            suggest = "event_wrapper_settings"
        elif key == "globalEventCaptureSettings":
            suggest = "global_event_capture_settings"
        elif key == "instrumentUnsupportedAjaxFrameworks":
            suggest = "instrument_unsupported_ajax_frameworks"
        elif key == "specialCharactersToEscape":
            suggest = "special_characters_to_escape"
        elif key == "syncBeaconFirefox":
            suggest = "sync_beacon_firefox"
        elif key == "syncBeaconInternetExplorer":
            suggest = "sync_beacon_internet_explorer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_action_name_length: int,
                 max_errors_to_capture: int,
                 additional_event_handlers: Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers'] = None,
                 event_wrapper_settings: Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings'] = None,
                 global_event_capture_settings: Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings'] = None,
                 instrument_unsupported_ajax_frameworks: Optional[bool] = None,
                 special_characters_to_escape: Optional[str] = None,
                 sync_beacon_firefox: Optional[bool] = None,
                 sync_beacon_internet_explorer: Optional[bool] = None):
        pulumi.set(__self__, "max_action_name_length", max_action_name_length)
        pulumi.set(__self__, "max_errors_to_capture", max_errors_to_capture)
        if additional_event_handlers is not None:
            pulumi.set(__self__, "additional_event_handlers", additional_event_handlers)
        if event_wrapper_settings is not None:
            pulumi.set(__self__, "event_wrapper_settings", event_wrapper_settings)
        if global_event_capture_settings is not None:
            pulumi.set(__self__, "global_event_capture_settings", global_event_capture_settings)
        if instrument_unsupported_ajax_frameworks is not None:
            pulumi.set(__self__, "instrument_unsupported_ajax_frameworks", instrument_unsupported_ajax_frameworks)
        if special_characters_to_escape is not None:
            pulumi.set(__self__, "special_characters_to_escape", special_characters_to_escape)
        if sync_beacon_firefox is not None:
            pulumi.set(__self__, "sync_beacon_firefox", sync_beacon_firefox)
        if sync_beacon_internet_explorer is not None:
            pulumi.set(__self__, "sync_beacon_internet_explorer", sync_beacon_internet_explorer)

    @property
    @pulumi.getter(name="maxActionNameLength")
    def max_action_name_length(self) -> int:
        return pulumi.get(self, "max_action_name_length")

    @property
    @pulumi.getter(name="maxErrorsToCapture")
    def max_errors_to_capture(self) -> int:
        return pulumi.get(self, "max_errors_to_capture")

    @property
    @pulumi.getter(name="additionalEventHandlers")
    def additional_event_handlers(self) -> Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers']:
        return pulumi.get(self, "additional_event_handlers")

    @property
    @pulumi.getter(name="eventWrapperSettings")
    def event_wrapper_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings']:
        return pulumi.get(self, "event_wrapper_settings")

    @property
    @pulumi.getter(name="globalEventCaptureSettings")
    def global_event_capture_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings']:
        return pulumi.get(self, "global_event_capture_settings")

    @property
    @pulumi.getter(name="instrumentUnsupportedAjaxFrameworks")
    def instrument_unsupported_ajax_frameworks(self) -> Optional[bool]:
        return pulumi.get(self, "instrument_unsupported_ajax_frameworks")

    @property
    @pulumi.getter(name="specialCharactersToEscape")
    def special_characters_to_escape(self) -> Optional[str]:
        return pulumi.get(self, "special_characters_to_escape")

    @property
    @pulumi.getter(name="syncBeaconFirefox")
    def sync_beacon_firefox(self) -> Optional[bool]:
        return pulumi.get(self, "sync_beacon_firefox")

    @property
    @pulumi.getter(name="syncBeaconInternetExplorer")
    def sync_beacon_internet_explorer(self) -> Optional[bool]:
        return pulumi.get(self, "sync_beacon_internet_explorer")


@pulumi.output_type
class WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxDomNodes":
            suggest = "max_dom_nodes"
        elif key == "toStringMethod":
            suggest = "to_string_method"
        elif key == "useMouseUpEventForClicks":
            suggest = "use_mouse_up_event_for_clicks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_dom_nodes: int,
                 blur: Optional[bool] = None,
                 change: Optional[bool] = None,
                 click: Optional[bool] = None,
                 mouseup: Optional[bool] = None,
                 to_string_method: Optional[bool] = None,
                 use_mouse_up_event_for_clicks: Optional[bool] = None):
        pulumi.set(__self__, "max_dom_nodes", max_dom_nodes)
        if blur is not None:
            pulumi.set(__self__, "blur", blur)
        if change is not None:
            pulumi.set(__self__, "change", change)
        if click is not None:
            pulumi.set(__self__, "click", click)
        if mouseup is not None:
            pulumi.set(__self__, "mouseup", mouseup)
        if to_string_method is not None:
            pulumi.set(__self__, "to_string_method", to_string_method)
        if use_mouse_up_event_for_clicks is not None:
            pulumi.set(__self__, "use_mouse_up_event_for_clicks", use_mouse_up_event_for_clicks)

    @property
    @pulumi.getter(name="maxDomNodes")
    def max_dom_nodes(self) -> int:
        return pulumi.get(self, "max_dom_nodes")

    @property
    @pulumi.getter
    def blur(self) -> Optional[bool]:
        return pulumi.get(self, "blur")

    @property
    @pulumi.getter
    def change(self) -> Optional[bool]:
        return pulumi.get(self, "change")

    @property
    @pulumi.getter
    def click(self) -> Optional[bool]:
        return pulumi.get(self, "click")

    @property
    @pulumi.getter
    def mouseup(self) -> Optional[bool]:
        return pulumi.get(self, "mouseup")

    @property
    @pulumi.getter(name="toStringMethod")
    def to_string_method(self) -> Optional[bool]:
        return pulumi.get(self, "to_string_method")

    @property
    @pulumi.getter(name="useMouseUpEventForClicks")
    def use_mouse_up_event_for_clicks(self) -> Optional[bool]:
        return pulumi.get(self, "use_mouse_up_event_for_clicks")


@pulumi.output_type
class WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "touchEnd":
            suggest = "touch_end"
        elif key == "touchStart":
            suggest = "touch_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blur: Optional[bool] = None,
                 change: Optional[bool] = None,
                 click: Optional[bool] = None,
                 mouseup: Optional[bool] = None,
                 touch_end: Optional[bool] = None,
                 touch_start: Optional[bool] = None):
        if blur is not None:
            pulumi.set(__self__, "blur", blur)
        if change is not None:
            pulumi.set(__self__, "change", change)
        if click is not None:
            pulumi.set(__self__, "click", click)
        if mouseup is not None:
            pulumi.set(__self__, "mouseup", mouseup)
        if touch_end is not None:
            pulumi.set(__self__, "touch_end", touch_end)
        if touch_start is not None:
            pulumi.set(__self__, "touch_start", touch_start)

    @property
    @pulumi.getter
    def blur(self) -> Optional[bool]:
        return pulumi.get(self, "blur")

    @property
    @pulumi.getter
    def change(self) -> Optional[bool]:
        return pulumi.get(self, "change")

    @property
    @pulumi.getter
    def click(self) -> Optional[bool]:
        return pulumi.get(self, "click")

    @property
    @pulumi.getter
    def mouseup(self) -> Optional[bool]:
        return pulumi.get(self, "mouseup")

    @property
    @pulumi.getter(name="touchEnd")
    def touch_end(self) -> Optional[bool]:
        return pulumi.get(self, "touch_end")

    @property
    @pulumi.getter(name="touchStart")
    def touch_start(self) -> Optional[bool]:
        return pulumi.get(self, "touch_start")


@pulumi.output_type
class WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalEventCapturedAsUserInput":
            suggest = "additional_event_captured_as_user_input"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_event_captured_as_user_input: Optional[str] = None,
                 click: Optional[bool] = None,
                 doubleclick: Optional[bool] = None,
                 keydown: Optional[bool] = None,
                 keyup: Optional[bool] = None,
                 mousedown: Optional[bool] = None,
                 mouseup: Optional[bool] = None,
                 scroll: Optional[bool] = None):
        if additional_event_captured_as_user_input is not None:
            pulumi.set(__self__, "additional_event_captured_as_user_input", additional_event_captured_as_user_input)
        if click is not None:
            pulumi.set(__self__, "click", click)
        if doubleclick is not None:
            pulumi.set(__self__, "doubleclick", doubleclick)
        if keydown is not None:
            pulumi.set(__self__, "keydown", keydown)
        if keyup is not None:
            pulumi.set(__self__, "keyup", keyup)
        if mousedown is not None:
            pulumi.set(__self__, "mousedown", mousedown)
        if mouseup is not None:
            pulumi.set(__self__, "mouseup", mouseup)
        if scroll is not None:
            pulumi.set(__self__, "scroll", scroll)

    @property
    @pulumi.getter(name="additionalEventCapturedAsUserInput")
    def additional_event_captured_as_user_input(self) -> Optional[str]:
        return pulumi.get(self, "additional_event_captured_as_user_input")

    @property
    @pulumi.getter
    def click(self) -> Optional[bool]:
        return pulumi.get(self, "click")

    @property
    @pulumi.getter
    def doubleclick(self) -> Optional[bool]:
        return pulumi.get(self, "doubleclick")

    @property
    @pulumi.getter
    def keydown(self) -> Optional[bool]:
        return pulumi.get(self, "keydown")

    @property
    @pulumi.getter
    def keyup(self) -> Optional[bool]:
        return pulumi.get(self, "keyup")

    @property
    @pulumi.getter
    def mousedown(self) -> Optional[bool]:
        return pulumi.get(self, "mousedown")

    @property
    @pulumi.getter
    def mouseup(self) -> Optional[bool]:
        return pulumi.get(self, "mouseup")

    @property
    @pulumi.getter
    def scroll(self) -> Optional[bool]:
        return pulumi.get(self, "scroll")


@pulumi.output_type
class WebApplicationMonitoringSettingsBrowserRestrictionSettings(dict):
    def __init__(__self__, *,
                 mode: str,
                 restrictions: Optional['outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictions'] = None):
        pulumi.set(__self__, "mode", mode)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional['outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictions']:
        return pulumi.get(self, "restrictions")


@pulumi.output_type
class WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictions(dict):
    def __init__(__self__, *,
                 restrictions: Sequence['outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction']):
        pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def restrictions(self) -> Sequence['outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction']:
        return pulumi.get(self, "restrictions")


@pulumi.output_type
class WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "browserType":
            suggest = "browser_type"
        elif key == "browserVersion":
            suggest = "browser_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 browser_type: str,
                 browser_version: Optional[str] = None,
                 comparator: Optional[str] = None,
                 platform: Optional[str] = None):
        pulumi.set(__self__, "browser_type", browser_type)
        if browser_version is not None:
            pulumi.set(__self__, "browser_version", browser_version)
        if comparator is not None:
            pulumi.set(__self__, "comparator", comparator)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @property
    @pulumi.getter(name="browserType")
    def browser_type(self) -> str:
        return pulumi.get(self, "browser_type")

    @property
    @pulumi.getter(name="browserVersion")
    def browser_version(self) -> Optional[str]:
        return pulumi.get(self, "browser_version")

    @property
    @pulumi.getter
    def comparator(self) -> Optional[str]:
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def platform(self) -> Optional[str]:
        return pulumi.get(self, "platform")


@pulumi.output_type
class WebApplicationMonitoringSettingsContentCapture(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "javascriptErrors":
            suggest = "javascript_errors"
        elif key == "resourceTimingSettings":
            suggest = "resource_timing_settings"
        elif key == "timeoutSettings":
            suggest = "timeout_settings"
        elif key == "visuallyCompleteAndSpeedIndex":
            suggest = "visually_complete_and_speed_index"
        elif key == "visuallyCompleteSettings":
            suggest = "visually_complete_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsContentCapture. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsContentCapture.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsContentCapture.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 javascript_errors: Optional[bool] = None,
                 resource_timing_settings: Optional['outputs.WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings'] = None,
                 timeout_settings: Optional['outputs.WebApplicationMonitoringSettingsContentCaptureTimeoutSettings'] = None,
                 visually_complete_and_speed_index: Optional[bool] = None,
                 visually_complete_settings: Optional['outputs.WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings'] = None):
        if javascript_errors is not None:
            pulumi.set(__self__, "javascript_errors", javascript_errors)
        if resource_timing_settings is not None:
            pulumi.set(__self__, "resource_timing_settings", resource_timing_settings)
        if timeout_settings is not None:
            pulumi.set(__self__, "timeout_settings", timeout_settings)
        if visually_complete_and_speed_index is not None:
            pulumi.set(__self__, "visually_complete_and_speed_index", visually_complete_and_speed_index)
        if visually_complete_settings is not None:
            pulumi.set(__self__, "visually_complete_settings", visually_complete_settings)

    @property
    @pulumi.getter(name="javascriptErrors")
    def javascript_errors(self) -> Optional[bool]:
        return pulumi.get(self, "javascript_errors")

    @property
    @pulumi.getter(name="resourceTimingSettings")
    def resource_timing_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings']:
        return pulumi.get(self, "resource_timing_settings")

    @property
    @pulumi.getter(name="timeoutSettings")
    def timeout_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsContentCaptureTimeoutSettings']:
        return pulumi.get(self, "timeout_settings")

    @property
    @pulumi.getter(name="visuallyCompleteAndSpeedIndex")
    def visually_complete_and_speed_index(self) -> Optional[bool]:
        return pulumi.get(self, "visually_complete_and_speed_index")

    @property
    @pulumi.getter(name="visuallyCompleteSettings")
    def visually_complete_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings']:
        return pulumi.get(self, "visually_complete_settings")


@pulumi.output_type
class WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instrumentationDelay":
            suggest = "instrumentation_delay"
        elif key == "nonW3cResourceTimings":
            suggest = "non_w3c_resource_timings"
        elif key == "resourceTimingCaptureType":
            suggest = "resource_timing_capture_type"
        elif key == "resourceTimingsDomainLimit":
            suggest = "resource_timings_domain_limit"
        elif key == "w3cResourceTimings":
            suggest = "w3c_resource_timings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instrumentation_delay: int,
                 non_w3c_resource_timings: Optional[bool] = None,
                 resource_timing_capture_type: Optional[str] = None,
                 resource_timings_domain_limit: Optional[int] = None,
                 w3c_resource_timings: Optional[bool] = None):
        pulumi.set(__self__, "instrumentation_delay", instrumentation_delay)
        if non_w3c_resource_timings is not None:
            pulumi.set(__self__, "non_w3c_resource_timings", non_w3c_resource_timings)
        if resource_timing_capture_type is not None:
            pulumi.set(__self__, "resource_timing_capture_type", resource_timing_capture_type)
        if resource_timings_domain_limit is not None:
            pulumi.set(__self__, "resource_timings_domain_limit", resource_timings_domain_limit)
        if w3c_resource_timings is not None:
            pulumi.set(__self__, "w3c_resource_timings", w3c_resource_timings)

    @property
    @pulumi.getter(name="instrumentationDelay")
    def instrumentation_delay(self) -> int:
        return pulumi.get(self, "instrumentation_delay")

    @property
    @pulumi.getter(name="nonW3cResourceTimings")
    def non_w3c_resource_timings(self) -> Optional[bool]:
        return pulumi.get(self, "non_w3c_resource_timings")

    @property
    @pulumi.getter(name="resourceTimingCaptureType")
    def resource_timing_capture_type(self) -> Optional[str]:
        return pulumi.get(self, "resource_timing_capture_type")

    @property
    @pulumi.getter(name="resourceTimingsDomainLimit")
    def resource_timings_domain_limit(self) -> Optional[int]:
        return pulumi.get(self, "resource_timings_domain_limit")

    @property
    @pulumi.getter(name="w3cResourceTimings")
    def w3c_resource_timings(self) -> Optional[bool]:
        return pulumi.get(self, "w3c_resource_timings")


@pulumi.output_type
class WebApplicationMonitoringSettingsContentCaptureTimeoutSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "temporaryActionLimit":
            suggest = "temporary_action_limit"
        elif key == "temporaryActionTotalTimeout":
            suggest = "temporary_action_total_timeout"
        elif key == "timedActionSupport":
            suggest = "timed_action_support"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsContentCaptureTimeoutSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsContentCaptureTimeoutSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsContentCaptureTimeoutSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 temporary_action_limit: int,
                 temporary_action_total_timeout: int,
                 timed_action_support: Optional[bool] = None):
        pulumi.set(__self__, "temporary_action_limit", temporary_action_limit)
        pulumi.set(__self__, "temporary_action_total_timeout", temporary_action_total_timeout)
        if timed_action_support is not None:
            pulumi.set(__self__, "timed_action_support", timed_action_support)

    @property
    @pulumi.getter(name="temporaryActionLimit")
    def temporary_action_limit(self) -> int:
        return pulumi.get(self, "temporary_action_limit")

    @property
    @pulumi.getter(name="temporaryActionTotalTimeout")
    def temporary_action_total_timeout(self) -> int:
        return pulumi.get(self, "temporary_action_total_timeout")

    @property
    @pulumi.getter(name="timedActionSupport")
    def timed_action_support(self) -> Optional[bool]:
        return pulumi.get(self, "timed_action_support")


@pulumi.output_type
class WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeUrlRegex":
            suggest = "exclude_url_regex"
        elif key == "ignoredMutationsList":
            suggest = "ignored_mutations_list"
        elif key == "inactivityTimeout":
            suggest = "inactivity_timeout"
        elif key == "mutationTimeout":
            suggest = "mutation_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_url_regex: Optional[str] = None,
                 ignored_mutations_list: Optional[str] = None,
                 inactivity_timeout: Optional[int] = None,
                 mutation_timeout: Optional[int] = None,
                 threshold: Optional[int] = None):
        if exclude_url_regex is not None:
            pulumi.set(__self__, "exclude_url_regex", exclude_url_regex)
        if ignored_mutations_list is not None:
            pulumi.set(__self__, "ignored_mutations_list", ignored_mutations_list)
        if inactivity_timeout is not None:
            pulumi.set(__self__, "inactivity_timeout", inactivity_timeout)
        if mutation_timeout is not None:
            pulumi.set(__self__, "mutation_timeout", mutation_timeout)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="excludeUrlRegex")
    def exclude_url_regex(self) -> Optional[str]:
        return pulumi.get(self, "exclude_url_regex")

    @property
    @pulumi.getter(name="ignoredMutationsList")
    def ignored_mutations_list(self) -> Optional[str]:
        return pulumi.get(self, "ignored_mutations_list")

    @property
    @pulumi.getter(name="inactivityTimeout")
    def inactivity_timeout(self) -> Optional[int]:
        return pulumi.get(self, "inactivity_timeout")

    @property
    @pulumi.getter(name="mutationTimeout")
    def mutation_timeout(self) -> Optional[int]:
        return pulumi.get(self, "mutation_timeout")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[int]:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class WebApplicationMonitoringSettingsIpAddressRestrictionSettings(dict):
    def __init__(__self__, *,
                 mode: str,
                 restrictions: Optional['outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictions'] = None):
        pulumi.set(__self__, "mode", mode)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional['outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictions']:
        return pulumi.get(self, "restrictions")


@pulumi.output_type
class WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictions(dict):
    def __init__(__self__, *,
                 ranges: Sequence['outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange']):
        pulumi.set(__self__, "ranges", ranges)

    @property
    @pulumi.getter
    def ranges(self) -> Sequence['outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange']:
        return pulumi.get(self, "ranges")


@pulumi.output_type
class WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressTo":
            suggest = "address_to"
        elif key == "subnetMask":
            suggest = "subnet_mask"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 address_to: Optional[str] = None,
                 subnet_mask: Optional[int] = None):
        pulumi.set(__self__, "address", address)
        if address_to is not None:
            pulumi.set(__self__, "address_to", address_to)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="addressTo")
    def address_to(self) -> Optional[str]:
        return pulumi.get(self, "address_to")

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[int]:
        return pulumi.get(self, "subnet_mask")


@pulumi.output_type
class WebApplicationMonitoringSettingsJavascriptFrameworkSupport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeXObject":
            suggest = "active_x_object"
        elif key == "mooTools":
            suggest = "moo_tools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsJavascriptFrameworkSupport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsJavascriptFrameworkSupport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsJavascriptFrameworkSupport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_x_object: Optional[bool] = None,
                 angular: Optional[bool] = None,
                 dojo: Optional[bool] = None,
                 extjs: Optional[bool] = None,
                 icefaces: Optional[bool] = None,
                 jquery: Optional[bool] = None,
                 moo_tools: Optional[bool] = None,
                 prototype: Optional[bool] = None):
        if active_x_object is not None:
            pulumi.set(__self__, "active_x_object", active_x_object)
        if angular is not None:
            pulumi.set(__self__, "angular", angular)
        if dojo is not None:
            pulumi.set(__self__, "dojo", dojo)
        if extjs is not None:
            pulumi.set(__self__, "extjs", extjs)
        if icefaces is not None:
            pulumi.set(__self__, "icefaces", icefaces)
        if jquery is not None:
            pulumi.set(__self__, "jquery", jquery)
        if moo_tools is not None:
            pulumi.set(__self__, "moo_tools", moo_tools)
        if prototype is not None:
            pulumi.set(__self__, "prototype", prototype)

    @property
    @pulumi.getter(name="activeXObject")
    def active_x_object(self) -> Optional[bool]:
        return pulumi.get(self, "active_x_object")

    @property
    @pulumi.getter
    def angular(self) -> Optional[bool]:
        return pulumi.get(self, "angular")

    @property
    @pulumi.getter
    def dojo(self) -> Optional[bool]:
        return pulumi.get(self, "dojo")

    @property
    @pulumi.getter
    def extjs(self) -> Optional[bool]:
        return pulumi.get(self, "extjs")

    @property
    @pulumi.getter
    def icefaces(self) -> Optional[bool]:
        return pulumi.get(self, "icefaces")

    @property
    @pulumi.getter
    def jquery(self) -> Optional[bool]:
        return pulumi.get(self, "jquery")

    @property
    @pulumi.getter(name="mooTools")
    def moo_tools(self) -> Optional[bool]:
        return pulumi.get(self, "moo_tools")

    @property
    @pulumi.getter
    def prototype(self) -> Optional[bool]:
        return pulumi.get(self, "prototype")


@pulumi.output_type
class WebApplicationMonitoringSettingsJavascriptInjectionRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.WebApplicationMonitoringSettingsJavascriptInjectionRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.WebApplicationMonitoringSettingsJavascriptInjectionRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class WebApplicationMonitoringSettingsJavascriptInjectionRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlOperator":
            suggest = "url_operator"
        elif key == "htmlPattern":
            suggest = "html_pattern"
        elif key == "urlPattern":
            suggest = "url_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsJavascriptInjectionRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsJavascriptInjectionRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsJavascriptInjectionRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule: str,
                 url_operator: str,
                 enabled: Optional[bool] = None,
                 html_pattern: Optional[str] = None,
                 target: Optional[str] = None,
                 url_pattern: Optional[str] = None):
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "url_operator", url_operator)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if html_pattern is not None:
            pulumi.set(__self__, "html_pattern", html_pattern)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if url_pattern is not None:
            pulumi.set(__self__, "url_pattern", url_pattern)

    @property
    @pulumi.getter
    def rule(self) -> str:
        return pulumi.get(self, "rule")

    @property
    @pulumi.getter(name="urlOperator")
    def url_operator(self) -> str:
        return pulumi.get(self, "url_operator")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="htmlPattern")
    def html_pattern(self) -> Optional[str]:
        return pulumi.get(self, "html_pattern")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="urlPattern")
    def url_pattern(self) -> Optional[str]:
        return pulumi.get(self, "url_pattern")


@pulumi.output_type
class WebApplicationSessionReplayConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costControlPercentage":
            suggest = "cost_control_percentage"
        elif key == "cssResourceCapturingExclusionRules":
            suggest = "css_resource_capturing_exclusion_rules"
        elif key == "enableCssResourceCapturing":
            suggest = "enable_css_resource_capturing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationSessionReplayConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationSessionReplayConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationSessionReplayConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_control_percentage: int,
                 css_resource_capturing_exclusion_rules: Optional[Sequence[str]] = None,
                 enable_css_resource_capturing: Optional[bool] = None,
                 enabled: Optional[bool] = None):
        """
        :param int cost_control_percentage: (Field has overlap with `WebAppEnablement`) Session replay sampling rating in percent
        :param Sequence[str] css_resource_capturing_exclusion_rules: (Field has overlap with `SessionReplayResourceCapture`) A list of URLs to be excluded from CSS resource capturing
        :param bool enable_css_resource_capturing: (Field has overlap with `SessionReplayResourceCapture`) Capture (`true`) or don't capture (`false`) CSS resources from the session
        :param bool enabled: (Field has overlap with `WebAppEnablement`) SessionReplay Enabled/Disabled
        """
        pulumi.set(__self__, "cost_control_percentage", cost_control_percentage)
        if css_resource_capturing_exclusion_rules is not None:
            pulumi.set(__self__, "css_resource_capturing_exclusion_rules", css_resource_capturing_exclusion_rules)
        if enable_css_resource_capturing is not None:
            pulumi.set(__self__, "enable_css_resource_capturing", enable_css_resource_capturing)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="costControlPercentage")
    def cost_control_percentage(self) -> int:
        """
        (Field has overlap with `WebAppEnablement`) Session replay sampling rating in percent
        """
        return pulumi.get(self, "cost_control_percentage")

    @property
    @pulumi.getter(name="cssResourceCapturingExclusionRules")
    def css_resource_capturing_exclusion_rules(self) -> Optional[Sequence[str]]:
        """
        (Field has overlap with `SessionReplayResourceCapture`) A list of URLs to be excluded from CSS resource capturing
        """
        return pulumi.get(self, "css_resource_capturing_exclusion_rules")

    @property
    @pulumi.getter(name="enableCssResourceCapturing")
    def enable_css_resource_capturing(self) -> Optional[bool]:
        """
        (Field has overlap with `SessionReplayResourceCapture`) Capture (`true`) or don't capture (`false`) CSS resources from the session
        """
        return pulumi.get(self, "enable_css_resource_capturing")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        (Field has overlap with `WebAppEnablement`) SessionReplay Enabled/Disabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WebApplicationUserActionAndSessionProperties(dict):
    def __init__(__self__, *,
                 properties: Optional[Sequence['outputs.WebApplicationUserActionAndSessionPropertiesProperty']] = None):
        """
        :param Sequence['WebApplicationUserActionAndSessionPropertiesPropertyArgs'] properties: User action and session properties settings
        """
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def properties(self) -> Optional[Sequence['outputs.WebApplicationUserActionAndSessionPropertiesProperty']]:
        """
        User action and session properties settings
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class WebApplicationUserActionAndSessionPropertiesProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupRule":
            suggest = "cleanup_rule"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "longStringLength":
            suggest = "long_string_length"
        elif key == "metadataId":
            suggest = "metadata_id"
        elif key == "serverSideRequestAttribute":
            suggest = "server_side_request_attribute"
        elif key == "storeAsSessionProperty":
            suggest = "store_as_session_property"
        elif key == "storeAsUserActionProperty":
            suggest = "store_as_user_action_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionAndSessionPropertiesProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionAndSessionPropertiesProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionAndSessionPropertiesProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: int,
                 key: str,
                 origin: str,
                 type: str,
                 aggregation: Optional[str] = None,
                 cleanup_rule: Optional[str] = None,
                 display_name: Optional[str] = None,
                 ignore_case: Optional[bool] = None,
                 long_string_length: Optional[int] = None,
                 metadata_id: Optional[int] = None,
                 server_side_request_attribute: Optional[str] = None,
                 store_as_session_property: Optional[bool] = None,
                 store_as_user_action_property: Optional[bool] = None):
        """
        :param int id: The ID of this resource.
        :param str type: The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "type", type)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if cleanup_rule is not None:
            pulumi.set(__self__, "cleanup_rule", cleanup_rule)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if long_string_length is not None:
            pulumi.set(__self__, "long_string_length", long_string_length)
        if metadata_id is not None:
            pulumi.set(__self__, "metadata_id", metadata_id)
        if server_side_request_attribute is not None:
            pulumi.set(__self__, "server_side_request_attribute", server_side_request_attribute)
        if store_as_session_property is not None:
            pulumi.set(__self__, "store_as_session_property", store_as_session_property)
        if store_as_user_action_property is not None:
            pulumi.set(__self__, "store_as_user_action_property", store_as_user_action_property)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def origin(self) -> str:
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="cleanupRule")
    def cleanup_rule(self) -> Optional[str]:
        return pulumi.get(self, "cleanup_rule")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="longStringLength")
    def long_string_length(self) -> Optional[int]:
        return pulumi.get(self, "long_string_length")

    @property
    @pulumi.getter(name="metadataId")
    def metadata_id(self) -> Optional[int]:
        return pulumi.get(self, "metadata_id")

    @property
    @pulumi.getter(name="serverSideRequestAttribute")
    def server_side_request_attribute(self) -> Optional[str]:
        return pulumi.get(self, "server_side_request_attribute")

    @property
    @pulumi.getter(name="storeAsSessionProperty")
    def store_as_session_property(self) -> Optional[bool]:
        return pulumi.get(self, "store_as_session_property")

    @property
    @pulumi.getter(name="storeAsUserActionProperty")
    def store_as_user_action_property(self) -> Optional[bool]:
        return pulumi.get(self, "store_as_user_action_property")


@pulumi.output_type
class WebApplicationUserActionNamingSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionNamingRules":
            suggest = "custom_action_naming_rules"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "loadActionNamingRules":
            suggest = "load_action_naming_rules"
        elif key == "queryParameterCleanups":
            suggest = "query_parameter_cleanups"
        elif key == "splitUserActionsByDomain":
            suggest = "split_user_actions_by_domain"
        elif key == "useFirstDetectedLoadAction":
            suggest = "use_first_detected_load_action"
        elif key == "xhrActionNamingRules":
            suggest = "xhr_action_naming_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionNamingSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionNamingSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionNamingSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_naming_rules: Optional['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRules'] = None,
                 ignore_case: Optional[bool] = None,
                 load_action_naming_rules: Optional['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRules'] = None,
                 placeholders: Optional['outputs.WebApplicationUserActionNamingSettingsPlaceholders'] = None,
                 query_parameter_cleanups: Optional[Sequence[str]] = None,
                 split_user_actions_by_domain: Optional[bool] = None,
                 use_first_detected_load_action: Optional[bool] = None,
                 xhr_action_naming_rules: Optional['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRules'] = None):
        """
        :param 'WebApplicationUserActionNamingSettingsCustomActionNamingRulesArgs' custom_action_naming_rules: User action naming rules for custom actions
        :param bool ignore_case: Case insensitive naming
        :param 'WebApplicationUserActionNamingSettingsLoadActionNamingRulesArgs' load_action_naming_rules: User action naming rules for loading actions
        :param 'WebApplicationUserActionNamingSettingsPlaceholdersArgs' placeholders: User action placeholders
        :param Sequence[str] query_parameter_cleanups: User action naming rules for custom actions
        :param bool split_user_actions_by_domain: Deactivate this setting if different domains should not result in separate user actions
        :param bool use_first_detected_load_action: First load action found under an XHR action should be used when true. Else the deepest one under the xhr action is used
        :param 'WebApplicationUserActionNamingSettingsXhrActionNamingRulesArgs' xhr_action_naming_rules: User action naming rules for XHR actions
        """
        if custom_action_naming_rules is not None:
            pulumi.set(__self__, "custom_action_naming_rules", custom_action_naming_rules)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if load_action_naming_rules is not None:
            pulumi.set(__self__, "load_action_naming_rules", load_action_naming_rules)
        if placeholders is not None:
            pulumi.set(__self__, "placeholders", placeholders)
        if query_parameter_cleanups is not None:
            pulumi.set(__self__, "query_parameter_cleanups", query_parameter_cleanups)
        if split_user_actions_by_domain is not None:
            pulumi.set(__self__, "split_user_actions_by_domain", split_user_actions_by_domain)
        if use_first_detected_load_action is not None:
            pulumi.set(__self__, "use_first_detected_load_action", use_first_detected_load_action)
        if xhr_action_naming_rules is not None:
            pulumi.set(__self__, "xhr_action_naming_rules", xhr_action_naming_rules)

    @property
    @pulumi.getter(name="customActionNamingRules")
    def custom_action_naming_rules(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRules']:
        """
        User action naming rules for custom actions
        """
        return pulumi.get(self, "custom_action_naming_rules")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Case insensitive naming
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="loadActionNamingRules")
    def load_action_naming_rules(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRules']:
        """
        User action naming rules for loading actions
        """
        return pulumi.get(self, "load_action_naming_rules")

    @property
    @pulumi.getter
    def placeholders(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsPlaceholders']:
        """
        User action placeholders
        """
        return pulumi.get(self, "placeholders")

    @property
    @pulumi.getter(name="queryParameterCleanups")
    def query_parameter_cleanups(self) -> Optional[Sequence[str]]:
        """
        User action naming rules for custom actions
        """
        return pulumi.get(self, "query_parameter_cleanups")

    @property
    @pulumi.getter(name="splitUserActionsByDomain")
    def split_user_actions_by_domain(self) -> Optional[bool]:
        """
        Deactivate this setting if different domains should not result in separate user actions
        """
        return pulumi.get(self, "split_user_actions_by_domain")

    @property
    @pulumi.getter(name="useFirstDetectedLoadAction")
    def use_first_detected_load_action(self) -> Optional[bool]:
        """
        First load action found under an XHR action should be used when true. Else the deepest one under the xhr action is used
        """
        return pulumi.get(self, "use_first_detected_load_action")

    @property
    @pulumi.getter(name="xhrActionNamingRules")
    def xhr_action_naming_rules(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRules']:
        """
        User action naming rules for XHR actions
        """
        return pulumi.get(self, "xhr_action_naming_rules")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsCustomActionNamingRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useOrConditions":
            suggest = "use_or_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template: str,
                 conditions: Optional['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditions'] = None,
                 use_or_conditions: Optional[bool] = None):
        pulumi.set(__self__, "template", template)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if use_or_conditions is not None:
            pulumi.set(__self__, "use_or_conditions", use_or_conditions)

    @property
    @pulumi.getter
    def template(self) -> str:
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def conditions(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditions']:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="useOrConditions")
    def use_or_conditions(self) -> Optional[bool]:
        return pulumi.get(self, "use_or_conditions")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCondition(dict):
    def __init__(__self__, *,
                 operand1: str,
                 operator: str,
                 operand2: Optional[str] = None):
        pulumi.set(__self__, "operand1", operand1)
        pulumi.set(__self__, "operator", operator)
        if operand2 is not None:
            pulumi.set(__self__, "operand2", operand2)

    @property
    @pulumi.getter
    def operand1(self) -> str:
        return pulumi.get(self, "operand1")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def operand2(self) -> Optional[str]:
        return pulumi.get(self, "operand2")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsLoadActionNamingRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useOrConditions":
            suggest = "use_or_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template: str,
                 conditions: Optional['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditions'] = None,
                 use_or_conditions: Optional[bool] = None):
        pulumi.set(__self__, "template", template)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if use_or_conditions is not None:
            pulumi.set(__self__, "use_or_conditions", use_or_conditions)

    @property
    @pulumi.getter
    def template(self) -> str:
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def conditions(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditions']:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="useOrConditions")
    def use_or_conditions(self) -> Optional[bool]:
        return pulumi.get(self, "use_or_conditions")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCondition(dict):
    def __init__(__self__, *,
                 operand1: str,
                 operator: str,
                 operand2: Optional[str] = None):
        pulumi.set(__self__, "operand1", operand1)
        pulumi.set(__self__, "operator", operator)
        if operand2 is not None:
            pulumi.set(__self__, "operand2", operand2)

    @property
    @pulumi.getter
    def operand1(self) -> str:
        return pulumi.get(self, "operand1")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def operand2(self) -> Optional[str]:
        return pulumi.get(self, "operand2")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsPlaceholders(dict):
    def __init__(__self__, *,
                 placeholders: Sequence['outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder']):
        pulumi.set(__self__, "placeholders", placeholders)

    @property
    @pulumi.getter
    def placeholders(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder']:
        return pulumi.get(self, "placeholders")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "processingPart":
            suggest = "processing_part"
        elif key == "metadataId":
            suggest = "metadata_id"
        elif key == "processingSteps":
            suggest = "processing_steps"
        elif key == "useGuessedElementIdentifier":
            suggest = "use_guessed_element_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input: str,
                 name: str,
                 processing_part: str,
                 metadata_id: Optional[int] = None,
                 processing_steps: Optional['outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps'] = None,
                 use_guessed_element_identifier: Optional[bool] = None):
        """
        :param str name: The name of the web application, displayed in the UI
        """
        pulumi.set(__self__, "input", input)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "processing_part", processing_part)
        if metadata_id is not None:
            pulumi.set(__self__, "metadata_id", metadata_id)
        if processing_steps is not None:
            pulumi.set(__self__, "processing_steps", processing_steps)
        if use_guessed_element_identifier is not None:
            pulumi.set(__self__, "use_guessed_element_identifier", use_guessed_element_identifier)

    @property
    @pulumi.getter
    def input(self) -> str:
        return pulumi.get(self, "input")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the web application, displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="processingPart")
    def processing_part(self) -> str:
        return pulumi.get(self, "processing_part")

    @property
    @pulumi.getter(name="metadataId")
    def metadata_id(self) -> Optional[int]:
        return pulumi.get(self, "metadata_id")

    @property
    @pulumi.getter(name="processingSteps")
    def processing_steps(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps']:
        return pulumi.get(self, "processing_steps")

    @property
    @pulumi.getter(name="useGuessedElementIdentifier")
    def use_guessed_element_identifier(self) -> Optional[bool]:
        return pulumi.get(self, "use_guessed_element_identifier")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps(dict):
    def __init__(__self__, *,
                 steps: Sequence['outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep']):
        pulumi.set(__self__, "steps", steps)

    @property
    @pulumi.getter
    def steps(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep']:
        return pulumi.get(self, "steps")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackToInput":
            suggest = "fallback_to_input"
        elif key == "patternAfter":
            suggest = "pattern_after"
        elif key == "patternAfterSearchType":
            suggest = "pattern_after_search_type"
        elif key == "patternBefore":
            suggest = "pattern_before"
        elif key == "patternBeforeSearchType":
            suggest = "pattern_before_search_type"
        elif key == "patternToReplace":
            suggest = "pattern_to_replace"
        elif key == "regularExpression":
            suggest = "regular_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fallback_to_input: Optional[bool] = None,
                 pattern_after: Optional[str] = None,
                 pattern_after_search_type: Optional[str] = None,
                 pattern_before: Optional[str] = None,
                 pattern_before_search_type: Optional[str] = None,
                 pattern_to_replace: Optional[str] = None,
                 regular_expression: Optional[str] = None,
                 replacement: Optional[str] = None):
        """
        :param str type: The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        pulumi.set(__self__, "type", type)
        if fallback_to_input is not None:
            pulumi.set(__self__, "fallback_to_input", fallback_to_input)
        if pattern_after is not None:
            pulumi.set(__self__, "pattern_after", pattern_after)
        if pattern_after_search_type is not None:
            pulumi.set(__self__, "pattern_after_search_type", pattern_after_search_type)
        if pattern_before is not None:
            pulumi.set(__self__, "pattern_before", pattern_before)
        if pattern_before_search_type is not None:
            pulumi.set(__self__, "pattern_before_search_type", pattern_before_search_type)
        if pattern_to_replace is not None:
            pulumi.set(__self__, "pattern_to_replace", pattern_to_replace)
        if regular_expression is not None:
            pulumi.set(__self__, "regular_expression", regular_expression)
        if replacement is not None:
            pulumi.set(__self__, "replacement", replacement)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="fallbackToInput")
    def fallback_to_input(self) -> Optional[bool]:
        return pulumi.get(self, "fallback_to_input")

    @property
    @pulumi.getter(name="patternAfter")
    def pattern_after(self) -> Optional[str]:
        return pulumi.get(self, "pattern_after")

    @property
    @pulumi.getter(name="patternAfterSearchType")
    def pattern_after_search_type(self) -> Optional[str]:
        return pulumi.get(self, "pattern_after_search_type")

    @property
    @pulumi.getter(name="patternBefore")
    def pattern_before(self) -> Optional[str]:
        return pulumi.get(self, "pattern_before")

    @property
    @pulumi.getter(name="patternBeforeSearchType")
    def pattern_before_search_type(self) -> Optional[str]:
        return pulumi.get(self, "pattern_before_search_type")

    @property
    @pulumi.getter(name="patternToReplace")
    def pattern_to_replace(self) -> Optional[str]:
        return pulumi.get(self, "pattern_to_replace")

    @property
    @pulumi.getter(name="regularExpression")
    def regular_expression(self) -> Optional[str]:
        return pulumi.get(self, "regular_expression")

    @property
    @pulumi.getter
    def replacement(self) -> Optional[str]:
        return pulumi.get(self, "replacement")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsXhrActionNamingRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useOrConditions":
            suggest = "use_or_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template: str,
                 conditions: Optional['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditions'] = None,
                 use_or_conditions: Optional[bool] = None):
        pulumi.set(__self__, "template", template)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if use_or_conditions is not None:
            pulumi.set(__self__, "use_or_conditions", use_or_conditions)

    @property
    @pulumi.getter
    def template(self) -> str:
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def conditions(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditions']:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="useOrConditions")
    def use_or_conditions(self) -> Optional[bool]:
        return pulumi.get(self, "use_or_conditions")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCondition(dict):
    def __init__(__self__, *,
                 operand1: str,
                 operator: str,
                 operand2: Optional[str] = None):
        pulumi.set(__self__, "operand1", operand1)
        pulumi.set(__self__, "operator", operator)
        if operand2 is not None:
            pulumi.set(__self__, "operand2", operand2)

    @property
    @pulumi.getter
    def operand1(self) -> str:
        return pulumi.get(self, "operand1")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def operand2(self) -> Optional[str]:
        return pulumi.get(self, "operand2")


@pulumi.output_type
class WebApplicationUserTags(dict):
    def __init__(__self__, *,
                 tags: Sequence['outputs.WebApplicationUserTagsTag']):
        """
        :param Sequence['WebApplicationUserTagsTagArgs'] tags: User tag settings
        """
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.WebApplicationUserTagsTag']:
        """
        User tag settings
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class WebApplicationUserTagsTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupRule":
            suggest = "cleanup_rule"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "metadataId":
            suggest = "metadata_id"
        elif key == "serverSideRequestAttribute":
            suggest = "server_side_request_attribute"
        elif key == "uniqueId":
            suggest = "unique_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserTagsTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserTagsTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserTagsTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cleanup_rule: Optional[str] = None,
                 id: Optional[int] = None,
                 ignore_case: Optional[bool] = None,
                 metadata_id: Optional[int] = None,
                 server_side_request_attribute: Optional[str] = None,
                 unique_id: Optional[int] = None):
        """
        :param int id: The ID of this resource.
        """
        if cleanup_rule is not None:
            pulumi.set(__self__, "cleanup_rule", cleanup_rule)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if metadata_id is not None:
            pulumi.set(__self__, "metadata_id", metadata_id)
        if server_side_request_attribute is not None:
            pulumi.set(__self__, "server_side_request_attribute", server_side_request_attribute)
        if unique_id is not None:
            pulumi.set(__self__, "unique_id", unique_id)

    @property
    @pulumi.getter(name="cleanupRule")
    def cleanup_rule(self) -> Optional[str]:
        return pulumi.get(self, "cleanup_rule")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="metadataId")
    def metadata_id(self) -> Optional[int]:
        return pulumi.get(self, "metadata_id")

    @property
    @pulumi.getter(name="serverSideRequestAttribute")
    def server_side_request_attribute(self) -> Optional[str]:
        return pulumi.get(self, "server_side_request_attribute")

    @property
    @pulumi.getter(name="uniqueId")
    def unique_id(self) -> Optional[int]:
        return pulumi.get(self, "unique_id")


@pulumi.output_type
class WebApplicationWaterfallSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceBrowserCachingThreshold":
            suggest = "resource_browser_caching_threshold"
        elif key == "resourcesThreshold":
            suggest = "resources_threshold"
        elif key == "slowCndResourcesThreshold":
            suggest = "slow_cnd_resources_threshold"
        elif key == "slowFirstPartyResourcesThreshold":
            suggest = "slow_first_party_resources_threshold"
        elif key == "slowThirdPartyResourcesThreshold":
            suggest = "slow_third_party_resources_threshold"
        elif key == "speedIndexVisuallyCompleteRatioThreshold":
            suggest = "speed_index_visually_complete_ratio_threshold"
        elif key == "uncompressedResourcesThreshold":
            suggest = "uncompressed_resources_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationWaterfallSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationWaterfallSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationWaterfallSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_browser_caching_threshold: int,
                 resources_threshold: int,
                 slow_cnd_resources_threshold: int,
                 slow_first_party_resources_threshold: int,
                 slow_third_party_resources_threshold: int,
                 speed_index_visually_complete_ratio_threshold: int,
                 uncompressed_resources_threshold: int):
        """
        :param int resource_browser_caching_threshold: Warn about resources with a lower browser cache rate above *X*%. Values between 1 and 100 are allowed.
        :param int resources_threshold: Warn about resources larger than *X* bytes. Values between 0 and 99999000 are allowed.
        :param int slow_cnd_resources_threshold: Warn about slow CDN resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
        :param int slow_first_party_resources_threshold: Warn about slow 1st party resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
        :param int slow_third_party_resources_threshold: Warn about slow 3rd party resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
        :param int speed_index_visually_complete_ratio_threshold: Warn if Speed index exceeds *X* % of Visually complete. Values between 1 and 99 are allowed.
        :param int uncompressed_resources_threshold: Warn about uncompressed resources larger than *X* bytes. Values between 0 and 99999 are allowed.
        """
        pulumi.set(__self__, "resource_browser_caching_threshold", resource_browser_caching_threshold)
        pulumi.set(__self__, "resources_threshold", resources_threshold)
        pulumi.set(__self__, "slow_cnd_resources_threshold", slow_cnd_resources_threshold)
        pulumi.set(__self__, "slow_first_party_resources_threshold", slow_first_party_resources_threshold)
        pulumi.set(__self__, "slow_third_party_resources_threshold", slow_third_party_resources_threshold)
        pulumi.set(__self__, "speed_index_visually_complete_ratio_threshold", speed_index_visually_complete_ratio_threshold)
        pulumi.set(__self__, "uncompressed_resources_threshold", uncompressed_resources_threshold)

    @property
    @pulumi.getter(name="resourceBrowserCachingThreshold")
    def resource_browser_caching_threshold(self) -> int:
        """
        Warn about resources with a lower browser cache rate above *X*%. Values between 1 and 100 are allowed.
        """
        return pulumi.get(self, "resource_browser_caching_threshold")

    @property
    @pulumi.getter(name="resourcesThreshold")
    def resources_threshold(self) -> int:
        """
        Warn about resources larger than *X* bytes. Values between 0 and 99999000 are allowed.
        """
        return pulumi.get(self, "resources_threshold")

    @property
    @pulumi.getter(name="slowCndResourcesThreshold")
    def slow_cnd_resources_threshold(self) -> int:
        """
        Warn about slow CDN resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
        """
        return pulumi.get(self, "slow_cnd_resources_threshold")

    @property
    @pulumi.getter(name="slowFirstPartyResourcesThreshold")
    def slow_first_party_resources_threshold(self) -> int:
        """
        Warn about slow 1st party resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
        """
        return pulumi.get(self, "slow_first_party_resources_threshold")

    @property
    @pulumi.getter(name="slowThirdPartyResourcesThreshold")
    def slow_third_party_resources_threshold(self) -> int:
        """
        Warn about slow 3rd party resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
        """
        return pulumi.get(self, "slow_third_party_resources_threshold")

    @property
    @pulumi.getter(name="speedIndexVisuallyCompleteRatioThreshold")
    def speed_index_visually_complete_ratio_threshold(self) -> int:
        """
        Warn if Speed index exceeds *X* % of Visually complete. Values between 1 and 99 are allowed.
        """
        return pulumi.get(self, "speed_index_visually_complete_ratio_threshold")

    @property
    @pulumi.getter(name="uncompressedResourcesThreshold")
    def uncompressed_resources_threshold(self) -> int:
        """
        Warn about uncompressed resources larger than *X* bytes. Values between 0 and 99999 are allowed.
        """
        return pulumi.get(self, "uncompressed_resources_threshold")


@pulumi.output_type
class WebApplicationXhrActionApdexSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frustratingFallbackThreshold":
            suggest = "frustrating_fallback_threshold"
        elif key == "frustratingThreshold":
            suggest = "frustrating_threshold"
        elif key == "toleratedFallbackThreshold":
            suggest = "tolerated_fallback_threshold"
        elif key == "toleratedThreshold":
            suggest = "tolerated_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationXhrActionApdexSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationXhrActionApdexSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationXhrActionApdexSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frustrating_fallback_threshold: Optional[int] = None,
                 frustrating_threshold: Optional[int] = None,
                 threshold: Optional[int] = None,
                 tolerated_fallback_threshold: Optional[int] = None,
                 tolerated_threshold: Optional[int] = None):
        """
        :param int frustrating_fallback_threshold: Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
        :param int frustrating_threshold: Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
        :param int threshold: no documentation available
        :param int tolerated_fallback_threshold: Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
        :param int tolerated_threshold: Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
        """
        if frustrating_fallback_threshold is not None:
            pulumi.set(__self__, "frustrating_fallback_threshold", frustrating_fallback_threshold)
        if frustrating_threshold is not None:
            pulumi.set(__self__, "frustrating_threshold", frustrating_threshold)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if tolerated_fallback_threshold is not None:
            pulumi.set(__self__, "tolerated_fallback_threshold", tolerated_fallback_threshold)
        if tolerated_threshold is not None:
            pulumi.set(__self__, "tolerated_threshold", tolerated_threshold)

    @property
    @pulumi.getter(name="frustratingFallbackThreshold")
    def frustrating_fallback_threshold(self) -> Optional[int]:
        """
        Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
        """
        return pulumi.get(self, "frustrating_fallback_threshold")

    @property
    @pulumi.getter(name="frustratingThreshold")
    def frustrating_threshold(self) -> Optional[int]:
        """
        Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
        """
        return pulumi.get(self, "frustrating_threshold")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[int]:
        """
        no documentation available
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="toleratedFallbackThreshold")
    def tolerated_fallback_threshold(self) -> Optional[int]:
        """
        Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
        """
        return pulumi.get(self, "tolerated_fallback_threshold")

    @property
    @pulumi.getter(name="toleratedThreshold")
    def tolerated_threshold(self) -> Optional[int]:
        """
        Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
        """
        return pulumi.get(self, "tolerated_threshold")


@pulumi.output_type
class WebhookNotificationHeaders(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.WebhookNotificationHeadersHeader']):
        """
        :param Sequence['WebhookNotificationHeadersHeaderArgs'] headers: An additional HTTP Header to include when sending requests
        """
        pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.WebhookNotificationHeadersHeader']:
        """
        An additional HTTP Header to include when sending requests
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class WebhookNotificationHeadersHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretValue":
            suggest = "secret_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhookNotificationHeadersHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhookNotificationHeadersHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhookNotificationHeadersHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 secret_value: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the notification configuration
        """
        pulumi.set(__self__, "name", name)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[str]:
        return pulumi.get(self, "secret_value")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class XmattersNotificationHeaders(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.XmattersNotificationHeadersHeader']):
        """
        :param Sequence['XmattersNotificationHeadersHeaderArgs'] headers: An additional HTTP Header to include when sending requests
        """
        pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.XmattersNotificationHeadersHeader']:
        """
        An additional HTTP Header to include when sending requests
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class XmattersNotificationHeadersHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretValue":
            suggest = "secret_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in XmattersNotificationHeadersHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        XmattersNotificationHeadersHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        XmattersNotificationHeadersHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 secret_value: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the notification configuration
        """
        pulumi.set(__self__, "name", name)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[str]:
        return pulumi.get(self, "secret_value")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAlertingProfilesValueResult(dict):
    def __init__(__self__, *,
                 id: str,
                 legacy_id: str,
                 management_zone_id: str,
                 management_zone_legacy_id: str,
                 name: str):
        """
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "legacy_id", legacy_id)
        pulumi.set(__self__, "management_zone_id", management_zone_id)
        pulumi.set(__self__, "management_zone_legacy_id", management_zone_legacy_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="legacyId")
    def legacy_id(self) -> str:
        return pulumi.get(self, "legacy_id")

    @property
    @pulumi.getter(name="managementZoneId")
    def management_zone_id(self) -> str:
        return pulumi.get(self, "management_zone_id")

    @property
    @pulumi.getter(name="managementZoneLegacyId")
    def management_zone_legacy_id(self) -> str:
        return pulumi.get(self, "management_zone_legacy_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetEntitiesEntitiesResult(dict):
    def __init__(__self__, *,
                 entities: Optional[Sequence['outputs.GetEntitiesEntitiesEntityResult']] = None):
        """
        :param Sequence['GetEntitiesEntitiesEntityArgs'] entities: A list of monitored entities.
        """
        if entities is not None:
            pulumi.set(__self__, "entities", entities)

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.GetEntitiesEntitiesEntityResult']]:
        """
        A list of monitored entities.
        """
        return pulumi.get(self, "entities")


@pulumi.output_type
class GetEntitiesEntitiesEntityResult(dict):
    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 entity_id: Optional[str] = None,
                 tags: Optional[Sequence['outputs.GetEntitiesEntitiesEntityTagResult']] = None,
                 type: Optional[str] = None):
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[str]:
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.GetEntitiesEntitiesEntityTagResult']]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEntitiesEntitiesEntityTagResult(dict):
    def __init__(__self__, *,
                 tags: Optional[Sequence['outputs.GetEntitiesEntitiesEntityTagTagResult']] = None):
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.GetEntitiesEntitiesEntityTagTagResult']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetEntitiesEntitiesEntityTagTagResult(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 string_representation: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if string_representation is not None:
            pulumi.set(__self__, "string_representation", string_representation)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="stringRepresentation")
    def string_representation(self) -> Optional[str]:
        return pulumi.get(self, "string_representation")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetManagementZonesValueResult(dict):
    def __init__(__self__, *,
                 description: str,
                 id: str,
                 legacy_id: str,
                 name: str):
        """
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "legacy_id", legacy_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="legacyId")
    def legacy_id(self) -> str:
        return pulumi.get(self, "legacy_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSyntheticLocationsLocationsResult(dict):
    def __init__(__self__, *,
                 cloud_platform: str,
                 ips: Sequence[str],
                 stage: str,
                 status: str,
                 entity_id: Optional[str] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str cloud_platform: The cloud provider where the location is hosted.
        """
        pulumi.set(__self__, "cloud_platform", cloud_platform)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "stage", stage)
        pulumi.set(__self__, "status", status)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="cloudPlatform")
    def cloud_platform(self) -> str:
        """
        The cloud provider where the location is hosted.
        """
        return pulumi.get(self, "cloud_platform")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def stage(self) -> str:
        return pulumi.get(self, "stage")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[str]:
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


