// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type AttackAllowlist struct {
	pulumi.CustomResourceState

	// Step 2: Define attack control for chosen criteria
	AttackHandling AttackAllowlistAttackHandlingOutput `pulumi:"attackHandling"`
	// Step 1: Define criteria. Please specify at least one of source IP or attack pattern.
	Criteria AttackAllowlistCriteriaOutput `pulumi:"criteria"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringOutput `pulumi:"insertAfter"`
	// Step 3: Leave comment
	Metadata AttackAllowlistMetadataOutput `pulumi:"metadata"`
}

// NewAttackAllowlist registers a new resource with the given unique name, arguments, and options.
func NewAttackAllowlist(ctx *pulumi.Context,
	name string, args *AttackAllowlistArgs, opts ...pulumi.ResourceOption) (*AttackAllowlist, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AttackHandling == nil {
		return nil, errors.New("invalid value for required argument 'AttackHandling'")
	}
	if args.Criteria == nil {
		return nil, errors.New("invalid value for required argument 'Criteria'")
	}
	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.Metadata == nil {
		return nil, errors.New("invalid value for required argument 'Metadata'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AttackAllowlist
	err := ctx.RegisterResource("dynatrace:index/attackAllowlist:AttackAllowlist", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAttackAllowlist gets an existing AttackAllowlist resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAttackAllowlist(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AttackAllowlistState, opts ...pulumi.ResourceOption) (*AttackAllowlist, error) {
	var resource AttackAllowlist
	err := ctx.ReadResource("dynatrace:index/attackAllowlist:AttackAllowlist", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AttackAllowlist resources.
type attackAllowlistState struct {
	// Step 2: Define attack control for chosen criteria
	AttackHandling *AttackAllowlistAttackHandling `pulumi:"attackHandling"`
	// Step 1: Define criteria. Please specify at least one of source IP or attack pattern.
	Criteria *AttackAllowlistCriteria `pulumi:"criteria"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Step 3: Leave comment
	Metadata *AttackAllowlistMetadata `pulumi:"metadata"`
}

type AttackAllowlistState struct {
	// Step 2: Define attack control for chosen criteria
	AttackHandling AttackAllowlistAttackHandlingPtrInput
	// Step 1: Define criteria. Please specify at least one of source IP or attack pattern.
	Criteria AttackAllowlistCriteriaPtrInput
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolPtrInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Step 3: Leave comment
	Metadata AttackAllowlistMetadataPtrInput
}

func (AttackAllowlistState) ElementType() reflect.Type {
	return reflect.TypeOf((*attackAllowlistState)(nil)).Elem()
}

type attackAllowlistArgs struct {
	// Step 2: Define attack control for chosen criteria
	AttackHandling AttackAllowlistAttackHandling `pulumi:"attackHandling"`
	// Step 1: Define criteria. Please specify at least one of source IP or attack pattern.
	Criteria AttackAllowlistCriteria `pulumi:"criteria"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled bool `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Step 3: Leave comment
	Metadata AttackAllowlistMetadata `pulumi:"metadata"`
}

// The set of arguments for constructing a AttackAllowlist resource.
type AttackAllowlistArgs struct {
	// Step 2: Define attack control for chosen criteria
	AttackHandling AttackAllowlistAttackHandlingInput
	// Step 1: Define criteria. Please specify at least one of source IP or attack pattern.
	Criteria AttackAllowlistCriteriaInput
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Step 3: Leave comment
	Metadata AttackAllowlistMetadataInput
}

func (AttackAllowlistArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*attackAllowlistArgs)(nil)).Elem()
}

type AttackAllowlistInput interface {
	pulumi.Input

	ToAttackAllowlistOutput() AttackAllowlistOutput
	ToAttackAllowlistOutputWithContext(ctx context.Context) AttackAllowlistOutput
}

func (*AttackAllowlist) ElementType() reflect.Type {
	return reflect.TypeOf((**AttackAllowlist)(nil)).Elem()
}

func (i *AttackAllowlist) ToAttackAllowlistOutput() AttackAllowlistOutput {
	return i.ToAttackAllowlistOutputWithContext(context.Background())
}

func (i *AttackAllowlist) ToAttackAllowlistOutputWithContext(ctx context.Context) AttackAllowlistOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttackAllowlistOutput)
}

// AttackAllowlistArrayInput is an input type that accepts AttackAllowlistArray and AttackAllowlistArrayOutput values.
// You can construct a concrete instance of `AttackAllowlistArrayInput` via:
//
//	AttackAllowlistArray{ AttackAllowlistArgs{...} }
type AttackAllowlistArrayInput interface {
	pulumi.Input

	ToAttackAllowlistArrayOutput() AttackAllowlistArrayOutput
	ToAttackAllowlistArrayOutputWithContext(context.Context) AttackAllowlistArrayOutput
}

type AttackAllowlistArray []AttackAllowlistInput

func (AttackAllowlistArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AttackAllowlist)(nil)).Elem()
}

func (i AttackAllowlistArray) ToAttackAllowlistArrayOutput() AttackAllowlistArrayOutput {
	return i.ToAttackAllowlistArrayOutputWithContext(context.Background())
}

func (i AttackAllowlistArray) ToAttackAllowlistArrayOutputWithContext(ctx context.Context) AttackAllowlistArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttackAllowlistArrayOutput)
}

// AttackAllowlistMapInput is an input type that accepts AttackAllowlistMap and AttackAllowlistMapOutput values.
// You can construct a concrete instance of `AttackAllowlistMapInput` via:
//
//	AttackAllowlistMap{ "key": AttackAllowlistArgs{...} }
type AttackAllowlistMapInput interface {
	pulumi.Input

	ToAttackAllowlistMapOutput() AttackAllowlistMapOutput
	ToAttackAllowlistMapOutputWithContext(context.Context) AttackAllowlistMapOutput
}

type AttackAllowlistMap map[string]AttackAllowlistInput

func (AttackAllowlistMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AttackAllowlist)(nil)).Elem()
}

func (i AttackAllowlistMap) ToAttackAllowlistMapOutput() AttackAllowlistMapOutput {
	return i.ToAttackAllowlistMapOutputWithContext(context.Background())
}

func (i AttackAllowlistMap) ToAttackAllowlistMapOutputWithContext(ctx context.Context) AttackAllowlistMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttackAllowlistMapOutput)
}

type AttackAllowlistOutput struct{ *pulumi.OutputState }

func (AttackAllowlistOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AttackAllowlist)(nil)).Elem()
}

func (o AttackAllowlistOutput) ToAttackAllowlistOutput() AttackAllowlistOutput {
	return o
}

func (o AttackAllowlistOutput) ToAttackAllowlistOutputWithContext(ctx context.Context) AttackAllowlistOutput {
	return o
}

// Step 2: Define attack control for chosen criteria
func (o AttackAllowlistOutput) AttackHandling() AttackAllowlistAttackHandlingOutput {
	return o.ApplyT(func(v *AttackAllowlist) AttackAllowlistAttackHandlingOutput { return v.AttackHandling }).(AttackAllowlistAttackHandlingOutput)
}

// Step 1: Define criteria. Please specify at least one of source IP or attack pattern.
func (o AttackAllowlistOutput) Criteria() AttackAllowlistCriteriaOutput {
	return o.ApplyT(func(v *AttackAllowlist) AttackAllowlistCriteriaOutput { return v.Criteria }).(AttackAllowlistCriteriaOutput)
}

// This setting is enabled (`true`) or disabled (`false`)
func (o AttackAllowlistOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *AttackAllowlist) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
func (o AttackAllowlistOutput) InsertAfter() pulumi.StringOutput {
	return o.ApplyT(func(v *AttackAllowlist) pulumi.StringOutput { return v.InsertAfter }).(pulumi.StringOutput)
}

// Step 3: Leave comment
func (o AttackAllowlistOutput) Metadata() AttackAllowlistMetadataOutput {
	return o.ApplyT(func(v *AttackAllowlist) AttackAllowlistMetadataOutput { return v.Metadata }).(AttackAllowlistMetadataOutput)
}

type AttackAllowlistArrayOutput struct{ *pulumi.OutputState }

func (AttackAllowlistArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AttackAllowlist)(nil)).Elem()
}

func (o AttackAllowlistArrayOutput) ToAttackAllowlistArrayOutput() AttackAllowlistArrayOutput {
	return o
}

func (o AttackAllowlistArrayOutput) ToAttackAllowlistArrayOutputWithContext(ctx context.Context) AttackAllowlistArrayOutput {
	return o
}

func (o AttackAllowlistArrayOutput) Index(i pulumi.IntInput) AttackAllowlistOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AttackAllowlist {
		return vs[0].([]*AttackAllowlist)[vs[1].(int)]
	}).(AttackAllowlistOutput)
}

type AttackAllowlistMapOutput struct{ *pulumi.OutputState }

func (AttackAllowlistMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AttackAllowlist)(nil)).Elem()
}

func (o AttackAllowlistMapOutput) ToAttackAllowlistMapOutput() AttackAllowlistMapOutput {
	return o
}

func (o AttackAllowlistMapOutput) ToAttackAllowlistMapOutputWithContext(ctx context.Context) AttackAllowlistMapOutput {
	return o
}

func (o AttackAllowlistMapOutput) MapIndex(k pulumi.StringInput) AttackAllowlistOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AttackAllowlist {
		return vs[0].(map[string]*AttackAllowlist)[vs[1].(string)]
	}).(AttackAllowlistOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AttackAllowlistInput)(nil)).Elem(), &AttackAllowlist{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttackAllowlistArrayInput)(nil)).Elem(), AttackAllowlistArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttackAllowlistMapInput)(nil)).Elem(), AttackAllowlistMap{})
	pulumi.RegisterOutputType(AttackAllowlistOutput{})
	pulumi.RegisterOutputType(AttackAllowlistArrayOutput{})
	pulumi.RegisterOutputType(AttackAllowlistMapOutput{})
}
