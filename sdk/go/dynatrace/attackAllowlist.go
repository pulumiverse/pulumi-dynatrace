// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type AttackAllowlist struct {
	pulumi.CustomResourceState

	// Step 1: Define attack control for chosen criteria
	AttackHandling AttackAllowlistAttackHandlingOutput `pulumi:"attackHandling"`
	// Step 1: Define criteria. Please specify at least one of source IP or attack pattern.
	//
	// Deprecated: The `criteria` attribute has been deprecated, please use the `rules` and `resourceAttributeConditions` attributes instead.
	Criteria AttackAllowlistCriteriaPtrOutput `pulumi:"criteria"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringOutput `pulumi:"insertAfter"`
	// Step 4: Leave comment (optional)
	Metadata AttackAllowlistMetadataOutput `pulumi:"metadata"`
	// When you add multiple conditions, the rule applies if all conditions apply.
	ResourceAttributeConditions AttackAllowlistResourceAttributeConditionsPtrOutput `pulumi:"resourceAttributeConditions"`
	// Rule name
	RuleName pulumi.StringPtrOutput `pulumi:"ruleName"`
	// Provide conditions that must be met by the detection finding you want to allowlist.
	Rules AttackAllowlistRulesOutput `pulumi:"rules"`
}

// NewAttackAllowlist registers a new resource with the given unique name, arguments, and options.
func NewAttackAllowlist(ctx *pulumi.Context,
	name string, args *AttackAllowlistArgs, opts ...pulumi.ResourceOption) (*AttackAllowlist, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AttackHandling == nil {
		return nil, errors.New("invalid value for required argument 'AttackHandling'")
	}
	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.Metadata == nil {
		return nil, errors.New("invalid value for required argument 'Metadata'")
	}
	if args.Rules == nil {
		return nil, errors.New("invalid value for required argument 'Rules'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AttackAllowlist
	err := ctx.RegisterResource("dynatrace:index/attackAllowlist:AttackAllowlist", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAttackAllowlist gets an existing AttackAllowlist resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAttackAllowlist(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AttackAllowlistState, opts ...pulumi.ResourceOption) (*AttackAllowlist, error) {
	var resource AttackAllowlist
	err := ctx.ReadResource("dynatrace:index/attackAllowlist:AttackAllowlist", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AttackAllowlist resources.
type attackAllowlistState struct {
	// Step 1: Define attack control for chosen criteria
	AttackHandling *AttackAllowlistAttackHandling `pulumi:"attackHandling"`
	// Step 1: Define criteria. Please specify at least one of source IP or attack pattern.
	//
	// Deprecated: The `criteria` attribute has been deprecated, please use the `rules` and `resourceAttributeConditions` attributes instead.
	Criteria *AttackAllowlistCriteria `pulumi:"criteria"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Step 4: Leave comment (optional)
	Metadata *AttackAllowlistMetadata `pulumi:"metadata"`
	// When you add multiple conditions, the rule applies if all conditions apply.
	ResourceAttributeConditions *AttackAllowlistResourceAttributeConditions `pulumi:"resourceAttributeConditions"`
	// Rule name
	RuleName *string `pulumi:"ruleName"`
	// Provide conditions that must be met by the detection finding you want to allowlist.
	Rules *AttackAllowlistRules `pulumi:"rules"`
}

type AttackAllowlistState struct {
	// Step 1: Define attack control for chosen criteria
	AttackHandling AttackAllowlistAttackHandlingPtrInput
	// Step 1: Define criteria. Please specify at least one of source IP or attack pattern.
	//
	// Deprecated: The `criteria` attribute has been deprecated, please use the `rules` and `resourceAttributeConditions` attributes instead.
	Criteria AttackAllowlistCriteriaPtrInput
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolPtrInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Step 4: Leave comment (optional)
	Metadata AttackAllowlistMetadataPtrInput
	// When you add multiple conditions, the rule applies if all conditions apply.
	ResourceAttributeConditions AttackAllowlistResourceAttributeConditionsPtrInput
	// Rule name
	RuleName pulumi.StringPtrInput
	// Provide conditions that must be met by the detection finding you want to allowlist.
	Rules AttackAllowlistRulesPtrInput
}

func (AttackAllowlistState) ElementType() reflect.Type {
	return reflect.TypeOf((*attackAllowlistState)(nil)).Elem()
}

type attackAllowlistArgs struct {
	// Step 1: Define attack control for chosen criteria
	AttackHandling AttackAllowlistAttackHandling `pulumi:"attackHandling"`
	// Step 1: Define criteria. Please specify at least one of source IP or attack pattern.
	//
	// Deprecated: The `criteria` attribute has been deprecated, please use the `rules` and `resourceAttributeConditions` attributes instead.
	Criteria *AttackAllowlistCriteria `pulumi:"criteria"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled bool `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Step 4: Leave comment (optional)
	Metadata AttackAllowlistMetadata `pulumi:"metadata"`
	// When you add multiple conditions, the rule applies if all conditions apply.
	ResourceAttributeConditions *AttackAllowlistResourceAttributeConditions `pulumi:"resourceAttributeConditions"`
	// Rule name
	RuleName *string `pulumi:"ruleName"`
	// Provide conditions that must be met by the detection finding you want to allowlist.
	Rules AttackAllowlistRules `pulumi:"rules"`
}

// The set of arguments for constructing a AttackAllowlist resource.
type AttackAllowlistArgs struct {
	// Step 1: Define attack control for chosen criteria
	AttackHandling AttackAllowlistAttackHandlingInput
	// Step 1: Define criteria. Please specify at least one of source IP or attack pattern.
	//
	// Deprecated: The `criteria` attribute has been deprecated, please use the `rules` and `resourceAttributeConditions` attributes instead.
	Criteria AttackAllowlistCriteriaPtrInput
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Step 4: Leave comment (optional)
	Metadata AttackAllowlistMetadataInput
	// When you add multiple conditions, the rule applies if all conditions apply.
	ResourceAttributeConditions AttackAllowlistResourceAttributeConditionsPtrInput
	// Rule name
	RuleName pulumi.StringPtrInput
	// Provide conditions that must be met by the detection finding you want to allowlist.
	Rules AttackAllowlistRulesInput
}

func (AttackAllowlistArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*attackAllowlistArgs)(nil)).Elem()
}

type AttackAllowlistInput interface {
	pulumi.Input

	ToAttackAllowlistOutput() AttackAllowlistOutput
	ToAttackAllowlistOutputWithContext(ctx context.Context) AttackAllowlistOutput
}

func (*AttackAllowlist) ElementType() reflect.Type {
	return reflect.TypeOf((**AttackAllowlist)(nil)).Elem()
}

func (i *AttackAllowlist) ToAttackAllowlistOutput() AttackAllowlistOutput {
	return i.ToAttackAllowlistOutputWithContext(context.Background())
}

func (i *AttackAllowlist) ToAttackAllowlistOutputWithContext(ctx context.Context) AttackAllowlistOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttackAllowlistOutput)
}

// AttackAllowlistArrayInput is an input type that accepts AttackAllowlistArray and AttackAllowlistArrayOutput values.
// You can construct a concrete instance of `AttackAllowlistArrayInput` via:
//
//	AttackAllowlistArray{ AttackAllowlistArgs{...} }
type AttackAllowlistArrayInput interface {
	pulumi.Input

	ToAttackAllowlistArrayOutput() AttackAllowlistArrayOutput
	ToAttackAllowlistArrayOutputWithContext(context.Context) AttackAllowlistArrayOutput
}

type AttackAllowlistArray []AttackAllowlistInput

func (AttackAllowlistArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AttackAllowlist)(nil)).Elem()
}

func (i AttackAllowlistArray) ToAttackAllowlistArrayOutput() AttackAllowlistArrayOutput {
	return i.ToAttackAllowlistArrayOutputWithContext(context.Background())
}

func (i AttackAllowlistArray) ToAttackAllowlistArrayOutputWithContext(ctx context.Context) AttackAllowlistArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttackAllowlistArrayOutput)
}

// AttackAllowlistMapInput is an input type that accepts AttackAllowlistMap and AttackAllowlistMapOutput values.
// You can construct a concrete instance of `AttackAllowlistMapInput` via:
//
//	AttackAllowlistMap{ "key": AttackAllowlistArgs{...} }
type AttackAllowlistMapInput interface {
	pulumi.Input

	ToAttackAllowlistMapOutput() AttackAllowlistMapOutput
	ToAttackAllowlistMapOutputWithContext(context.Context) AttackAllowlistMapOutput
}

type AttackAllowlistMap map[string]AttackAllowlistInput

func (AttackAllowlistMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AttackAllowlist)(nil)).Elem()
}

func (i AttackAllowlistMap) ToAttackAllowlistMapOutput() AttackAllowlistMapOutput {
	return i.ToAttackAllowlistMapOutputWithContext(context.Background())
}

func (i AttackAllowlistMap) ToAttackAllowlistMapOutputWithContext(ctx context.Context) AttackAllowlistMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttackAllowlistMapOutput)
}

type AttackAllowlistOutput struct{ *pulumi.OutputState }

func (AttackAllowlistOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AttackAllowlist)(nil)).Elem()
}

func (o AttackAllowlistOutput) ToAttackAllowlistOutput() AttackAllowlistOutput {
	return o
}

func (o AttackAllowlistOutput) ToAttackAllowlistOutputWithContext(ctx context.Context) AttackAllowlistOutput {
	return o
}

// Step 1: Define attack control for chosen criteria
func (o AttackAllowlistOutput) AttackHandling() AttackAllowlistAttackHandlingOutput {
	return o.ApplyT(func(v *AttackAllowlist) AttackAllowlistAttackHandlingOutput { return v.AttackHandling }).(AttackAllowlistAttackHandlingOutput)
}

// Step 1: Define criteria. Please specify at least one of source IP or attack pattern.
//
// Deprecated: The `criteria` attribute has been deprecated, please use the `rules` and `resourceAttributeConditions` attributes instead.
func (o AttackAllowlistOutput) Criteria() AttackAllowlistCriteriaPtrOutput {
	return o.ApplyT(func(v *AttackAllowlist) AttackAllowlistCriteriaPtrOutput { return v.Criteria }).(AttackAllowlistCriteriaPtrOutput)
}

// This setting is enabled (`true`) or disabled (`false`)
func (o AttackAllowlistOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *AttackAllowlist) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
func (o AttackAllowlistOutput) InsertAfter() pulumi.StringOutput {
	return o.ApplyT(func(v *AttackAllowlist) pulumi.StringOutput { return v.InsertAfter }).(pulumi.StringOutput)
}

// Step 4: Leave comment (optional)
func (o AttackAllowlistOutput) Metadata() AttackAllowlistMetadataOutput {
	return o.ApplyT(func(v *AttackAllowlist) AttackAllowlistMetadataOutput { return v.Metadata }).(AttackAllowlistMetadataOutput)
}

// When you add multiple conditions, the rule applies if all conditions apply.
func (o AttackAllowlistOutput) ResourceAttributeConditions() AttackAllowlistResourceAttributeConditionsPtrOutput {
	return o.ApplyT(func(v *AttackAllowlist) AttackAllowlistResourceAttributeConditionsPtrOutput {
		return v.ResourceAttributeConditions
	}).(AttackAllowlistResourceAttributeConditionsPtrOutput)
}

// Rule name
func (o AttackAllowlistOutput) RuleName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AttackAllowlist) pulumi.StringPtrOutput { return v.RuleName }).(pulumi.StringPtrOutput)
}

// Provide conditions that must be met by the detection finding you want to allowlist.
func (o AttackAllowlistOutput) Rules() AttackAllowlistRulesOutput {
	return o.ApplyT(func(v *AttackAllowlist) AttackAllowlistRulesOutput { return v.Rules }).(AttackAllowlistRulesOutput)
}

type AttackAllowlistArrayOutput struct{ *pulumi.OutputState }

func (AttackAllowlistArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AttackAllowlist)(nil)).Elem()
}

func (o AttackAllowlistArrayOutput) ToAttackAllowlistArrayOutput() AttackAllowlistArrayOutput {
	return o
}

func (o AttackAllowlistArrayOutput) ToAttackAllowlistArrayOutputWithContext(ctx context.Context) AttackAllowlistArrayOutput {
	return o
}

func (o AttackAllowlistArrayOutput) Index(i pulumi.IntInput) AttackAllowlistOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AttackAllowlist {
		return vs[0].([]*AttackAllowlist)[vs[1].(int)]
	}).(AttackAllowlistOutput)
}

type AttackAllowlistMapOutput struct{ *pulumi.OutputState }

func (AttackAllowlistMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AttackAllowlist)(nil)).Elem()
}

func (o AttackAllowlistMapOutput) ToAttackAllowlistMapOutput() AttackAllowlistMapOutput {
	return o
}

func (o AttackAllowlistMapOutput) ToAttackAllowlistMapOutputWithContext(ctx context.Context) AttackAllowlistMapOutput {
	return o
}

func (o AttackAllowlistMapOutput) MapIndex(k pulumi.StringInput) AttackAllowlistOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AttackAllowlist {
		return vs[0].(map[string]*AttackAllowlist)[vs[1].(string)]
	}).(AttackAllowlistOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AttackAllowlistInput)(nil)).Elem(), &AttackAllowlist{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttackAllowlistArrayInput)(nil)).Elem(), AttackAllowlistArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttackAllowlistMapInput)(nil)).Elem(), AttackAllowlistMap{})
	pulumi.RegisterOutputType(AttackAllowlistOutput{})
	pulumi.RegisterOutputType(AttackAllowlistArrayOutput{})
	pulumi.RegisterOutputType(AttackAllowlistMapOutput{})
}
