// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type DiskAnomalies struct {
	pulumi.CustomResourceState

	// Narrows the rule usage down to disks, matching the specified criteria
	DiskName DiskAnomaliesDiskNamePtrOutput `pulumi:"diskName"`
	// Disk event rule enabled/disabled
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// Narrows the rule usage down to disks that run on hosts that themselves run on the specified host group
	HostGroupId pulumi.StringPtrOutput `pulumi:"hostGroupId"`
	// The metric to monitor. Possible values are: `LOW_DISK_SPACE`, `LOW_INODES`, `READ_TIME_EXCEEDING` and `WRITE_TIME_EXCEEDING`
	Metric pulumi.StringOutput `pulumi:"metric"`
	// The name of the disk event rule
	Name pulumi.StringOutput `pulumi:"name"`
	// The number of samples to evaluate
	Samples pulumi.IntOutput `pulumi:"samples"`
	// Narrows the rule usage down to the hosts matching the specified tags
	Tags DiskAnomaliesTagsPtrOutput `pulumi:"tags"`
	// The threshold to trigger disk event.   * A percentage for `LowDiskSpace` or `LowInodes` metrics.   * In milliseconds for `ReadTimeExceeding` or `WriteTimeExceeding` metrics
	Threshold pulumi.Float64Output `pulumi:"threshold"`
	// The number of samples that must violate the threshold to trigger an event. Must not exceed the number of evaluated samples
	ViolatingSamples pulumi.IntOutput `pulumi:"violatingSamples"`
}

// NewDiskAnomalies registers a new resource with the given unique name, arguments, and options.
func NewDiskAnomalies(ctx *pulumi.Context,
	name string, args *DiskAnomaliesArgs, opts ...pulumi.ResourceOption) (*DiskAnomalies, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.Metric == nil {
		return nil, errors.New("invalid value for required argument 'Metric'")
	}
	if args.Samples == nil {
		return nil, errors.New("invalid value for required argument 'Samples'")
	}
	if args.Threshold == nil {
		return nil, errors.New("invalid value for required argument 'Threshold'")
	}
	if args.ViolatingSamples == nil {
		return nil, errors.New("invalid value for required argument 'ViolatingSamples'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource DiskAnomalies
	err := ctx.RegisterResource("dynatrace:index/diskAnomalies:DiskAnomalies", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDiskAnomalies gets an existing DiskAnomalies resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDiskAnomalies(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DiskAnomaliesState, opts ...pulumi.ResourceOption) (*DiskAnomalies, error) {
	var resource DiskAnomalies
	err := ctx.ReadResource("dynatrace:index/diskAnomalies:DiskAnomalies", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DiskAnomalies resources.
type diskAnomaliesState struct {
	// Narrows the rule usage down to disks, matching the specified criteria
	DiskName *DiskAnomaliesDiskName `pulumi:"diskName"`
	// Disk event rule enabled/disabled
	Enabled *bool `pulumi:"enabled"`
	// Narrows the rule usage down to disks that run on hosts that themselves run on the specified host group
	HostGroupId *string `pulumi:"hostGroupId"`
	// The metric to monitor. Possible values are: `LOW_DISK_SPACE`, `LOW_INODES`, `READ_TIME_EXCEEDING` and `WRITE_TIME_EXCEEDING`
	Metric *string `pulumi:"metric"`
	// The name of the disk event rule
	Name *string `pulumi:"name"`
	// The number of samples to evaluate
	Samples *int `pulumi:"samples"`
	// Narrows the rule usage down to the hosts matching the specified tags
	Tags *DiskAnomaliesTags `pulumi:"tags"`
	// The threshold to trigger disk event.   * A percentage for `LowDiskSpace` or `LowInodes` metrics.   * In milliseconds for `ReadTimeExceeding` or `WriteTimeExceeding` metrics
	Threshold *float64 `pulumi:"threshold"`
	// The number of samples that must violate the threshold to trigger an event. Must not exceed the number of evaluated samples
	ViolatingSamples *int `pulumi:"violatingSamples"`
}

type DiskAnomaliesState struct {
	// Narrows the rule usage down to disks, matching the specified criteria
	DiskName DiskAnomaliesDiskNamePtrInput
	// Disk event rule enabled/disabled
	Enabled pulumi.BoolPtrInput
	// Narrows the rule usage down to disks that run on hosts that themselves run on the specified host group
	HostGroupId pulumi.StringPtrInput
	// The metric to monitor. Possible values are: `LOW_DISK_SPACE`, `LOW_INODES`, `READ_TIME_EXCEEDING` and `WRITE_TIME_EXCEEDING`
	Metric pulumi.StringPtrInput
	// The name of the disk event rule
	Name pulumi.StringPtrInput
	// The number of samples to evaluate
	Samples pulumi.IntPtrInput
	// Narrows the rule usage down to the hosts matching the specified tags
	Tags DiskAnomaliesTagsPtrInput
	// The threshold to trigger disk event.   * A percentage for `LowDiskSpace` or `LowInodes` metrics.   * In milliseconds for `ReadTimeExceeding` or `WriteTimeExceeding` metrics
	Threshold pulumi.Float64PtrInput
	// The number of samples that must violate the threshold to trigger an event. Must not exceed the number of evaluated samples
	ViolatingSamples pulumi.IntPtrInput
}

func (DiskAnomaliesState) ElementType() reflect.Type {
	return reflect.TypeOf((*diskAnomaliesState)(nil)).Elem()
}

type diskAnomaliesArgs struct {
	// Narrows the rule usage down to disks, matching the specified criteria
	DiskName *DiskAnomaliesDiskName `pulumi:"diskName"`
	// Disk event rule enabled/disabled
	Enabled bool `pulumi:"enabled"`
	// Narrows the rule usage down to disks that run on hosts that themselves run on the specified host group
	HostGroupId *string `pulumi:"hostGroupId"`
	// The metric to monitor. Possible values are: `LOW_DISK_SPACE`, `LOW_INODES`, `READ_TIME_EXCEEDING` and `WRITE_TIME_EXCEEDING`
	Metric string `pulumi:"metric"`
	// The name of the disk event rule
	Name *string `pulumi:"name"`
	// The number of samples to evaluate
	Samples int `pulumi:"samples"`
	// Narrows the rule usage down to the hosts matching the specified tags
	Tags *DiskAnomaliesTags `pulumi:"tags"`
	// The threshold to trigger disk event.   * A percentage for `LowDiskSpace` or `LowInodes` metrics.   * In milliseconds for `ReadTimeExceeding` or `WriteTimeExceeding` metrics
	Threshold float64 `pulumi:"threshold"`
	// The number of samples that must violate the threshold to trigger an event. Must not exceed the number of evaluated samples
	ViolatingSamples int `pulumi:"violatingSamples"`
}

// The set of arguments for constructing a DiskAnomalies resource.
type DiskAnomaliesArgs struct {
	// Narrows the rule usage down to disks, matching the specified criteria
	DiskName DiskAnomaliesDiskNamePtrInput
	// Disk event rule enabled/disabled
	Enabled pulumi.BoolInput
	// Narrows the rule usage down to disks that run on hosts that themselves run on the specified host group
	HostGroupId pulumi.StringPtrInput
	// The metric to monitor. Possible values are: `LOW_DISK_SPACE`, `LOW_INODES`, `READ_TIME_EXCEEDING` and `WRITE_TIME_EXCEEDING`
	Metric pulumi.StringInput
	// The name of the disk event rule
	Name pulumi.StringPtrInput
	// The number of samples to evaluate
	Samples pulumi.IntInput
	// Narrows the rule usage down to the hosts matching the specified tags
	Tags DiskAnomaliesTagsPtrInput
	// The threshold to trigger disk event.   * A percentage for `LowDiskSpace` or `LowInodes` metrics.   * In milliseconds for `ReadTimeExceeding` or `WriteTimeExceeding` metrics
	Threshold pulumi.Float64Input
	// The number of samples that must violate the threshold to trigger an event. Must not exceed the number of evaluated samples
	ViolatingSamples pulumi.IntInput
}

func (DiskAnomaliesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*diskAnomaliesArgs)(nil)).Elem()
}

type DiskAnomaliesInput interface {
	pulumi.Input

	ToDiskAnomaliesOutput() DiskAnomaliesOutput
	ToDiskAnomaliesOutputWithContext(ctx context.Context) DiskAnomaliesOutput
}

func (*DiskAnomalies) ElementType() reflect.Type {
	return reflect.TypeOf((**DiskAnomalies)(nil)).Elem()
}

func (i *DiskAnomalies) ToDiskAnomaliesOutput() DiskAnomaliesOutput {
	return i.ToDiskAnomaliesOutputWithContext(context.Background())
}

func (i *DiskAnomalies) ToDiskAnomaliesOutputWithContext(ctx context.Context) DiskAnomaliesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiskAnomaliesOutput)
}

// DiskAnomaliesArrayInput is an input type that accepts DiskAnomaliesArray and DiskAnomaliesArrayOutput values.
// You can construct a concrete instance of `DiskAnomaliesArrayInput` via:
//
//	DiskAnomaliesArray{ DiskAnomaliesArgs{...} }
type DiskAnomaliesArrayInput interface {
	pulumi.Input

	ToDiskAnomaliesArrayOutput() DiskAnomaliesArrayOutput
	ToDiskAnomaliesArrayOutputWithContext(context.Context) DiskAnomaliesArrayOutput
}

type DiskAnomaliesArray []DiskAnomaliesInput

func (DiskAnomaliesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DiskAnomalies)(nil)).Elem()
}

func (i DiskAnomaliesArray) ToDiskAnomaliesArrayOutput() DiskAnomaliesArrayOutput {
	return i.ToDiskAnomaliesArrayOutputWithContext(context.Background())
}

func (i DiskAnomaliesArray) ToDiskAnomaliesArrayOutputWithContext(ctx context.Context) DiskAnomaliesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiskAnomaliesArrayOutput)
}

// DiskAnomaliesMapInput is an input type that accepts DiskAnomaliesMap and DiskAnomaliesMapOutput values.
// You can construct a concrete instance of `DiskAnomaliesMapInput` via:
//
//	DiskAnomaliesMap{ "key": DiskAnomaliesArgs{...} }
type DiskAnomaliesMapInput interface {
	pulumi.Input

	ToDiskAnomaliesMapOutput() DiskAnomaliesMapOutput
	ToDiskAnomaliesMapOutputWithContext(context.Context) DiskAnomaliesMapOutput
}

type DiskAnomaliesMap map[string]DiskAnomaliesInput

func (DiskAnomaliesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DiskAnomalies)(nil)).Elem()
}

func (i DiskAnomaliesMap) ToDiskAnomaliesMapOutput() DiskAnomaliesMapOutput {
	return i.ToDiskAnomaliesMapOutputWithContext(context.Background())
}

func (i DiskAnomaliesMap) ToDiskAnomaliesMapOutputWithContext(ctx context.Context) DiskAnomaliesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiskAnomaliesMapOutput)
}

type DiskAnomaliesOutput struct{ *pulumi.OutputState }

func (DiskAnomaliesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DiskAnomalies)(nil)).Elem()
}

func (o DiskAnomaliesOutput) ToDiskAnomaliesOutput() DiskAnomaliesOutput {
	return o
}

func (o DiskAnomaliesOutput) ToDiskAnomaliesOutputWithContext(ctx context.Context) DiskAnomaliesOutput {
	return o
}

// Narrows the rule usage down to disks, matching the specified criteria
func (o DiskAnomaliesOutput) DiskName() DiskAnomaliesDiskNamePtrOutput {
	return o.ApplyT(func(v *DiskAnomalies) DiskAnomaliesDiskNamePtrOutput { return v.DiskName }).(DiskAnomaliesDiskNamePtrOutput)
}

// Disk event rule enabled/disabled
func (o DiskAnomaliesOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *DiskAnomalies) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// Narrows the rule usage down to disks that run on hosts that themselves run on the specified host group
func (o DiskAnomaliesOutput) HostGroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DiskAnomalies) pulumi.StringPtrOutput { return v.HostGroupId }).(pulumi.StringPtrOutput)
}

// The metric to monitor. Possible values are: `LOW_DISK_SPACE`, `LOW_INODES`, `READ_TIME_EXCEEDING` and `WRITE_TIME_EXCEEDING`
func (o DiskAnomaliesOutput) Metric() pulumi.StringOutput {
	return o.ApplyT(func(v *DiskAnomalies) pulumi.StringOutput { return v.Metric }).(pulumi.StringOutput)
}

// The name of the disk event rule
func (o DiskAnomaliesOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *DiskAnomalies) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The number of samples to evaluate
func (o DiskAnomaliesOutput) Samples() pulumi.IntOutput {
	return o.ApplyT(func(v *DiskAnomalies) pulumi.IntOutput { return v.Samples }).(pulumi.IntOutput)
}

// Narrows the rule usage down to the hosts matching the specified tags
func (o DiskAnomaliesOutput) Tags() DiskAnomaliesTagsPtrOutput {
	return o.ApplyT(func(v *DiskAnomalies) DiskAnomaliesTagsPtrOutput { return v.Tags }).(DiskAnomaliesTagsPtrOutput)
}

// The threshold to trigger disk event.   * A percentage for `LowDiskSpace` or `LowInodes` metrics.   * In milliseconds for `ReadTimeExceeding` or `WriteTimeExceeding` metrics
func (o DiskAnomaliesOutput) Threshold() pulumi.Float64Output {
	return o.ApplyT(func(v *DiskAnomalies) pulumi.Float64Output { return v.Threshold }).(pulumi.Float64Output)
}

// The number of samples that must violate the threshold to trigger an event. Must not exceed the number of evaluated samples
func (o DiskAnomaliesOutput) ViolatingSamples() pulumi.IntOutput {
	return o.ApplyT(func(v *DiskAnomalies) pulumi.IntOutput { return v.ViolatingSamples }).(pulumi.IntOutput)
}

type DiskAnomaliesArrayOutput struct{ *pulumi.OutputState }

func (DiskAnomaliesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DiskAnomalies)(nil)).Elem()
}

func (o DiskAnomaliesArrayOutput) ToDiskAnomaliesArrayOutput() DiskAnomaliesArrayOutput {
	return o
}

func (o DiskAnomaliesArrayOutput) ToDiskAnomaliesArrayOutputWithContext(ctx context.Context) DiskAnomaliesArrayOutput {
	return o
}

func (o DiskAnomaliesArrayOutput) Index(i pulumi.IntInput) DiskAnomaliesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DiskAnomalies {
		return vs[0].([]*DiskAnomalies)[vs[1].(int)]
	}).(DiskAnomaliesOutput)
}

type DiskAnomaliesMapOutput struct{ *pulumi.OutputState }

func (DiskAnomaliesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DiskAnomalies)(nil)).Elem()
}

func (o DiskAnomaliesMapOutput) ToDiskAnomaliesMapOutput() DiskAnomaliesMapOutput {
	return o
}

func (o DiskAnomaliesMapOutput) ToDiskAnomaliesMapOutputWithContext(ctx context.Context) DiskAnomaliesMapOutput {
	return o
}

func (o DiskAnomaliesMapOutput) MapIndex(k pulumi.StringInput) DiskAnomaliesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DiskAnomalies {
		return vs[0].(map[string]*DiskAnomalies)[vs[1].(string)]
	}).(DiskAnomaliesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DiskAnomaliesInput)(nil)).Elem(), &DiskAnomalies{})
	pulumi.RegisterInputType(reflect.TypeOf((*DiskAnomaliesArrayInput)(nil)).Elem(), DiskAnomaliesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DiskAnomaliesMapInput)(nil)).Elem(), DiskAnomaliesMap{})
	pulumi.RegisterOutputType(DiskAnomaliesOutput{})
	pulumi.RegisterOutputType(DiskAnomaliesArrayOutput{})
	pulumi.RegisterOutputType(DiskAnomaliesMapOutput{})
}
