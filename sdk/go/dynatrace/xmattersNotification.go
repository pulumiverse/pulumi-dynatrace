// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type XmattersNotification struct {
	pulumi.CustomResourceState

	// The configuration is enabled (`true`) or disabled (`false`)
	Active pulumi.BoolOutput `pulumi:"active"`
	// A list of the additional HTTP headers
	Headers XmattersNotificationHeadersPtrOutput `pulumi:"headers"`
	// Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
	Insecure pulumi.BoolPtrOutput `pulumi:"insecure"`
	// The ID of these settings when referred to from resources requiring the REST API V1 keys
	LegacyId pulumi.StringOutput `pulumi:"legacyId"`
	// The name of the notification configuration
	Name pulumi.StringOutput `pulumi:"name"`
	// The content of the notification message. You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
	Payload pulumi.StringOutput `pulumi:"payload"`
	// The ID of the associated alerting profile
	Profile pulumi.StringOutput `pulumi:"profile"`
	// The URL of the WebHook endpoint
	Url pulumi.StringOutput `pulumi:"url"`
}

// NewXmattersNotification registers a new resource with the given unique name, arguments, and options.
func NewXmattersNotification(ctx *pulumi.Context,
	name string, args *XmattersNotificationArgs, opts ...pulumi.ResourceOption) (*XmattersNotification, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Active == nil {
		return nil, errors.New("invalid value for required argument 'Active'")
	}
	if args.Payload == nil {
		return nil, errors.New("invalid value for required argument 'Payload'")
	}
	if args.Profile == nil {
		return nil, errors.New("invalid value for required argument 'Profile'")
	}
	if args.Url == nil {
		return nil, errors.New("invalid value for required argument 'Url'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource XmattersNotification
	err := ctx.RegisterResource("dynatrace:index/xmattersNotification:XmattersNotification", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetXmattersNotification gets an existing XmattersNotification resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetXmattersNotification(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *XmattersNotificationState, opts ...pulumi.ResourceOption) (*XmattersNotification, error) {
	var resource XmattersNotification
	err := ctx.ReadResource("dynatrace:index/xmattersNotification:XmattersNotification", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering XmattersNotification resources.
type xmattersNotificationState struct {
	// The configuration is enabled (`true`) or disabled (`false`)
	Active *bool `pulumi:"active"`
	// A list of the additional HTTP headers
	Headers *XmattersNotificationHeaders `pulumi:"headers"`
	// Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
	Insecure *bool `pulumi:"insecure"`
	// The ID of these settings when referred to from resources requiring the REST API V1 keys
	LegacyId *string `pulumi:"legacyId"`
	// The name of the notification configuration
	Name *string `pulumi:"name"`
	// The content of the notification message. You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
	Payload *string `pulumi:"payload"`
	// The ID of the associated alerting profile
	Profile *string `pulumi:"profile"`
	// The URL of the WebHook endpoint
	Url *string `pulumi:"url"`
}

type XmattersNotificationState struct {
	// The configuration is enabled (`true`) or disabled (`false`)
	Active pulumi.BoolPtrInput
	// A list of the additional HTTP headers
	Headers XmattersNotificationHeadersPtrInput
	// Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
	Insecure pulumi.BoolPtrInput
	// The ID of these settings when referred to from resources requiring the REST API V1 keys
	LegacyId pulumi.StringPtrInput
	// The name of the notification configuration
	Name pulumi.StringPtrInput
	// The content of the notification message. You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
	Payload pulumi.StringPtrInput
	// The ID of the associated alerting profile
	Profile pulumi.StringPtrInput
	// The URL of the WebHook endpoint
	Url pulumi.StringPtrInput
}

func (XmattersNotificationState) ElementType() reflect.Type {
	return reflect.TypeOf((*xmattersNotificationState)(nil)).Elem()
}

type xmattersNotificationArgs struct {
	// The configuration is enabled (`true`) or disabled (`false`)
	Active bool `pulumi:"active"`
	// A list of the additional HTTP headers
	Headers *XmattersNotificationHeaders `pulumi:"headers"`
	// Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
	Insecure *bool `pulumi:"insecure"`
	// The ID of these settings when referred to from resources requiring the REST API V1 keys
	LegacyId *string `pulumi:"legacyId"`
	// The name of the notification configuration
	Name *string `pulumi:"name"`
	// The content of the notification message. You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
	Payload string `pulumi:"payload"`
	// The ID of the associated alerting profile
	Profile string `pulumi:"profile"`
	// The URL of the WebHook endpoint
	Url string `pulumi:"url"`
}

// The set of arguments for constructing a XmattersNotification resource.
type XmattersNotificationArgs struct {
	// The configuration is enabled (`true`) or disabled (`false`)
	Active pulumi.BoolInput
	// A list of the additional HTTP headers
	Headers XmattersNotificationHeadersPtrInput
	// Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
	Insecure pulumi.BoolPtrInput
	// The ID of these settings when referred to from resources requiring the REST API V1 keys
	LegacyId pulumi.StringPtrInput
	// The name of the notification configuration
	Name pulumi.StringPtrInput
	// The content of the notification message. You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
	Payload pulumi.StringInput
	// The ID of the associated alerting profile
	Profile pulumi.StringInput
	// The URL of the WebHook endpoint
	Url pulumi.StringInput
}

func (XmattersNotificationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*xmattersNotificationArgs)(nil)).Elem()
}

type XmattersNotificationInput interface {
	pulumi.Input

	ToXmattersNotificationOutput() XmattersNotificationOutput
	ToXmattersNotificationOutputWithContext(ctx context.Context) XmattersNotificationOutput
}

func (*XmattersNotification) ElementType() reflect.Type {
	return reflect.TypeOf((**XmattersNotification)(nil)).Elem()
}

func (i *XmattersNotification) ToXmattersNotificationOutput() XmattersNotificationOutput {
	return i.ToXmattersNotificationOutputWithContext(context.Background())
}

func (i *XmattersNotification) ToXmattersNotificationOutputWithContext(ctx context.Context) XmattersNotificationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XmattersNotificationOutput)
}

// XmattersNotificationArrayInput is an input type that accepts XmattersNotificationArray and XmattersNotificationArrayOutput values.
// You can construct a concrete instance of `XmattersNotificationArrayInput` via:
//
//	XmattersNotificationArray{ XmattersNotificationArgs{...} }
type XmattersNotificationArrayInput interface {
	pulumi.Input

	ToXmattersNotificationArrayOutput() XmattersNotificationArrayOutput
	ToXmattersNotificationArrayOutputWithContext(context.Context) XmattersNotificationArrayOutput
}

type XmattersNotificationArray []XmattersNotificationInput

func (XmattersNotificationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*XmattersNotification)(nil)).Elem()
}

func (i XmattersNotificationArray) ToXmattersNotificationArrayOutput() XmattersNotificationArrayOutput {
	return i.ToXmattersNotificationArrayOutputWithContext(context.Background())
}

func (i XmattersNotificationArray) ToXmattersNotificationArrayOutputWithContext(ctx context.Context) XmattersNotificationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XmattersNotificationArrayOutput)
}

// XmattersNotificationMapInput is an input type that accepts XmattersNotificationMap and XmattersNotificationMapOutput values.
// You can construct a concrete instance of `XmattersNotificationMapInput` via:
//
//	XmattersNotificationMap{ "key": XmattersNotificationArgs{...} }
type XmattersNotificationMapInput interface {
	pulumi.Input

	ToXmattersNotificationMapOutput() XmattersNotificationMapOutput
	ToXmattersNotificationMapOutputWithContext(context.Context) XmattersNotificationMapOutput
}

type XmattersNotificationMap map[string]XmattersNotificationInput

func (XmattersNotificationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*XmattersNotification)(nil)).Elem()
}

func (i XmattersNotificationMap) ToXmattersNotificationMapOutput() XmattersNotificationMapOutput {
	return i.ToXmattersNotificationMapOutputWithContext(context.Background())
}

func (i XmattersNotificationMap) ToXmattersNotificationMapOutputWithContext(ctx context.Context) XmattersNotificationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XmattersNotificationMapOutput)
}

type XmattersNotificationOutput struct{ *pulumi.OutputState }

func (XmattersNotificationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XmattersNotification)(nil)).Elem()
}

func (o XmattersNotificationOutput) ToXmattersNotificationOutput() XmattersNotificationOutput {
	return o
}

func (o XmattersNotificationOutput) ToXmattersNotificationOutputWithContext(ctx context.Context) XmattersNotificationOutput {
	return o
}

// The configuration is enabled (`true`) or disabled (`false`)
func (o XmattersNotificationOutput) Active() pulumi.BoolOutput {
	return o.ApplyT(func(v *XmattersNotification) pulumi.BoolOutput { return v.Active }).(pulumi.BoolOutput)
}

// A list of the additional HTTP headers
func (o XmattersNotificationOutput) Headers() XmattersNotificationHeadersPtrOutput {
	return o.ApplyT(func(v *XmattersNotification) XmattersNotificationHeadersPtrOutput { return v.Headers }).(XmattersNotificationHeadersPtrOutput)
}

// Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
func (o XmattersNotificationOutput) Insecure() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *XmattersNotification) pulumi.BoolPtrOutput { return v.Insecure }).(pulumi.BoolPtrOutput)
}

// The ID of these settings when referred to from resources requiring the REST API V1 keys
func (o XmattersNotificationOutput) LegacyId() pulumi.StringOutput {
	return o.ApplyT(func(v *XmattersNotification) pulumi.StringOutput { return v.LegacyId }).(pulumi.StringOutput)
}

// The name of the notification configuration
func (o XmattersNotificationOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *XmattersNotification) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The content of the notification message. You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
func (o XmattersNotificationOutput) Payload() pulumi.StringOutput {
	return o.ApplyT(func(v *XmattersNotification) pulumi.StringOutput { return v.Payload }).(pulumi.StringOutput)
}

// The ID of the associated alerting profile
func (o XmattersNotificationOutput) Profile() pulumi.StringOutput {
	return o.ApplyT(func(v *XmattersNotification) pulumi.StringOutput { return v.Profile }).(pulumi.StringOutput)
}

// The URL of the WebHook endpoint
func (o XmattersNotificationOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v *XmattersNotification) pulumi.StringOutput { return v.Url }).(pulumi.StringOutput)
}

type XmattersNotificationArrayOutput struct{ *pulumi.OutputState }

func (XmattersNotificationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*XmattersNotification)(nil)).Elem()
}

func (o XmattersNotificationArrayOutput) ToXmattersNotificationArrayOutput() XmattersNotificationArrayOutput {
	return o
}

func (o XmattersNotificationArrayOutput) ToXmattersNotificationArrayOutputWithContext(ctx context.Context) XmattersNotificationArrayOutput {
	return o
}

func (o XmattersNotificationArrayOutput) Index(i pulumi.IntInput) XmattersNotificationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *XmattersNotification {
		return vs[0].([]*XmattersNotification)[vs[1].(int)]
	}).(XmattersNotificationOutput)
}

type XmattersNotificationMapOutput struct{ *pulumi.OutputState }

func (XmattersNotificationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*XmattersNotification)(nil)).Elem()
}

func (o XmattersNotificationMapOutput) ToXmattersNotificationMapOutput() XmattersNotificationMapOutput {
	return o
}

func (o XmattersNotificationMapOutput) ToXmattersNotificationMapOutputWithContext(ctx context.Context) XmattersNotificationMapOutput {
	return o
}

func (o XmattersNotificationMapOutput) MapIndex(k pulumi.StringInput) XmattersNotificationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *XmattersNotification {
		return vs[0].(map[string]*XmattersNotification)[vs[1].(string)]
	}).(XmattersNotificationOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*XmattersNotificationInput)(nil)).Elem(), &XmattersNotification{})
	pulumi.RegisterInputType(reflect.TypeOf((*XmattersNotificationArrayInput)(nil)).Elem(), XmattersNotificationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XmattersNotificationMapInput)(nil)).Elem(), XmattersNotificationMap{})
	pulumi.RegisterOutputType(XmattersNotificationOutput{})
	pulumi.RegisterOutputType(XmattersNotificationArrayOutput{})
	pulumi.RegisterOutputType(XmattersNotificationMapOutput{})
}
