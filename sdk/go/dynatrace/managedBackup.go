// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type ManagedBackup struct {
	pulumi.CustomResourceState

	// Cassandra backup bandwidth limit in Mbps
	BandwidthLimitMbits pulumi.IntPtrOutput `pulumi:"bandwidthLimitMbits"`
	// Hour to start Cassandra backups each day.
	CassandraScheduledTime pulumi.IntOutput `pulumi:"cassandraScheduledTime"`
	// For internal use: current state of rules in JSON format
	CurrentState pulumi.StringOutput `pulumi:"currentState"`
	// Datacenter which will create backups
	Datacenter pulumi.StringPtrOutput `pulumi:"datacenter"`
	// Backups are enabled (true) or disabled (false).
	Enabled pulumi.BoolPtrOutput `pulumi:"enabled"`
	// Include (true) or exclude (false) Log Monitoring v2 data
	IncludeLm20Data pulumi.BoolPtrOutput `pulumi:"includeLm20Data"`
	// Include user sessions (true) or GDPR compliance (false)
	IncludeRumData pulumi.BoolPtrOutput `pulumi:"includeRumData"`
	// Include time series metric-data (true) or retain configuration data only (false))
	IncludeTsMetricData pulumi.BoolPtrOutput `pulumi:"includeTsMetricData"`
	// Max number of Elasticsearch snapshots to clean. Elasticsearch snapshots won't be created anymore if there will be more backups to clean than this value.
	MaxEsSnapshotsToClean pulumi.IntPtrOutput `pulumi:"maxEsSnapshotsToClean"`
	// Pauses Elasticsearch and Cassandra backups. In comparison to enable/disable backup, this option does not modify any configuration like Elasticsearch properties.
	PauseBackups pulumi.BoolPtrOutput `pulumi:"pauseBackups"`
	// A full path to the backup archive
	StoragePath pulumi.StringPtrOutput `pulumi:"storagePath"`
}

// NewManagedBackup registers a new resource with the given unique name, arguments, and options.
func NewManagedBackup(ctx *pulumi.Context,
	name string, args *ManagedBackupArgs, opts ...pulumi.ResourceOption) (*ManagedBackup, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CassandraScheduledTime == nil {
		return nil, errors.New("invalid value for required argument 'CassandraScheduledTime'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ManagedBackup
	err := ctx.RegisterResource("dynatrace:index/managedBackup:ManagedBackup", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetManagedBackup gets an existing ManagedBackup resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetManagedBackup(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ManagedBackupState, opts ...pulumi.ResourceOption) (*ManagedBackup, error) {
	var resource ManagedBackup
	err := ctx.ReadResource("dynatrace:index/managedBackup:ManagedBackup", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ManagedBackup resources.
type managedBackupState struct {
	// Cassandra backup bandwidth limit in Mbps
	BandwidthLimitMbits *int `pulumi:"bandwidthLimitMbits"`
	// Hour to start Cassandra backups each day.
	CassandraScheduledTime *int `pulumi:"cassandraScheduledTime"`
	// For internal use: current state of rules in JSON format
	CurrentState *string `pulumi:"currentState"`
	// Datacenter which will create backups
	Datacenter *string `pulumi:"datacenter"`
	// Backups are enabled (true) or disabled (false).
	Enabled *bool `pulumi:"enabled"`
	// Include (true) or exclude (false) Log Monitoring v2 data
	IncludeLm20Data *bool `pulumi:"includeLm20Data"`
	// Include user sessions (true) or GDPR compliance (false)
	IncludeRumData *bool `pulumi:"includeRumData"`
	// Include time series metric-data (true) or retain configuration data only (false))
	IncludeTsMetricData *bool `pulumi:"includeTsMetricData"`
	// Max number of Elasticsearch snapshots to clean. Elasticsearch snapshots won't be created anymore if there will be more backups to clean than this value.
	MaxEsSnapshotsToClean *int `pulumi:"maxEsSnapshotsToClean"`
	// Pauses Elasticsearch and Cassandra backups. In comparison to enable/disable backup, this option does not modify any configuration like Elasticsearch properties.
	PauseBackups *bool `pulumi:"pauseBackups"`
	// A full path to the backup archive
	StoragePath *string `pulumi:"storagePath"`
}

type ManagedBackupState struct {
	// Cassandra backup bandwidth limit in Mbps
	BandwidthLimitMbits pulumi.IntPtrInput
	// Hour to start Cassandra backups each day.
	CassandraScheduledTime pulumi.IntPtrInput
	// For internal use: current state of rules in JSON format
	CurrentState pulumi.StringPtrInput
	// Datacenter which will create backups
	Datacenter pulumi.StringPtrInput
	// Backups are enabled (true) or disabled (false).
	Enabled pulumi.BoolPtrInput
	// Include (true) or exclude (false) Log Monitoring v2 data
	IncludeLm20Data pulumi.BoolPtrInput
	// Include user sessions (true) or GDPR compliance (false)
	IncludeRumData pulumi.BoolPtrInput
	// Include time series metric-data (true) or retain configuration data only (false))
	IncludeTsMetricData pulumi.BoolPtrInput
	// Max number of Elasticsearch snapshots to clean. Elasticsearch snapshots won't be created anymore if there will be more backups to clean than this value.
	MaxEsSnapshotsToClean pulumi.IntPtrInput
	// Pauses Elasticsearch and Cassandra backups. In comparison to enable/disable backup, this option does not modify any configuration like Elasticsearch properties.
	PauseBackups pulumi.BoolPtrInput
	// A full path to the backup archive
	StoragePath pulumi.StringPtrInput
}

func (ManagedBackupState) ElementType() reflect.Type {
	return reflect.TypeOf((*managedBackupState)(nil)).Elem()
}

type managedBackupArgs struct {
	// Cassandra backup bandwidth limit in Mbps
	BandwidthLimitMbits *int `pulumi:"bandwidthLimitMbits"`
	// Hour to start Cassandra backups each day.
	CassandraScheduledTime int `pulumi:"cassandraScheduledTime"`
	// For internal use: current state of rules in JSON format
	CurrentState *string `pulumi:"currentState"`
	// Datacenter which will create backups
	Datacenter *string `pulumi:"datacenter"`
	// Backups are enabled (true) or disabled (false).
	Enabled *bool `pulumi:"enabled"`
	// Include (true) or exclude (false) Log Monitoring v2 data
	IncludeLm20Data *bool `pulumi:"includeLm20Data"`
	// Include user sessions (true) or GDPR compliance (false)
	IncludeRumData *bool `pulumi:"includeRumData"`
	// Include time series metric-data (true) or retain configuration data only (false))
	IncludeTsMetricData *bool `pulumi:"includeTsMetricData"`
	// Max number of Elasticsearch snapshots to clean. Elasticsearch snapshots won't be created anymore if there will be more backups to clean than this value.
	MaxEsSnapshotsToClean *int `pulumi:"maxEsSnapshotsToClean"`
	// Pauses Elasticsearch and Cassandra backups. In comparison to enable/disable backup, this option does not modify any configuration like Elasticsearch properties.
	PauseBackups *bool `pulumi:"pauseBackups"`
	// A full path to the backup archive
	StoragePath *string `pulumi:"storagePath"`
}

// The set of arguments for constructing a ManagedBackup resource.
type ManagedBackupArgs struct {
	// Cassandra backup bandwidth limit in Mbps
	BandwidthLimitMbits pulumi.IntPtrInput
	// Hour to start Cassandra backups each day.
	CassandraScheduledTime pulumi.IntInput
	// For internal use: current state of rules in JSON format
	CurrentState pulumi.StringPtrInput
	// Datacenter which will create backups
	Datacenter pulumi.StringPtrInput
	// Backups are enabled (true) or disabled (false).
	Enabled pulumi.BoolPtrInput
	// Include (true) or exclude (false) Log Monitoring v2 data
	IncludeLm20Data pulumi.BoolPtrInput
	// Include user sessions (true) or GDPR compliance (false)
	IncludeRumData pulumi.BoolPtrInput
	// Include time series metric-data (true) or retain configuration data only (false))
	IncludeTsMetricData pulumi.BoolPtrInput
	// Max number of Elasticsearch snapshots to clean. Elasticsearch snapshots won't be created anymore if there will be more backups to clean than this value.
	MaxEsSnapshotsToClean pulumi.IntPtrInput
	// Pauses Elasticsearch and Cassandra backups. In comparison to enable/disable backup, this option does not modify any configuration like Elasticsearch properties.
	PauseBackups pulumi.BoolPtrInput
	// A full path to the backup archive
	StoragePath pulumi.StringPtrInput
}

func (ManagedBackupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*managedBackupArgs)(nil)).Elem()
}

type ManagedBackupInput interface {
	pulumi.Input

	ToManagedBackupOutput() ManagedBackupOutput
	ToManagedBackupOutputWithContext(ctx context.Context) ManagedBackupOutput
}

func (*ManagedBackup) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedBackup)(nil)).Elem()
}

func (i *ManagedBackup) ToManagedBackupOutput() ManagedBackupOutput {
	return i.ToManagedBackupOutputWithContext(context.Background())
}

func (i *ManagedBackup) ToManagedBackupOutputWithContext(ctx context.Context) ManagedBackupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedBackupOutput)
}

// ManagedBackupArrayInput is an input type that accepts ManagedBackupArray and ManagedBackupArrayOutput values.
// You can construct a concrete instance of `ManagedBackupArrayInput` via:
//
//	ManagedBackupArray{ ManagedBackupArgs{...} }
type ManagedBackupArrayInput interface {
	pulumi.Input

	ToManagedBackupArrayOutput() ManagedBackupArrayOutput
	ToManagedBackupArrayOutputWithContext(context.Context) ManagedBackupArrayOutput
}

type ManagedBackupArray []ManagedBackupInput

func (ManagedBackupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ManagedBackup)(nil)).Elem()
}

func (i ManagedBackupArray) ToManagedBackupArrayOutput() ManagedBackupArrayOutput {
	return i.ToManagedBackupArrayOutputWithContext(context.Background())
}

func (i ManagedBackupArray) ToManagedBackupArrayOutputWithContext(ctx context.Context) ManagedBackupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedBackupArrayOutput)
}

// ManagedBackupMapInput is an input type that accepts ManagedBackupMap and ManagedBackupMapOutput values.
// You can construct a concrete instance of `ManagedBackupMapInput` via:
//
//	ManagedBackupMap{ "key": ManagedBackupArgs{...} }
type ManagedBackupMapInput interface {
	pulumi.Input

	ToManagedBackupMapOutput() ManagedBackupMapOutput
	ToManagedBackupMapOutputWithContext(context.Context) ManagedBackupMapOutput
}

type ManagedBackupMap map[string]ManagedBackupInput

func (ManagedBackupMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ManagedBackup)(nil)).Elem()
}

func (i ManagedBackupMap) ToManagedBackupMapOutput() ManagedBackupMapOutput {
	return i.ToManagedBackupMapOutputWithContext(context.Background())
}

func (i ManagedBackupMap) ToManagedBackupMapOutputWithContext(ctx context.Context) ManagedBackupMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedBackupMapOutput)
}

type ManagedBackupOutput struct{ *pulumi.OutputState }

func (ManagedBackupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedBackup)(nil)).Elem()
}

func (o ManagedBackupOutput) ToManagedBackupOutput() ManagedBackupOutput {
	return o
}

func (o ManagedBackupOutput) ToManagedBackupOutputWithContext(ctx context.Context) ManagedBackupOutput {
	return o
}

// Cassandra backup bandwidth limit in Mbps
func (o ManagedBackupOutput) BandwidthLimitMbits() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ManagedBackup) pulumi.IntPtrOutput { return v.BandwidthLimitMbits }).(pulumi.IntPtrOutput)
}

// Hour to start Cassandra backups each day.
func (o ManagedBackupOutput) CassandraScheduledTime() pulumi.IntOutput {
	return o.ApplyT(func(v *ManagedBackup) pulumi.IntOutput { return v.CassandraScheduledTime }).(pulumi.IntOutput)
}

// For internal use: current state of rules in JSON format
func (o ManagedBackupOutput) CurrentState() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedBackup) pulumi.StringOutput { return v.CurrentState }).(pulumi.StringOutput)
}

// Datacenter which will create backups
func (o ManagedBackupOutput) Datacenter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedBackup) pulumi.StringPtrOutput { return v.Datacenter }).(pulumi.StringPtrOutput)
}

// Backups are enabled (true) or disabled (false).
func (o ManagedBackupOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ManagedBackup) pulumi.BoolPtrOutput { return v.Enabled }).(pulumi.BoolPtrOutput)
}

// Include (true) or exclude (false) Log Monitoring v2 data
func (o ManagedBackupOutput) IncludeLm20Data() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ManagedBackup) pulumi.BoolPtrOutput { return v.IncludeLm20Data }).(pulumi.BoolPtrOutput)
}

// Include user sessions (true) or GDPR compliance (false)
func (o ManagedBackupOutput) IncludeRumData() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ManagedBackup) pulumi.BoolPtrOutput { return v.IncludeRumData }).(pulumi.BoolPtrOutput)
}

// Include time series metric-data (true) or retain configuration data only (false))
func (o ManagedBackupOutput) IncludeTsMetricData() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ManagedBackup) pulumi.BoolPtrOutput { return v.IncludeTsMetricData }).(pulumi.BoolPtrOutput)
}

// Max number of Elasticsearch snapshots to clean. Elasticsearch snapshots won't be created anymore if there will be more backups to clean than this value.
func (o ManagedBackupOutput) MaxEsSnapshotsToClean() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ManagedBackup) pulumi.IntPtrOutput { return v.MaxEsSnapshotsToClean }).(pulumi.IntPtrOutput)
}

// Pauses Elasticsearch and Cassandra backups. In comparison to enable/disable backup, this option does not modify any configuration like Elasticsearch properties.
func (o ManagedBackupOutput) PauseBackups() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ManagedBackup) pulumi.BoolPtrOutput { return v.PauseBackups }).(pulumi.BoolPtrOutput)
}

// A full path to the backup archive
func (o ManagedBackupOutput) StoragePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedBackup) pulumi.StringPtrOutput { return v.StoragePath }).(pulumi.StringPtrOutput)
}

type ManagedBackupArrayOutput struct{ *pulumi.OutputState }

func (ManagedBackupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ManagedBackup)(nil)).Elem()
}

func (o ManagedBackupArrayOutput) ToManagedBackupArrayOutput() ManagedBackupArrayOutput {
	return o
}

func (o ManagedBackupArrayOutput) ToManagedBackupArrayOutputWithContext(ctx context.Context) ManagedBackupArrayOutput {
	return o
}

func (o ManagedBackupArrayOutput) Index(i pulumi.IntInput) ManagedBackupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ManagedBackup {
		return vs[0].([]*ManagedBackup)[vs[1].(int)]
	}).(ManagedBackupOutput)
}

type ManagedBackupMapOutput struct{ *pulumi.OutputState }

func (ManagedBackupMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ManagedBackup)(nil)).Elem()
}

func (o ManagedBackupMapOutput) ToManagedBackupMapOutput() ManagedBackupMapOutput {
	return o
}

func (o ManagedBackupMapOutput) ToManagedBackupMapOutputWithContext(ctx context.Context) ManagedBackupMapOutput {
	return o
}

func (o ManagedBackupMapOutput) MapIndex(k pulumi.StringInput) ManagedBackupOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ManagedBackup {
		return vs[0].(map[string]*ManagedBackup)[vs[1].(string)]
	}).(ManagedBackupOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedBackupInput)(nil)).Elem(), &ManagedBackup{})
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedBackupArrayInput)(nil)).Elem(), ManagedBackupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedBackupMapInput)(nil)).Elem(), ManagedBackupMap{})
	pulumi.RegisterOutputType(ManagedBackupOutput{})
	pulumi.RegisterOutputType(ManagedBackupArrayOutput{})
	pulumi.RegisterOutputType(ManagedBackupMapOutput{})
}
