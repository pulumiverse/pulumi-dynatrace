// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

// > This resource requires the API token scopes **Read settings** (`settings.read`) and **Write settings** (`settings.write`)
//
// ## Dynatrace Documentation
//
// - Services - https://docs.dynatrace.com/docs/observe/applications-and-microservices/services
//
// - Settings API - https://www.dynatrace.com/support/help/dynatrace-api/environment-api/settings (schemaId: `builtin:service-splitting-rules`)
//
// ## Resource Example Usage
type ServiceSplitting struct {
	pulumi.CustomResourceState

	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringOutput `pulumi:"insertAfter"`
	// Rule
	Rule ServiceSplittingRuleOutput `pulumi:"rule"`
	// The scope of this setting (CLOUD*APPLICATION*NAMESPACE, KUBERNETES*CLUSTER, HOST*GROUP). Omit this property if you want to cover the whole environment.
	Scope pulumi.StringPtrOutput `pulumi:"scope"`
}

// NewServiceSplitting registers a new resource with the given unique name, arguments, and options.
func NewServiceSplitting(ctx *pulumi.Context,
	name string, args *ServiceSplittingArgs, opts ...pulumi.ResourceOption) (*ServiceSplitting, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.Rule == nil {
		return nil, errors.New("invalid value for required argument 'Rule'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ServiceSplitting
	err := ctx.RegisterResource("dynatrace:index/serviceSplitting:ServiceSplitting", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetServiceSplitting gets an existing ServiceSplitting resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetServiceSplitting(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ServiceSplittingState, opts ...pulumi.ResourceOption) (*ServiceSplitting, error) {
	var resource ServiceSplitting
	err := ctx.ReadResource("dynatrace:index/serviceSplitting:ServiceSplitting", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ServiceSplitting resources.
type serviceSplittingState struct {
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Rule
	Rule *ServiceSplittingRule `pulumi:"rule"`
	// The scope of this setting (CLOUD*APPLICATION*NAMESPACE, KUBERNETES*CLUSTER, HOST*GROUP). Omit this property if you want to cover the whole environment.
	Scope *string `pulumi:"scope"`
}

type ServiceSplittingState struct {
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolPtrInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Rule
	Rule ServiceSplittingRulePtrInput
	// The scope of this setting (CLOUD*APPLICATION*NAMESPACE, KUBERNETES*CLUSTER, HOST*GROUP). Omit this property if you want to cover the whole environment.
	Scope pulumi.StringPtrInput
}

func (ServiceSplittingState) ElementType() reflect.Type {
	return reflect.TypeOf((*serviceSplittingState)(nil)).Elem()
}

type serviceSplittingArgs struct {
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled bool `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Rule
	Rule ServiceSplittingRule `pulumi:"rule"`
	// The scope of this setting (CLOUD*APPLICATION*NAMESPACE, KUBERNETES*CLUSTER, HOST*GROUP). Omit this property if you want to cover the whole environment.
	Scope *string `pulumi:"scope"`
}

// The set of arguments for constructing a ServiceSplitting resource.
type ServiceSplittingArgs struct {
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Rule
	Rule ServiceSplittingRuleInput
	// The scope of this setting (CLOUD*APPLICATION*NAMESPACE, KUBERNETES*CLUSTER, HOST*GROUP). Omit this property if you want to cover the whole environment.
	Scope pulumi.StringPtrInput
}

func (ServiceSplittingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*serviceSplittingArgs)(nil)).Elem()
}

type ServiceSplittingInput interface {
	pulumi.Input

	ToServiceSplittingOutput() ServiceSplittingOutput
	ToServiceSplittingOutputWithContext(ctx context.Context) ServiceSplittingOutput
}

func (*ServiceSplitting) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceSplitting)(nil)).Elem()
}

func (i *ServiceSplitting) ToServiceSplittingOutput() ServiceSplittingOutput {
	return i.ToServiceSplittingOutputWithContext(context.Background())
}

func (i *ServiceSplitting) ToServiceSplittingOutputWithContext(ctx context.Context) ServiceSplittingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceSplittingOutput)
}

// ServiceSplittingArrayInput is an input type that accepts ServiceSplittingArray and ServiceSplittingArrayOutput values.
// You can construct a concrete instance of `ServiceSplittingArrayInput` via:
//
//	ServiceSplittingArray{ ServiceSplittingArgs{...} }
type ServiceSplittingArrayInput interface {
	pulumi.Input

	ToServiceSplittingArrayOutput() ServiceSplittingArrayOutput
	ToServiceSplittingArrayOutputWithContext(context.Context) ServiceSplittingArrayOutput
}

type ServiceSplittingArray []ServiceSplittingInput

func (ServiceSplittingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ServiceSplitting)(nil)).Elem()
}

func (i ServiceSplittingArray) ToServiceSplittingArrayOutput() ServiceSplittingArrayOutput {
	return i.ToServiceSplittingArrayOutputWithContext(context.Background())
}

func (i ServiceSplittingArray) ToServiceSplittingArrayOutputWithContext(ctx context.Context) ServiceSplittingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceSplittingArrayOutput)
}

// ServiceSplittingMapInput is an input type that accepts ServiceSplittingMap and ServiceSplittingMapOutput values.
// You can construct a concrete instance of `ServiceSplittingMapInput` via:
//
//	ServiceSplittingMap{ "key": ServiceSplittingArgs{...} }
type ServiceSplittingMapInput interface {
	pulumi.Input

	ToServiceSplittingMapOutput() ServiceSplittingMapOutput
	ToServiceSplittingMapOutputWithContext(context.Context) ServiceSplittingMapOutput
}

type ServiceSplittingMap map[string]ServiceSplittingInput

func (ServiceSplittingMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ServiceSplitting)(nil)).Elem()
}

func (i ServiceSplittingMap) ToServiceSplittingMapOutput() ServiceSplittingMapOutput {
	return i.ToServiceSplittingMapOutputWithContext(context.Background())
}

func (i ServiceSplittingMap) ToServiceSplittingMapOutputWithContext(ctx context.Context) ServiceSplittingMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceSplittingMapOutput)
}

type ServiceSplittingOutput struct{ *pulumi.OutputState }

func (ServiceSplittingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceSplitting)(nil)).Elem()
}

func (o ServiceSplittingOutput) ToServiceSplittingOutput() ServiceSplittingOutput {
	return o
}

func (o ServiceSplittingOutput) ToServiceSplittingOutputWithContext(ctx context.Context) ServiceSplittingOutput {
	return o
}

// This setting is enabled (`true`) or disabled (`false`)
func (o ServiceSplittingOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *ServiceSplitting) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
func (o ServiceSplittingOutput) InsertAfter() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceSplitting) pulumi.StringOutput { return v.InsertAfter }).(pulumi.StringOutput)
}

// Rule
func (o ServiceSplittingOutput) Rule() ServiceSplittingRuleOutput {
	return o.ApplyT(func(v *ServiceSplitting) ServiceSplittingRuleOutput { return v.Rule }).(ServiceSplittingRuleOutput)
}

// The scope of this setting (CLOUD*APPLICATION*NAMESPACE, KUBERNETES*CLUSTER, HOST*GROUP). Omit this property if you want to cover the whole environment.
func (o ServiceSplittingOutput) Scope() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServiceSplitting) pulumi.StringPtrOutput { return v.Scope }).(pulumi.StringPtrOutput)
}

type ServiceSplittingArrayOutput struct{ *pulumi.OutputState }

func (ServiceSplittingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ServiceSplitting)(nil)).Elem()
}

func (o ServiceSplittingArrayOutput) ToServiceSplittingArrayOutput() ServiceSplittingArrayOutput {
	return o
}

func (o ServiceSplittingArrayOutput) ToServiceSplittingArrayOutputWithContext(ctx context.Context) ServiceSplittingArrayOutput {
	return o
}

func (o ServiceSplittingArrayOutput) Index(i pulumi.IntInput) ServiceSplittingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ServiceSplitting {
		return vs[0].([]*ServiceSplitting)[vs[1].(int)]
	}).(ServiceSplittingOutput)
}

type ServiceSplittingMapOutput struct{ *pulumi.OutputState }

func (ServiceSplittingMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ServiceSplitting)(nil)).Elem()
}

func (o ServiceSplittingMapOutput) ToServiceSplittingMapOutput() ServiceSplittingMapOutput {
	return o
}

func (o ServiceSplittingMapOutput) ToServiceSplittingMapOutputWithContext(ctx context.Context) ServiceSplittingMapOutput {
	return o
}

func (o ServiceSplittingMapOutput) MapIndex(k pulumi.StringInput) ServiceSplittingOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ServiceSplitting {
		return vs[0].(map[string]*ServiceSplitting)[vs[1].(string)]
	}).(ServiceSplittingOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceSplittingInput)(nil)).Elem(), &ServiceSplitting{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceSplittingArrayInput)(nil)).Elem(), ServiceSplittingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceSplittingMapInput)(nil)).Elem(), ServiceSplittingMap{})
	pulumi.RegisterOutputType(ServiceSplittingOutput{})
	pulumi.RegisterOutputType(ServiceSplittingArrayOutput{})
	pulumi.RegisterOutputType(ServiceSplittingMapOutput{})
}
