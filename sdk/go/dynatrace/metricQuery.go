// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type MetricQuery struct {
	pulumi.CustomResourceState

	// The scope of this setting (metric)
	MetricId pulumi.StringOutput `pulumi:"metricId"`
	// Query
	MetricSelector pulumi.StringOutput `pulumi:"metricSelector"`
}

// NewMetricQuery registers a new resource with the given unique name, arguments, and options.
func NewMetricQuery(ctx *pulumi.Context,
	name string, args *MetricQueryArgs, opts ...pulumi.ResourceOption) (*MetricQuery, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.MetricId == nil {
		return nil, errors.New("invalid value for required argument 'MetricId'")
	}
	if args.MetricSelector == nil {
		return nil, errors.New("invalid value for required argument 'MetricSelector'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource MetricQuery
	err := ctx.RegisterResource("dynatrace:index/metricQuery:MetricQuery", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMetricQuery gets an existing MetricQuery resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMetricQuery(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MetricQueryState, opts ...pulumi.ResourceOption) (*MetricQuery, error) {
	var resource MetricQuery
	err := ctx.ReadResource("dynatrace:index/metricQuery:MetricQuery", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MetricQuery resources.
type metricQueryState struct {
	// The scope of this setting (metric)
	MetricId *string `pulumi:"metricId"`
	// Query
	MetricSelector *string `pulumi:"metricSelector"`
}

type MetricQueryState struct {
	// The scope of this setting (metric)
	MetricId pulumi.StringPtrInput
	// Query
	MetricSelector pulumi.StringPtrInput
}

func (MetricQueryState) ElementType() reflect.Type {
	return reflect.TypeOf((*metricQueryState)(nil)).Elem()
}

type metricQueryArgs struct {
	// The scope of this setting (metric)
	MetricId string `pulumi:"metricId"`
	// Query
	MetricSelector string `pulumi:"metricSelector"`
}

// The set of arguments for constructing a MetricQuery resource.
type MetricQueryArgs struct {
	// The scope of this setting (metric)
	MetricId pulumi.StringInput
	// Query
	MetricSelector pulumi.StringInput
}

func (MetricQueryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*metricQueryArgs)(nil)).Elem()
}

type MetricQueryInput interface {
	pulumi.Input

	ToMetricQueryOutput() MetricQueryOutput
	ToMetricQueryOutputWithContext(ctx context.Context) MetricQueryOutput
}

func (*MetricQuery) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricQuery)(nil)).Elem()
}

func (i *MetricQuery) ToMetricQueryOutput() MetricQueryOutput {
	return i.ToMetricQueryOutputWithContext(context.Background())
}

func (i *MetricQuery) ToMetricQueryOutputWithContext(ctx context.Context) MetricQueryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricQueryOutput)
}

// MetricQueryArrayInput is an input type that accepts MetricQueryArray and MetricQueryArrayOutput values.
// You can construct a concrete instance of `MetricQueryArrayInput` via:
//
//	MetricQueryArray{ MetricQueryArgs{...} }
type MetricQueryArrayInput interface {
	pulumi.Input

	ToMetricQueryArrayOutput() MetricQueryArrayOutput
	ToMetricQueryArrayOutputWithContext(context.Context) MetricQueryArrayOutput
}

type MetricQueryArray []MetricQueryInput

func (MetricQueryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MetricQuery)(nil)).Elem()
}

func (i MetricQueryArray) ToMetricQueryArrayOutput() MetricQueryArrayOutput {
	return i.ToMetricQueryArrayOutputWithContext(context.Background())
}

func (i MetricQueryArray) ToMetricQueryArrayOutputWithContext(ctx context.Context) MetricQueryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricQueryArrayOutput)
}

// MetricQueryMapInput is an input type that accepts MetricQueryMap and MetricQueryMapOutput values.
// You can construct a concrete instance of `MetricQueryMapInput` via:
//
//	MetricQueryMap{ "key": MetricQueryArgs{...} }
type MetricQueryMapInput interface {
	pulumi.Input

	ToMetricQueryMapOutput() MetricQueryMapOutput
	ToMetricQueryMapOutputWithContext(context.Context) MetricQueryMapOutput
}

type MetricQueryMap map[string]MetricQueryInput

func (MetricQueryMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MetricQuery)(nil)).Elem()
}

func (i MetricQueryMap) ToMetricQueryMapOutput() MetricQueryMapOutput {
	return i.ToMetricQueryMapOutputWithContext(context.Background())
}

func (i MetricQueryMap) ToMetricQueryMapOutputWithContext(ctx context.Context) MetricQueryMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricQueryMapOutput)
}

type MetricQueryOutput struct{ *pulumi.OutputState }

func (MetricQueryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricQuery)(nil)).Elem()
}

func (o MetricQueryOutput) ToMetricQueryOutput() MetricQueryOutput {
	return o
}

func (o MetricQueryOutput) ToMetricQueryOutputWithContext(ctx context.Context) MetricQueryOutput {
	return o
}

// The scope of this setting (metric)
func (o MetricQueryOutput) MetricId() pulumi.StringOutput {
	return o.ApplyT(func(v *MetricQuery) pulumi.StringOutput { return v.MetricId }).(pulumi.StringOutput)
}

// Query
func (o MetricQueryOutput) MetricSelector() pulumi.StringOutput {
	return o.ApplyT(func(v *MetricQuery) pulumi.StringOutput { return v.MetricSelector }).(pulumi.StringOutput)
}

type MetricQueryArrayOutput struct{ *pulumi.OutputState }

func (MetricQueryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MetricQuery)(nil)).Elem()
}

func (o MetricQueryArrayOutput) ToMetricQueryArrayOutput() MetricQueryArrayOutput {
	return o
}

func (o MetricQueryArrayOutput) ToMetricQueryArrayOutputWithContext(ctx context.Context) MetricQueryArrayOutput {
	return o
}

func (o MetricQueryArrayOutput) Index(i pulumi.IntInput) MetricQueryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *MetricQuery {
		return vs[0].([]*MetricQuery)[vs[1].(int)]
	}).(MetricQueryOutput)
}

type MetricQueryMapOutput struct{ *pulumi.OutputState }

func (MetricQueryMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MetricQuery)(nil)).Elem()
}

func (o MetricQueryMapOutput) ToMetricQueryMapOutput() MetricQueryMapOutput {
	return o
}

func (o MetricQueryMapOutput) ToMetricQueryMapOutputWithContext(ctx context.Context) MetricQueryMapOutput {
	return o
}

func (o MetricQueryMapOutput) MapIndex(k pulumi.StringInput) MetricQueryOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *MetricQuery {
		return vs[0].(map[string]*MetricQuery)[vs[1].(string)]
	}).(MetricQueryOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MetricQueryInput)(nil)).Elem(), &MetricQuery{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetricQueryArrayInput)(nil)).Elem(), MetricQueryArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetricQueryMapInput)(nil)).Elem(), MetricQueryMap{})
	pulumi.RegisterOutputType(MetricQueryOutput{})
	pulumi.RegisterOutputType(MetricQueryArrayOutput{})
	pulumi.RegisterOutputType(MetricQueryMapOutput{})
}
