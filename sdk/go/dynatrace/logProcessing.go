// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type LogProcessing struct {
	pulumi.CustomResourceState

	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringOutput `pulumi:"insertAfter"`
	// ## Processor definition
	// Add a rule definition using our syntax. [In our documentation](https://dt-url.net/8k03xm2) you will find instructions and application [examples](https://dt-url.net/m24305t).
	ProcessorDefinition LogProcessingProcessorDefinitionOutput `pulumi:"processorDefinition"`
	// Matcher
	Query pulumi.StringOutput `pulumi:"query"`
	// Rule name
	RuleName pulumi.StringOutput `pulumi:"ruleName"`
	// ## Rule testing
	// ### 1. Paste a log / JSON sample
	RuleTesting LogProcessingRuleTestingOutput `pulumi:"ruleTesting"`
}

// NewLogProcessing registers a new resource with the given unique name, arguments, and options.
func NewLogProcessing(ctx *pulumi.Context,
	name string, args *LogProcessingArgs, opts ...pulumi.ResourceOption) (*LogProcessing, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.ProcessorDefinition == nil {
		return nil, errors.New("invalid value for required argument 'ProcessorDefinition'")
	}
	if args.Query == nil {
		return nil, errors.New("invalid value for required argument 'Query'")
	}
	if args.RuleName == nil {
		return nil, errors.New("invalid value for required argument 'RuleName'")
	}
	if args.RuleTesting == nil {
		return nil, errors.New("invalid value for required argument 'RuleTesting'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource LogProcessing
	err := ctx.RegisterResource("dynatrace:index/logProcessing:LogProcessing", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLogProcessing gets an existing LogProcessing resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLogProcessing(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LogProcessingState, opts ...pulumi.ResourceOption) (*LogProcessing, error) {
	var resource LogProcessing
	err := ctx.ReadResource("dynatrace:index/logProcessing:LogProcessing", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LogProcessing resources.
type logProcessingState struct {
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// ## Processor definition
	// Add a rule definition using our syntax. [In our documentation](https://dt-url.net/8k03xm2) you will find instructions and application [examples](https://dt-url.net/m24305t).
	ProcessorDefinition *LogProcessingProcessorDefinition `pulumi:"processorDefinition"`
	// Matcher
	Query *string `pulumi:"query"`
	// Rule name
	RuleName *string `pulumi:"ruleName"`
	// ## Rule testing
	// ### 1. Paste a log / JSON sample
	RuleTesting *LogProcessingRuleTesting `pulumi:"ruleTesting"`
}

type LogProcessingState struct {
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolPtrInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// ## Processor definition
	// Add a rule definition using our syntax. [In our documentation](https://dt-url.net/8k03xm2) you will find instructions and application [examples](https://dt-url.net/m24305t).
	ProcessorDefinition LogProcessingProcessorDefinitionPtrInput
	// Matcher
	Query pulumi.StringPtrInput
	// Rule name
	RuleName pulumi.StringPtrInput
	// ## Rule testing
	// ### 1. Paste a log / JSON sample
	RuleTesting LogProcessingRuleTestingPtrInput
}

func (LogProcessingState) ElementType() reflect.Type {
	return reflect.TypeOf((*logProcessingState)(nil)).Elem()
}

type logProcessingArgs struct {
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled bool `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// ## Processor definition
	// Add a rule definition using our syntax. [In our documentation](https://dt-url.net/8k03xm2) you will find instructions and application [examples](https://dt-url.net/m24305t).
	ProcessorDefinition LogProcessingProcessorDefinition `pulumi:"processorDefinition"`
	// Matcher
	Query string `pulumi:"query"`
	// Rule name
	RuleName string `pulumi:"ruleName"`
	// ## Rule testing
	// ### 1. Paste a log / JSON sample
	RuleTesting LogProcessingRuleTesting `pulumi:"ruleTesting"`
}

// The set of arguments for constructing a LogProcessing resource.
type LogProcessingArgs struct {
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// ## Processor definition
	// Add a rule definition using our syntax. [In our documentation](https://dt-url.net/8k03xm2) you will find instructions and application [examples](https://dt-url.net/m24305t).
	ProcessorDefinition LogProcessingProcessorDefinitionInput
	// Matcher
	Query pulumi.StringInput
	// Rule name
	RuleName pulumi.StringInput
	// ## Rule testing
	// ### 1. Paste a log / JSON sample
	RuleTesting LogProcessingRuleTestingInput
}

func (LogProcessingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*logProcessingArgs)(nil)).Elem()
}

type LogProcessingInput interface {
	pulumi.Input

	ToLogProcessingOutput() LogProcessingOutput
	ToLogProcessingOutputWithContext(ctx context.Context) LogProcessingOutput
}

func (*LogProcessing) ElementType() reflect.Type {
	return reflect.TypeOf((**LogProcessing)(nil)).Elem()
}

func (i *LogProcessing) ToLogProcessingOutput() LogProcessingOutput {
	return i.ToLogProcessingOutputWithContext(context.Background())
}

func (i *LogProcessing) ToLogProcessingOutputWithContext(ctx context.Context) LogProcessingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogProcessingOutput)
}

// LogProcessingArrayInput is an input type that accepts LogProcessingArray and LogProcessingArrayOutput values.
// You can construct a concrete instance of `LogProcessingArrayInput` via:
//
//	LogProcessingArray{ LogProcessingArgs{...} }
type LogProcessingArrayInput interface {
	pulumi.Input

	ToLogProcessingArrayOutput() LogProcessingArrayOutput
	ToLogProcessingArrayOutputWithContext(context.Context) LogProcessingArrayOutput
}

type LogProcessingArray []LogProcessingInput

func (LogProcessingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LogProcessing)(nil)).Elem()
}

func (i LogProcessingArray) ToLogProcessingArrayOutput() LogProcessingArrayOutput {
	return i.ToLogProcessingArrayOutputWithContext(context.Background())
}

func (i LogProcessingArray) ToLogProcessingArrayOutputWithContext(ctx context.Context) LogProcessingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogProcessingArrayOutput)
}

// LogProcessingMapInput is an input type that accepts LogProcessingMap and LogProcessingMapOutput values.
// You can construct a concrete instance of `LogProcessingMapInput` via:
//
//	LogProcessingMap{ "key": LogProcessingArgs{...} }
type LogProcessingMapInput interface {
	pulumi.Input

	ToLogProcessingMapOutput() LogProcessingMapOutput
	ToLogProcessingMapOutputWithContext(context.Context) LogProcessingMapOutput
}

type LogProcessingMap map[string]LogProcessingInput

func (LogProcessingMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LogProcessing)(nil)).Elem()
}

func (i LogProcessingMap) ToLogProcessingMapOutput() LogProcessingMapOutput {
	return i.ToLogProcessingMapOutputWithContext(context.Background())
}

func (i LogProcessingMap) ToLogProcessingMapOutputWithContext(ctx context.Context) LogProcessingMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogProcessingMapOutput)
}

type LogProcessingOutput struct{ *pulumi.OutputState }

func (LogProcessingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogProcessing)(nil)).Elem()
}

func (o LogProcessingOutput) ToLogProcessingOutput() LogProcessingOutput {
	return o
}

func (o LogProcessingOutput) ToLogProcessingOutputWithContext(ctx context.Context) LogProcessingOutput {
	return o
}

// This setting is enabled (`true`) or disabled (`false`)
func (o LogProcessingOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *LogProcessing) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
func (o LogProcessingOutput) InsertAfter() pulumi.StringOutput {
	return o.ApplyT(func(v *LogProcessing) pulumi.StringOutput { return v.InsertAfter }).(pulumi.StringOutput)
}

// ## Processor definition
// Add a rule definition using our syntax. [In our documentation](https://dt-url.net/8k03xm2) you will find instructions and application [examples](https://dt-url.net/m24305t).
func (o LogProcessingOutput) ProcessorDefinition() LogProcessingProcessorDefinitionOutput {
	return o.ApplyT(func(v *LogProcessing) LogProcessingProcessorDefinitionOutput { return v.ProcessorDefinition }).(LogProcessingProcessorDefinitionOutput)
}

// Matcher
func (o LogProcessingOutput) Query() pulumi.StringOutput {
	return o.ApplyT(func(v *LogProcessing) pulumi.StringOutput { return v.Query }).(pulumi.StringOutput)
}

// Rule name
func (o LogProcessingOutput) RuleName() pulumi.StringOutput {
	return o.ApplyT(func(v *LogProcessing) pulumi.StringOutput { return v.RuleName }).(pulumi.StringOutput)
}

// ## Rule testing
// ### 1. Paste a log / JSON sample
func (o LogProcessingOutput) RuleTesting() LogProcessingRuleTestingOutput {
	return o.ApplyT(func(v *LogProcessing) LogProcessingRuleTestingOutput { return v.RuleTesting }).(LogProcessingRuleTestingOutput)
}

type LogProcessingArrayOutput struct{ *pulumi.OutputState }

func (LogProcessingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LogProcessing)(nil)).Elem()
}

func (o LogProcessingArrayOutput) ToLogProcessingArrayOutput() LogProcessingArrayOutput {
	return o
}

func (o LogProcessingArrayOutput) ToLogProcessingArrayOutputWithContext(ctx context.Context) LogProcessingArrayOutput {
	return o
}

func (o LogProcessingArrayOutput) Index(i pulumi.IntInput) LogProcessingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *LogProcessing {
		return vs[0].([]*LogProcessing)[vs[1].(int)]
	}).(LogProcessingOutput)
}

type LogProcessingMapOutput struct{ *pulumi.OutputState }

func (LogProcessingMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LogProcessing)(nil)).Elem()
}

func (o LogProcessingMapOutput) ToLogProcessingMapOutput() LogProcessingMapOutput {
	return o
}

func (o LogProcessingMapOutput) ToLogProcessingMapOutputWithContext(ctx context.Context) LogProcessingMapOutput {
	return o
}

func (o LogProcessingMapOutput) MapIndex(k pulumi.StringInput) LogProcessingOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *LogProcessing {
		return vs[0].(map[string]*LogProcessing)[vs[1].(string)]
	}).(LogProcessingOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LogProcessingInput)(nil)).Elem(), &LogProcessing{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogProcessingArrayInput)(nil)).Elem(), LogProcessingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogProcessingMapInput)(nil)).Elem(), LogProcessingMap{})
	pulumi.RegisterOutputType(LogProcessingOutput{})
	pulumi.RegisterOutputType(LogProcessingArrayOutput{})
	pulumi.RegisterOutputType(LogProcessingMapOutput{})
}
