// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type PolicyBindings struct {
	pulumi.CustomResourceState

	// The UUID of the cluster. The attribute `policies` must contain ONLY policies defined for that cluster.
	Cluster pulumi.StringPtrOutput `pulumi:"cluster"`
	// The ID of the environment (https://<environmentid>.live.dynatrace.com). The attribute `policies` must contain ONLY
	// policies defined for that environment.
	Environment pulumi.StringPtrOutput `pulumi:"environment"`
	// The name of the policy
	Group pulumi.StringOutput `pulumi:"group"`
	// A list of IDs referring to policies bound to that group. It's not possible to mix policies here that are defined for
	// different scopes (different clusters or environments) than specified via attributes `cluster` or `environment`.
	Policies pulumi.StringArrayOutput `pulumi:"policies"`
}

// NewPolicyBindings registers a new resource with the given unique name, arguments, and options.
func NewPolicyBindings(ctx *pulumi.Context,
	name string, args *PolicyBindingsArgs, opts ...pulumi.ResourceOption) (*PolicyBindings, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Group == nil {
		return nil, errors.New("invalid value for required argument 'Group'")
	}
	if args.Policies == nil {
		return nil, errors.New("invalid value for required argument 'Policies'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource PolicyBindings
	err := ctx.RegisterResource("dynatrace:index/policyBindings:PolicyBindings", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPolicyBindings gets an existing PolicyBindings resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPolicyBindings(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PolicyBindingsState, opts ...pulumi.ResourceOption) (*PolicyBindings, error) {
	var resource PolicyBindings
	err := ctx.ReadResource("dynatrace:index/policyBindings:PolicyBindings", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering PolicyBindings resources.
type policyBindingsState struct {
	// The UUID of the cluster. The attribute `policies` must contain ONLY policies defined for that cluster.
	Cluster *string `pulumi:"cluster"`
	// The ID of the environment (https://<environmentid>.live.dynatrace.com). The attribute `policies` must contain ONLY
	// policies defined for that environment.
	Environment *string `pulumi:"environment"`
	// The name of the policy
	Group *string `pulumi:"group"`
	// A list of IDs referring to policies bound to that group. It's not possible to mix policies here that are defined for
	// different scopes (different clusters or environments) than specified via attributes `cluster` or `environment`.
	Policies []string `pulumi:"policies"`
}

type PolicyBindingsState struct {
	// The UUID of the cluster. The attribute `policies` must contain ONLY policies defined for that cluster.
	Cluster pulumi.StringPtrInput
	// The ID of the environment (https://<environmentid>.live.dynatrace.com). The attribute `policies` must contain ONLY
	// policies defined for that environment.
	Environment pulumi.StringPtrInput
	// The name of the policy
	Group pulumi.StringPtrInput
	// A list of IDs referring to policies bound to that group. It's not possible to mix policies here that are defined for
	// different scopes (different clusters or environments) than specified via attributes `cluster` or `environment`.
	Policies pulumi.StringArrayInput
}

func (PolicyBindingsState) ElementType() reflect.Type {
	return reflect.TypeOf((*policyBindingsState)(nil)).Elem()
}

type policyBindingsArgs struct {
	// The UUID of the cluster. The attribute `policies` must contain ONLY policies defined for that cluster.
	Cluster *string `pulumi:"cluster"`
	// The ID of the environment (https://<environmentid>.live.dynatrace.com). The attribute `policies` must contain ONLY
	// policies defined for that environment.
	Environment *string `pulumi:"environment"`
	// The name of the policy
	Group string `pulumi:"group"`
	// A list of IDs referring to policies bound to that group. It's not possible to mix policies here that are defined for
	// different scopes (different clusters or environments) than specified via attributes `cluster` or `environment`.
	Policies []string `pulumi:"policies"`
}

// The set of arguments for constructing a PolicyBindings resource.
type PolicyBindingsArgs struct {
	// The UUID of the cluster. The attribute `policies` must contain ONLY policies defined for that cluster.
	Cluster pulumi.StringPtrInput
	// The ID of the environment (https://<environmentid>.live.dynatrace.com). The attribute `policies` must contain ONLY
	// policies defined for that environment.
	Environment pulumi.StringPtrInput
	// The name of the policy
	Group pulumi.StringInput
	// A list of IDs referring to policies bound to that group. It's not possible to mix policies here that are defined for
	// different scopes (different clusters or environments) than specified via attributes `cluster` or `environment`.
	Policies pulumi.StringArrayInput
}

func (PolicyBindingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*policyBindingsArgs)(nil)).Elem()
}

type PolicyBindingsInput interface {
	pulumi.Input

	ToPolicyBindingsOutput() PolicyBindingsOutput
	ToPolicyBindingsOutputWithContext(ctx context.Context) PolicyBindingsOutput
}

func (*PolicyBindings) ElementType() reflect.Type {
	return reflect.TypeOf((**PolicyBindings)(nil)).Elem()
}

func (i *PolicyBindings) ToPolicyBindingsOutput() PolicyBindingsOutput {
	return i.ToPolicyBindingsOutputWithContext(context.Background())
}

func (i *PolicyBindings) ToPolicyBindingsOutputWithContext(ctx context.Context) PolicyBindingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyBindingsOutput)
}

// PolicyBindingsArrayInput is an input type that accepts PolicyBindingsArray and PolicyBindingsArrayOutput values.
// You can construct a concrete instance of `PolicyBindingsArrayInput` via:
//
//	PolicyBindingsArray{ PolicyBindingsArgs{...} }
type PolicyBindingsArrayInput interface {
	pulumi.Input

	ToPolicyBindingsArrayOutput() PolicyBindingsArrayOutput
	ToPolicyBindingsArrayOutputWithContext(context.Context) PolicyBindingsArrayOutput
}

type PolicyBindingsArray []PolicyBindingsInput

func (PolicyBindingsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PolicyBindings)(nil)).Elem()
}

func (i PolicyBindingsArray) ToPolicyBindingsArrayOutput() PolicyBindingsArrayOutput {
	return i.ToPolicyBindingsArrayOutputWithContext(context.Background())
}

func (i PolicyBindingsArray) ToPolicyBindingsArrayOutputWithContext(ctx context.Context) PolicyBindingsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyBindingsArrayOutput)
}

// PolicyBindingsMapInput is an input type that accepts PolicyBindingsMap and PolicyBindingsMapOutput values.
// You can construct a concrete instance of `PolicyBindingsMapInput` via:
//
//	PolicyBindingsMap{ "key": PolicyBindingsArgs{...} }
type PolicyBindingsMapInput interface {
	pulumi.Input

	ToPolicyBindingsMapOutput() PolicyBindingsMapOutput
	ToPolicyBindingsMapOutputWithContext(context.Context) PolicyBindingsMapOutput
}

type PolicyBindingsMap map[string]PolicyBindingsInput

func (PolicyBindingsMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PolicyBindings)(nil)).Elem()
}

func (i PolicyBindingsMap) ToPolicyBindingsMapOutput() PolicyBindingsMapOutput {
	return i.ToPolicyBindingsMapOutputWithContext(context.Background())
}

func (i PolicyBindingsMap) ToPolicyBindingsMapOutputWithContext(ctx context.Context) PolicyBindingsMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyBindingsMapOutput)
}

type PolicyBindingsOutput struct{ *pulumi.OutputState }

func (PolicyBindingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PolicyBindings)(nil)).Elem()
}

func (o PolicyBindingsOutput) ToPolicyBindingsOutput() PolicyBindingsOutput {
	return o
}

func (o PolicyBindingsOutput) ToPolicyBindingsOutputWithContext(ctx context.Context) PolicyBindingsOutput {
	return o
}

// The UUID of the cluster. The attribute `policies` must contain ONLY policies defined for that cluster.
func (o PolicyBindingsOutput) Cluster() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PolicyBindings) pulumi.StringPtrOutput { return v.Cluster }).(pulumi.StringPtrOutput)
}

// The ID of the environment (https://<environmentid>.live.dynatrace.com). The attribute `policies` must contain ONLY
// policies defined for that environment.
func (o PolicyBindingsOutput) Environment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PolicyBindings) pulumi.StringPtrOutput { return v.Environment }).(pulumi.StringPtrOutput)
}

// The name of the policy
func (o PolicyBindingsOutput) Group() pulumi.StringOutput {
	return o.ApplyT(func(v *PolicyBindings) pulumi.StringOutput { return v.Group }).(pulumi.StringOutput)
}

// A list of IDs referring to policies bound to that group. It's not possible to mix policies here that are defined for
// different scopes (different clusters or environments) than specified via attributes `cluster` or `environment`.
func (o PolicyBindingsOutput) Policies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *PolicyBindings) pulumi.StringArrayOutput { return v.Policies }).(pulumi.StringArrayOutput)
}

type PolicyBindingsArrayOutput struct{ *pulumi.OutputState }

func (PolicyBindingsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PolicyBindings)(nil)).Elem()
}

func (o PolicyBindingsArrayOutput) ToPolicyBindingsArrayOutput() PolicyBindingsArrayOutput {
	return o
}

func (o PolicyBindingsArrayOutput) ToPolicyBindingsArrayOutputWithContext(ctx context.Context) PolicyBindingsArrayOutput {
	return o
}

func (o PolicyBindingsArrayOutput) Index(i pulumi.IntInput) PolicyBindingsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *PolicyBindings {
		return vs[0].([]*PolicyBindings)[vs[1].(int)]
	}).(PolicyBindingsOutput)
}

type PolicyBindingsMapOutput struct{ *pulumi.OutputState }

func (PolicyBindingsMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PolicyBindings)(nil)).Elem()
}

func (o PolicyBindingsMapOutput) ToPolicyBindingsMapOutput() PolicyBindingsMapOutput {
	return o
}

func (o PolicyBindingsMapOutput) ToPolicyBindingsMapOutputWithContext(ctx context.Context) PolicyBindingsMapOutput {
	return o
}

func (o PolicyBindingsMapOutput) MapIndex(k pulumi.StringInput) PolicyBindingsOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *PolicyBindings {
		return vs[0].(map[string]*PolicyBindings)[vs[1].(string)]
	}).(PolicyBindingsOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyBindingsInput)(nil)).Elem(), &PolicyBindings{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyBindingsArrayInput)(nil)).Elem(), PolicyBindingsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyBindingsMapInput)(nil)).Elem(), PolicyBindingsMap{})
	pulumi.RegisterOutputType(PolicyBindingsOutput{})
	pulumi.RegisterOutputType(PolicyBindingsArrayOutput{})
	pulumi.RegisterOutputType(PolicyBindingsMapOutput{})
}
