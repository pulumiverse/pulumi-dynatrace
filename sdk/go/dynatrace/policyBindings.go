// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type PolicyBindings struct {
	pulumi.CustomResourceState

	// The UUID of the cluster. The attribute `policies` must contain ONLY policies defined for that cluster.
	Cluster pulumi.StringPtrOutput `pulumi:"cluster"`
	// The ID of the environment (https://\n\n.live.dynatrace.com). The attribute `policies` must contain ONLY policies defined for that environment.
	Environment pulumi.StringPtrOutput `pulumi:"environment"`
	// The name of the policy
	Group pulumi.StringOutput `pulumi:"group"`
	// A list of IDs referring to policies bound to that group. It's not possible to mix policies here that are defined for different scopes (different clusters or environments) than specified via attributes `cluster` or `environment`.
	Policies pulumi.StringArrayOutput `pulumi:"policies"`
}

// NewPolicyBindings registers a new resource with the given unique name, arguments, and options.
func NewPolicyBindings(ctx *pulumi.Context,
	name string, args *PolicyBindingsArgs, opts ...pulumi.ResourceOption) (*PolicyBindings, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Group == nil {
		return nil, errors.New("invalid value for required argument 'Group'")
	}
	if args.Policies == nil {
		return nil, errors.New("invalid value for required argument 'Policies'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource PolicyBindings
	err := ctx.RegisterResource("dynatrace:index/policyBindings:PolicyBindings", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPolicyBindings gets an existing PolicyBindings resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPolicyBindings(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PolicyBindingsState, opts ...pulumi.ResourceOption) (*PolicyBindings, error) {
	var resource PolicyBindings
	err := ctx.ReadResource("dynatrace:index/policyBindings:PolicyBindings", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering PolicyBindings resources.
type policyBindingsState struct {
	// The UUID of the cluster. The attribute `policies` must contain ONLY policies defined for that cluster.
	Cluster *string `pulumi:"cluster"`
	// The ID of the environment (https://\n\n.live.dynatrace.com). The attribute `policies` must contain ONLY policies defined for that environment.
	Environment *string `pulumi:"environment"`
	// The name of the policy
	Group *string `pulumi:"group"`
	// A list of IDs referring to policies bound to that group. It's not possible to mix policies here that are defined for different scopes (different clusters or environments) than specified via attributes `cluster` or `environment`.
	Policies []string `pulumi:"policies"`
}

type PolicyBindingsState struct {
	// The UUID of the cluster. The attribute `policies` must contain ONLY policies defined for that cluster.
	Cluster pulumi.StringPtrInput
	// The ID of the environment (https://\n\n.live.dynatrace.com). The attribute `policies` must contain ONLY policies defined for that environment.
	Environment pulumi.StringPtrInput
	// The name of the policy
	Group pulumi.StringPtrInput
	// A list of IDs referring to policies bound to that group. It's not possible to mix policies here that are defined for different scopes (different clusters or environments) than specified via attributes `cluster` or `environment`.
	Policies pulumi.StringArrayInput
}

func (PolicyBindingsState) ElementType() reflect.Type {
	return reflect.TypeOf((*policyBindingsState)(nil)).Elem()
}

type policyBindingsArgs struct {
	// The UUID of the cluster. The attribute `policies` must contain ONLY policies defined for that cluster.
	Cluster *string `pulumi:"cluster"`
	// The ID of the environment (https://\n\n.live.dynatrace.com). The attribute `policies` must contain ONLY policies defined for that environment.
	Environment *string `pulumi:"environment"`
	// The name of the policy
	Group string `pulumi:"group"`
	// A list of IDs referring to policies bound to that group. It's not possible to mix policies here that are defined for different scopes (different clusters or environments) than specified via attributes `cluster` or `environment`.
	Policies []string `pulumi:"policies"`
}

// The set of arguments for constructing a PolicyBindings resource.
type PolicyBindingsArgs struct {
	// The UUID of the cluster. The attribute `policies` must contain ONLY policies defined for that cluster.
	Cluster pulumi.StringPtrInput
	// The ID of the environment (https://\n\n.live.dynatrace.com). The attribute `policies` must contain ONLY policies defined for that environment.
	Environment pulumi.StringPtrInput
	// The name of the policy
	Group pulumi.StringInput
	// A list of IDs referring to policies bound to that group. It's not possible to mix policies here that are defined for different scopes (different clusters or environments) than specified via attributes `cluster` or `environment`.
	Policies pulumi.StringArrayInput
}

func (PolicyBindingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*policyBindingsArgs)(nil)).Elem()
}

type PolicyBindingsInput interface {
	pulumi.Input

	ToPolicyBindingsOutput() PolicyBindingsOutput
	ToPolicyBindingsOutputWithContext(ctx context.Context) PolicyBindingsOutput
}

func (*PolicyBindings) ElementType() reflect.Type {
	return reflect.TypeOf((**PolicyBindings)(nil)).Elem()
}

func (i *PolicyBindings) ToPolicyBindingsOutput() PolicyBindingsOutput {
	return i.ToPolicyBindingsOutputWithContext(context.Background())
}

func (i *PolicyBindings) ToPolicyBindingsOutputWithContext(ctx context.Context) PolicyBindingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyBindingsOutput)
}

// PolicyBindingsArrayInput is an input type that accepts PolicyBindingsArray and PolicyBindingsArrayOutput values.
// You can construct a concrete instance of `PolicyBindingsArrayInput` via:
//
//	PolicyBindingsArray{ PolicyBindingsArgs{...} }
type PolicyBindingsArrayInput interface {
	pulumi.Input

	ToPolicyBindingsArrayOutput() PolicyBindingsArrayOutput
	ToPolicyBindingsArrayOutputWithContext(context.Context) PolicyBindingsArrayOutput
}

type PolicyBindingsArray []PolicyBindingsInput

func (PolicyBindingsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PolicyBindings)(nil)).Elem()
}

func (i PolicyBindingsArray) ToPolicyBindingsArrayOutput() PolicyBindingsArrayOutput {
	return i.ToPolicyBindingsArrayOutputWithContext(context.Background())
}

func (i PolicyBindingsArray) ToPolicyBindingsArrayOutputWithContext(ctx context.Context) PolicyBindingsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyBindingsArrayOutput)
}

// PolicyBindingsMapInput is an input type that accepts PolicyBindingsMap and PolicyBindingsMapOutput values.
// You can construct a concrete instance of `PolicyBindingsMapInput` via:
//
//	PolicyBindingsMap{ "key": PolicyBindingsArgs{...} }
type PolicyBindingsMapInput interface {
	pulumi.Input

	ToPolicyBindingsMapOutput() PolicyBindingsMapOutput
	ToPolicyBindingsMapOutputWithContext(context.Context) PolicyBindingsMapOutput
}

type PolicyBindingsMap map[string]PolicyBindingsInput

func (PolicyBindingsMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PolicyBindings)(nil)).Elem()
}

func (i PolicyBindingsMap) ToPolicyBindingsMapOutput() PolicyBindingsMapOutput {
	return i.ToPolicyBindingsMapOutputWithContext(context.Background())
}

func (i PolicyBindingsMap) ToPolicyBindingsMapOutputWithContext(ctx context.Context) PolicyBindingsMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyBindingsMapOutput)
}

type PolicyBindingsOutput struct{ *pulumi.OutputState }

func (PolicyBindingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PolicyBindings)(nil)).Elem()
}

func (o PolicyBindingsOutput) ToPolicyBindingsOutput() PolicyBindingsOutput {
	return o
}

func (o PolicyBindingsOutput) ToPolicyBindingsOutputWithContext(ctx context.Context) PolicyBindingsOutput {
	return o
}

// The UUID of the cluster. The attribute `policies` must contain ONLY policies defined for that cluster.
func (o PolicyBindingsOutput) Cluster() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PolicyBindings) pulumi.StringPtrOutput { return v.Cluster }).(pulumi.StringPtrOutput)
}

// The ID of the environment (https://\n\n.live.dynatrace.com). The attribute `policies` must contain ONLY policies defined for that environment.
func (o PolicyBindingsOutput) Environment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PolicyBindings) pulumi.StringPtrOutput { return v.Environment }).(pulumi.StringPtrOutput)
}

// The name of the policy
func (o PolicyBindingsOutput) Group() pulumi.StringOutput {
	return o.ApplyT(func(v *PolicyBindings) pulumi.StringOutput { return v.Group }).(pulumi.StringOutput)
}

// A list of IDs referring to policies bound to that group. It's not possible to mix policies here that are defined for different scopes (different clusters or environments) than specified via attributes `cluster` or `environment`.
func (o PolicyBindingsOutput) Policies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *PolicyBindings) pulumi.StringArrayOutput { return v.Policies }).(pulumi.StringArrayOutput)
}

type PolicyBindingsArrayOutput struct{ *pulumi.OutputState }

func (PolicyBindingsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PolicyBindings)(nil)).Elem()
}

func (o PolicyBindingsArrayOutput) ToPolicyBindingsArrayOutput() PolicyBindingsArrayOutput {
	return o
}

func (o PolicyBindingsArrayOutput) ToPolicyBindingsArrayOutputWithContext(ctx context.Context) PolicyBindingsArrayOutput {
	return o
}

func (o PolicyBindingsArrayOutput) Index(i pulumi.IntInput) PolicyBindingsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *PolicyBindings {
		return vs[0].([]*PolicyBindings)[vs[1].(int)]
	}).(PolicyBindingsOutput)
}

type PolicyBindingsMapOutput struct{ *pulumi.OutputState }

func (PolicyBindingsMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PolicyBindings)(nil)).Elem()
}

func (o PolicyBindingsMapOutput) ToPolicyBindingsMapOutput() PolicyBindingsMapOutput {
	return o
}

func (o PolicyBindingsMapOutput) ToPolicyBindingsMapOutputWithContext(ctx context.Context) PolicyBindingsMapOutput {
	return o
}

func (o PolicyBindingsMapOutput) MapIndex(k pulumi.StringInput) PolicyBindingsOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *PolicyBindings {
		return vs[0].(map[string]*PolicyBindings)[vs[1].(string)]
	}).(PolicyBindingsOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyBindingsInput)(nil)).Elem(), &PolicyBindings{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyBindingsArrayInput)(nil)).Elem(), PolicyBindingsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyBindingsMapInput)(nil)).Elem(), PolicyBindingsMap{})
	pulumi.RegisterOutputType(PolicyBindingsOutput{})
	pulumi.RegisterOutputType(PolicyBindingsArrayOutput{})
	pulumi.RegisterOutputType(PolicyBindingsMapOutput{})
}
