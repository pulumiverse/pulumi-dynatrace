// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type SpanCaptureRule struct {
	pulumi.CustomResourceState

	// Whether to create an entry point or not
	Action pulumi.StringOutput `pulumi:"action"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringOutput `pulumi:"insertAfter"`
	// Matching strategies for the Span
	Matches SpanCaptureRuleMatchesOutput `pulumi:"matches"`
	// The name of the rule
	Name pulumi.StringOutput `pulumi:"name"`
}

// NewSpanCaptureRule registers a new resource with the given unique name, arguments, and options.
func NewSpanCaptureRule(ctx *pulumi.Context,
	name string, args *SpanCaptureRuleArgs, opts ...pulumi.ResourceOption) (*SpanCaptureRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Action == nil {
		return nil, errors.New("invalid value for required argument 'Action'")
	}
	if args.Matches == nil {
		return nil, errors.New("invalid value for required argument 'Matches'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SpanCaptureRule
	err := ctx.RegisterResource("dynatrace:index/spanCaptureRule:SpanCaptureRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSpanCaptureRule gets an existing SpanCaptureRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSpanCaptureRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SpanCaptureRuleState, opts ...pulumi.ResourceOption) (*SpanCaptureRule, error) {
	var resource SpanCaptureRule
	err := ctx.ReadResource("dynatrace:index/spanCaptureRule:SpanCaptureRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SpanCaptureRule resources.
type spanCaptureRuleState struct {
	// Whether to create an entry point or not
	Action *string `pulumi:"action"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Matching strategies for the Span
	Matches *SpanCaptureRuleMatches `pulumi:"matches"`
	// The name of the rule
	Name *string `pulumi:"name"`
}

type SpanCaptureRuleState struct {
	// Whether to create an entry point or not
	Action pulumi.StringPtrInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Matching strategies for the Span
	Matches SpanCaptureRuleMatchesPtrInput
	// The name of the rule
	Name pulumi.StringPtrInput
}

func (SpanCaptureRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*spanCaptureRuleState)(nil)).Elem()
}

type spanCaptureRuleArgs struct {
	// Whether to create an entry point or not
	Action string `pulumi:"action"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Matching strategies for the Span
	Matches SpanCaptureRuleMatches `pulumi:"matches"`
	// The name of the rule
	Name *string `pulumi:"name"`
}

// The set of arguments for constructing a SpanCaptureRule resource.
type SpanCaptureRuleArgs struct {
	// Whether to create an entry point or not
	Action pulumi.StringInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Matching strategies for the Span
	Matches SpanCaptureRuleMatchesInput
	// The name of the rule
	Name pulumi.StringPtrInput
}

func (SpanCaptureRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*spanCaptureRuleArgs)(nil)).Elem()
}

type SpanCaptureRuleInput interface {
	pulumi.Input

	ToSpanCaptureRuleOutput() SpanCaptureRuleOutput
	ToSpanCaptureRuleOutputWithContext(ctx context.Context) SpanCaptureRuleOutput
}

func (*SpanCaptureRule) ElementType() reflect.Type {
	return reflect.TypeOf((**SpanCaptureRule)(nil)).Elem()
}

func (i *SpanCaptureRule) ToSpanCaptureRuleOutput() SpanCaptureRuleOutput {
	return i.ToSpanCaptureRuleOutputWithContext(context.Background())
}

func (i *SpanCaptureRule) ToSpanCaptureRuleOutputWithContext(ctx context.Context) SpanCaptureRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SpanCaptureRuleOutput)
}

// SpanCaptureRuleArrayInput is an input type that accepts SpanCaptureRuleArray and SpanCaptureRuleArrayOutput values.
// You can construct a concrete instance of `SpanCaptureRuleArrayInput` via:
//
//	SpanCaptureRuleArray{ SpanCaptureRuleArgs{...} }
type SpanCaptureRuleArrayInput interface {
	pulumi.Input

	ToSpanCaptureRuleArrayOutput() SpanCaptureRuleArrayOutput
	ToSpanCaptureRuleArrayOutputWithContext(context.Context) SpanCaptureRuleArrayOutput
}

type SpanCaptureRuleArray []SpanCaptureRuleInput

func (SpanCaptureRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SpanCaptureRule)(nil)).Elem()
}

func (i SpanCaptureRuleArray) ToSpanCaptureRuleArrayOutput() SpanCaptureRuleArrayOutput {
	return i.ToSpanCaptureRuleArrayOutputWithContext(context.Background())
}

func (i SpanCaptureRuleArray) ToSpanCaptureRuleArrayOutputWithContext(ctx context.Context) SpanCaptureRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SpanCaptureRuleArrayOutput)
}

// SpanCaptureRuleMapInput is an input type that accepts SpanCaptureRuleMap and SpanCaptureRuleMapOutput values.
// You can construct a concrete instance of `SpanCaptureRuleMapInput` via:
//
//	SpanCaptureRuleMap{ "key": SpanCaptureRuleArgs{...} }
type SpanCaptureRuleMapInput interface {
	pulumi.Input

	ToSpanCaptureRuleMapOutput() SpanCaptureRuleMapOutput
	ToSpanCaptureRuleMapOutputWithContext(context.Context) SpanCaptureRuleMapOutput
}

type SpanCaptureRuleMap map[string]SpanCaptureRuleInput

func (SpanCaptureRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SpanCaptureRule)(nil)).Elem()
}

func (i SpanCaptureRuleMap) ToSpanCaptureRuleMapOutput() SpanCaptureRuleMapOutput {
	return i.ToSpanCaptureRuleMapOutputWithContext(context.Background())
}

func (i SpanCaptureRuleMap) ToSpanCaptureRuleMapOutputWithContext(ctx context.Context) SpanCaptureRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SpanCaptureRuleMapOutput)
}

type SpanCaptureRuleOutput struct{ *pulumi.OutputState }

func (SpanCaptureRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SpanCaptureRule)(nil)).Elem()
}

func (o SpanCaptureRuleOutput) ToSpanCaptureRuleOutput() SpanCaptureRuleOutput {
	return o
}

func (o SpanCaptureRuleOutput) ToSpanCaptureRuleOutputWithContext(ctx context.Context) SpanCaptureRuleOutput {
	return o
}

// Whether to create an entry point or not
func (o SpanCaptureRuleOutput) Action() pulumi.StringOutput {
	return o.ApplyT(func(v *SpanCaptureRule) pulumi.StringOutput { return v.Action }).(pulumi.StringOutput)
}

// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
func (o SpanCaptureRuleOutput) InsertAfter() pulumi.StringOutput {
	return o.ApplyT(func(v *SpanCaptureRule) pulumi.StringOutput { return v.InsertAfter }).(pulumi.StringOutput)
}

// Matching strategies for the Span
func (o SpanCaptureRuleOutput) Matches() SpanCaptureRuleMatchesOutput {
	return o.ApplyT(func(v *SpanCaptureRule) SpanCaptureRuleMatchesOutput { return v.Matches }).(SpanCaptureRuleMatchesOutput)
}

// The name of the rule
func (o SpanCaptureRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *SpanCaptureRule) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

type SpanCaptureRuleArrayOutput struct{ *pulumi.OutputState }

func (SpanCaptureRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SpanCaptureRule)(nil)).Elem()
}

func (o SpanCaptureRuleArrayOutput) ToSpanCaptureRuleArrayOutput() SpanCaptureRuleArrayOutput {
	return o
}

func (o SpanCaptureRuleArrayOutput) ToSpanCaptureRuleArrayOutputWithContext(ctx context.Context) SpanCaptureRuleArrayOutput {
	return o
}

func (o SpanCaptureRuleArrayOutput) Index(i pulumi.IntInput) SpanCaptureRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SpanCaptureRule {
		return vs[0].([]*SpanCaptureRule)[vs[1].(int)]
	}).(SpanCaptureRuleOutput)
}

type SpanCaptureRuleMapOutput struct{ *pulumi.OutputState }

func (SpanCaptureRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SpanCaptureRule)(nil)).Elem()
}

func (o SpanCaptureRuleMapOutput) ToSpanCaptureRuleMapOutput() SpanCaptureRuleMapOutput {
	return o
}

func (o SpanCaptureRuleMapOutput) ToSpanCaptureRuleMapOutputWithContext(ctx context.Context) SpanCaptureRuleMapOutput {
	return o
}

func (o SpanCaptureRuleMapOutput) MapIndex(k pulumi.StringInput) SpanCaptureRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SpanCaptureRule {
		return vs[0].(map[string]*SpanCaptureRule)[vs[1].(string)]
	}).(SpanCaptureRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SpanCaptureRuleInput)(nil)).Elem(), &SpanCaptureRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*SpanCaptureRuleArrayInput)(nil)).Elem(), SpanCaptureRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SpanCaptureRuleMapInput)(nil)).Elem(), SpanCaptureRuleMap{})
	pulumi.RegisterOutputType(SpanCaptureRuleOutput{})
	pulumi.RegisterOutputType(SpanCaptureRuleArrayOutput{})
	pulumi.RegisterOutputType(SpanCaptureRuleMapOutput{})
}
