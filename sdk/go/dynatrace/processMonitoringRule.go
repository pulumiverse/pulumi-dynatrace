// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type ProcessMonitoringRule struct {
	pulumi.CustomResourceState

	// Condition
	Condition ProcessMonitoringRuleConditionOutput `pulumi:"condition"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// The scope of this settings. If the settings should cover the whole environment, just don't specify any scope
	HostGroupId pulumi.StringPtrOutput `pulumi:"hostGroupId"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringOutput `pulumi:"insertAfter"`
	// Possible Values: `MONITORING_ON`, `MONITORING_OFF`
	Mode pulumi.StringOutput `pulumi:"mode"`
}

// NewProcessMonitoringRule registers a new resource with the given unique name, arguments, and options.
func NewProcessMonitoringRule(ctx *pulumi.Context,
	name string, args *ProcessMonitoringRuleArgs, opts ...pulumi.ResourceOption) (*ProcessMonitoringRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Condition == nil {
		return nil, errors.New("invalid value for required argument 'Condition'")
	}
	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.Mode == nil {
		return nil, errors.New("invalid value for required argument 'Mode'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ProcessMonitoringRule
	err := ctx.RegisterResource("dynatrace:index/processMonitoringRule:ProcessMonitoringRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetProcessMonitoringRule gets an existing ProcessMonitoringRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetProcessMonitoringRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ProcessMonitoringRuleState, opts ...pulumi.ResourceOption) (*ProcessMonitoringRule, error) {
	var resource ProcessMonitoringRule
	err := ctx.ReadResource("dynatrace:index/processMonitoringRule:ProcessMonitoringRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ProcessMonitoringRule resources.
type processMonitoringRuleState struct {
	// Condition
	Condition *ProcessMonitoringRuleCondition `pulumi:"condition"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `pulumi:"enabled"`
	// The scope of this settings. If the settings should cover the whole environment, just don't specify any scope
	HostGroupId *string `pulumi:"hostGroupId"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Possible Values: `MONITORING_ON`, `MONITORING_OFF`
	Mode *string `pulumi:"mode"`
}

type ProcessMonitoringRuleState struct {
	// Condition
	Condition ProcessMonitoringRuleConditionPtrInput
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolPtrInput
	// The scope of this settings. If the settings should cover the whole environment, just don't specify any scope
	HostGroupId pulumi.StringPtrInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Possible Values: `MONITORING_ON`, `MONITORING_OFF`
	Mode pulumi.StringPtrInput
}

func (ProcessMonitoringRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*processMonitoringRuleState)(nil)).Elem()
}

type processMonitoringRuleArgs struct {
	// Condition
	Condition ProcessMonitoringRuleCondition `pulumi:"condition"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled bool `pulumi:"enabled"`
	// The scope of this settings. If the settings should cover the whole environment, just don't specify any scope
	HostGroupId *string `pulumi:"hostGroupId"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Possible Values: `MONITORING_ON`, `MONITORING_OFF`
	Mode string `pulumi:"mode"`
}

// The set of arguments for constructing a ProcessMonitoringRule resource.
type ProcessMonitoringRuleArgs struct {
	// Condition
	Condition ProcessMonitoringRuleConditionInput
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolInput
	// The scope of this settings. If the settings should cover the whole environment, just don't specify any scope
	HostGroupId pulumi.StringPtrInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Possible Values: `MONITORING_ON`, `MONITORING_OFF`
	Mode pulumi.StringInput
}

func (ProcessMonitoringRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*processMonitoringRuleArgs)(nil)).Elem()
}

type ProcessMonitoringRuleInput interface {
	pulumi.Input

	ToProcessMonitoringRuleOutput() ProcessMonitoringRuleOutput
	ToProcessMonitoringRuleOutputWithContext(ctx context.Context) ProcessMonitoringRuleOutput
}

func (*ProcessMonitoringRule) ElementType() reflect.Type {
	return reflect.TypeOf((**ProcessMonitoringRule)(nil)).Elem()
}

func (i *ProcessMonitoringRule) ToProcessMonitoringRuleOutput() ProcessMonitoringRuleOutput {
	return i.ToProcessMonitoringRuleOutputWithContext(context.Background())
}

func (i *ProcessMonitoringRule) ToProcessMonitoringRuleOutputWithContext(ctx context.Context) ProcessMonitoringRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessMonitoringRuleOutput)
}

// ProcessMonitoringRuleArrayInput is an input type that accepts ProcessMonitoringRuleArray and ProcessMonitoringRuleArrayOutput values.
// You can construct a concrete instance of `ProcessMonitoringRuleArrayInput` via:
//
//	ProcessMonitoringRuleArray{ ProcessMonitoringRuleArgs{...} }
type ProcessMonitoringRuleArrayInput interface {
	pulumi.Input

	ToProcessMonitoringRuleArrayOutput() ProcessMonitoringRuleArrayOutput
	ToProcessMonitoringRuleArrayOutputWithContext(context.Context) ProcessMonitoringRuleArrayOutput
}

type ProcessMonitoringRuleArray []ProcessMonitoringRuleInput

func (ProcessMonitoringRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProcessMonitoringRule)(nil)).Elem()
}

func (i ProcessMonitoringRuleArray) ToProcessMonitoringRuleArrayOutput() ProcessMonitoringRuleArrayOutput {
	return i.ToProcessMonitoringRuleArrayOutputWithContext(context.Background())
}

func (i ProcessMonitoringRuleArray) ToProcessMonitoringRuleArrayOutputWithContext(ctx context.Context) ProcessMonitoringRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessMonitoringRuleArrayOutput)
}

// ProcessMonitoringRuleMapInput is an input type that accepts ProcessMonitoringRuleMap and ProcessMonitoringRuleMapOutput values.
// You can construct a concrete instance of `ProcessMonitoringRuleMapInput` via:
//
//	ProcessMonitoringRuleMap{ "key": ProcessMonitoringRuleArgs{...} }
type ProcessMonitoringRuleMapInput interface {
	pulumi.Input

	ToProcessMonitoringRuleMapOutput() ProcessMonitoringRuleMapOutput
	ToProcessMonitoringRuleMapOutputWithContext(context.Context) ProcessMonitoringRuleMapOutput
}

type ProcessMonitoringRuleMap map[string]ProcessMonitoringRuleInput

func (ProcessMonitoringRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProcessMonitoringRule)(nil)).Elem()
}

func (i ProcessMonitoringRuleMap) ToProcessMonitoringRuleMapOutput() ProcessMonitoringRuleMapOutput {
	return i.ToProcessMonitoringRuleMapOutputWithContext(context.Background())
}

func (i ProcessMonitoringRuleMap) ToProcessMonitoringRuleMapOutputWithContext(ctx context.Context) ProcessMonitoringRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessMonitoringRuleMapOutput)
}

type ProcessMonitoringRuleOutput struct{ *pulumi.OutputState }

func (ProcessMonitoringRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ProcessMonitoringRule)(nil)).Elem()
}

func (o ProcessMonitoringRuleOutput) ToProcessMonitoringRuleOutput() ProcessMonitoringRuleOutput {
	return o
}

func (o ProcessMonitoringRuleOutput) ToProcessMonitoringRuleOutputWithContext(ctx context.Context) ProcessMonitoringRuleOutput {
	return o
}

// Condition
func (o ProcessMonitoringRuleOutput) Condition() ProcessMonitoringRuleConditionOutput {
	return o.ApplyT(func(v *ProcessMonitoringRule) ProcessMonitoringRuleConditionOutput { return v.Condition }).(ProcessMonitoringRuleConditionOutput)
}

// This setting is enabled (`true`) or disabled (`false`)
func (o ProcessMonitoringRuleOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProcessMonitoringRule) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// The scope of this settings. If the settings should cover the whole environment, just don't specify any scope
func (o ProcessMonitoringRuleOutput) HostGroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ProcessMonitoringRule) pulumi.StringPtrOutput { return v.HostGroupId }).(pulumi.StringPtrOutput)
}

// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
func (o ProcessMonitoringRuleOutput) InsertAfter() pulumi.StringOutput {
	return o.ApplyT(func(v *ProcessMonitoringRule) pulumi.StringOutput { return v.InsertAfter }).(pulumi.StringOutput)
}

// Possible Values: `MONITORING_ON`, `MONITORING_OFF`
func (o ProcessMonitoringRuleOutput) Mode() pulumi.StringOutput {
	return o.ApplyT(func(v *ProcessMonitoringRule) pulumi.StringOutput { return v.Mode }).(pulumi.StringOutput)
}

type ProcessMonitoringRuleArrayOutput struct{ *pulumi.OutputState }

func (ProcessMonitoringRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProcessMonitoringRule)(nil)).Elem()
}

func (o ProcessMonitoringRuleArrayOutput) ToProcessMonitoringRuleArrayOutput() ProcessMonitoringRuleArrayOutput {
	return o
}

func (o ProcessMonitoringRuleArrayOutput) ToProcessMonitoringRuleArrayOutputWithContext(ctx context.Context) ProcessMonitoringRuleArrayOutput {
	return o
}

func (o ProcessMonitoringRuleArrayOutput) Index(i pulumi.IntInput) ProcessMonitoringRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ProcessMonitoringRule {
		return vs[0].([]*ProcessMonitoringRule)[vs[1].(int)]
	}).(ProcessMonitoringRuleOutput)
}

type ProcessMonitoringRuleMapOutput struct{ *pulumi.OutputState }

func (ProcessMonitoringRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProcessMonitoringRule)(nil)).Elem()
}

func (o ProcessMonitoringRuleMapOutput) ToProcessMonitoringRuleMapOutput() ProcessMonitoringRuleMapOutput {
	return o
}

func (o ProcessMonitoringRuleMapOutput) ToProcessMonitoringRuleMapOutputWithContext(ctx context.Context) ProcessMonitoringRuleMapOutput {
	return o
}

func (o ProcessMonitoringRuleMapOutput) MapIndex(k pulumi.StringInput) ProcessMonitoringRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ProcessMonitoringRule {
		return vs[0].(map[string]*ProcessMonitoringRule)[vs[1].(string)]
	}).(ProcessMonitoringRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ProcessMonitoringRuleInput)(nil)).Elem(), &ProcessMonitoringRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProcessMonitoringRuleArrayInput)(nil)).Elem(), ProcessMonitoringRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProcessMonitoringRuleMapInput)(nil)).Elem(), ProcessMonitoringRuleMap{})
	pulumi.RegisterOutputType(ProcessMonitoringRuleOutput{})
	pulumi.RegisterOutputType(ProcessMonitoringRuleArrayOutput{})
	pulumi.RegisterOutputType(ProcessMonitoringRuleMapOutput{})
}
