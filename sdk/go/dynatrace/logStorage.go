// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type LogStorage struct {
	pulumi.CustomResourceState

	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringOutput `pulumi:"insertAfter"`
	// no documentation available
	Matchers LogStorageMatchersPtrOutput `pulumi:"matchers"`
	// Name
	Name pulumi.StringOutput `pulumi:"name"`
	// The scope of this setting (HOST, KUBERNETES*CLUSTER, HOST*GROUP). Omit this property if you want to cover the whole environment.
	Scope pulumi.StringPtrOutput `pulumi:"scope"`
	// If `true` matching logs will be included in storage. If `false` matching logs will be excluded from storage.
	SendToStorage pulumi.BoolOutput `pulumi:"sendToStorage"`
}

// NewLogStorage registers a new resource with the given unique name, arguments, and options.
func NewLogStorage(ctx *pulumi.Context,
	name string, args *LogStorageArgs, opts ...pulumi.ResourceOption) (*LogStorage, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.SendToStorage == nil {
		return nil, errors.New("invalid value for required argument 'SendToStorage'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource LogStorage
	err := ctx.RegisterResource("dynatrace:index/logStorage:LogStorage", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLogStorage gets an existing LogStorage resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLogStorage(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LogStorageState, opts ...pulumi.ResourceOption) (*LogStorage, error) {
	var resource LogStorage
	err := ctx.ReadResource("dynatrace:index/logStorage:LogStorage", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LogStorage resources.
type logStorageState struct {
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// no documentation available
	Matchers *LogStorageMatchers `pulumi:"matchers"`
	// Name
	Name *string `pulumi:"name"`
	// The scope of this setting (HOST, KUBERNETES*CLUSTER, HOST*GROUP). Omit this property if you want to cover the whole environment.
	Scope *string `pulumi:"scope"`
	// If `true` matching logs will be included in storage. If `false` matching logs will be excluded from storage.
	SendToStorage *bool `pulumi:"sendToStorage"`
}

type LogStorageState struct {
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolPtrInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// no documentation available
	Matchers LogStorageMatchersPtrInput
	// Name
	Name pulumi.StringPtrInput
	// The scope of this setting (HOST, KUBERNETES*CLUSTER, HOST*GROUP). Omit this property if you want to cover the whole environment.
	Scope pulumi.StringPtrInput
	// If `true` matching logs will be included in storage. If `false` matching logs will be excluded from storage.
	SendToStorage pulumi.BoolPtrInput
}

func (LogStorageState) ElementType() reflect.Type {
	return reflect.TypeOf((*logStorageState)(nil)).Elem()
}

type logStorageArgs struct {
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled bool `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// no documentation available
	Matchers *LogStorageMatchers `pulumi:"matchers"`
	// Name
	Name *string `pulumi:"name"`
	// The scope of this setting (HOST, KUBERNETES*CLUSTER, HOST*GROUP). Omit this property if you want to cover the whole environment.
	Scope *string `pulumi:"scope"`
	// If `true` matching logs will be included in storage. If `false` matching logs will be excluded from storage.
	SendToStorage bool `pulumi:"sendToStorage"`
}

// The set of arguments for constructing a LogStorage resource.
type LogStorageArgs struct {
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// no documentation available
	Matchers LogStorageMatchersPtrInput
	// Name
	Name pulumi.StringPtrInput
	// The scope of this setting (HOST, KUBERNETES*CLUSTER, HOST*GROUP). Omit this property if you want to cover the whole environment.
	Scope pulumi.StringPtrInput
	// If `true` matching logs will be included in storage. If `false` matching logs will be excluded from storage.
	SendToStorage pulumi.BoolInput
}

func (LogStorageArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*logStorageArgs)(nil)).Elem()
}

type LogStorageInput interface {
	pulumi.Input

	ToLogStorageOutput() LogStorageOutput
	ToLogStorageOutputWithContext(ctx context.Context) LogStorageOutput
}

func (*LogStorage) ElementType() reflect.Type {
	return reflect.TypeOf((**LogStorage)(nil)).Elem()
}

func (i *LogStorage) ToLogStorageOutput() LogStorageOutput {
	return i.ToLogStorageOutputWithContext(context.Background())
}

func (i *LogStorage) ToLogStorageOutputWithContext(ctx context.Context) LogStorageOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogStorageOutput)
}

// LogStorageArrayInput is an input type that accepts LogStorageArray and LogStorageArrayOutput values.
// You can construct a concrete instance of `LogStorageArrayInput` via:
//
//	LogStorageArray{ LogStorageArgs{...} }
type LogStorageArrayInput interface {
	pulumi.Input

	ToLogStorageArrayOutput() LogStorageArrayOutput
	ToLogStorageArrayOutputWithContext(context.Context) LogStorageArrayOutput
}

type LogStorageArray []LogStorageInput

func (LogStorageArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LogStorage)(nil)).Elem()
}

func (i LogStorageArray) ToLogStorageArrayOutput() LogStorageArrayOutput {
	return i.ToLogStorageArrayOutputWithContext(context.Background())
}

func (i LogStorageArray) ToLogStorageArrayOutputWithContext(ctx context.Context) LogStorageArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogStorageArrayOutput)
}

// LogStorageMapInput is an input type that accepts LogStorageMap and LogStorageMapOutput values.
// You can construct a concrete instance of `LogStorageMapInput` via:
//
//	LogStorageMap{ "key": LogStorageArgs{...} }
type LogStorageMapInput interface {
	pulumi.Input

	ToLogStorageMapOutput() LogStorageMapOutput
	ToLogStorageMapOutputWithContext(context.Context) LogStorageMapOutput
}

type LogStorageMap map[string]LogStorageInput

func (LogStorageMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LogStorage)(nil)).Elem()
}

func (i LogStorageMap) ToLogStorageMapOutput() LogStorageMapOutput {
	return i.ToLogStorageMapOutputWithContext(context.Background())
}

func (i LogStorageMap) ToLogStorageMapOutputWithContext(ctx context.Context) LogStorageMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogStorageMapOutput)
}

type LogStorageOutput struct{ *pulumi.OutputState }

func (LogStorageOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogStorage)(nil)).Elem()
}

func (o LogStorageOutput) ToLogStorageOutput() LogStorageOutput {
	return o
}

func (o LogStorageOutput) ToLogStorageOutputWithContext(ctx context.Context) LogStorageOutput {
	return o
}

// This setting is enabled (`true`) or disabled (`false`)
func (o LogStorageOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *LogStorage) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
func (o LogStorageOutput) InsertAfter() pulumi.StringOutput {
	return o.ApplyT(func(v *LogStorage) pulumi.StringOutput { return v.InsertAfter }).(pulumi.StringOutput)
}

// no documentation available
func (o LogStorageOutput) Matchers() LogStorageMatchersPtrOutput {
	return o.ApplyT(func(v *LogStorage) LogStorageMatchersPtrOutput { return v.Matchers }).(LogStorageMatchersPtrOutput)
}

// Name
func (o LogStorageOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *LogStorage) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The scope of this setting (HOST, KUBERNETES*CLUSTER, HOST*GROUP). Omit this property if you want to cover the whole environment.
func (o LogStorageOutput) Scope() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogStorage) pulumi.StringPtrOutput { return v.Scope }).(pulumi.StringPtrOutput)
}

// If `true` matching logs will be included in storage. If `false` matching logs will be excluded from storage.
func (o LogStorageOutput) SendToStorage() pulumi.BoolOutput {
	return o.ApplyT(func(v *LogStorage) pulumi.BoolOutput { return v.SendToStorage }).(pulumi.BoolOutput)
}

type LogStorageArrayOutput struct{ *pulumi.OutputState }

func (LogStorageArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LogStorage)(nil)).Elem()
}

func (o LogStorageArrayOutput) ToLogStorageArrayOutput() LogStorageArrayOutput {
	return o
}

func (o LogStorageArrayOutput) ToLogStorageArrayOutputWithContext(ctx context.Context) LogStorageArrayOutput {
	return o
}

func (o LogStorageArrayOutput) Index(i pulumi.IntInput) LogStorageOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *LogStorage {
		return vs[0].([]*LogStorage)[vs[1].(int)]
	}).(LogStorageOutput)
}

type LogStorageMapOutput struct{ *pulumi.OutputState }

func (LogStorageMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LogStorage)(nil)).Elem()
}

func (o LogStorageMapOutput) ToLogStorageMapOutput() LogStorageMapOutput {
	return o
}

func (o LogStorageMapOutput) ToLogStorageMapOutputWithContext(ctx context.Context) LogStorageMapOutput {
	return o
}

func (o LogStorageMapOutput) MapIndex(k pulumi.StringInput) LogStorageOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *LogStorage {
		return vs[0].(map[string]*LogStorage)[vs[1].(string)]
	}).(LogStorageOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LogStorageInput)(nil)).Elem(), &LogStorage{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogStorageArrayInput)(nil)).Elem(), LogStorageArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogStorageMapInput)(nil)).Elem(), LogStorageMap{})
	pulumi.RegisterOutputType(LogStorageOutput{})
	pulumi.RegisterOutputType(LogStorageArrayOutput{})
	pulumi.RegisterOutputType(LogStorageMapOutput{})
}
