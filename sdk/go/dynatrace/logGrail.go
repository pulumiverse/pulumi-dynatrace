// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type LogGrail struct {
	pulumi.CustomResourceState

	// Activate logs powered by Grail.
	Activated pulumi.BoolOutput `pulumi:"activated"`
	// Possible Values: `NONE`, `SEVEN_DAYS`, `THIRTY_FIVE_DAYS`
	ParallelIngestPeriod pulumi.StringOutput `pulumi:"parallelIngestPeriod"`
}

// NewLogGrail registers a new resource with the given unique name, arguments, and options.
func NewLogGrail(ctx *pulumi.Context,
	name string, args *LogGrailArgs, opts ...pulumi.ResourceOption) (*LogGrail, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Activated == nil {
		return nil, errors.New("invalid value for required argument 'Activated'")
	}
	if args.ParallelIngestPeriod == nil {
		return nil, errors.New("invalid value for required argument 'ParallelIngestPeriod'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource LogGrail
	err := ctx.RegisterResource("dynatrace:index/logGrail:LogGrail", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLogGrail gets an existing LogGrail resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLogGrail(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LogGrailState, opts ...pulumi.ResourceOption) (*LogGrail, error) {
	var resource LogGrail
	err := ctx.ReadResource("dynatrace:index/logGrail:LogGrail", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LogGrail resources.
type logGrailState struct {
	// Activate logs powered by Grail.
	Activated *bool `pulumi:"activated"`
	// Possible Values: `NONE`, `SEVEN_DAYS`, `THIRTY_FIVE_DAYS`
	ParallelIngestPeriod *string `pulumi:"parallelIngestPeriod"`
}

type LogGrailState struct {
	// Activate logs powered by Grail.
	Activated pulumi.BoolPtrInput
	// Possible Values: `NONE`, `SEVEN_DAYS`, `THIRTY_FIVE_DAYS`
	ParallelIngestPeriod pulumi.StringPtrInput
}

func (LogGrailState) ElementType() reflect.Type {
	return reflect.TypeOf((*logGrailState)(nil)).Elem()
}

type logGrailArgs struct {
	// Activate logs powered by Grail.
	Activated bool `pulumi:"activated"`
	// Possible Values: `NONE`, `SEVEN_DAYS`, `THIRTY_FIVE_DAYS`
	ParallelIngestPeriod string `pulumi:"parallelIngestPeriod"`
}

// The set of arguments for constructing a LogGrail resource.
type LogGrailArgs struct {
	// Activate logs powered by Grail.
	Activated pulumi.BoolInput
	// Possible Values: `NONE`, `SEVEN_DAYS`, `THIRTY_FIVE_DAYS`
	ParallelIngestPeriod pulumi.StringInput
}

func (LogGrailArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*logGrailArgs)(nil)).Elem()
}

type LogGrailInput interface {
	pulumi.Input

	ToLogGrailOutput() LogGrailOutput
	ToLogGrailOutputWithContext(ctx context.Context) LogGrailOutput
}

func (*LogGrail) ElementType() reflect.Type {
	return reflect.TypeOf((**LogGrail)(nil)).Elem()
}

func (i *LogGrail) ToLogGrailOutput() LogGrailOutput {
	return i.ToLogGrailOutputWithContext(context.Background())
}

func (i *LogGrail) ToLogGrailOutputWithContext(ctx context.Context) LogGrailOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogGrailOutput)
}

// LogGrailArrayInput is an input type that accepts LogGrailArray and LogGrailArrayOutput values.
// You can construct a concrete instance of `LogGrailArrayInput` via:
//
//	LogGrailArray{ LogGrailArgs{...} }
type LogGrailArrayInput interface {
	pulumi.Input

	ToLogGrailArrayOutput() LogGrailArrayOutput
	ToLogGrailArrayOutputWithContext(context.Context) LogGrailArrayOutput
}

type LogGrailArray []LogGrailInput

func (LogGrailArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LogGrail)(nil)).Elem()
}

func (i LogGrailArray) ToLogGrailArrayOutput() LogGrailArrayOutput {
	return i.ToLogGrailArrayOutputWithContext(context.Background())
}

func (i LogGrailArray) ToLogGrailArrayOutputWithContext(ctx context.Context) LogGrailArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogGrailArrayOutput)
}

// LogGrailMapInput is an input type that accepts LogGrailMap and LogGrailMapOutput values.
// You can construct a concrete instance of `LogGrailMapInput` via:
//
//	LogGrailMap{ "key": LogGrailArgs{...} }
type LogGrailMapInput interface {
	pulumi.Input

	ToLogGrailMapOutput() LogGrailMapOutput
	ToLogGrailMapOutputWithContext(context.Context) LogGrailMapOutput
}

type LogGrailMap map[string]LogGrailInput

func (LogGrailMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LogGrail)(nil)).Elem()
}

func (i LogGrailMap) ToLogGrailMapOutput() LogGrailMapOutput {
	return i.ToLogGrailMapOutputWithContext(context.Background())
}

func (i LogGrailMap) ToLogGrailMapOutputWithContext(ctx context.Context) LogGrailMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogGrailMapOutput)
}

type LogGrailOutput struct{ *pulumi.OutputState }

func (LogGrailOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogGrail)(nil)).Elem()
}

func (o LogGrailOutput) ToLogGrailOutput() LogGrailOutput {
	return o
}

func (o LogGrailOutput) ToLogGrailOutputWithContext(ctx context.Context) LogGrailOutput {
	return o
}

// Activate logs powered by Grail.
func (o LogGrailOutput) Activated() pulumi.BoolOutput {
	return o.ApplyT(func(v *LogGrail) pulumi.BoolOutput { return v.Activated }).(pulumi.BoolOutput)
}

// Possible Values: `NONE`, `SEVEN_DAYS`, `THIRTY_FIVE_DAYS`
func (o LogGrailOutput) ParallelIngestPeriod() pulumi.StringOutput {
	return o.ApplyT(func(v *LogGrail) pulumi.StringOutput { return v.ParallelIngestPeriod }).(pulumi.StringOutput)
}

type LogGrailArrayOutput struct{ *pulumi.OutputState }

func (LogGrailArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LogGrail)(nil)).Elem()
}

func (o LogGrailArrayOutput) ToLogGrailArrayOutput() LogGrailArrayOutput {
	return o
}

func (o LogGrailArrayOutput) ToLogGrailArrayOutputWithContext(ctx context.Context) LogGrailArrayOutput {
	return o
}

func (o LogGrailArrayOutput) Index(i pulumi.IntInput) LogGrailOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *LogGrail {
		return vs[0].([]*LogGrail)[vs[1].(int)]
	}).(LogGrailOutput)
}

type LogGrailMapOutput struct{ *pulumi.OutputState }

func (LogGrailMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LogGrail)(nil)).Elem()
}

func (o LogGrailMapOutput) ToLogGrailMapOutput() LogGrailMapOutput {
	return o
}

func (o LogGrailMapOutput) ToLogGrailMapOutputWithContext(ctx context.Context) LogGrailMapOutput {
	return o
}

func (o LogGrailMapOutput) MapIndex(k pulumi.StringInput) LogGrailOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *LogGrail {
		return vs[0].(map[string]*LogGrail)[vs[1].(string)]
	}).(LogGrailOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LogGrailInput)(nil)).Elem(), &LogGrail{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogGrailArrayInput)(nil)).Elem(), LogGrailArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogGrailMapInput)(nil)).Elem(), LogGrailMap{})
	pulumi.RegisterOutputType(LogGrailOutput{})
	pulumi.RegisterOutputType(LogGrailArrayOutput{})
	pulumi.RegisterOutputType(LogGrailMapOutput{})
}
