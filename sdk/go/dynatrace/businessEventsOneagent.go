// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type BusinessEventsOneagent struct {
	pulumi.CustomResourceState

	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// Event meta data
	Event BusinessEventsOneagentEventOutput `pulumi:"event"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringOutput `pulumi:"insertAfter"`
	// Rule name
	RuleName pulumi.StringOutput `pulumi:"ruleName"`
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope pulumi.StringPtrOutput `pulumi:"scope"`
	// Define conditions to trigger business events from incoming web requests. Triggers are connected by AND logic per capture rule. If you set multiple trigger rules, all of them need to be fulfilled to capture a business event.
	Triggers BusinessEventsOneagentTriggersOutput `pulumi:"triggers"`
}

// NewBusinessEventsOneagent registers a new resource with the given unique name, arguments, and options.
func NewBusinessEventsOneagent(ctx *pulumi.Context,
	name string, args *BusinessEventsOneagentArgs, opts ...pulumi.ResourceOption) (*BusinessEventsOneagent, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.Event == nil {
		return nil, errors.New("invalid value for required argument 'Event'")
	}
	if args.RuleName == nil {
		return nil, errors.New("invalid value for required argument 'RuleName'")
	}
	if args.Triggers == nil {
		return nil, errors.New("invalid value for required argument 'Triggers'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource BusinessEventsOneagent
	err := ctx.RegisterResource("dynatrace:index/businessEventsOneagent:BusinessEventsOneagent", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetBusinessEventsOneagent gets an existing BusinessEventsOneagent resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetBusinessEventsOneagent(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *BusinessEventsOneagentState, opts ...pulumi.ResourceOption) (*BusinessEventsOneagent, error) {
	var resource BusinessEventsOneagent
	err := ctx.ReadResource("dynatrace:index/businessEventsOneagent:BusinessEventsOneagent", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering BusinessEventsOneagent resources.
type businessEventsOneagentState struct {
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `pulumi:"enabled"`
	// Event meta data
	Event *BusinessEventsOneagentEvent `pulumi:"event"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Rule name
	RuleName *string `pulumi:"ruleName"`
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope *string `pulumi:"scope"`
	// Define conditions to trigger business events from incoming web requests. Triggers are connected by AND logic per capture rule. If you set multiple trigger rules, all of them need to be fulfilled to capture a business event.
	Triggers *BusinessEventsOneagentTriggers `pulumi:"triggers"`
}

type BusinessEventsOneagentState struct {
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolPtrInput
	// Event meta data
	Event BusinessEventsOneagentEventPtrInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Rule name
	RuleName pulumi.StringPtrInput
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope pulumi.StringPtrInput
	// Define conditions to trigger business events from incoming web requests. Triggers are connected by AND logic per capture rule. If you set multiple trigger rules, all of them need to be fulfilled to capture a business event.
	Triggers BusinessEventsOneagentTriggersPtrInput
}

func (BusinessEventsOneagentState) ElementType() reflect.Type {
	return reflect.TypeOf((*businessEventsOneagentState)(nil)).Elem()
}

type businessEventsOneagentArgs struct {
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled bool `pulumi:"enabled"`
	// Event meta data
	Event BusinessEventsOneagentEvent `pulumi:"event"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Rule name
	RuleName string `pulumi:"ruleName"`
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope *string `pulumi:"scope"`
	// Define conditions to trigger business events from incoming web requests. Triggers are connected by AND logic per capture rule. If you set multiple trigger rules, all of them need to be fulfilled to capture a business event.
	Triggers BusinessEventsOneagentTriggers `pulumi:"triggers"`
}

// The set of arguments for constructing a BusinessEventsOneagent resource.
type BusinessEventsOneagentArgs struct {
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolInput
	// Event meta data
	Event BusinessEventsOneagentEventInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Rule name
	RuleName pulumi.StringInput
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope pulumi.StringPtrInput
	// Define conditions to trigger business events from incoming web requests. Triggers are connected by AND logic per capture rule. If you set multiple trigger rules, all of them need to be fulfilled to capture a business event.
	Triggers BusinessEventsOneagentTriggersInput
}

func (BusinessEventsOneagentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*businessEventsOneagentArgs)(nil)).Elem()
}

type BusinessEventsOneagentInput interface {
	pulumi.Input

	ToBusinessEventsOneagentOutput() BusinessEventsOneagentOutput
	ToBusinessEventsOneagentOutputWithContext(ctx context.Context) BusinessEventsOneagentOutput
}

func (*BusinessEventsOneagent) ElementType() reflect.Type {
	return reflect.TypeOf((**BusinessEventsOneagent)(nil)).Elem()
}

func (i *BusinessEventsOneagent) ToBusinessEventsOneagentOutput() BusinessEventsOneagentOutput {
	return i.ToBusinessEventsOneagentOutputWithContext(context.Background())
}

func (i *BusinessEventsOneagent) ToBusinessEventsOneagentOutputWithContext(ctx context.Context) BusinessEventsOneagentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BusinessEventsOneagentOutput)
}

// BusinessEventsOneagentArrayInput is an input type that accepts BusinessEventsOneagentArray and BusinessEventsOneagentArrayOutput values.
// You can construct a concrete instance of `BusinessEventsOneagentArrayInput` via:
//
//	BusinessEventsOneagentArray{ BusinessEventsOneagentArgs{...} }
type BusinessEventsOneagentArrayInput interface {
	pulumi.Input

	ToBusinessEventsOneagentArrayOutput() BusinessEventsOneagentArrayOutput
	ToBusinessEventsOneagentArrayOutputWithContext(context.Context) BusinessEventsOneagentArrayOutput
}

type BusinessEventsOneagentArray []BusinessEventsOneagentInput

func (BusinessEventsOneagentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*BusinessEventsOneagent)(nil)).Elem()
}

func (i BusinessEventsOneagentArray) ToBusinessEventsOneagentArrayOutput() BusinessEventsOneagentArrayOutput {
	return i.ToBusinessEventsOneagentArrayOutputWithContext(context.Background())
}

func (i BusinessEventsOneagentArray) ToBusinessEventsOneagentArrayOutputWithContext(ctx context.Context) BusinessEventsOneagentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BusinessEventsOneagentArrayOutput)
}

// BusinessEventsOneagentMapInput is an input type that accepts BusinessEventsOneagentMap and BusinessEventsOneagentMapOutput values.
// You can construct a concrete instance of `BusinessEventsOneagentMapInput` via:
//
//	BusinessEventsOneagentMap{ "key": BusinessEventsOneagentArgs{...} }
type BusinessEventsOneagentMapInput interface {
	pulumi.Input

	ToBusinessEventsOneagentMapOutput() BusinessEventsOneagentMapOutput
	ToBusinessEventsOneagentMapOutputWithContext(context.Context) BusinessEventsOneagentMapOutput
}

type BusinessEventsOneagentMap map[string]BusinessEventsOneagentInput

func (BusinessEventsOneagentMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*BusinessEventsOneagent)(nil)).Elem()
}

func (i BusinessEventsOneagentMap) ToBusinessEventsOneagentMapOutput() BusinessEventsOneagentMapOutput {
	return i.ToBusinessEventsOneagentMapOutputWithContext(context.Background())
}

func (i BusinessEventsOneagentMap) ToBusinessEventsOneagentMapOutputWithContext(ctx context.Context) BusinessEventsOneagentMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BusinessEventsOneagentMapOutput)
}

type BusinessEventsOneagentOutput struct{ *pulumi.OutputState }

func (BusinessEventsOneagentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BusinessEventsOneagent)(nil)).Elem()
}

func (o BusinessEventsOneagentOutput) ToBusinessEventsOneagentOutput() BusinessEventsOneagentOutput {
	return o
}

func (o BusinessEventsOneagentOutput) ToBusinessEventsOneagentOutputWithContext(ctx context.Context) BusinessEventsOneagentOutput {
	return o
}

// This setting is enabled (`true`) or disabled (`false`)
func (o BusinessEventsOneagentOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *BusinessEventsOneagent) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// Event meta data
func (o BusinessEventsOneagentOutput) Event() BusinessEventsOneagentEventOutput {
	return o.ApplyT(func(v *BusinessEventsOneagent) BusinessEventsOneagentEventOutput { return v.Event }).(BusinessEventsOneagentEventOutput)
}

// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
func (o BusinessEventsOneagentOutput) InsertAfter() pulumi.StringOutput {
	return o.ApplyT(func(v *BusinessEventsOneagent) pulumi.StringOutput { return v.InsertAfter }).(pulumi.StringOutput)
}

// Rule name
func (o BusinessEventsOneagentOutput) RuleName() pulumi.StringOutput {
	return o.ApplyT(func(v *BusinessEventsOneagent) pulumi.StringOutput { return v.RuleName }).(pulumi.StringOutput)
}

// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
func (o BusinessEventsOneagentOutput) Scope() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BusinessEventsOneagent) pulumi.StringPtrOutput { return v.Scope }).(pulumi.StringPtrOutput)
}

// Define conditions to trigger business events from incoming web requests. Triggers are connected by AND logic per capture rule. If you set multiple trigger rules, all of them need to be fulfilled to capture a business event.
func (o BusinessEventsOneagentOutput) Triggers() BusinessEventsOneagentTriggersOutput {
	return o.ApplyT(func(v *BusinessEventsOneagent) BusinessEventsOneagentTriggersOutput { return v.Triggers }).(BusinessEventsOneagentTriggersOutput)
}

type BusinessEventsOneagentArrayOutput struct{ *pulumi.OutputState }

func (BusinessEventsOneagentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*BusinessEventsOneagent)(nil)).Elem()
}

func (o BusinessEventsOneagentArrayOutput) ToBusinessEventsOneagentArrayOutput() BusinessEventsOneagentArrayOutput {
	return o
}

func (o BusinessEventsOneagentArrayOutput) ToBusinessEventsOneagentArrayOutputWithContext(ctx context.Context) BusinessEventsOneagentArrayOutput {
	return o
}

func (o BusinessEventsOneagentArrayOutput) Index(i pulumi.IntInput) BusinessEventsOneagentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *BusinessEventsOneagent {
		return vs[0].([]*BusinessEventsOneagent)[vs[1].(int)]
	}).(BusinessEventsOneagentOutput)
}

type BusinessEventsOneagentMapOutput struct{ *pulumi.OutputState }

func (BusinessEventsOneagentMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*BusinessEventsOneagent)(nil)).Elem()
}

func (o BusinessEventsOneagentMapOutput) ToBusinessEventsOneagentMapOutput() BusinessEventsOneagentMapOutput {
	return o
}

func (o BusinessEventsOneagentMapOutput) ToBusinessEventsOneagentMapOutputWithContext(ctx context.Context) BusinessEventsOneagentMapOutput {
	return o
}

func (o BusinessEventsOneagentMapOutput) MapIndex(k pulumi.StringInput) BusinessEventsOneagentOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *BusinessEventsOneagent {
		return vs[0].(map[string]*BusinessEventsOneagent)[vs[1].(string)]
	}).(BusinessEventsOneagentOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BusinessEventsOneagentInput)(nil)).Elem(), &BusinessEventsOneagent{})
	pulumi.RegisterInputType(reflect.TypeOf((*BusinessEventsOneagentArrayInput)(nil)).Elem(), BusinessEventsOneagentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BusinessEventsOneagentMapInput)(nil)).Elem(), BusinessEventsOneagentMap{})
	pulumi.RegisterOutputType(BusinessEventsOneagentOutput{})
	pulumi.RegisterOutputType(BusinessEventsOneagentArrayOutput{})
	pulumi.RegisterOutputType(BusinessEventsOneagentMapOutput{})
}
