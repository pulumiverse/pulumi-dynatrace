// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type ApplicationDetectionRuleV2 struct {
	pulumi.CustomResourceState

	// Select an existing application or create a new one.
	ApplicationId pulumi.StringOutput `pulumi:"applicationId"`
	// (v1.274) Add a description for your rule
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringOutput `pulumi:"insertAfter"`
	// Possible Values: `DOMAIN_CONTAINS`, `DOMAIN_ENDS_WITH`, `DOMAIN_EQUALS`, `DOMAIN_MATCHES`, `DOMAIN_STARTS_WITH`, `URL_CONTAINS`, `URL_ENDS_WITH`, `URL_EQUALS`, `URL_STARTS_WITH`
	Matcher pulumi.StringOutput `pulumi:"matcher"`
	// Pattern
	Pattern pulumi.StringOutput `pulumi:"pattern"`
}

// NewApplicationDetectionRuleV2 registers a new resource with the given unique name, arguments, and options.
func NewApplicationDetectionRuleV2(ctx *pulumi.Context,
	name string, args *ApplicationDetectionRuleV2Args, opts ...pulumi.ResourceOption) (*ApplicationDetectionRuleV2, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ApplicationId == nil {
		return nil, errors.New("invalid value for required argument 'ApplicationId'")
	}
	if args.Matcher == nil {
		return nil, errors.New("invalid value for required argument 'Matcher'")
	}
	if args.Pattern == nil {
		return nil, errors.New("invalid value for required argument 'Pattern'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ApplicationDetectionRuleV2
	err := ctx.RegisterResource("dynatrace:index/applicationDetectionRuleV2:ApplicationDetectionRuleV2", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetApplicationDetectionRuleV2 gets an existing ApplicationDetectionRuleV2 resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetApplicationDetectionRuleV2(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ApplicationDetectionRuleV2State, opts ...pulumi.ResourceOption) (*ApplicationDetectionRuleV2, error) {
	var resource ApplicationDetectionRuleV2
	err := ctx.ReadResource("dynatrace:index/applicationDetectionRuleV2:ApplicationDetectionRuleV2", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ApplicationDetectionRuleV2 resources.
type applicationDetectionRuleV2State struct {
	// Select an existing application or create a new one.
	ApplicationId *string `pulumi:"applicationId"`
	// (v1.274) Add a description for your rule
	Description *string `pulumi:"description"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Possible Values: `DOMAIN_CONTAINS`, `DOMAIN_ENDS_WITH`, `DOMAIN_EQUALS`, `DOMAIN_MATCHES`, `DOMAIN_STARTS_WITH`, `URL_CONTAINS`, `URL_ENDS_WITH`, `URL_EQUALS`, `URL_STARTS_WITH`
	Matcher *string `pulumi:"matcher"`
	// Pattern
	Pattern *string `pulumi:"pattern"`
}

type ApplicationDetectionRuleV2State struct {
	// Select an existing application or create a new one.
	ApplicationId pulumi.StringPtrInput
	// (v1.274) Add a description for your rule
	Description pulumi.StringPtrInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Possible Values: `DOMAIN_CONTAINS`, `DOMAIN_ENDS_WITH`, `DOMAIN_EQUALS`, `DOMAIN_MATCHES`, `DOMAIN_STARTS_WITH`, `URL_CONTAINS`, `URL_ENDS_WITH`, `URL_EQUALS`, `URL_STARTS_WITH`
	Matcher pulumi.StringPtrInput
	// Pattern
	Pattern pulumi.StringPtrInput
}

func (ApplicationDetectionRuleV2State) ElementType() reflect.Type {
	return reflect.TypeOf((*applicationDetectionRuleV2State)(nil)).Elem()
}

type applicationDetectionRuleV2Args struct {
	// Select an existing application or create a new one.
	ApplicationId string `pulumi:"applicationId"`
	// (v1.274) Add a description for your rule
	Description *string `pulumi:"description"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Possible Values: `DOMAIN_CONTAINS`, `DOMAIN_ENDS_WITH`, `DOMAIN_EQUALS`, `DOMAIN_MATCHES`, `DOMAIN_STARTS_WITH`, `URL_CONTAINS`, `URL_ENDS_WITH`, `URL_EQUALS`, `URL_STARTS_WITH`
	Matcher string `pulumi:"matcher"`
	// Pattern
	Pattern string `pulumi:"pattern"`
}

// The set of arguments for constructing a ApplicationDetectionRuleV2 resource.
type ApplicationDetectionRuleV2Args struct {
	// Select an existing application or create a new one.
	ApplicationId pulumi.StringInput
	// (v1.274) Add a description for your rule
	Description pulumi.StringPtrInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Possible Values: `DOMAIN_CONTAINS`, `DOMAIN_ENDS_WITH`, `DOMAIN_EQUALS`, `DOMAIN_MATCHES`, `DOMAIN_STARTS_WITH`, `URL_CONTAINS`, `URL_ENDS_WITH`, `URL_EQUALS`, `URL_STARTS_WITH`
	Matcher pulumi.StringInput
	// Pattern
	Pattern pulumi.StringInput
}

func (ApplicationDetectionRuleV2Args) ElementType() reflect.Type {
	return reflect.TypeOf((*applicationDetectionRuleV2Args)(nil)).Elem()
}

type ApplicationDetectionRuleV2Input interface {
	pulumi.Input

	ToApplicationDetectionRuleV2Output() ApplicationDetectionRuleV2Output
	ToApplicationDetectionRuleV2OutputWithContext(ctx context.Context) ApplicationDetectionRuleV2Output
}

func (*ApplicationDetectionRuleV2) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationDetectionRuleV2)(nil)).Elem()
}

func (i *ApplicationDetectionRuleV2) ToApplicationDetectionRuleV2Output() ApplicationDetectionRuleV2Output {
	return i.ToApplicationDetectionRuleV2OutputWithContext(context.Background())
}

func (i *ApplicationDetectionRuleV2) ToApplicationDetectionRuleV2OutputWithContext(ctx context.Context) ApplicationDetectionRuleV2Output {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationDetectionRuleV2Output)
}

// ApplicationDetectionRuleV2ArrayInput is an input type that accepts ApplicationDetectionRuleV2Array and ApplicationDetectionRuleV2ArrayOutput values.
// You can construct a concrete instance of `ApplicationDetectionRuleV2ArrayInput` via:
//
//	ApplicationDetectionRuleV2Array{ ApplicationDetectionRuleV2Args{...} }
type ApplicationDetectionRuleV2ArrayInput interface {
	pulumi.Input

	ToApplicationDetectionRuleV2ArrayOutput() ApplicationDetectionRuleV2ArrayOutput
	ToApplicationDetectionRuleV2ArrayOutputWithContext(context.Context) ApplicationDetectionRuleV2ArrayOutput
}

type ApplicationDetectionRuleV2Array []ApplicationDetectionRuleV2Input

func (ApplicationDetectionRuleV2Array) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ApplicationDetectionRuleV2)(nil)).Elem()
}

func (i ApplicationDetectionRuleV2Array) ToApplicationDetectionRuleV2ArrayOutput() ApplicationDetectionRuleV2ArrayOutput {
	return i.ToApplicationDetectionRuleV2ArrayOutputWithContext(context.Background())
}

func (i ApplicationDetectionRuleV2Array) ToApplicationDetectionRuleV2ArrayOutputWithContext(ctx context.Context) ApplicationDetectionRuleV2ArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationDetectionRuleV2ArrayOutput)
}

// ApplicationDetectionRuleV2MapInput is an input type that accepts ApplicationDetectionRuleV2Map and ApplicationDetectionRuleV2MapOutput values.
// You can construct a concrete instance of `ApplicationDetectionRuleV2MapInput` via:
//
//	ApplicationDetectionRuleV2Map{ "key": ApplicationDetectionRuleV2Args{...} }
type ApplicationDetectionRuleV2MapInput interface {
	pulumi.Input

	ToApplicationDetectionRuleV2MapOutput() ApplicationDetectionRuleV2MapOutput
	ToApplicationDetectionRuleV2MapOutputWithContext(context.Context) ApplicationDetectionRuleV2MapOutput
}

type ApplicationDetectionRuleV2Map map[string]ApplicationDetectionRuleV2Input

func (ApplicationDetectionRuleV2Map) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ApplicationDetectionRuleV2)(nil)).Elem()
}

func (i ApplicationDetectionRuleV2Map) ToApplicationDetectionRuleV2MapOutput() ApplicationDetectionRuleV2MapOutput {
	return i.ToApplicationDetectionRuleV2MapOutputWithContext(context.Background())
}

func (i ApplicationDetectionRuleV2Map) ToApplicationDetectionRuleV2MapOutputWithContext(ctx context.Context) ApplicationDetectionRuleV2MapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationDetectionRuleV2MapOutput)
}

type ApplicationDetectionRuleV2Output struct{ *pulumi.OutputState }

func (ApplicationDetectionRuleV2Output) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationDetectionRuleV2)(nil)).Elem()
}

func (o ApplicationDetectionRuleV2Output) ToApplicationDetectionRuleV2Output() ApplicationDetectionRuleV2Output {
	return o
}

func (o ApplicationDetectionRuleV2Output) ToApplicationDetectionRuleV2OutputWithContext(ctx context.Context) ApplicationDetectionRuleV2Output {
	return o
}

// Select an existing application or create a new one.
func (o ApplicationDetectionRuleV2Output) ApplicationId() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationDetectionRuleV2) pulumi.StringOutput { return v.ApplicationId }).(pulumi.StringOutput)
}

// (v1.274) Add a description for your rule
func (o ApplicationDetectionRuleV2Output) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationDetectionRuleV2) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
func (o ApplicationDetectionRuleV2Output) InsertAfter() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationDetectionRuleV2) pulumi.StringOutput { return v.InsertAfter }).(pulumi.StringOutput)
}

// Possible Values: `DOMAIN_CONTAINS`, `DOMAIN_ENDS_WITH`, `DOMAIN_EQUALS`, `DOMAIN_MATCHES`, `DOMAIN_STARTS_WITH`, `URL_CONTAINS`, `URL_ENDS_WITH`, `URL_EQUALS`, `URL_STARTS_WITH`
func (o ApplicationDetectionRuleV2Output) Matcher() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationDetectionRuleV2) pulumi.StringOutput { return v.Matcher }).(pulumi.StringOutput)
}

// Pattern
func (o ApplicationDetectionRuleV2Output) Pattern() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationDetectionRuleV2) pulumi.StringOutput { return v.Pattern }).(pulumi.StringOutput)
}

type ApplicationDetectionRuleV2ArrayOutput struct{ *pulumi.OutputState }

func (ApplicationDetectionRuleV2ArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ApplicationDetectionRuleV2)(nil)).Elem()
}

func (o ApplicationDetectionRuleV2ArrayOutput) ToApplicationDetectionRuleV2ArrayOutput() ApplicationDetectionRuleV2ArrayOutput {
	return o
}

func (o ApplicationDetectionRuleV2ArrayOutput) ToApplicationDetectionRuleV2ArrayOutputWithContext(ctx context.Context) ApplicationDetectionRuleV2ArrayOutput {
	return o
}

func (o ApplicationDetectionRuleV2ArrayOutput) Index(i pulumi.IntInput) ApplicationDetectionRuleV2Output {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ApplicationDetectionRuleV2 {
		return vs[0].([]*ApplicationDetectionRuleV2)[vs[1].(int)]
	}).(ApplicationDetectionRuleV2Output)
}

type ApplicationDetectionRuleV2MapOutput struct{ *pulumi.OutputState }

func (ApplicationDetectionRuleV2MapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ApplicationDetectionRuleV2)(nil)).Elem()
}

func (o ApplicationDetectionRuleV2MapOutput) ToApplicationDetectionRuleV2MapOutput() ApplicationDetectionRuleV2MapOutput {
	return o
}

func (o ApplicationDetectionRuleV2MapOutput) ToApplicationDetectionRuleV2MapOutputWithContext(ctx context.Context) ApplicationDetectionRuleV2MapOutput {
	return o
}

func (o ApplicationDetectionRuleV2MapOutput) MapIndex(k pulumi.StringInput) ApplicationDetectionRuleV2Output {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ApplicationDetectionRuleV2 {
		return vs[0].(map[string]*ApplicationDetectionRuleV2)[vs[1].(string)]
	}).(ApplicationDetectionRuleV2Output)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ApplicationDetectionRuleV2Input)(nil)).Elem(), &ApplicationDetectionRuleV2{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApplicationDetectionRuleV2ArrayInput)(nil)).Elem(), ApplicationDetectionRuleV2Array{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApplicationDetectionRuleV2MapInput)(nil)).Elem(), ApplicationDetectionRuleV2Map{})
	pulumi.RegisterOutputType(ApplicationDetectionRuleV2Output{})
	pulumi.RegisterOutputType(ApplicationDetectionRuleV2ArrayOutput{})
	pulumi.RegisterOutputType(ApplicationDetectionRuleV2MapOutput{})
}
