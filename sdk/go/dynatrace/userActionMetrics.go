// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type UserActionMetrics struct {
	pulumi.CustomResourceState

	// Defines the fields that are used as dimensions. A dimension is a collection of reference information about a metric data point that is of interest to your business. Dimensions are parameters like "application", "type", "apdexCategory". For example, using "type" as a dimension allows you to split chart data based on the user action type.
	Dimensions pulumi.StringArrayOutput `pulumi:"dimensions"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// Defines the filters for the user action. Filters apply at the moment of extracting the data and only sessions that satisfy the filtering criteria will be used to extract the custom metrics. You will not be able to modify these filters in the metric data explorer. For example, using "type equals Xhr" will give you only data from xhr actions, while forcing the rest of user actions of different types to be ignored.
	Filters UserActionMetricsFiltersPtrOutput `pulumi:"filters"`
	// Metric key
	MetricKey pulumi.StringOutput `pulumi:"metricKey"`
	// Defines the type of value to be extracted from the user action. When using **user action counter**, the number of user actions is counted (similar to count(*) when using USQL). When using **user action field value**, the value of a user action field is extracted.
	Value UserActionMetricsValueOutput `pulumi:"value"`
}

// NewUserActionMetrics registers a new resource with the given unique name, arguments, and options.
func NewUserActionMetrics(ctx *pulumi.Context,
	name string, args *UserActionMetricsArgs, opts ...pulumi.ResourceOption) (*UserActionMetrics, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.MetricKey == nil {
		return nil, errors.New("invalid value for required argument 'MetricKey'")
	}
	if args.Value == nil {
		return nil, errors.New("invalid value for required argument 'Value'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource UserActionMetrics
	err := ctx.RegisterResource("dynatrace:index/userActionMetrics:UserActionMetrics", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetUserActionMetrics gets an existing UserActionMetrics resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetUserActionMetrics(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *UserActionMetricsState, opts ...pulumi.ResourceOption) (*UserActionMetrics, error) {
	var resource UserActionMetrics
	err := ctx.ReadResource("dynatrace:index/userActionMetrics:UserActionMetrics", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering UserActionMetrics resources.
type userActionMetricsState struct {
	// Defines the fields that are used as dimensions. A dimension is a collection of reference information about a metric data point that is of interest to your business. Dimensions are parameters like "application", "type", "apdexCategory". For example, using "type" as a dimension allows you to split chart data based on the user action type.
	Dimensions []string `pulumi:"dimensions"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `pulumi:"enabled"`
	// Defines the filters for the user action. Filters apply at the moment of extracting the data and only sessions that satisfy the filtering criteria will be used to extract the custom metrics. You will not be able to modify these filters in the metric data explorer. For example, using "type equals Xhr" will give you only data from xhr actions, while forcing the rest of user actions of different types to be ignored.
	Filters *UserActionMetricsFilters `pulumi:"filters"`
	// Metric key
	MetricKey *string `pulumi:"metricKey"`
	// Defines the type of value to be extracted from the user action. When using **user action counter**, the number of user actions is counted (similar to count(*) when using USQL). When using **user action field value**, the value of a user action field is extracted.
	Value *UserActionMetricsValue `pulumi:"value"`
}

type UserActionMetricsState struct {
	// Defines the fields that are used as dimensions. A dimension is a collection of reference information about a metric data point that is of interest to your business. Dimensions are parameters like "application", "type", "apdexCategory". For example, using "type" as a dimension allows you to split chart data based on the user action type.
	Dimensions pulumi.StringArrayInput
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolPtrInput
	// Defines the filters for the user action. Filters apply at the moment of extracting the data and only sessions that satisfy the filtering criteria will be used to extract the custom metrics. You will not be able to modify these filters in the metric data explorer. For example, using "type equals Xhr" will give you only data from xhr actions, while forcing the rest of user actions of different types to be ignored.
	Filters UserActionMetricsFiltersPtrInput
	// Metric key
	MetricKey pulumi.StringPtrInput
	// Defines the type of value to be extracted from the user action. When using **user action counter**, the number of user actions is counted (similar to count(*) when using USQL). When using **user action field value**, the value of a user action field is extracted.
	Value UserActionMetricsValuePtrInput
}

func (UserActionMetricsState) ElementType() reflect.Type {
	return reflect.TypeOf((*userActionMetricsState)(nil)).Elem()
}

type userActionMetricsArgs struct {
	// Defines the fields that are used as dimensions. A dimension is a collection of reference information about a metric data point that is of interest to your business. Dimensions are parameters like "application", "type", "apdexCategory". For example, using "type" as a dimension allows you to split chart data based on the user action type.
	Dimensions []string `pulumi:"dimensions"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled bool `pulumi:"enabled"`
	// Defines the filters for the user action. Filters apply at the moment of extracting the data and only sessions that satisfy the filtering criteria will be used to extract the custom metrics. You will not be able to modify these filters in the metric data explorer. For example, using "type equals Xhr" will give you only data from xhr actions, while forcing the rest of user actions of different types to be ignored.
	Filters *UserActionMetricsFilters `pulumi:"filters"`
	// Metric key
	MetricKey string `pulumi:"metricKey"`
	// Defines the type of value to be extracted from the user action. When using **user action counter**, the number of user actions is counted (similar to count(*) when using USQL). When using **user action field value**, the value of a user action field is extracted.
	Value UserActionMetricsValue `pulumi:"value"`
}

// The set of arguments for constructing a UserActionMetrics resource.
type UserActionMetricsArgs struct {
	// Defines the fields that are used as dimensions. A dimension is a collection of reference information about a metric data point that is of interest to your business. Dimensions are parameters like "application", "type", "apdexCategory". For example, using "type" as a dimension allows you to split chart data based on the user action type.
	Dimensions pulumi.StringArrayInput
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolInput
	// Defines the filters for the user action. Filters apply at the moment of extracting the data and only sessions that satisfy the filtering criteria will be used to extract the custom metrics. You will not be able to modify these filters in the metric data explorer. For example, using "type equals Xhr" will give you only data from xhr actions, while forcing the rest of user actions of different types to be ignored.
	Filters UserActionMetricsFiltersPtrInput
	// Metric key
	MetricKey pulumi.StringInput
	// Defines the type of value to be extracted from the user action. When using **user action counter**, the number of user actions is counted (similar to count(*) when using USQL). When using **user action field value**, the value of a user action field is extracted.
	Value UserActionMetricsValueInput
}

func (UserActionMetricsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*userActionMetricsArgs)(nil)).Elem()
}

type UserActionMetricsInput interface {
	pulumi.Input

	ToUserActionMetricsOutput() UserActionMetricsOutput
	ToUserActionMetricsOutputWithContext(ctx context.Context) UserActionMetricsOutput
}

func (*UserActionMetrics) ElementType() reflect.Type {
	return reflect.TypeOf((**UserActionMetrics)(nil)).Elem()
}

func (i *UserActionMetrics) ToUserActionMetricsOutput() UserActionMetricsOutput {
	return i.ToUserActionMetricsOutputWithContext(context.Background())
}

func (i *UserActionMetrics) ToUserActionMetricsOutputWithContext(ctx context.Context) UserActionMetricsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserActionMetricsOutput)
}

// UserActionMetricsArrayInput is an input type that accepts UserActionMetricsArray and UserActionMetricsArrayOutput values.
// You can construct a concrete instance of `UserActionMetricsArrayInput` via:
//
//	UserActionMetricsArray{ UserActionMetricsArgs{...} }
type UserActionMetricsArrayInput interface {
	pulumi.Input

	ToUserActionMetricsArrayOutput() UserActionMetricsArrayOutput
	ToUserActionMetricsArrayOutputWithContext(context.Context) UserActionMetricsArrayOutput
}

type UserActionMetricsArray []UserActionMetricsInput

func (UserActionMetricsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*UserActionMetrics)(nil)).Elem()
}

func (i UserActionMetricsArray) ToUserActionMetricsArrayOutput() UserActionMetricsArrayOutput {
	return i.ToUserActionMetricsArrayOutputWithContext(context.Background())
}

func (i UserActionMetricsArray) ToUserActionMetricsArrayOutputWithContext(ctx context.Context) UserActionMetricsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserActionMetricsArrayOutput)
}

// UserActionMetricsMapInput is an input type that accepts UserActionMetricsMap and UserActionMetricsMapOutput values.
// You can construct a concrete instance of `UserActionMetricsMapInput` via:
//
//	UserActionMetricsMap{ "key": UserActionMetricsArgs{...} }
type UserActionMetricsMapInput interface {
	pulumi.Input

	ToUserActionMetricsMapOutput() UserActionMetricsMapOutput
	ToUserActionMetricsMapOutputWithContext(context.Context) UserActionMetricsMapOutput
}

type UserActionMetricsMap map[string]UserActionMetricsInput

func (UserActionMetricsMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*UserActionMetrics)(nil)).Elem()
}

func (i UserActionMetricsMap) ToUserActionMetricsMapOutput() UserActionMetricsMapOutput {
	return i.ToUserActionMetricsMapOutputWithContext(context.Background())
}

func (i UserActionMetricsMap) ToUserActionMetricsMapOutputWithContext(ctx context.Context) UserActionMetricsMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserActionMetricsMapOutput)
}

type UserActionMetricsOutput struct{ *pulumi.OutputState }

func (UserActionMetricsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UserActionMetrics)(nil)).Elem()
}

func (o UserActionMetricsOutput) ToUserActionMetricsOutput() UserActionMetricsOutput {
	return o
}

func (o UserActionMetricsOutput) ToUserActionMetricsOutputWithContext(ctx context.Context) UserActionMetricsOutput {
	return o
}

// Defines the fields that are used as dimensions. A dimension is a collection of reference information about a metric data point that is of interest to your business. Dimensions are parameters like "application", "type", "apdexCategory". For example, using "type" as a dimension allows you to split chart data based on the user action type.
func (o UserActionMetricsOutput) Dimensions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *UserActionMetrics) pulumi.StringArrayOutput { return v.Dimensions }).(pulumi.StringArrayOutput)
}

// This setting is enabled (`true`) or disabled (`false`)
func (o UserActionMetricsOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *UserActionMetrics) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// Defines the filters for the user action. Filters apply at the moment of extracting the data and only sessions that satisfy the filtering criteria will be used to extract the custom metrics. You will not be able to modify these filters in the metric data explorer. For example, using "type equals Xhr" will give you only data from xhr actions, while forcing the rest of user actions of different types to be ignored.
func (o UserActionMetricsOutput) Filters() UserActionMetricsFiltersPtrOutput {
	return o.ApplyT(func(v *UserActionMetrics) UserActionMetricsFiltersPtrOutput { return v.Filters }).(UserActionMetricsFiltersPtrOutput)
}

// Metric key
func (o UserActionMetricsOutput) MetricKey() pulumi.StringOutput {
	return o.ApplyT(func(v *UserActionMetrics) pulumi.StringOutput { return v.MetricKey }).(pulumi.StringOutput)
}

// Defines the type of value to be extracted from the user action. When using **user action counter**, the number of user actions is counted (similar to count(*) when using USQL). When using **user action field value**, the value of a user action field is extracted.
func (o UserActionMetricsOutput) Value() UserActionMetricsValueOutput {
	return o.ApplyT(func(v *UserActionMetrics) UserActionMetricsValueOutput { return v.Value }).(UserActionMetricsValueOutput)
}

type UserActionMetricsArrayOutput struct{ *pulumi.OutputState }

func (UserActionMetricsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*UserActionMetrics)(nil)).Elem()
}

func (o UserActionMetricsArrayOutput) ToUserActionMetricsArrayOutput() UserActionMetricsArrayOutput {
	return o
}

func (o UserActionMetricsArrayOutput) ToUserActionMetricsArrayOutputWithContext(ctx context.Context) UserActionMetricsArrayOutput {
	return o
}

func (o UserActionMetricsArrayOutput) Index(i pulumi.IntInput) UserActionMetricsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *UserActionMetrics {
		return vs[0].([]*UserActionMetrics)[vs[1].(int)]
	}).(UserActionMetricsOutput)
}

type UserActionMetricsMapOutput struct{ *pulumi.OutputState }

func (UserActionMetricsMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*UserActionMetrics)(nil)).Elem()
}

func (o UserActionMetricsMapOutput) ToUserActionMetricsMapOutput() UserActionMetricsMapOutput {
	return o
}

func (o UserActionMetricsMapOutput) ToUserActionMetricsMapOutputWithContext(ctx context.Context) UserActionMetricsMapOutput {
	return o
}

func (o UserActionMetricsMapOutput) MapIndex(k pulumi.StringInput) UserActionMetricsOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *UserActionMetrics {
		return vs[0].(map[string]*UserActionMetrics)[vs[1].(string)]
	}).(UserActionMetricsOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*UserActionMetricsInput)(nil)).Elem(), &UserActionMetrics{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserActionMetricsArrayInput)(nil)).Elem(), UserActionMetricsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserActionMetricsMapInput)(nil)).Elem(), UserActionMetricsMap{})
	pulumi.RegisterOutputType(UserActionMetricsOutput{})
	pulumi.RegisterOutputType(UserActionMetricsArrayOutput{})
	pulumi.RegisterOutputType(UserActionMetricsMapOutput{})
}
