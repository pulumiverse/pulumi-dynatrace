// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type AttackRules struct {
	pulumi.CustomResourceState

	// Step 1: Select attack protection behavior
	AttackHandling AttackRulesAttackHandlingOutput `pulumi:"attackHandling"`
	// Step 2: Select attack type
	Criteria AttackRulesCriteriaOutput `pulumi:"criteria"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringOutput `pulumi:"insertAfter"`
	// Step 4: Leave comment (optional)
	Metadata AttackRulesMetadataOutput `pulumi:"metadata"`
	// If you add more than one condition, note that all conditions must be true simultaneously for the rule to apply.
	ResourceAttributeConditions AttackRulesResourceAttributeConditionsPtrOutput `pulumi:"resourceAttributeConditions"`
	// Rule name
	RuleName pulumi.StringPtrOutput `pulumi:"ruleName"`
}

// NewAttackRules registers a new resource with the given unique name, arguments, and options.
func NewAttackRules(ctx *pulumi.Context,
	name string, args *AttackRulesArgs, opts ...pulumi.ResourceOption) (*AttackRules, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AttackHandling == nil {
		return nil, errors.New("invalid value for required argument 'AttackHandling'")
	}
	if args.Criteria == nil {
		return nil, errors.New("invalid value for required argument 'Criteria'")
	}
	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.Metadata == nil {
		return nil, errors.New("invalid value for required argument 'Metadata'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AttackRules
	err := ctx.RegisterResource("dynatrace:index/attackRules:AttackRules", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAttackRules gets an existing AttackRules resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAttackRules(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AttackRulesState, opts ...pulumi.ResourceOption) (*AttackRules, error) {
	var resource AttackRules
	err := ctx.ReadResource("dynatrace:index/attackRules:AttackRules", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AttackRules resources.
type attackRulesState struct {
	// Step 1: Select attack protection behavior
	AttackHandling *AttackRulesAttackHandling `pulumi:"attackHandling"`
	// Step 2: Select attack type
	Criteria *AttackRulesCriteria `pulumi:"criteria"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Step 4: Leave comment (optional)
	Metadata *AttackRulesMetadata `pulumi:"metadata"`
	// If you add more than one condition, note that all conditions must be true simultaneously for the rule to apply.
	ResourceAttributeConditions *AttackRulesResourceAttributeConditions `pulumi:"resourceAttributeConditions"`
	// Rule name
	RuleName *string `pulumi:"ruleName"`
}

type AttackRulesState struct {
	// Step 1: Select attack protection behavior
	AttackHandling AttackRulesAttackHandlingPtrInput
	// Step 2: Select attack type
	Criteria AttackRulesCriteriaPtrInput
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolPtrInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Step 4: Leave comment (optional)
	Metadata AttackRulesMetadataPtrInput
	// If you add more than one condition, note that all conditions must be true simultaneously for the rule to apply.
	ResourceAttributeConditions AttackRulesResourceAttributeConditionsPtrInput
	// Rule name
	RuleName pulumi.StringPtrInput
}

func (AttackRulesState) ElementType() reflect.Type {
	return reflect.TypeOf((*attackRulesState)(nil)).Elem()
}

type attackRulesArgs struct {
	// Step 1: Select attack protection behavior
	AttackHandling AttackRulesAttackHandling `pulumi:"attackHandling"`
	// Step 2: Select attack type
	Criteria AttackRulesCriteria `pulumi:"criteria"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled bool `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Step 4: Leave comment (optional)
	Metadata AttackRulesMetadata `pulumi:"metadata"`
	// If you add more than one condition, note that all conditions must be true simultaneously for the rule to apply.
	ResourceAttributeConditions *AttackRulesResourceAttributeConditions `pulumi:"resourceAttributeConditions"`
	// Rule name
	RuleName *string `pulumi:"ruleName"`
}

// The set of arguments for constructing a AttackRules resource.
type AttackRulesArgs struct {
	// Step 1: Select attack protection behavior
	AttackHandling AttackRulesAttackHandlingInput
	// Step 2: Select attack type
	Criteria AttackRulesCriteriaInput
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Step 4: Leave comment (optional)
	Metadata AttackRulesMetadataInput
	// If you add more than one condition, note that all conditions must be true simultaneously for the rule to apply.
	ResourceAttributeConditions AttackRulesResourceAttributeConditionsPtrInput
	// Rule name
	RuleName pulumi.StringPtrInput
}

func (AttackRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*attackRulesArgs)(nil)).Elem()
}

type AttackRulesInput interface {
	pulumi.Input

	ToAttackRulesOutput() AttackRulesOutput
	ToAttackRulesOutputWithContext(ctx context.Context) AttackRulesOutput
}

func (*AttackRules) ElementType() reflect.Type {
	return reflect.TypeOf((**AttackRules)(nil)).Elem()
}

func (i *AttackRules) ToAttackRulesOutput() AttackRulesOutput {
	return i.ToAttackRulesOutputWithContext(context.Background())
}

func (i *AttackRules) ToAttackRulesOutputWithContext(ctx context.Context) AttackRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttackRulesOutput)
}

// AttackRulesArrayInput is an input type that accepts AttackRulesArray and AttackRulesArrayOutput values.
// You can construct a concrete instance of `AttackRulesArrayInput` via:
//
//	AttackRulesArray{ AttackRulesArgs{...} }
type AttackRulesArrayInput interface {
	pulumi.Input

	ToAttackRulesArrayOutput() AttackRulesArrayOutput
	ToAttackRulesArrayOutputWithContext(context.Context) AttackRulesArrayOutput
}

type AttackRulesArray []AttackRulesInput

func (AttackRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AttackRules)(nil)).Elem()
}

func (i AttackRulesArray) ToAttackRulesArrayOutput() AttackRulesArrayOutput {
	return i.ToAttackRulesArrayOutputWithContext(context.Background())
}

func (i AttackRulesArray) ToAttackRulesArrayOutputWithContext(ctx context.Context) AttackRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttackRulesArrayOutput)
}

// AttackRulesMapInput is an input type that accepts AttackRulesMap and AttackRulesMapOutput values.
// You can construct a concrete instance of `AttackRulesMapInput` via:
//
//	AttackRulesMap{ "key": AttackRulesArgs{...} }
type AttackRulesMapInput interface {
	pulumi.Input

	ToAttackRulesMapOutput() AttackRulesMapOutput
	ToAttackRulesMapOutputWithContext(context.Context) AttackRulesMapOutput
}

type AttackRulesMap map[string]AttackRulesInput

func (AttackRulesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AttackRules)(nil)).Elem()
}

func (i AttackRulesMap) ToAttackRulesMapOutput() AttackRulesMapOutput {
	return i.ToAttackRulesMapOutputWithContext(context.Background())
}

func (i AttackRulesMap) ToAttackRulesMapOutputWithContext(ctx context.Context) AttackRulesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttackRulesMapOutput)
}

type AttackRulesOutput struct{ *pulumi.OutputState }

func (AttackRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AttackRules)(nil)).Elem()
}

func (o AttackRulesOutput) ToAttackRulesOutput() AttackRulesOutput {
	return o
}

func (o AttackRulesOutput) ToAttackRulesOutputWithContext(ctx context.Context) AttackRulesOutput {
	return o
}

// Step 1: Select attack protection behavior
func (o AttackRulesOutput) AttackHandling() AttackRulesAttackHandlingOutput {
	return o.ApplyT(func(v *AttackRules) AttackRulesAttackHandlingOutput { return v.AttackHandling }).(AttackRulesAttackHandlingOutput)
}

// Step 2: Select attack type
func (o AttackRulesOutput) Criteria() AttackRulesCriteriaOutput {
	return o.ApplyT(func(v *AttackRules) AttackRulesCriteriaOutput { return v.Criteria }).(AttackRulesCriteriaOutput)
}

// This setting is enabled (`true`) or disabled (`false`)
func (o AttackRulesOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *AttackRules) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
func (o AttackRulesOutput) InsertAfter() pulumi.StringOutput {
	return o.ApplyT(func(v *AttackRules) pulumi.StringOutput { return v.InsertAfter }).(pulumi.StringOutput)
}

// Step 4: Leave comment (optional)
func (o AttackRulesOutput) Metadata() AttackRulesMetadataOutput {
	return o.ApplyT(func(v *AttackRules) AttackRulesMetadataOutput { return v.Metadata }).(AttackRulesMetadataOutput)
}

// If you add more than one condition, note that all conditions must be true simultaneously for the rule to apply.
func (o AttackRulesOutput) ResourceAttributeConditions() AttackRulesResourceAttributeConditionsPtrOutput {
	return o.ApplyT(func(v *AttackRules) AttackRulesResourceAttributeConditionsPtrOutput {
		return v.ResourceAttributeConditions
	}).(AttackRulesResourceAttributeConditionsPtrOutput)
}

// Rule name
func (o AttackRulesOutput) RuleName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AttackRules) pulumi.StringPtrOutput { return v.RuleName }).(pulumi.StringPtrOutput)
}

type AttackRulesArrayOutput struct{ *pulumi.OutputState }

func (AttackRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AttackRules)(nil)).Elem()
}

func (o AttackRulesArrayOutput) ToAttackRulesArrayOutput() AttackRulesArrayOutput {
	return o
}

func (o AttackRulesArrayOutput) ToAttackRulesArrayOutputWithContext(ctx context.Context) AttackRulesArrayOutput {
	return o
}

func (o AttackRulesArrayOutput) Index(i pulumi.IntInput) AttackRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AttackRules {
		return vs[0].([]*AttackRules)[vs[1].(int)]
	}).(AttackRulesOutput)
}

type AttackRulesMapOutput struct{ *pulumi.OutputState }

func (AttackRulesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AttackRules)(nil)).Elem()
}

func (o AttackRulesMapOutput) ToAttackRulesMapOutput() AttackRulesMapOutput {
	return o
}

func (o AttackRulesMapOutput) ToAttackRulesMapOutputWithContext(ctx context.Context) AttackRulesMapOutput {
	return o
}

func (o AttackRulesMapOutput) MapIndex(k pulumi.StringInput) AttackRulesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AttackRules {
		return vs[0].(map[string]*AttackRules)[vs[1].(string)]
	}).(AttackRulesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AttackRulesInput)(nil)).Elem(), &AttackRules{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttackRulesArrayInput)(nil)).Elem(), AttackRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttackRulesMapInput)(nil)).Elem(), AttackRulesMap{})
	pulumi.RegisterOutputType(AttackRulesOutput{})
	pulumi.RegisterOutputType(AttackRulesArrayOutput{})
	pulumi.RegisterOutputType(AttackRulesMapOutput{})
}
