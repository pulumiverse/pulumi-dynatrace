// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type PgAlerting struct {
	pulumi.CustomResourceState

	// Possible Values: `ON_INSTANCE_COUNT_VIOLATION`, `ON_PGI_UNAVAILABILITY`
	AlertingMode pulumi.StringPtrOutput `pulumi:"alertingMode"`
	// Enable (`true`) or disable (`false`) process group availability monitoring
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// Open a new problem if the number of active process instances in the group is fewer than X
	MinimumInstanceThreshold pulumi.IntPtrOutput `pulumi:"minimumInstanceThreshold"`
	// The process group ID for availability monitoring
	ProcessGroup pulumi.StringOutput `pulumi:"processGroup"`
}

// NewPgAlerting registers a new resource with the given unique name, arguments, and options.
func NewPgAlerting(ctx *pulumi.Context,
	name string, args *PgAlertingArgs, opts ...pulumi.ResourceOption) (*PgAlerting, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.ProcessGroup == nil {
		return nil, errors.New("invalid value for required argument 'ProcessGroup'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource PgAlerting
	err := ctx.RegisterResource("dynatrace:index/pgAlerting:PgAlerting", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPgAlerting gets an existing PgAlerting resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPgAlerting(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PgAlertingState, opts ...pulumi.ResourceOption) (*PgAlerting, error) {
	var resource PgAlerting
	err := ctx.ReadResource("dynatrace:index/pgAlerting:PgAlerting", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering PgAlerting resources.
type pgAlertingState struct {
	// Possible Values: `ON_INSTANCE_COUNT_VIOLATION`, `ON_PGI_UNAVAILABILITY`
	AlertingMode *string `pulumi:"alertingMode"`
	// Enable (`true`) or disable (`false`) process group availability monitoring
	Enabled *bool `pulumi:"enabled"`
	// Open a new problem if the number of active process instances in the group is fewer than X
	MinimumInstanceThreshold *int `pulumi:"minimumInstanceThreshold"`
	// The process group ID for availability monitoring
	ProcessGroup *string `pulumi:"processGroup"`
}

type PgAlertingState struct {
	// Possible Values: `ON_INSTANCE_COUNT_VIOLATION`, `ON_PGI_UNAVAILABILITY`
	AlertingMode pulumi.StringPtrInput
	// Enable (`true`) or disable (`false`) process group availability monitoring
	Enabled pulumi.BoolPtrInput
	// Open a new problem if the number of active process instances in the group is fewer than X
	MinimumInstanceThreshold pulumi.IntPtrInput
	// The process group ID for availability monitoring
	ProcessGroup pulumi.StringPtrInput
}

func (PgAlertingState) ElementType() reflect.Type {
	return reflect.TypeOf((*pgAlertingState)(nil)).Elem()
}

type pgAlertingArgs struct {
	// Possible Values: `ON_INSTANCE_COUNT_VIOLATION`, `ON_PGI_UNAVAILABILITY`
	AlertingMode *string `pulumi:"alertingMode"`
	// Enable (`true`) or disable (`false`) process group availability monitoring
	Enabled bool `pulumi:"enabled"`
	// Open a new problem if the number of active process instances in the group is fewer than X
	MinimumInstanceThreshold *int `pulumi:"minimumInstanceThreshold"`
	// The process group ID for availability monitoring
	ProcessGroup string `pulumi:"processGroup"`
}

// The set of arguments for constructing a PgAlerting resource.
type PgAlertingArgs struct {
	// Possible Values: `ON_INSTANCE_COUNT_VIOLATION`, `ON_PGI_UNAVAILABILITY`
	AlertingMode pulumi.StringPtrInput
	// Enable (`true`) or disable (`false`) process group availability monitoring
	Enabled pulumi.BoolInput
	// Open a new problem if the number of active process instances in the group is fewer than X
	MinimumInstanceThreshold pulumi.IntPtrInput
	// The process group ID for availability monitoring
	ProcessGroup pulumi.StringInput
}

func (PgAlertingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*pgAlertingArgs)(nil)).Elem()
}

type PgAlertingInput interface {
	pulumi.Input

	ToPgAlertingOutput() PgAlertingOutput
	ToPgAlertingOutputWithContext(ctx context.Context) PgAlertingOutput
}

func (*PgAlerting) ElementType() reflect.Type {
	return reflect.TypeOf((**PgAlerting)(nil)).Elem()
}

func (i *PgAlerting) ToPgAlertingOutput() PgAlertingOutput {
	return i.ToPgAlertingOutputWithContext(context.Background())
}

func (i *PgAlerting) ToPgAlertingOutputWithContext(ctx context.Context) PgAlertingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PgAlertingOutput)
}

// PgAlertingArrayInput is an input type that accepts PgAlertingArray and PgAlertingArrayOutput values.
// You can construct a concrete instance of `PgAlertingArrayInput` via:
//
//	PgAlertingArray{ PgAlertingArgs{...} }
type PgAlertingArrayInput interface {
	pulumi.Input

	ToPgAlertingArrayOutput() PgAlertingArrayOutput
	ToPgAlertingArrayOutputWithContext(context.Context) PgAlertingArrayOutput
}

type PgAlertingArray []PgAlertingInput

func (PgAlertingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PgAlerting)(nil)).Elem()
}

func (i PgAlertingArray) ToPgAlertingArrayOutput() PgAlertingArrayOutput {
	return i.ToPgAlertingArrayOutputWithContext(context.Background())
}

func (i PgAlertingArray) ToPgAlertingArrayOutputWithContext(ctx context.Context) PgAlertingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PgAlertingArrayOutput)
}

// PgAlertingMapInput is an input type that accepts PgAlertingMap and PgAlertingMapOutput values.
// You can construct a concrete instance of `PgAlertingMapInput` via:
//
//	PgAlertingMap{ "key": PgAlertingArgs{...} }
type PgAlertingMapInput interface {
	pulumi.Input

	ToPgAlertingMapOutput() PgAlertingMapOutput
	ToPgAlertingMapOutputWithContext(context.Context) PgAlertingMapOutput
}

type PgAlertingMap map[string]PgAlertingInput

func (PgAlertingMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PgAlerting)(nil)).Elem()
}

func (i PgAlertingMap) ToPgAlertingMapOutput() PgAlertingMapOutput {
	return i.ToPgAlertingMapOutputWithContext(context.Background())
}

func (i PgAlertingMap) ToPgAlertingMapOutputWithContext(ctx context.Context) PgAlertingMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PgAlertingMapOutput)
}

type PgAlertingOutput struct{ *pulumi.OutputState }

func (PgAlertingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PgAlerting)(nil)).Elem()
}

func (o PgAlertingOutput) ToPgAlertingOutput() PgAlertingOutput {
	return o
}

func (o PgAlertingOutput) ToPgAlertingOutputWithContext(ctx context.Context) PgAlertingOutput {
	return o
}

// Possible Values: `ON_INSTANCE_COUNT_VIOLATION`, `ON_PGI_UNAVAILABILITY`
func (o PgAlertingOutput) AlertingMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PgAlerting) pulumi.StringPtrOutput { return v.AlertingMode }).(pulumi.StringPtrOutput)
}

// Enable (`true`) or disable (`false`) process group availability monitoring
func (o PgAlertingOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *PgAlerting) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// Open a new problem if the number of active process instances in the group is fewer than X
func (o PgAlertingOutput) MinimumInstanceThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PgAlerting) pulumi.IntPtrOutput { return v.MinimumInstanceThreshold }).(pulumi.IntPtrOutput)
}

// The process group ID for availability monitoring
func (o PgAlertingOutput) ProcessGroup() pulumi.StringOutput {
	return o.ApplyT(func(v *PgAlerting) pulumi.StringOutput { return v.ProcessGroup }).(pulumi.StringOutput)
}

type PgAlertingArrayOutput struct{ *pulumi.OutputState }

func (PgAlertingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PgAlerting)(nil)).Elem()
}

func (o PgAlertingArrayOutput) ToPgAlertingArrayOutput() PgAlertingArrayOutput {
	return o
}

func (o PgAlertingArrayOutput) ToPgAlertingArrayOutputWithContext(ctx context.Context) PgAlertingArrayOutput {
	return o
}

func (o PgAlertingArrayOutput) Index(i pulumi.IntInput) PgAlertingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *PgAlerting {
		return vs[0].([]*PgAlerting)[vs[1].(int)]
	}).(PgAlertingOutput)
}

type PgAlertingMapOutput struct{ *pulumi.OutputState }

func (PgAlertingMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PgAlerting)(nil)).Elem()
}

func (o PgAlertingMapOutput) ToPgAlertingMapOutput() PgAlertingMapOutput {
	return o
}

func (o PgAlertingMapOutput) ToPgAlertingMapOutputWithContext(ctx context.Context) PgAlertingMapOutput {
	return o
}

func (o PgAlertingMapOutput) MapIndex(k pulumi.StringInput) PgAlertingOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *PgAlerting {
		return vs[0].(map[string]*PgAlerting)[vs[1].(string)]
	}).(PgAlertingOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PgAlertingInput)(nil)).Elem(), &PgAlerting{})
	pulumi.RegisterInputType(reflect.TypeOf((*PgAlertingArrayInput)(nil)).Elem(), PgAlertingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PgAlertingMapInput)(nil)).Elem(), PgAlertingMap{})
	pulumi.RegisterOutputType(PgAlertingOutput{})
	pulumi.RegisterOutputType(PgAlertingArrayOutput{})
	pulumi.RegisterOutputType(PgAlertingMapOutput{})
}
