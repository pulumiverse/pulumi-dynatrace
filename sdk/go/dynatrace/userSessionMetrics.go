// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type UserSessionMetrics struct {
	pulumi.CustomResourceState

	// Defines the fields that are used as dimensions. A dimension is a collection of reference information about a metric data point that is of interest to your business. Dimensions are parameters like "browserFamily", "userType", "country". For example, using "userType" as a dimension allows you to split chart data based on user types.
	Dimensions pulumi.StringArrayOutput `pulumi:"dimensions"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// Defines the filters for the user session. Filters apply at the moment of extracting the data and only sessions that satisfy the filtering criteria will be used to extract the custom metrics. You will not be able to modify these filters in the metric data explorer. For example, using "userType equals REAL_USER" will give you only data from real users, while forcing the synthetic sessions to be ignored.
	Filters UserSessionMetricsFiltersPtrOutput `pulumi:"filters"`
	// Metric key
	MetricKey pulumi.StringOutput `pulumi:"metricKey"`
	// Defines the type of value to be extracted from the user session. When using **User session counter**, the number of user sessions is counted (similar to count(*) when using USQL). When using **User session field value**, the value of a user session field is extracted.
	Value UserSessionMetricsValueOutput `pulumi:"value"`
}

// NewUserSessionMetrics registers a new resource with the given unique name, arguments, and options.
func NewUserSessionMetrics(ctx *pulumi.Context,
	name string, args *UserSessionMetricsArgs, opts ...pulumi.ResourceOption) (*UserSessionMetrics, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.MetricKey == nil {
		return nil, errors.New("invalid value for required argument 'MetricKey'")
	}
	if args.Value == nil {
		return nil, errors.New("invalid value for required argument 'Value'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource UserSessionMetrics
	err := ctx.RegisterResource("dynatrace:index/userSessionMetrics:UserSessionMetrics", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetUserSessionMetrics gets an existing UserSessionMetrics resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetUserSessionMetrics(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *UserSessionMetricsState, opts ...pulumi.ResourceOption) (*UserSessionMetrics, error) {
	var resource UserSessionMetrics
	err := ctx.ReadResource("dynatrace:index/userSessionMetrics:UserSessionMetrics", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering UserSessionMetrics resources.
type userSessionMetricsState struct {
	// Defines the fields that are used as dimensions. A dimension is a collection of reference information about a metric data point that is of interest to your business. Dimensions are parameters like "browserFamily", "userType", "country". For example, using "userType" as a dimension allows you to split chart data based on user types.
	Dimensions []string `pulumi:"dimensions"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `pulumi:"enabled"`
	// Defines the filters for the user session. Filters apply at the moment of extracting the data and only sessions that satisfy the filtering criteria will be used to extract the custom metrics. You will not be able to modify these filters in the metric data explorer. For example, using "userType equals REAL_USER" will give you only data from real users, while forcing the synthetic sessions to be ignored.
	Filters *UserSessionMetricsFilters `pulumi:"filters"`
	// Metric key
	MetricKey *string `pulumi:"metricKey"`
	// Defines the type of value to be extracted from the user session. When using **User session counter**, the number of user sessions is counted (similar to count(*) when using USQL). When using **User session field value**, the value of a user session field is extracted.
	Value *UserSessionMetricsValue `pulumi:"value"`
}

type UserSessionMetricsState struct {
	// Defines the fields that are used as dimensions. A dimension is a collection of reference information about a metric data point that is of interest to your business. Dimensions are parameters like "browserFamily", "userType", "country". For example, using "userType" as a dimension allows you to split chart data based on user types.
	Dimensions pulumi.StringArrayInput
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolPtrInput
	// Defines the filters for the user session. Filters apply at the moment of extracting the data and only sessions that satisfy the filtering criteria will be used to extract the custom metrics. You will not be able to modify these filters in the metric data explorer. For example, using "userType equals REAL_USER" will give you only data from real users, while forcing the synthetic sessions to be ignored.
	Filters UserSessionMetricsFiltersPtrInput
	// Metric key
	MetricKey pulumi.StringPtrInput
	// Defines the type of value to be extracted from the user session. When using **User session counter**, the number of user sessions is counted (similar to count(*) when using USQL). When using **User session field value**, the value of a user session field is extracted.
	Value UserSessionMetricsValuePtrInput
}

func (UserSessionMetricsState) ElementType() reflect.Type {
	return reflect.TypeOf((*userSessionMetricsState)(nil)).Elem()
}

type userSessionMetricsArgs struct {
	// Defines the fields that are used as dimensions. A dimension is a collection of reference information about a metric data point that is of interest to your business. Dimensions are parameters like "browserFamily", "userType", "country". For example, using "userType" as a dimension allows you to split chart data based on user types.
	Dimensions []string `pulumi:"dimensions"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled bool `pulumi:"enabled"`
	// Defines the filters for the user session. Filters apply at the moment of extracting the data and only sessions that satisfy the filtering criteria will be used to extract the custom metrics. You will not be able to modify these filters in the metric data explorer. For example, using "userType equals REAL_USER" will give you only data from real users, while forcing the synthetic sessions to be ignored.
	Filters *UserSessionMetricsFilters `pulumi:"filters"`
	// Metric key
	MetricKey string `pulumi:"metricKey"`
	// Defines the type of value to be extracted from the user session. When using **User session counter**, the number of user sessions is counted (similar to count(*) when using USQL). When using **User session field value**, the value of a user session field is extracted.
	Value UserSessionMetricsValue `pulumi:"value"`
}

// The set of arguments for constructing a UserSessionMetrics resource.
type UserSessionMetricsArgs struct {
	// Defines the fields that are used as dimensions. A dimension is a collection of reference information about a metric data point that is of interest to your business. Dimensions are parameters like "browserFamily", "userType", "country". For example, using "userType" as a dimension allows you to split chart data based on user types.
	Dimensions pulumi.StringArrayInput
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolInput
	// Defines the filters for the user session. Filters apply at the moment of extracting the data and only sessions that satisfy the filtering criteria will be used to extract the custom metrics. You will not be able to modify these filters in the metric data explorer. For example, using "userType equals REAL_USER" will give you only data from real users, while forcing the synthetic sessions to be ignored.
	Filters UserSessionMetricsFiltersPtrInput
	// Metric key
	MetricKey pulumi.StringInput
	// Defines the type of value to be extracted from the user session. When using **User session counter**, the number of user sessions is counted (similar to count(*) when using USQL). When using **User session field value**, the value of a user session field is extracted.
	Value UserSessionMetricsValueInput
}

func (UserSessionMetricsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*userSessionMetricsArgs)(nil)).Elem()
}

type UserSessionMetricsInput interface {
	pulumi.Input

	ToUserSessionMetricsOutput() UserSessionMetricsOutput
	ToUserSessionMetricsOutputWithContext(ctx context.Context) UserSessionMetricsOutput
}

func (*UserSessionMetrics) ElementType() reflect.Type {
	return reflect.TypeOf((**UserSessionMetrics)(nil)).Elem()
}

func (i *UserSessionMetrics) ToUserSessionMetricsOutput() UserSessionMetricsOutput {
	return i.ToUserSessionMetricsOutputWithContext(context.Background())
}

func (i *UserSessionMetrics) ToUserSessionMetricsOutputWithContext(ctx context.Context) UserSessionMetricsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserSessionMetricsOutput)
}

// UserSessionMetricsArrayInput is an input type that accepts UserSessionMetricsArray and UserSessionMetricsArrayOutput values.
// You can construct a concrete instance of `UserSessionMetricsArrayInput` via:
//
//	UserSessionMetricsArray{ UserSessionMetricsArgs{...} }
type UserSessionMetricsArrayInput interface {
	pulumi.Input

	ToUserSessionMetricsArrayOutput() UserSessionMetricsArrayOutput
	ToUserSessionMetricsArrayOutputWithContext(context.Context) UserSessionMetricsArrayOutput
}

type UserSessionMetricsArray []UserSessionMetricsInput

func (UserSessionMetricsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*UserSessionMetrics)(nil)).Elem()
}

func (i UserSessionMetricsArray) ToUserSessionMetricsArrayOutput() UserSessionMetricsArrayOutput {
	return i.ToUserSessionMetricsArrayOutputWithContext(context.Background())
}

func (i UserSessionMetricsArray) ToUserSessionMetricsArrayOutputWithContext(ctx context.Context) UserSessionMetricsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserSessionMetricsArrayOutput)
}

// UserSessionMetricsMapInput is an input type that accepts UserSessionMetricsMap and UserSessionMetricsMapOutput values.
// You can construct a concrete instance of `UserSessionMetricsMapInput` via:
//
//	UserSessionMetricsMap{ "key": UserSessionMetricsArgs{...} }
type UserSessionMetricsMapInput interface {
	pulumi.Input

	ToUserSessionMetricsMapOutput() UserSessionMetricsMapOutput
	ToUserSessionMetricsMapOutputWithContext(context.Context) UserSessionMetricsMapOutput
}

type UserSessionMetricsMap map[string]UserSessionMetricsInput

func (UserSessionMetricsMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*UserSessionMetrics)(nil)).Elem()
}

func (i UserSessionMetricsMap) ToUserSessionMetricsMapOutput() UserSessionMetricsMapOutput {
	return i.ToUserSessionMetricsMapOutputWithContext(context.Background())
}

func (i UserSessionMetricsMap) ToUserSessionMetricsMapOutputWithContext(ctx context.Context) UserSessionMetricsMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserSessionMetricsMapOutput)
}

type UserSessionMetricsOutput struct{ *pulumi.OutputState }

func (UserSessionMetricsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UserSessionMetrics)(nil)).Elem()
}

func (o UserSessionMetricsOutput) ToUserSessionMetricsOutput() UserSessionMetricsOutput {
	return o
}

func (o UserSessionMetricsOutput) ToUserSessionMetricsOutputWithContext(ctx context.Context) UserSessionMetricsOutput {
	return o
}

// Defines the fields that are used as dimensions. A dimension is a collection of reference information about a metric data point that is of interest to your business. Dimensions are parameters like "browserFamily", "userType", "country". For example, using "userType" as a dimension allows you to split chart data based on user types.
func (o UserSessionMetricsOutput) Dimensions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *UserSessionMetrics) pulumi.StringArrayOutput { return v.Dimensions }).(pulumi.StringArrayOutput)
}

// This setting is enabled (`true`) or disabled (`false`)
func (o UserSessionMetricsOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *UserSessionMetrics) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// Defines the filters for the user session. Filters apply at the moment of extracting the data and only sessions that satisfy the filtering criteria will be used to extract the custom metrics. You will not be able to modify these filters in the metric data explorer. For example, using "userType equals REAL_USER" will give you only data from real users, while forcing the synthetic sessions to be ignored.
func (o UserSessionMetricsOutput) Filters() UserSessionMetricsFiltersPtrOutput {
	return o.ApplyT(func(v *UserSessionMetrics) UserSessionMetricsFiltersPtrOutput { return v.Filters }).(UserSessionMetricsFiltersPtrOutput)
}

// Metric key
func (o UserSessionMetricsOutput) MetricKey() pulumi.StringOutput {
	return o.ApplyT(func(v *UserSessionMetrics) pulumi.StringOutput { return v.MetricKey }).(pulumi.StringOutput)
}

// Defines the type of value to be extracted from the user session. When using **User session counter**, the number of user sessions is counted (similar to count(*) when using USQL). When using **User session field value**, the value of a user session field is extracted.
func (o UserSessionMetricsOutput) Value() UserSessionMetricsValueOutput {
	return o.ApplyT(func(v *UserSessionMetrics) UserSessionMetricsValueOutput { return v.Value }).(UserSessionMetricsValueOutput)
}

type UserSessionMetricsArrayOutput struct{ *pulumi.OutputState }

func (UserSessionMetricsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*UserSessionMetrics)(nil)).Elem()
}

func (o UserSessionMetricsArrayOutput) ToUserSessionMetricsArrayOutput() UserSessionMetricsArrayOutput {
	return o
}

func (o UserSessionMetricsArrayOutput) ToUserSessionMetricsArrayOutputWithContext(ctx context.Context) UserSessionMetricsArrayOutput {
	return o
}

func (o UserSessionMetricsArrayOutput) Index(i pulumi.IntInput) UserSessionMetricsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *UserSessionMetrics {
		return vs[0].([]*UserSessionMetrics)[vs[1].(int)]
	}).(UserSessionMetricsOutput)
}

type UserSessionMetricsMapOutput struct{ *pulumi.OutputState }

func (UserSessionMetricsMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*UserSessionMetrics)(nil)).Elem()
}

func (o UserSessionMetricsMapOutput) ToUserSessionMetricsMapOutput() UserSessionMetricsMapOutput {
	return o
}

func (o UserSessionMetricsMapOutput) ToUserSessionMetricsMapOutputWithContext(ctx context.Context) UserSessionMetricsMapOutput {
	return o
}

func (o UserSessionMetricsMapOutput) MapIndex(k pulumi.StringInput) UserSessionMetricsOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *UserSessionMetrics {
		return vs[0].(map[string]*UserSessionMetrics)[vs[1].(string)]
	}).(UserSessionMetricsOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*UserSessionMetricsInput)(nil)).Elem(), &UserSessionMetrics{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserSessionMetricsArrayInput)(nil)).Elem(), UserSessionMetricsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserSessionMetricsMapInput)(nil)).Elem(), UserSessionMetricsMap{})
	pulumi.RegisterOutputType(UserSessionMetricsOutput{})
	pulumi.RegisterOutputType(UserSessionMetricsArrayOutput{})
	pulumi.RegisterOutputType(UserSessionMetricsMapOutput{})
}
