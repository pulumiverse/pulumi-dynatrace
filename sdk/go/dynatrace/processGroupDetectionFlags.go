// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type ProcessGroupDetectionFlags struct {
	pulumi.CustomResourceState

	// In older versions, Node.js applications were distinguished based on their directory name, omitting the script name. Changing this setting may change the general handling of Node.js process groups. Leave unchanged if in doubt.
	AddNodeJsScriptName pulumi.BoolOutput `pulumi:"addNodeJsScriptName"`
	// Enabling this flag will detect separate Cassandra process groups based on the configured Cassandra cluster name.
	AutoDetectCassandraClusters pulumi.BoolOutput `pulumi:"autoDetectCassandraClusters"`
	// Enabling this flag will detect Spring Boot process groups based on command line and applications' configuration files.
	AutoDetectSpringBoot pulumi.BoolOutput `pulumi:"autoDetectSpringBoot"`
	// Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
	AutoDetectTibcoContainerEditionEngines pulumi.BoolOutput `pulumi:"autoDetectTibcoContainerEditionEngines"`
	// Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
	AutoDetectTibcoEngines pulumi.BoolOutput `pulumi:"autoDetectTibcoEngines"`
	// Enabling this flag will detect webMethods Integration Server including specific properties like install root and product name.
	AutoDetectWebMethodsIntegrationServer pulumi.BoolOutput `pulumi:"autoDetectWebMethodsIntegrationServer"`
	// Enabling this flag will detect separate WebSphere Liberty process groups based on java command line.
	AutoDetectWebSphereLibertyApplication pulumi.BoolOutput `pulumi:"autoDetectWebSphereLibertyApplication"`
	// Enable to group and separately analyze the processes of each IBM MQ Queue manager instance. Each process group receives a unique name based on the queue manager instance name.
	GroupIbmmqbyInstanceName pulumi.BoolOutput `pulumi:"groupIbmmqbyInstanceName"`
	// Enabling this flag will detect the JBoss server name from the system property jboss.server.name=\n\n, only if -D[Server:\n\n] is not set.
	IdentifyJbossServerBySystemProperty pulumi.BoolOutput `pulumi:"identifyJbossServerBySystemProperty"`
	// To determine the unique identity of each detected process, and to generate a unique name for each detected process, Dynatrace evaluates the name of the directory that each process binary is contained within. For application containers like Tomcat and JBoss, Dynatrace evaluates important directories like CATALINA*HOME and JBOSS*HOME for this information. In some automated deployment scenarios such directory names are updated automatically with new version numbers, build numbers, dates, or GUIDs. Enable this setting to ensure that automated directory name changes don't result in Dynatrace registering pre-existing processes as new processes.
	IgnoreUniqueIdentifiers pulumi.BoolOutput `pulumi:"ignoreUniqueIdentifiers"`
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope pulumi.StringPtrOutput `pulumi:"scope"`
	// This flag enables the detection of security software such as anti-malware protection.
	SecuritySoftwareDetectionEnabled pulumi.BoolPtrOutput `pulumi:"securitySoftwareDetectionEnabled"`
	// Enable to monitor CPU and memory usage of short lived processes, otherwise being lost by traditional monitoring. Disabling this flag blocks passing data to cluster only, it does not stop data collection and has no effect on performance.
	ShortLivedProcessesMonitoring pulumi.BoolOutput `pulumi:"shortLivedProcessesMonitoring"`
	// Enable to group and separately analyze the processes of each Oracle DB. Each process group receives a unique name based on the Oracle DB SID.
	SplitOracleDatabasePg pulumi.BoolOutput `pulumi:"splitOracleDatabasePg"`
	// Enable to group and separately analyze the processes of each Oracle Listener. Each process group receives a unique name based on the Oracle Listener name.
	SplitOracleListenerPg pulumi.BoolOutput `pulumi:"splitOracleListenerPg"`
	// By default, Tomcat clusters are identified and named based on the CATALINA*HOME directory name. This setting results in the use of the CATALINA*BASE directory name to identify multiple Tomcat nodes within each Tomcat cluster. If this setting is not enabled, each CATALINA*HOME+CATALINA*BASE combination will be considered a separate Tomcat cluster. In other words, Tomcat clusters can't have multiple nodes on a single host.
	UseCatalinaBase pulumi.BoolOutput `pulumi:"useCatalinaBase"`
	// By default, Dynatrace uses image names as identifiers for individual process groups, with one process-group instance per host. Normally Docker container names can't serve as stable identifiers of process group instances because they are variable and auto-generated. You can however manually assign proper container names to their Docker instances. Such manually-assigned container names can serve as reliable process-group instance identifiers. This flag instructs Dynatrace to use Docker-provided names to distinguish between multiple instances of the same image. If this flag is not applied and you run multiple containers of the same image on the same host, the resulting processes will be consolidated into a single process view. Use this flag with caution!
	UseDockerContainerName pulumi.BoolOutput `pulumi:"useDockerContainerName"`
}

// NewProcessGroupDetectionFlags registers a new resource with the given unique name, arguments, and options.
func NewProcessGroupDetectionFlags(ctx *pulumi.Context,
	name string, args *ProcessGroupDetectionFlagsArgs, opts ...pulumi.ResourceOption) (*ProcessGroupDetectionFlags, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AddNodeJsScriptName == nil {
		return nil, errors.New("invalid value for required argument 'AddNodeJsScriptName'")
	}
	if args.AutoDetectCassandraClusters == nil {
		return nil, errors.New("invalid value for required argument 'AutoDetectCassandraClusters'")
	}
	if args.AutoDetectSpringBoot == nil {
		return nil, errors.New("invalid value for required argument 'AutoDetectSpringBoot'")
	}
	if args.AutoDetectTibcoContainerEditionEngines == nil {
		return nil, errors.New("invalid value for required argument 'AutoDetectTibcoContainerEditionEngines'")
	}
	if args.AutoDetectTibcoEngines == nil {
		return nil, errors.New("invalid value for required argument 'AutoDetectTibcoEngines'")
	}
	if args.AutoDetectWebMethodsIntegrationServer == nil {
		return nil, errors.New("invalid value for required argument 'AutoDetectWebMethodsIntegrationServer'")
	}
	if args.AutoDetectWebSphereLibertyApplication == nil {
		return nil, errors.New("invalid value for required argument 'AutoDetectWebSphereLibertyApplication'")
	}
	if args.GroupIbmmqbyInstanceName == nil {
		return nil, errors.New("invalid value for required argument 'GroupIbmmqbyInstanceName'")
	}
	if args.IdentifyJbossServerBySystemProperty == nil {
		return nil, errors.New("invalid value for required argument 'IdentifyJbossServerBySystemProperty'")
	}
	if args.IgnoreUniqueIdentifiers == nil {
		return nil, errors.New("invalid value for required argument 'IgnoreUniqueIdentifiers'")
	}
	if args.ShortLivedProcessesMonitoring == nil {
		return nil, errors.New("invalid value for required argument 'ShortLivedProcessesMonitoring'")
	}
	if args.SplitOracleDatabasePg == nil {
		return nil, errors.New("invalid value for required argument 'SplitOracleDatabasePg'")
	}
	if args.SplitOracleListenerPg == nil {
		return nil, errors.New("invalid value for required argument 'SplitOracleListenerPg'")
	}
	if args.UseCatalinaBase == nil {
		return nil, errors.New("invalid value for required argument 'UseCatalinaBase'")
	}
	if args.UseDockerContainerName == nil {
		return nil, errors.New("invalid value for required argument 'UseDockerContainerName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ProcessGroupDetectionFlags
	err := ctx.RegisterResource("dynatrace:index/processGroupDetectionFlags:ProcessGroupDetectionFlags", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetProcessGroupDetectionFlags gets an existing ProcessGroupDetectionFlags resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetProcessGroupDetectionFlags(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ProcessGroupDetectionFlagsState, opts ...pulumi.ResourceOption) (*ProcessGroupDetectionFlags, error) {
	var resource ProcessGroupDetectionFlags
	err := ctx.ReadResource("dynatrace:index/processGroupDetectionFlags:ProcessGroupDetectionFlags", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ProcessGroupDetectionFlags resources.
type processGroupDetectionFlagsState struct {
	// In older versions, Node.js applications were distinguished based on their directory name, omitting the script name. Changing this setting may change the general handling of Node.js process groups. Leave unchanged if in doubt.
	AddNodeJsScriptName *bool `pulumi:"addNodeJsScriptName"`
	// Enabling this flag will detect separate Cassandra process groups based on the configured Cassandra cluster name.
	AutoDetectCassandraClusters *bool `pulumi:"autoDetectCassandraClusters"`
	// Enabling this flag will detect Spring Boot process groups based on command line and applications' configuration files.
	AutoDetectSpringBoot *bool `pulumi:"autoDetectSpringBoot"`
	// Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
	AutoDetectTibcoContainerEditionEngines *bool `pulumi:"autoDetectTibcoContainerEditionEngines"`
	// Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
	AutoDetectTibcoEngines *bool `pulumi:"autoDetectTibcoEngines"`
	// Enabling this flag will detect webMethods Integration Server including specific properties like install root and product name.
	AutoDetectWebMethodsIntegrationServer *bool `pulumi:"autoDetectWebMethodsIntegrationServer"`
	// Enabling this flag will detect separate WebSphere Liberty process groups based on java command line.
	AutoDetectWebSphereLibertyApplication *bool `pulumi:"autoDetectWebSphereLibertyApplication"`
	// Enable to group and separately analyze the processes of each IBM MQ Queue manager instance. Each process group receives a unique name based on the queue manager instance name.
	GroupIbmmqbyInstanceName *bool `pulumi:"groupIbmmqbyInstanceName"`
	// Enabling this flag will detect the JBoss server name from the system property jboss.server.name=\n\n, only if -D[Server:\n\n] is not set.
	IdentifyJbossServerBySystemProperty *bool `pulumi:"identifyJbossServerBySystemProperty"`
	// To determine the unique identity of each detected process, and to generate a unique name for each detected process, Dynatrace evaluates the name of the directory that each process binary is contained within. For application containers like Tomcat and JBoss, Dynatrace evaluates important directories like CATALINA*HOME and JBOSS*HOME for this information. In some automated deployment scenarios such directory names are updated automatically with new version numbers, build numbers, dates, or GUIDs. Enable this setting to ensure that automated directory name changes don't result in Dynatrace registering pre-existing processes as new processes.
	IgnoreUniqueIdentifiers *bool `pulumi:"ignoreUniqueIdentifiers"`
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope *string `pulumi:"scope"`
	// This flag enables the detection of security software such as anti-malware protection.
	SecuritySoftwareDetectionEnabled *bool `pulumi:"securitySoftwareDetectionEnabled"`
	// Enable to monitor CPU and memory usage of short lived processes, otherwise being lost by traditional monitoring. Disabling this flag blocks passing data to cluster only, it does not stop data collection and has no effect on performance.
	ShortLivedProcessesMonitoring *bool `pulumi:"shortLivedProcessesMonitoring"`
	// Enable to group and separately analyze the processes of each Oracle DB. Each process group receives a unique name based on the Oracle DB SID.
	SplitOracleDatabasePg *bool `pulumi:"splitOracleDatabasePg"`
	// Enable to group and separately analyze the processes of each Oracle Listener. Each process group receives a unique name based on the Oracle Listener name.
	SplitOracleListenerPg *bool `pulumi:"splitOracleListenerPg"`
	// By default, Tomcat clusters are identified and named based on the CATALINA*HOME directory name. This setting results in the use of the CATALINA*BASE directory name to identify multiple Tomcat nodes within each Tomcat cluster. If this setting is not enabled, each CATALINA*HOME+CATALINA*BASE combination will be considered a separate Tomcat cluster. In other words, Tomcat clusters can't have multiple nodes on a single host.
	UseCatalinaBase *bool `pulumi:"useCatalinaBase"`
	// By default, Dynatrace uses image names as identifiers for individual process groups, with one process-group instance per host. Normally Docker container names can't serve as stable identifiers of process group instances because they are variable and auto-generated. You can however manually assign proper container names to their Docker instances. Such manually-assigned container names can serve as reliable process-group instance identifiers. This flag instructs Dynatrace to use Docker-provided names to distinguish between multiple instances of the same image. If this flag is not applied and you run multiple containers of the same image on the same host, the resulting processes will be consolidated into a single process view. Use this flag with caution!
	UseDockerContainerName *bool `pulumi:"useDockerContainerName"`
}

type ProcessGroupDetectionFlagsState struct {
	// In older versions, Node.js applications were distinguished based on their directory name, omitting the script name. Changing this setting may change the general handling of Node.js process groups. Leave unchanged if in doubt.
	AddNodeJsScriptName pulumi.BoolPtrInput
	// Enabling this flag will detect separate Cassandra process groups based on the configured Cassandra cluster name.
	AutoDetectCassandraClusters pulumi.BoolPtrInput
	// Enabling this flag will detect Spring Boot process groups based on command line and applications' configuration files.
	AutoDetectSpringBoot pulumi.BoolPtrInput
	// Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
	AutoDetectTibcoContainerEditionEngines pulumi.BoolPtrInput
	// Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
	AutoDetectTibcoEngines pulumi.BoolPtrInput
	// Enabling this flag will detect webMethods Integration Server including specific properties like install root and product name.
	AutoDetectWebMethodsIntegrationServer pulumi.BoolPtrInput
	// Enabling this flag will detect separate WebSphere Liberty process groups based on java command line.
	AutoDetectWebSphereLibertyApplication pulumi.BoolPtrInput
	// Enable to group and separately analyze the processes of each IBM MQ Queue manager instance. Each process group receives a unique name based on the queue manager instance name.
	GroupIbmmqbyInstanceName pulumi.BoolPtrInput
	// Enabling this flag will detect the JBoss server name from the system property jboss.server.name=\n\n, only if -D[Server:\n\n] is not set.
	IdentifyJbossServerBySystemProperty pulumi.BoolPtrInput
	// To determine the unique identity of each detected process, and to generate a unique name for each detected process, Dynatrace evaluates the name of the directory that each process binary is contained within. For application containers like Tomcat and JBoss, Dynatrace evaluates important directories like CATALINA*HOME and JBOSS*HOME for this information. In some automated deployment scenarios such directory names are updated automatically with new version numbers, build numbers, dates, or GUIDs. Enable this setting to ensure that automated directory name changes don't result in Dynatrace registering pre-existing processes as new processes.
	IgnoreUniqueIdentifiers pulumi.BoolPtrInput
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope pulumi.StringPtrInput
	// This flag enables the detection of security software such as anti-malware protection.
	SecuritySoftwareDetectionEnabled pulumi.BoolPtrInput
	// Enable to monitor CPU and memory usage of short lived processes, otherwise being lost by traditional monitoring. Disabling this flag blocks passing data to cluster only, it does not stop data collection and has no effect on performance.
	ShortLivedProcessesMonitoring pulumi.BoolPtrInput
	// Enable to group and separately analyze the processes of each Oracle DB. Each process group receives a unique name based on the Oracle DB SID.
	SplitOracleDatabasePg pulumi.BoolPtrInput
	// Enable to group and separately analyze the processes of each Oracle Listener. Each process group receives a unique name based on the Oracle Listener name.
	SplitOracleListenerPg pulumi.BoolPtrInput
	// By default, Tomcat clusters are identified and named based on the CATALINA*HOME directory name. This setting results in the use of the CATALINA*BASE directory name to identify multiple Tomcat nodes within each Tomcat cluster. If this setting is not enabled, each CATALINA*HOME+CATALINA*BASE combination will be considered a separate Tomcat cluster. In other words, Tomcat clusters can't have multiple nodes on a single host.
	UseCatalinaBase pulumi.BoolPtrInput
	// By default, Dynatrace uses image names as identifiers for individual process groups, with one process-group instance per host. Normally Docker container names can't serve as stable identifiers of process group instances because they are variable and auto-generated. You can however manually assign proper container names to their Docker instances. Such manually-assigned container names can serve as reliable process-group instance identifiers. This flag instructs Dynatrace to use Docker-provided names to distinguish between multiple instances of the same image. If this flag is not applied and you run multiple containers of the same image on the same host, the resulting processes will be consolidated into a single process view. Use this flag with caution!
	UseDockerContainerName pulumi.BoolPtrInput
}

func (ProcessGroupDetectionFlagsState) ElementType() reflect.Type {
	return reflect.TypeOf((*processGroupDetectionFlagsState)(nil)).Elem()
}

type processGroupDetectionFlagsArgs struct {
	// In older versions, Node.js applications were distinguished based on their directory name, omitting the script name. Changing this setting may change the general handling of Node.js process groups. Leave unchanged if in doubt.
	AddNodeJsScriptName bool `pulumi:"addNodeJsScriptName"`
	// Enabling this flag will detect separate Cassandra process groups based on the configured Cassandra cluster name.
	AutoDetectCassandraClusters bool `pulumi:"autoDetectCassandraClusters"`
	// Enabling this flag will detect Spring Boot process groups based on command line and applications' configuration files.
	AutoDetectSpringBoot bool `pulumi:"autoDetectSpringBoot"`
	// Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
	AutoDetectTibcoContainerEditionEngines bool `pulumi:"autoDetectTibcoContainerEditionEngines"`
	// Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
	AutoDetectTibcoEngines bool `pulumi:"autoDetectTibcoEngines"`
	// Enabling this flag will detect webMethods Integration Server including specific properties like install root and product name.
	AutoDetectWebMethodsIntegrationServer bool `pulumi:"autoDetectWebMethodsIntegrationServer"`
	// Enabling this flag will detect separate WebSphere Liberty process groups based on java command line.
	AutoDetectWebSphereLibertyApplication bool `pulumi:"autoDetectWebSphereLibertyApplication"`
	// Enable to group and separately analyze the processes of each IBM MQ Queue manager instance. Each process group receives a unique name based on the queue manager instance name.
	GroupIbmmqbyInstanceName bool `pulumi:"groupIbmmqbyInstanceName"`
	// Enabling this flag will detect the JBoss server name from the system property jboss.server.name=\n\n, only if -D[Server:\n\n] is not set.
	IdentifyJbossServerBySystemProperty bool `pulumi:"identifyJbossServerBySystemProperty"`
	// To determine the unique identity of each detected process, and to generate a unique name for each detected process, Dynatrace evaluates the name of the directory that each process binary is contained within. For application containers like Tomcat and JBoss, Dynatrace evaluates important directories like CATALINA*HOME and JBOSS*HOME for this information. In some automated deployment scenarios such directory names are updated automatically with new version numbers, build numbers, dates, or GUIDs. Enable this setting to ensure that automated directory name changes don't result in Dynatrace registering pre-existing processes as new processes.
	IgnoreUniqueIdentifiers bool `pulumi:"ignoreUniqueIdentifiers"`
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope *string `pulumi:"scope"`
	// This flag enables the detection of security software such as anti-malware protection.
	SecuritySoftwareDetectionEnabled *bool `pulumi:"securitySoftwareDetectionEnabled"`
	// Enable to monitor CPU and memory usage of short lived processes, otherwise being lost by traditional monitoring. Disabling this flag blocks passing data to cluster only, it does not stop data collection and has no effect on performance.
	ShortLivedProcessesMonitoring bool `pulumi:"shortLivedProcessesMonitoring"`
	// Enable to group and separately analyze the processes of each Oracle DB. Each process group receives a unique name based on the Oracle DB SID.
	SplitOracleDatabasePg bool `pulumi:"splitOracleDatabasePg"`
	// Enable to group and separately analyze the processes of each Oracle Listener. Each process group receives a unique name based on the Oracle Listener name.
	SplitOracleListenerPg bool `pulumi:"splitOracleListenerPg"`
	// By default, Tomcat clusters are identified and named based on the CATALINA*HOME directory name. This setting results in the use of the CATALINA*BASE directory name to identify multiple Tomcat nodes within each Tomcat cluster. If this setting is not enabled, each CATALINA*HOME+CATALINA*BASE combination will be considered a separate Tomcat cluster. In other words, Tomcat clusters can't have multiple nodes on a single host.
	UseCatalinaBase bool `pulumi:"useCatalinaBase"`
	// By default, Dynatrace uses image names as identifiers for individual process groups, with one process-group instance per host. Normally Docker container names can't serve as stable identifiers of process group instances because they are variable and auto-generated. You can however manually assign proper container names to their Docker instances. Such manually-assigned container names can serve as reliable process-group instance identifiers. This flag instructs Dynatrace to use Docker-provided names to distinguish between multiple instances of the same image. If this flag is not applied and you run multiple containers of the same image on the same host, the resulting processes will be consolidated into a single process view. Use this flag with caution!
	UseDockerContainerName bool `pulumi:"useDockerContainerName"`
}

// The set of arguments for constructing a ProcessGroupDetectionFlags resource.
type ProcessGroupDetectionFlagsArgs struct {
	// In older versions, Node.js applications were distinguished based on their directory name, omitting the script name. Changing this setting may change the general handling of Node.js process groups. Leave unchanged if in doubt.
	AddNodeJsScriptName pulumi.BoolInput
	// Enabling this flag will detect separate Cassandra process groups based on the configured Cassandra cluster name.
	AutoDetectCassandraClusters pulumi.BoolInput
	// Enabling this flag will detect Spring Boot process groups based on command line and applications' configuration files.
	AutoDetectSpringBoot pulumi.BoolInput
	// Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
	AutoDetectTibcoContainerEditionEngines pulumi.BoolInput
	// Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
	AutoDetectTibcoEngines pulumi.BoolInput
	// Enabling this flag will detect webMethods Integration Server including specific properties like install root and product name.
	AutoDetectWebMethodsIntegrationServer pulumi.BoolInput
	// Enabling this flag will detect separate WebSphere Liberty process groups based on java command line.
	AutoDetectWebSphereLibertyApplication pulumi.BoolInput
	// Enable to group and separately analyze the processes of each IBM MQ Queue manager instance. Each process group receives a unique name based on the queue manager instance name.
	GroupIbmmqbyInstanceName pulumi.BoolInput
	// Enabling this flag will detect the JBoss server name from the system property jboss.server.name=\n\n, only if -D[Server:\n\n] is not set.
	IdentifyJbossServerBySystemProperty pulumi.BoolInput
	// To determine the unique identity of each detected process, and to generate a unique name for each detected process, Dynatrace evaluates the name of the directory that each process binary is contained within. For application containers like Tomcat and JBoss, Dynatrace evaluates important directories like CATALINA*HOME and JBOSS*HOME for this information. In some automated deployment scenarios such directory names are updated automatically with new version numbers, build numbers, dates, or GUIDs. Enable this setting to ensure that automated directory name changes don't result in Dynatrace registering pre-existing processes as new processes.
	IgnoreUniqueIdentifiers pulumi.BoolInput
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope pulumi.StringPtrInput
	// This flag enables the detection of security software such as anti-malware protection.
	SecuritySoftwareDetectionEnabled pulumi.BoolPtrInput
	// Enable to monitor CPU and memory usage of short lived processes, otherwise being lost by traditional monitoring. Disabling this flag blocks passing data to cluster only, it does not stop data collection and has no effect on performance.
	ShortLivedProcessesMonitoring pulumi.BoolInput
	// Enable to group and separately analyze the processes of each Oracle DB. Each process group receives a unique name based on the Oracle DB SID.
	SplitOracleDatabasePg pulumi.BoolInput
	// Enable to group and separately analyze the processes of each Oracle Listener. Each process group receives a unique name based on the Oracle Listener name.
	SplitOracleListenerPg pulumi.BoolInput
	// By default, Tomcat clusters are identified and named based on the CATALINA*HOME directory name. This setting results in the use of the CATALINA*BASE directory name to identify multiple Tomcat nodes within each Tomcat cluster. If this setting is not enabled, each CATALINA*HOME+CATALINA*BASE combination will be considered a separate Tomcat cluster. In other words, Tomcat clusters can't have multiple nodes on a single host.
	UseCatalinaBase pulumi.BoolInput
	// By default, Dynatrace uses image names as identifiers for individual process groups, with one process-group instance per host. Normally Docker container names can't serve as stable identifiers of process group instances because they are variable and auto-generated. You can however manually assign proper container names to their Docker instances. Such manually-assigned container names can serve as reliable process-group instance identifiers. This flag instructs Dynatrace to use Docker-provided names to distinguish between multiple instances of the same image. If this flag is not applied and you run multiple containers of the same image on the same host, the resulting processes will be consolidated into a single process view. Use this flag with caution!
	UseDockerContainerName pulumi.BoolInput
}

func (ProcessGroupDetectionFlagsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*processGroupDetectionFlagsArgs)(nil)).Elem()
}

type ProcessGroupDetectionFlagsInput interface {
	pulumi.Input

	ToProcessGroupDetectionFlagsOutput() ProcessGroupDetectionFlagsOutput
	ToProcessGroupDetectionFlagsOutputWithContext(ctx context.Context) ProcessGroupDetectionFlagsOutput
}

func (*ProcessGroupDetectionFlags) ElementType() reflect.Type {
	return reflect.TypeOf((**ProcessGroupDetectionFlags)(nil)).Elem()
}

func (i *ProcessGroupDetectionFlags) ToProcessGroupDetectionFlagsOutput() ProcessGroupDetectionFlagsOutput {
	return i.ToProcessGroupDetectionFlagsOutputWithContext(context.Background())
}

func (i *ProcessGroupDetectionFlags) ToProcessGroupDetectionFlagsOutputWithContext(ctx context.Context) ProcessGroupDetectionFlagsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessGroupDetectionFlagsOutput)
}

// ProcessGroupDetectionFlagsArrayInput is an input type that accepts ProcessGroupDetectionFlagsArray and ProcessGroupDetectionFlagsArrayOutput values.
// You can construct a concrete instance of `ProcessGroupDetectionFlagsArrayInput` via:
//
//	ProcessGroupDetectionFlagsArray{ ProcessGroupDetectionFlagsArgs{...} }
type ProcessGroupDetectionFlagsArrayInput interface {
	pulumi.Input

	ToProcessGroupDetectionFlagsArrayOutput() ProcessGroupDetectionFlagsArrayOutput
	ToProcessGroupDetectionFlagsArrayOutputWithContext(context.Context) ProcessGroupDetectionFlagsArrayOutput
}

type ProcessGroupDetectionFlagsArray []ProcessGroupDetectionFlagsInput

func (ProcessGroupDetectionFlagsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProcessGroupDetectionFlags)(nil)).Elem()
}

func (i ProcessGroupDetectionFlagsArray) ToProcessGroupDetectionFlagsArrayOutput() ProcessGroupDetectionFlagsArrayOutput {
	return i.ToProcessGroupDetectionFlagsArrayOutputWithContext(context.Background())
}

func (i ProcessGroupDetectionFlagsArray) ToProcessGroupDetectionFlagsArrayOutputWithContext(ctx context.Context) ProcessGroupDetectionFlagsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessGroupDetectionFlagsArrayOutput)
}

// ProcessGroupDetectionFlagsMapInput is an input type that accepts ProcessGroupDetectionFlagsMap and ProcessGroupDetectionFlagsMapOutput values.
// You can construct a concrete instance of `ProcessGroupDetectionFlagsMapInput` via:
//
//	ProcessGroupDetectionFlagsMap{ "key": ProcessGroupDetectionFlagsArgs{...} }
type ProcessGroupDetectionFlagsMapInput interface {
	pulumi.Input

	ToProcessGroupDetectionFlagsMapOutput() ProcessGroupDetectionFlagsMapOutput
	ToProcessGroupDetectionFlagsMapOutputWithContext(context.Context) ProcessGroupDetectionFlagsMapOutput
}

type ProcessGroupDetectionFlagsMap map[string]ProcessGroupDetectionFlagsInput

func (ProcessGroupDetectionFlagsMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProcessGroupDetectionFlags)(nil)).Elem()
}

func (i ProcessGroupDetectionFlagsMap) ToProcessGroupDetectionFlagsMapOutput() ProcessGroupDetectionFlagsMapOutput {
	return i.ToProcessGroupDetectionFlagsMapOutputWithContext(context.Background())
}

func (i ProcessGroupDetectionFlagsMap) ToProcessGroupDetectionFlagsMapOutputWithContext(ctx context.Context) ProcessGroupDetectionFlagsMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessGroupDetectionFlagsMapOutput)
}

type ProcessGroupDetectionFlagsOutput struct{ *pulumi.OutputState }

func (ProcessGroupDetectionFlagsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ProcessGroupDetectionFlags)(nil)).Elem()
}

func (o ProcessGroupDetectionFlagsOutput) ToProcessGroupDetectionFlagsOutput() ProcessGroupDetectionFlagsOutput {
	return o
}

func (o ProcessGroupDetectionFlagsOutput) ToProcessGroupDetectionFlagsOutputWithContext(ctx context.Context) ProcessGroupDetectionFlagsOutput {
	return o
}

// In older versions, Node.js applications were distinguished based on their directory name, omitting the script name. Changing this setting may change the general handling of Node.js process groups. Leave unchanged if in doubt.
func (o ProcessGroupDetectionFlagsOutput) AddNodeJsScriptName() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProcessGroupDetectionFlags) pulumi.BoolOutput { return v.AddNodeJsScriptName }).(pulumi.BoolOutput)
}

// Enabling this flag will detect separate Cassandra process groups based on the configured Cassandra cluster name.
func (o ProcessGroupDetectionFlagsOutput) AutoDetectCassandraClusters() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProcessGroupDetectionFlags) pulumi.BoolOutput { return v.AutoDetectCassandraClusters }).(pulumi.BoolOutput)
}

// Enabling this flag will detect Spring Boot process groups based on command line and applications' configuration files.
func (o ProcessGroupDetectionFlagsOutput) AutoDetectSpringBoot() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProcessGroupDetectionFlags) pulumi.BoolOutput { return v.AutoDetectSpringBoot }).(pulumi.BoolOutput)
}

// Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
func (o ProcessGroupDetectionFlagsOutput) AutoDetectTibcoContainerEditionEngines() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProcessGroupDetectionFlags) pulumi.BoolOutput { return v.AutoDetectTibcoContainerEditionEngines }).(pulumi.BoolOutput)
}

// Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
func (o ProcessGroupDetectionFlagsOutput) AutoDetectTibcoEngines() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProcessGroupDetectionFlags) pulumi.BoolOutput { return v.AutoDetectTibcoEngines }).(pulumi.BoolOutput)
}

// Enabling this flag will detect webMethods Integration Server including specific properties like install root and product name.
func (o ProcessGroupDetectionFlagsOutput) AutoDetectWebMethodsIntegrationServer() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProcessGroupDetectionFlags) pulumi.BoolOutput { return v.AutoDetectWebMethodsIntegrationServer }).(pulumi.BoolOutput)
}

// Enabling this flag will detect separate WebSphere Liberty process groups based on java command line.
func (o ProcessGroupDetectionFlagsOutput) AutoDetectWebSphereLibertyApplication() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProcessGroupDetectionFlags) pulumi.BoolOutput { return v.AutoDetectWebSphereLibertyApplication }).(pulumi.BoolOutput)
}

// Enable to group and separately analyze the processes of each IBM MQ Queue manager instance. Each process group receives a unique name based on the queue manager instance name.
func (o ProcessGroupDetectionFlagsOutput) GroupIbmmqbyInstanceName() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProcessGroupDetectionFlags) pulumi.BoolOutput { return v.GroupIbmmqbyInstanceName }).(pulumi.BoolOutput)
}

// Enabling this flag will detect the JBoss server name from the system property jboss.server.name=\n\n, only if -D[Server:\n\n] is not set.
func (o ProcessGroupDetectionFlagsOutput) IdentifyJbossServerBySystemProperty() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProcessGroupDetectionFlags) pulumi.BoolOutput { return v.IdentifyJbossServerBySystemProperty }).(pulumi.BoolOutput)
}

// To determine the unique identity of each detected process, and to generate a unique name for each detected process, Dynatrace evaluates the name of the directory that each process binary is contained within. For application containers like Tomcat and JBoss, Dynatrace evaluates important directories like CATALINA*HOME and JBOSS*HOME for this information. In some automated deployment scenarios such directory names are updated automatically with new version numbers, build numbers, dates, or GUIDs. Enable this setting to ensure that automated directory name changes don't result in Dynatrace registering pre-existing processes as new processes.
func (o ProcessGroupDetectionFlagsOutput) IgnoreUniqueIdentifiers() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProcessGroupDetectionFlags) pulumi.BoolOutput { return v.IgnoreUniqueIdentifiers }).(pulumi.BoolOutput)
}

// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
func (o ProcessGroupDetectionFlagsOutput) Scope() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ProcessGroupDetectionFlags) pulumi.StringPtrOutput { return v.Scope }).(pulumi.StringPtrOutput)
}

// This flag enables the detection of security software such as anti-malware protection.
func (o ProcessGroupDetectionFlagsOutput) SecuritySoftwareDetectionEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ProcessGroupDetectionFlags) pulumi.BoolPtrOutput { return v.SecuritySoftwareDetectionEnabled }).(pulumi.BoolPtrOutput)
}

// Enable to monitor CPU and memory usage of short lived processes, otherwise being lost by traditional monitoring. Disabling this flag blocks passing data to cluster only, it does not stop data collection and has no effect on performance.
func (o ProcessGroupDetectionFlagsOutput) ShortLivedProcessesMonitoring() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProcessGroupDetectionFlags) pulumi.BoolOutput { return v.ShortLivedProcessesMonitoring }).(pulumi.BoolOutput)
}

// Enable to group and separately analyze the processes of each Oracle DB. Each process group receives a unique name based on the Oracle DB SID.
func (o ProcessGroupDetectionFlagsOutput) SplitOracleDatabasePg() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProcessGroupDetectionFlags) pulumi.BoolOutput { return v.SplitOracleDatabasePg }).(pulumi.BoolOutput)
}

// Enable to group and separately analyze the processes of each Oracle Listener. Each process group receives a unique name based on the Oracle Listener name.
func (o ProcessGroupDetectionFlagsOutput) SplitOracleListenerPg() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProcessGroupDetectionFlags) pulumi.BoolOutput { return v.SplitOracleListenerPg }).(pulumi.BoolOutput)
}

// By default, Tomcat clusters are identified and named based on the CATALINA*HOME directory name. This setting results in the use of the CATALINA*BASE directory name to identify multiple Tomcat nodes within each Tomcat cluster. If this setting is not enabled, each CATALINA*HOME+CATALINA*BASE combination will be considered a separate Tomcat cluster. In other words, Tomcat clusters can't have multiple nodes on a single host.
func (o ProcessGroupDetectionFlagsOutput) UseCatalinaBase() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProcessGroupDetectionFlags) pulumi.BoolOutput { return v.UseCatalinaBase }).(pulumi.BoolOutput)
}

// By default, Dynatrace uses image names as identifiers for individual process groups, with one process-group instance per host. Normally Docker container names can't serve as stable identifiers of process group instances because they are variable and auto-generated. You can however manually assign proper container names to their Docker instances. Such manually-assigned container names can serve as reliable process-group instance identifiers. This flag instructs Dynatrace to use Docker-provided names to distinguish between multiple instances of the same image. If this flag is not applied and you run multiple containers of the same image on the same host, the resulting processes will be consolidated into a single process view. Use this flag with caution!
func (o ProcessGroupDetectionFlagsOutput) UseDockerContainerName() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProcessGroupDetectionFlags) pulumi.BoolOutput { return v.UseDockerContainerName }).(pulumi.BoolOutput)
}

type ProcessGroupDetectionFlagsArrayOutput struct{ *pulumi.OutputState }

func (ProcessGroupDetectionFlagsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProcessGroupDetectionFlags)(nil)).Elem()
}

func (o ProcessGroupDetectionFlagsArrayOutput) ToProcessGroupDetectionFlagsArrayOutput() ProcessGroupDetectionFlagsArrayOutput {
	return o
}

func (o ProcessGroupDetectionFlagsArrayOutput) ToProcessGroupDetectionFlagsArrayOutputWithContext(ctx context.Context) ProcessGroupDetectionFlagsArrayOutput {
	return o
}

func (o ProcessGroupDetectionFlagsArrayOutput) Index(i pulumi.IntInput) ProcessGroupDetectionFlagsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ProcessGroupDetectionFlags {
		return vs[0].([]*ProcessGroupDetectionFlags)[vs[1].(int)]
	}).(ProcessGroupDetectionFlagsOutput)
}

type ProcessGroupDetectionFlagsMapOutput struct{ *pulumi.OutputState }

func (ProcessGroupDetectionFlagsMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProcessGroupDetectionFlags)(nil)).Elem()
}

func (o ProcessGroupDetectionFlagsMapOutput) ToProcessGroupDetectionFlagsMapOutput() ProcessGroupDetectionFlagsMapOutput {
	return o
}

func (o ProcessGroupDetectionFlagsMapOutput) ToProcessGroupDetectionFlagsMapOutputWithContext(ctx context.Context) ProcessGroupDetectionFlagsMapOutput {
	return o
}

func (o ProcessGroupDetectionFlagsMapOutput) MapIndex(k pulumi.StringInput) ProcessGroupDetectionFlagsOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ProcessGroupDetectionFlags {
		return vs[0].(map[string]*ProcessGroupDetectionFlags)[vs[1].(string)]
	}).(ProcessGroupDetectionFlagsOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ProcessGroupDetectionFlagsInput)(nil)).Elem(), &ProcessGroupDetectionFlags{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProcessGroupDetectionFlagsArrayInput)(nil)).Elem(), ProcessGroupDetectionFlagsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProcessGroupDetectionFlagsMapInput)(nil)).Elem(), ProcessGroupDetectionFlagsMap{})
	pulumi.RegisterOutputType(ProcessGroupDetectionFlagsOutput{})
	pulumi.RegisterOutputType(ProcessGroupDetectionFlagsArrayOutput{})
	pulumi.RegisterOutputType(ProcessGroupDetectionFlagsMapOutput{})
}
