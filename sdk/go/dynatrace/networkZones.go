// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type NetworkZones struct {
	pulumi.CustomResourceState

	// Network Zones are enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
}

// NewNetworkZones registers a new resource with the given unique name, arguments, and options.
func NewNetworkZones(ctx *pulumi.Context,
	name string, args *NetworkZonesArgs, opts ...pulumi.ResourceOption) (*NetworkZones, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource NetworkZones
	err := ctx.RegisterResource("dynatrace:index/networkZones:NetworkZones", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNetworkZones gets an existing NetworkZones resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNetworkZones(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NetworkZonesState, opts ...pulumi.ResourceOption) (*NetworkZones, error) {
	var resource NetworkZones
	err := ctx.ReadResource("dynatrace:index/networkZones:NetworkZones", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NetworkZones resources.
type networkZonesState struct {
	// Network Zones are enabled (`true`) or disabled (`false`)
	Enabled *bool `pulumi:"enabled"`
}

type NetworkZonesState struct {
	// Network Zones are enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolPtrInput
}

func (NetworkZonesState) ElementType() reflect.Type {
	return reflect.TypeOf((*networkZonesState)(nil)).Elem()
}

type networkZonesArgs struct {
	// Network Zones are enabled (`true`) or disabled (`false`)
	Enabled bool `pulumi:"enabled"`
}

// The set of arguments for constructing a NetworkZones resource.
type NetworkZonesArgs struct {
	// Network Zones are enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolInput
}

func (NetworkZonesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*networkZonesArgs)(nil)).Elem()
}

type NetworkZonesInput interface {
	pulumi.Input

	ToNetworkZonesOutput() NetworkZonesOutput
	ToNetworkZonesOutputWithContext(ctx context.Context) NetworkZonesOutput
}

func (*NetworkZones) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkZones)(nil)).Elem()
}

func (i *NetworkZones) ToNetworkZonesOutput() NetworkZonesOutput {
	return i.ToNetworkZonesOutputWithContext(context.Background())
}

func (i *NetworkZones) ToNetworkZonesOutputWithContext(ctx context.Context) NetworkZonesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkZonesOutput)
}

// NetworkZonesArrayInput is an input type that accepts NetworkZonesArray and NetworkZonesArrayOutput values.
// You can construct a concrete instance of `NetworkZonesArrayInput` via:
//
//	NetworkZonesArray{ NetworkZonesArgs{...} }
type NetworkZonesArrayInput interface {
	pulumi.Input

	ToNetworkZonesArrayOutput() NetworkZonesArrayOutput
	ToNetworkZonesArrayOutputWithContext(context.Context) NetworkZonesArrayOutput
}

type NetworkZonesArray []NetworkZonesInput

func (NetworkZonesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NetworkZones)(nil)).Elem()
}

func (i NetworkZonesArray) ToNetworkZonesArrayOutput() NetworkZonesArrayOutput {
	return i.ToNetworkZonesArrayOutputWithContext(context.Background())
}

func (i NetworkZonesArray) ToNetworkZonesArrayOutputWithContext(ctx context.Context) NetworkZonesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkZonesArrayOutput)
}

// NetworkZonesMapInput is an input type that accepts NetworkZonesMap and NetworkZonesMapOutput values.
// You can construct a concrete instance of `NetworkZonesMapInput` via:
//
//	NetworkZonesMap{ "key": NetworkZonesArgs{...} }
type NetworkZonesMapInput interface {
	pulumi.Input

	ToNetworkZonesMapOutput() NetworkZonesMapOutput
	ToNetworkZonesMapOutputWithContext(context.Context) NetworkZonesMapOutput
}

type NetworkZonesMap map[string]NetworkZonesInput

func (NetworkZonesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NetworkZones)(nil)).Elem()
}

func (i NetworkZonesMap) ToNetworkZonesMapOutput() NetworkZonesMapOutput {
	return i.ToNetworkZonesMapOutputWithContext(context.Background())
}

func (i NetworkZonesMap) ToNetworkZonesMapOutputWithContext(ctx context.Context) NetworkZonesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkZonesMapOutput)
}

type NetworkZonesOutput struct{ *pulumi.OutputState }

func (NetworkZonesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkZones)(nil)).Elem()
}

func (o NetworkZonesOutput) ToNetworkZonesOutput() NetworkZonesOutput {
	return o
}

func (o NetworkZonesOutput) ToNetworkZonesOutputWithContext(ctx context.Context) NetworkZonesOutput {
	return o
}

// Network Zones are enabled (`true`) or disabled (`false`)
func (o NetworkZonesOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *NetworkZones) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

type NetworkZonesArrayOutput struct{ *pulumi.OutputState }

func (NetworkZonesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NetworkZones)(nil)).Elem()
}

func (o NetworkZonesArrayOutput) ToNetworkZonesArrayOutput() NetworkZonesArrayOutput {
	return o
}

func (o NetworkZonesArrayOutput) ToNetworkZonesArrayOutputWithContext(ctx context.Context) NetworkZonesArrayOutput {
	return o
}

func (o NetworkZonesArrayOutput) Index(i pulumi.IntInput) NetworkZonesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *NetworkZones {
		return vs[0].([]*NetworkZones)[vs[1].(int)]
	}).(NetworkZonesOutput)
}

type NetworkZonesMapOutput struct{ *pulumi.OutputState }

func (NetworkZonesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NetworkZones)(nil)).Elem()
}

func (o NetworkZonesMapOutput) ToNetworkZonesMapOutput() NetworkZonesMapOutput {
	return o
}

func (o NetworkZonesMapOutput) ToNetworkZonesMapOutputWithContext(ctx context.Context) NetworkZonesMapOutput {
	return o
}

func (o NetworkZonesMapOutput) MapIndex(k pulumi.StringInput) NetworkZonesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *NetworkZones {
		return vs[0].(map[string]*NetworkZones)[vs[1].(string)]
	}).(NetworkZonesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkZonesInput)(nil)).Elem(), &NetworkZones{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkZonesArrayInput)(nil)).Elem(), NetworkZonesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkZonesMapInput)(nil)).Elem(), NetworkZonesMap{})
	pulumi.RegisterOutputType(NetworkZonesOutput{})
	pulumi.RegisterOutputType(NetworkZonesArrayOutput{})
	pulumi.RegisterOutputType(NetworkZonesMapOutput{})
}
