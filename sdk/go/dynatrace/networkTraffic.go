// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type NetworkTraffic struct {
	pulumi.CustomResourceState

	// Providing a host IP address, you will exclude network traffic only in calculating connectivity (other metrics will still be calculated).
	ExcludeIp NetworkTrafficExcludeIpPtrOutput `pulumi:"excludeIp"`
	// Selecting a network interface, you will exclude all network traffic on that interface from being monitored. You can select from the list below what to not monitor, or input it manually using the "other one" option.
	ExcludeNic NetworkTrafficExcludeNicPtrOutput `pulumi:"excludeNic"`
	// The scope of this settings. If the settings should cover the whole environment, just don't specify any scope.
	HostId pulumi.StringOutput `pulumi:"hostId"`
}

// NewNetworkTraffic registers a new resource with the given unique name, arguments, and options.
func NewNetworkTraffic(ctx *pulumi.Context,
	name string, args *NetworkTrafficArgs, opts ...pulumi.ResourceOption) (*NetworkTraffic, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.HostId == nil {
		return nil, errors.New("invalid value for required argument 'HostId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource NetworkTraffic
	err := ctx.RegisterResource("dynatrace:index/networkTraffic:NetworkTraffic", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNetworkTraffic gets an existing NetworkTraffic resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNetworkTraffic(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NetworkTrafficState, opts ...pulumi.ResourceOption) (*NetworkTraffic, error) {
	var resource NetworkTraffic
	err := ctx.ReadResource("dynatrace:index/networkTraffic:NetworkTraffic", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NetworkTraffic resources.
type networkTrafficState struct {
	// Providing a host IP address, you will exclude network traffic only in calculating connectivity (other metrics will still be calculated).
	ExcludeIp *NetworkTrafficExcludeIp `pulumi:"excludeIp"`
	// Selecting a network interface, you will exclude all network traffic on that interface from being monitored. You can select from the list below what to not monitor, or input it manually using the "other one" option.
	ExcludeNic *NetworkTrafficExcludeNic `pulumi:"excludeNic"`
	// The scope of this settings. If the settings should cover the whole environment, just don't specify any scope.
	HostId *string `pulumi:"hostId"`
}

type NetworkTrafficState struct {
	// Providing a host IP address, you will exclude network traffic only in calculating connectivity (other metrics will still be calculated).
	ExcludeIp NetworkTrafficExcludeIpPtrInput
	// Selecting a network interface, you will exclude all network traffic on that interface from being monitored. You can select from the list below what to not monitor, or input it manually using the "other one" option.
	ExcludeNic NetworkTrafficExcludeNicPtrInput
	// The scope of this settings. If the settings should cover the whole environment, just don't specify any scope.
	HostId pulumi.StringPtrInput
}

func (NetworkTrafficState) ElementType() reflect.Type {
	return reflect.TypeOf((*networkTrafficState)(nil)).Elem()
}

type networkTrafficArgs struct {
	// Providing a host IP address, you will exclude network traffic only in calculating connectivity (other metrics will still be calculated).
	ExcludeIp *NetworkTrafficExcludeIp `pulumi:"excludeIp"`
	// Selecting a network interface, you will exclude all network traffic on that interface from being monitored. You can select from the list below what to not monitor, or input it manually using the "other one" option.
	ExcludeNic *NetworkTrafficExcludeNic `pulumi:"excludeNic"`
	// The scope of this settings. If the settings should cover the whole environment, just don't specify any scope.
	HostId string `pulumi:"hostId"`
}

// The set of arguments for constructing a NetworkTraffic resource.
type NetworkTrafficArgs struct {
	// Providing a host IP address, you will exclude network traffic only in calculating connectivity (other metrics will still be calculated).
	ExcludeIp NetworkTrafficExcludeIpPtrInput
	// Selecting a network interface, you will exclude all network traffic on that interface from being monitored. You can select from the list below what to not monitor, or input it manually using the "other one" option.
	ExcludeNic NetworkTrafficExcludeNicPtrInput
	// The scope of this settings. If the settings should cover the whole environment, just don't specify any scope.
	HostId pulumi.StringInput
}

func (NetworkTrafficArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*networkTrafficArgs)(nil)).Elem()
}

type NetworkTrafficInput interface {
	pulumi.Input

	ToNetworkTrafficOutput() NetworkTrafficOutput
	ToNetworkTrafficOutputWithContext(ctx context.Context) NetworkTrafficOutput
}

func (*NetworkTraffic) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkTraffic)(nil)).Elem()
}

func (i *NetworkTraffic) ToNetworkTrafficOutput() NetworkTrafficOutput {
	return i.ToNetworkTrafficOutputWithContext(context.Background())
}

func (i *NetworkTraffic) ToNetworkTrafficOutputWithContext(ctx context.Context) NetworkTrafficOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkTrafficOutput)
}

// NetworkTrafficArrayInput is an input type that accepts NetworkTrafficArray and NetworkTrafficArrayOutput values.
// You can construct a concrete instance of `NetworkTrafficArrayInput` via:
//
//	NetworkTrafficArray{ NetworkTrafficArgs{...} }
type NetworkTrafficArrayInput interface {
	pulumi.Input

	ToNetworkTrafficArrayOutput() NetworkTrafficArrayOutput
	ToNetworkTrafficArrayOutputWithContext(context.Context) NetworkTrafficArrayOutput
}

type NetworkTrafficArray []NetworkTrafficInput

func (NetworkTrafficArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NetworkTraffic)(nil)).Elem()
}

func (i NetworkTrafficArray) ToNetworkTrafficArrayOutput() NetworkTrafficArrayOutput {
	return i.ToNetworkTrafficArrayOutputWithContext(context.Background())
}

func (i NetworkTrafficArray) ToNetworkTrafficArrayOutputWithContext(ctx context.Context) NetworkTrafficArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkTrafficArrayOutput)
}

// NetworkTrafficMapInput is an input type that accepts NetworkTrafficMap and NetworkTrafficMapOutput values.
// You can construct a concrete instance of `NetworkTrafficMapInput` via:
//
//	NetworkTrafficMap{ "key": NetworkTrafficArgs{...} }
type NetworkTrafficMapInput interface {
	pulumi.Input

	ToNetworkTrafficMapOutput() NetworkTrafficMapOutput
	ToNetworkTrafficMapOutputWithContext(context.Context) NetworkTrafficMapOutput
}

type NetworkTrafficMap map[string]NetworkTrafficInput

func (NetworkTrafficMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NetworkTraffic)(nil)).Elem()
}

func (i NetworkTrafficMap) ToNetworkTrafficMapOutput() NetworkTrafficMapOutput {
	return i.ToNetworkTrafficMapOutputWithContext(context.Background())
}

func (i NetworkTrafficMap) ToNetworkTrafficMapOutputWithContext(ctx context.Context) NetworkTrafficMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkTrafficMapOutput)
}

type NetworkTrafficOutput struct{ *pulumi.OutputState }

func (NetworkTrafficOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkTraffic)(nil)).Elem()
}

func (o NetworkTrafficOutput) ToNetworkTrafficOutput() NetworkTrafficOutput {
	return o
}

func (o NetworkTrafficOutput) ToNetworkTrafficOutputWithContext(ctx context.Context) NetworkTrafficOutput {
	return o
}

// Providing a host IP address, you will exclude network traffic only in calculating connectivity (other metrics will still be calculated).
func (o NetworkTrafficOutput) ExcludeIp() NetworkTrafficExcludeIpPtrOutput {
	return o.ApplyT(func(v *NetworkTraffic) NetworkTrafficExcludeIpPtrOutput { return v.ExcludeIp }).(NetworkTrafficExcludeIpPtrOutput)
}

// Selecting a network interface, you will exclude all network traffic on that interface from being monitored. You can select from the list below what to not monitor, or input it manually using the "other one" option.
func (o NetworkTrafficOutput) ExcludeNic() NetworkTrafficExcludeNicPtrOutput {
	return o.ApplyT(func(v *NetworkTraffic) NetworkTrafficExcludeNicPtrOutput { return v.ExcludeNic }).(NetworkTrafficExcludeNicPtrOutput)
}

// The scope of this settings. If the settings should cover the whole environment, just don't specify any scope.
func (o NetworkTrafficOutput) HostId() pulumi.StringOutput {
	return o.ApplyT(func(v *NetworkTraffic) pulumi.StringOutput { return v.HostId }).(pulumi.StringOutput)
}

type NetworkTrafficArrayOutput struct{ *pulumi.OutputState }

func (NetworkTrafficArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NetworkTraffic)(nil)).Elem()
}

func (o NetworkTrafficArrayOutput) ToNetworkTrafficArrayOutput() NetworkTrafficArrayOutput {
	return o
}

func (o NetworkTrafficArrayOutput) ToNetworkTrafficArrayOutputWithContext(ctx context.Context) NetworkTrafficArrayOutput {
	return o
}

func (o NetworkTrafficArrayOutput) Index(i pulumi.IntInput) NetworkTrafficOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *NetworkTraffic {
		return vs[0].([]*NetworkTraffic)[vs[1].(int)]
	}).(NetworkTrafficOutput)
}

type NetworkTrafficMapOutput struct{ *pulumi.OutputState }

func (NetworkTrafficMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NetworkTraffic)(nil)).Elem()
}

func (o NetworkTrafficMapOutput) ToNetworkTrafficMapOutput() NetworkTrafficMapOutput {
	return o
}

func (o NetworkTrafficMapOutput) ToNetworkTrafficMapOutputWithContext(ctx context.Context) NetworkTrafficMapOutput {
	return o
}

func (o NetworkTrafficMapOutput) MapIndex(k pulumi.StringInput) NetworkTrafficOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *NetworkTraffic {
		return vs[0].(map[string]*NetworkTraffic)[vs[1].(string)]
	}).(NetworkTrafficOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkTrafficInput)(nil)).Elem(), &NetworkTraffic{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkTrafficArrayInput)(nil)).Elem(), NetworkTrafficArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkTrafficMapInput)(nil)).Elem(), NetworkTrafficMap{})
	pulumi.RegisterOutputType(NetworkTrafficOutput{})
	pulumi.RegisterOutputType(NetworkTrafficArrayOutput{})
	pulumi.RegisterOutputType(NetworkTrafficMapOutput{})
}
