// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type Alerting struct {
	pulumi.CustomResourceState

	// The list of event filters.  For all filters that are *negated* inside of these event filters, that is all `Predefined` as well as `Custom` (Title and/or Description) ones the AND logic applies. For all *non-negated* ones the OR logic applies. Between these two groups, negated and non-negated, the AND logic applies.  If you specify both severity rule and event filter, the AND logic applies
	Filters AlertingFiltersPtrOutput `pulumi:"filters"`
	// The ID of this setting when referred to by the Config REST API V1
	LegacyId pulumi.StringOutput `pulumi:"legacyId"`
	// Entities which are part of the configured management zones will match this alerting profile. It is recommended to use manual tags instead.
	ManagementZone pulumi.StringPtrOutput `pulumi:"managementZone"`
	// The name of the alerting profile, displayed in the UI
	Name pulumi.StringOutput `pulumi:"name"`
	// A list of rules for management zone usage.  Each rule is evaluated independently of all other rules
	Rules AlertingRulesPtrOutput `pulumi:"rules"`
}

// NewAlerting registers a new resource with the given unique name, arguments, and options.
func NewAlerting(ctx *pulumi.Context,
	name string, args *AlertingArgs, opts ...pulumi.ResourceOption) (*Alerting, error) {
	if args == nil {
		args = &AlertingArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Alerting
	err := ctx.RegisterResource("dynatrace:index/alerting:Alerting", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAlerting gets an existing Alerting resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAlerting(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AlertingState, opts ...pulumi.ResourceOption) (*Alerting, error) {
	var resource Alerting
	err := ctx.ReadResource("dynatrace:index/alerting:Alerting", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Alerting resources.
type alertingState struct {
	// The list of event filters.  For all filters that are *negated* inside of these event filters, that is all `Predefined` as well as `Custom` (Title and/or Description) ones the AND logic applies. For all *non-negated* ones the OR logic applies. Between these two groups, negated and non-negated, the AND logic applies.  If you specify both severity rule and event filter, the AND logic applies
	Filters *AlertingFilters `pulumi:"filters"`
	// The ID of this setting when referred to by the Config REST API V1
	LegacyId *string `pulumi:"legacyId"`
	// Entities which are part of the configured management zones will match this alerting profile. It is recommended to use manual tags instead.
	ManagementZone *string `pulumi:"managementZone"`
	// The name of the alerting profile, displayed in the UI
	Name *string `pulumi:"name"`
	// A list of rules for management zone usage.  Each rule is evaluated independently of all other rules
	Rules *AlertingRules `pulumi:"rules"`
}

type AlertingState struct {
	// The list of event filters.  For all filters that are *negated* inside of these event filters, that is all `Predefined` as well as `Custom` (Title and/or Description) ones the AND logic applies. For all *non-negated* ones the OR logic applies. Between these two groups, negated and non-negated, the AND logic applies.  If you specify both severity rule and event filter, the AND logic applies
	Filters AlertingFiltersPtrInput
	// The ID of this setting when referred to by the Config REST API V1
	LegacyId pulumi.StringPtrInput
	// Entities which are part of the configured management zones will match this alerting profile. It is recommended to use manual tags instead.
	ManagementZone pulumi.StringPtrInput
	// The name of the alerting profile, displayed in the UI
	Name pulumi.StringPtrInput
	// A list of rules for management zone usage.  Each rule is evaluated independently of all other rules
	Rules AlertingRulesPtrInput
}

func (AlertingState) ElementType() reflect.Type {
	return reflect.TypeOf((*alertingState)(nil)).Elem()
}

type alertingArgs struct {
	// The list of event filters.  For all filters that are *negated* inside of these event filters, that is all `Predefined` as well as `Custom` (Title and/or Description) ones the AND logic applies. For all *non-negated* ones the OR logic applies. Between these two groups, negated and non-negated, the AND logic applies.  If you specify both severity rule and event filter, the AND logic applies
	Filters *AlertingFilters `pulumi:"filters"`
	// The ID of this setting when referred to by the Config REST API V1
	LegacyId *string `pulumi:"legacyId"`
	// Entities which are part of the configured management zones will match this alerting profile. It is recommended to use manual tags instead.
	ManagementZone *string `pulumi:"managementZone"`
	// The name of the alerting profile, displayed in the UI
	Name *string `pulumi:"name"`
	// A list of rules for management zone usage.  Each rule is evaluated independently of all other rules
	Rules *AlertingRules `pulumi:"rules"`
}

// The set of arguments for constructing a Alerting resource.
type AlertingArgs struct {
	// The list of event filters.  For all filters that are *negated* inside of these event filters, that is all `Predefined` as well as `Custom` (Title and/or Description) ones the AND logic applies. For all *non-negated* ones the OR logic applies. Between these two groups, negated and non-negated, the AND logic applies.  If you specify both severity rule and event filter, the AND logic applies
	Filters AlertingFiltersPtrInput
	// The ID of this setting when referred to by the Config REST API V1
	LegacyId pulumi.StringPtrInput
	// Entities which are part of the configured management zones will match this alerting profile. It is recommended to use manual tags instead.
	ManagementZone pulumi.StringPtrInput
	// The name of the alerting profile, displayed in the UI
	Name pulumi.StringPtrInput
	// A list of rules for management zone usage.  Each rule is evaluated independently of all other rules
	Rules AlertingRulesPtrInput
}

func (AlertingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*alertingArgs)(nil)).Elem()
}

type AlertingInput interface {
	pulumi.Input

	ToAlertingOutput() AlertingOutput
	ToAlertingOutputWithContext(ctx context.Context) AlertingOutput
}

func (*Alerting) ElementType() reflect.Type {
	return reflect.TypeOf((**Alerting)(nil)).Elem()
}

func (i *Alerting) ToAlertingOutput() AlertingOutput {
	return i.ToAlertingOutputWithContext(context.Background())
}

func (i *Alerting) ToAlertingOutputWithContext(ctx context.Context) AlertingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertingOutput)
}

// AlertingArrayInput is an input type that accepts AlertingArray and AlertingArrayOutput values.
// You can construct a concrete instance of `AlertingArrayInput` via:
//
//	AlertingArray{ AlertingArgs{...} }
type AlertingArrayInput interface {
	pulumi.Input

	ToAlertingArrayOutput() AlertingArrayOutput
	ToAlertingArrayOutputWithContext(context.Context) AlertingArrayOutput
}

type AlertingArray []AlertingInput

func (AlertingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Alerting)(nil)).Elem()
}

func (i AlertingArray) ToAlertingArrayOutput() AlertingArrayOutput {
	return i.ToAlertingArrayOutputWithContext(context.Background())
}

func (i AlertingArray) ToAlertingArrayOutputWithContext(ctx context.Context) AlertingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertingArrayOutput)
}

// AlertingMapInput is an input type that accepts AlertingMap and AlertingMapOutput values.
// You can construct a concrete instance of `AlertingMapInput` via:
//
//	AlertingMap{ "key": AlertingArgs{...} }
type AlertingMapInput interface {
	pulumi.Input

	ToAlertingMapOutput() AlertingMapOutput
	ToAlertingMapOutputWithContext(context.Context) AlertingMapOutput
}

type AlertingMap map[string]AlertingInput

func (AlertingMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Alerting)(nil)).Elem()
}

func (i AlertingMap) ToAlertingMapOutput() AlertingMapOutput {
	return i.ToAlertingMapOutputWithContext(context.Background())
}

func (i AlertingMap) ToAlertingMapOutputWithContext(ctx context.Context) AlertingMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertingMapOutput)
}

type AlertingOutput struct{ *pulumi.OutputState }

func (AlertingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Alerting)(nil)).Elem()
}

func (o AlertingOutput) ToAlertingOutput() AlertingOutput {
	return o
}

func (o AlertingOutput) ToAlertingOutputWithContext(ctx context.Context) AlertingOutput {
	return o
}

// The list of event filters.  For all filters that are *negated* inside of these event filters, that is all `Predefined` as well as `Custom` (Title and/or Description) ones the AND logic applies. For all *non-negated* ones the OR logic applies. Between these two groups, negated and non-negated, the AND logic applies.  If you specify both severity rule and event filter, the AND logic applies
func (o AlertingOutput) Filters() AlertingFiltersPtrOutput {
	return o.ApplyT(func(v *Alerting) AlertingFiltersPtrOutput { return v.Filters }).(AlertingFiltersPtrOutput)
}

// The ID of this setting when referred to by the Config REST API V1
func (o AlertingOutput) LegacyId() pulumi.StringOutput {
	return o.ApplyT(func(v *Alerting) pulumi.StringOutput { return v.LegacyId }).(pulumi.StringOutput)
}

// Entities which are part of the configured management zones will match this alerting profile. It is recommended to use manual tags instead.
func (o AlertingOutput) ManagementZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Alerting) pulumi.StringPtrOutput { return v.ManagementZone }).(pulumi.StringPtrOutput)
}

// The name of the alerting profile, displayed in the UI
func (o AlertingOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Alerting) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// A list of rules for management zone usage.  Each rule is evaluated independently of all other rules
func (o AlertingOutput) Rules() AlertingRulesPtrOutput {
	return o.ApplyT(func(v *Alerting) AlertingRulesPtrOutput { return v.Rules }).(AlertingRulesPtrOutput)
}

type AlertingArrayOutput struct{ *pulumi.OutputState }

func (AlertingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Alerting)(nil)).Elem()
}

func (o AlertingArrayOutput) ToAlertingArrayOutput() AlertingArrayOutput {
	return o
}

func (o AlertingArrayOutput) ToAlertingArrayOutputWithContext(ctx context.Context) AlertingArrayOutput {
	return o
}

func (o AlertingArrayOutput) Index(i pulumi.IntInput) AlertingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Alerting {
		return vs[0].([]*Alerting)[vs[1].(int)]
	}).(AlertingOutput)
}

type AlertingMapOutput struct{ *pulumi.OutputState }

func (AlertingMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Alerting)(nil)).Elem()
}

func (o AlertingMapOutput) ToAlertingMapOutput() AlertingMapOutput {
	return o
}

func (o AlertingMapOutput) ToAlertingMapOutputWithContext(ctx context.Context) AlertingMapOutput {
	return o
}

func (o AlertingMapOutput) MapIndex(k pulumi.StringInput) AlertingOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Alerting {
		return vs[0].(map[string]*Alerting)[vs[1].(string)]
	}).(AlertingOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AlertingInput)(nil)).Elem(), &Alerting{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlertingArrayInput)(nil)).Elem(), AlertingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlertingMapInput)(nil)).Elem(), AlertingMap{})
	pulumi.RegisterOutputType(AlertingOutput{})
	pulumi.RegisterOutputType(AlertingArrayOutput{})
	pulumi.RegisterOutputType(AlertingMapOutput{})
}
