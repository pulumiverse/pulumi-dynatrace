// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

type OsServices struct {
	pulumi.CustomResourceState

	// The number of **10-second measurement cycles** before alerting is triggered
	AlertActivationDuration pulumi.IntPtrOutput `pulumi:"alertActivationDuration"`
	// Toggle the switch in order to enable or disable alerting for this policy
	Alerting pulumi.BoolOutput `pulumi:"alerting"`
	// Detection rules
	DetectionConditionsLinux OsServicesDetectionConditionsLinuxPtrOutput `pulumi:"detectionConditionsLinux"`
	// Detection rules
	DetectionConditionsWindows OsServicesDetectionConditionsWindowsPtrOutput `pulumi:"detectionConditionsWindows"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringOutput `pulumi:"insertAfter"`
	// Set of additional key-value properties to be attached to the triggered event.
	Metadata OsServicesMetadataPtrOutput `pulumi:"metadata"`
	// Toggle the switch in order to enable or disable availability metric monitoring for this policy. Availability metrics produce custom metrics. Refer to [documentation](https://dt-url.net/vl03xzk) for consumption examples. Each monitored service consumes one custom metric.
	Monitoring pulumi.BoolOutput `pulumi:"monitoring"`
	// Rule name
	Name pulumi.StringOutput `pulumi:"name"`
	// By default, Dynatrace does not alert if the service is not installed. Toggle the switch to enable or disable this feature
	NotInstalledAlerting pulumi.BoolPtrOutput `pulumi:"notInstalledAlerting"`
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope pulumi.StringPtrOutput `pulumi:"scope"`
	// This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk).
	StatusConditionLinux pulumi.StringPtrOutput `pulumi:"statusConditionLinux"`
	// This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk). - `$eq(paused)`
	// – Matches services that are in paused state. Available logic operations: - `$not($eq(paused))` – Matches services
	// that are in state different from paused. - `$or($eq(paused),$eq(running))` – Matches services that are either in
	// paused or running state. Use one of the following values as a parameter for this condition: - `running` - `stopped` -
	// `startPending` - `stopPending` - `continuePending` - `pausePending` - `paused`
	StatusConditionWindows pulumi.StringPtrOutput `pulumi:"statusConditionWindows"`
	// Possible Values: `LINUX`, `WINDOWS`
	System pulumi.StringOutput `pulumi:"system"`
}

// NewOsServices registers a new resource with the given unique name, arguments, and options.
func NewOsServices(ctx *pulumi.Context,
	name string, args *OsServicesArgs, opts ...pulumi.ResourceOption) (*OsServices, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Alerting == nil {
		return nil, errors.New("invalid value for required argument 'Alerting'")
	}
	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.Monitoring == nil {
		return nil, errors.New("invalid value for required argument 'Monitoring'")
	}
	if args.System == nil {
		return nil, errors.New("invalid value for required argument 'System'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource OsServices
	err := ctx.RegisterResource("dynatrace:index/osServices:OsServices", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetOsServices gets an existing OsServices resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetOsServices(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *OsServicesState, opts ...pulumi.ResourceOption) (*OsServices, error) {
	var resource OsServices
	err := ctx.ReadResource("dynatrace:index/osServices:OsServices", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering OsServices resources.
type osServicesState struct {
	// The number of **10-second measurement cycles** before alerting is triggered
	AlertActivationDuration *int `pulumi:"alertActivationDuration"`
	// Toggle the switch in order to enable or disable alerting for this policy
	Alerting *bool `pulumi:"alerting"`
	// Detection rules
	DetectionConditionsLinux *OsServicesDetectionConditionsLinux `pulumi:"detectionConditionsLinux"`
	// Detection rules
	DetectionConditionsWindows *OsServicesDetectionConditionsWindows `pulumi:"detectionConditionsWindows"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Set of additional key-value properties to be attached to the triggered event.
	Metadata *OsServicesMetadata `pulumi:"metadata"`
	// Toggle the switch in order to enable or disable availability metric monitoring for this policy. Availability metrics produce custom metrics. Refer to [documentation](https://dt-url.net/vl03xzk) for consumption examples. Each monitored service consumes one custom metric.
	Monitoring *bool `pulumi:"monitoring"`
	// Rule name
	Name *string `pulumi:"name"`
	// By default, Dynatrace does not alert if the service is not installed. Toggle the switch to enable or disable this feature
	NotInstalledAlerting *bool `pulumi:"notInstalledAlerting"`
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope *string `pulumi:"scope"`
	// This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk).
	StatusConditionLinux *string `pulumi:"statusConditionLinux"`
	// This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk). - `$eq(paused)`
	// – Matches services that are in paused state. Available logic operations: - `$not($eq(paused))` – Matches services
	// that are in state different from paused. - `$or($eq(paused),$eq(running))` – Matches services that are either in
	// paused or running state. Use one of the following values as a parameter for this condition: - `running` - `stopped` -
	// `startPending` - `stopPending` - `continuePending` - `pausePending` - `paused`
	StatusConditionWindows *string `pulumi:"statusConditionWindows"`
	// Possible Values: `LINUX`, `WINDOWS`
	System *string `pulumi:"system"`
}

type OsServicesState struct {
	// The number of **10-second measurement cycles** before alerting is triggered
	AlertActivationDuration pulumi.IntPtrInput
	// Toggle the switch in order to enable or disable alerting for this policy
	Alerting pulumi.BoolPtrInput
	// Detection rules
	DetectionConditionsLinux OsServicesDetectionConditionsLinuxPtrInput
	// Detection rules
	DetectionConditionsWindows OsServicesDetectionConditionsWindowsPtrInput
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolPtrInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Set of additional key-value properties to be attached to the triggered event.
	Metadata OsServicesMetadataPtrInput
	// Toggle the switch in order to enable or disable availability metric monitoring for this policy. Availability metrics produce custom metrics. Refer to [documentation](https://dt-url.net/vl03xzk) for consumption examples. Each monitored service consumes one custom metric.
	Monitoring pulumi.BoolPtrInput
	// Rule name
	Name pulumi.StringPtrInput
	// By default, Dynatrace does not alert if the service is not installed. Toggle the switch to enable or disable this feature
	NotInstalledAlerting pulumi.BoolPtrInput
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope pulumi.StringPtrInput
	// This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk).
	StatusConditionLinux pulumi.StringPtrInput
	// This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk). - `$eq(paused)`
	// – Matches services that are in paused state. Available logic operations: - `$not($eq(paused))` – Matches services
	// that are in state different from paused. - `$or($eq(paused),$eq(running))` – Matches services that are either in
	// paused or running state. Use one of the following values as a parameter for this condition: - `running` - `stopped` -
	// `startPending` - `stopPending` - `continuePending` - `pausePending` - `paused`
	StatusConditionWindows pulumi.StringPtrInput
	// Possible Values: `LINUX`, `WINDOWS`
	System pulumi.StringPtrInput
}

func (OsServicesState) ElementType() reflect.Type {
	return reflect.TypeOf((*osServicesState)(nil)).Elem()
}

type osServicesArgs struct {
	// The number of **10-second measurement cycles** before alerting is triggered
	AlertActivationDuration *int `pulumi:"alertActivationDuration"`
	// Toggle the switch in order to enable or disable alerting for this policy
	Alerting bool `pulumi:"alerting"`
	// Detection rules
	DetectionConditionsLinux *OsServicesDetectionConditionsLinux `pulumi:"detectionConditionsLinux"`
	// Detection rules
	DetectionConditionsWindows *OsServicesDetectionConditionsWindows `pulumi:"detectionConditionsWindows"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled bool `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Set of additional key-value properties to be attached to the triggered event.
	Metadata *OsServicesMetadata `pulumi:"metadata"`
	// Toggle the switch in order to enable or disable availability metric monitoring for this policy. Availability metrics produce custom metrics. Refer to [documentation](https://dt-url.net/vl03xzk) for consumption examples. Each monitored service consumes one custom metric.
	Monitoring bool `pulumi:"monitoring"`
	// Rule name
	Name *string `pulumi:"name"`
	// By default, Dynatrace does not alert if the service is not installed. Toggle the switch to enable or disable this feature
	NotInstalledAlerting *bool `pulumi:"notInstalledAlerting"`
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope *string `pulumi:"scope"`
	// This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk).
	StatusConditionLinux *string `pulumi:"statusConditionLinux"`
	// This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk). - `$eq(paused)`
	// – Matches services that are in paused state. Available logic operations: - `$not($eq(paused))` – Matches services
	// that are in state different from paused. - `$or($eq(paused),$eq(running))` – Matches services that are either in
	// paused or running state. Use one of the following values as a parameter for this condition: - `running` - `stopped` -
	// `startPending` - `stopPending` - `continuePending` - `pausePending` - `paused`
	StatusConditionWindows *string `pulumi:"statusConditionWindows"`
	// Possible Values: `LINUX`, `WINDOWS`
	System string `pulumi:"system"`
}

// The set of arguments for constructing a OsServices resource.
type OsServicesArgs struct {
	// The number of **10-second measurement cycles** before alerting is triggered
	AlertActivationDuration pulumi.IntPtrInput
	// Toggle the switch in order to enable or disable alerting for this policy
	Alerting pulumi.BoolInput
	// Detection rules
	DetectionConditionsLinux OsServicesDetectionConditionsLinuxPtrInput
	// Detection rules
	DetectionConditionsWindows OsServicesDetectionConditionsWindowsPtrInput
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Set of additional key-value properties to be attached to the triggered event.
	Metadata OsServicesMetadataPtrInput
	// Toggle the switch in order to enable or disable availability metric monitoring for this policy. Availability metrics produce custom metrics. Refer to [documentation](https://dt-url.net/vl03xzk) for consumption examples. Each monitored service consumes one custom metric.
	Monitoring pulumi.BoolInput
	// Rule name
	Name pulumi.StringPtrInput
	// By default, Dynatrace does not alert if the service is not installed. Toggle the switch to enable or disable this feature
	NotInstalledAlerting pulumi.BoolPtrInput
	// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
	Scope pulumi.StringPtrInput
	// This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk).
	StatusConditionLinux pulumi.StringPtrInput
	// This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk). - `$eq(paused)`
	// – Matches services that are in paused state. Available logic operations: - `$not($eq(paused))` – Matches services
	// that are in state different from paused. - `$or($eq(paused),$eq(running))` – Matches services that are either in
	// paused or running state. Use one of the following values as a parameter for this condition: - `running` - `stopped` -
	// `startPending` - `stopPending` - `continuePending` - `pausePending` - `paused`
	StatusConditionWindows pulumi.StringPtrInput
	// Possible Values: `LINUX`, `WINDOWS`
	System pulumi.StringInput
}

func (OsServicesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*osServicesArgs)(nil)).Elem()
}

type OsServicesInput interface {
	pulumi.Input

	ToOsServicesOutput() OsServicesOutput
	ToOsServicesOutputWithContext(ctx context.Context) OsServicesOutput
}

func (*OsServices) ElementType() reflect.Type {
	return reflect.TypeOf((**OsServices)(nil)).Elem()
}

func (i *OsServices) ToOsServicesOutput() OsServicesOutput {
	return i.ToOsServicesOutputWithContext(context.Background())
}

func (i *OsServices) ToOsServicesOutputWithContext(ctx context.Context) OsServicesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OsServicesOutput)
}

// OsServicesArrayInput is an input type that accepts OsServicesArray and OsServicesArrayOutput values.
// You can construct a concrete instance of `OsServicesArrayInput` via:
//
//	OsServicesArray{ OsServicesArgs{...} }
type OsServicesArrayInput interface {
	pulumi.Input

	ToOsServicesArrayOutput() OsServicesArrayOutput
	ToOsServicesArrayOutputWithContext(context.Context) OsServicesArrayOutput
}

type OsServicesArray []OsServicesInput

func (OsServicesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*OsServices)(nil)).Elem()
}

func (i OsServicesArray) ToOsServicesArrayOutput() OsServicesArrayOutput {
	return i.ToOsServicesArrayOutputWithContext(context.Background())
}

func (i OsServicesArray) ToOsServicesArrayOutputWithContext(ctx context.Context) OsServicesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OsServicesArrayOutput)
}

// OsServicesMapInput is an input type that accepts OsServicesMap and OsServicesMapOutput values.
// You can construct a concrete instance of `OsServicesMapInput` via:
//
//	OsServicesMap{ "key": OsServicesArgs{...} }
type OsServicesMapInput interface {
	pulumi.Input

	ToOsServicesMapOutput() OsServicesMapOutput
	ToOsServicesMapOutputWithContext(context.Context) OsServicesMapOutput
}

type OsServicesMap map[string]OsServicesInput

func (OsServicesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*OsServices)(nil)).Elem()
}

func (i OsServicesMap) ToOsServicesMapOutput() OsServicesMapOutput {
	return i.ToOsServicesMapOutputWithContext(context.Background())
}

func (i OsServicesMap) ToOsServicesMapOutputWithContext(ctx context.Context) OsServicesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OsServicesMapOutput)
}

type OsServicesOutput struct{ *pulumi.OutputState }

func (OsServicesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OsServices)(nil)).Elem()
}

func (o OsServicesOutput) ToOsServicesOutput() OsServicesOutput {
	return o
}

func (o OsServicesOutput) ToOsServicesOutputWithContext(ctx context.Context) OsServicesOutput {
	return o
}

// The number of **10-second measurement cycles** before alerting is triggered
func (o OsServicesOutput) AlertActivationDuration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *OsServices) pulumi.IntPtrOutput { return v.AlertActivationDuration }).(pulumi.IntPtrOutput)
}

// Toggle the switch in order to enable or disable alerting for this policy
func (o OsServicesOutput) Alerting() pulumi.BoolOutput {
	return o.ApplyT(func(v *OsServices) pulumi.BoolOutput { return v.Alerting }).(pulumi.BoolOutput)
}

// Detection rules
func (o OsServicesOutput) DetectionConditionsLinux() OsServicesDetectionConditionsLinuxPtrOutput {
	return o.ApplyT(func(v *OsServices) OsServicesDetectionConditionsLinuxPtrOutput { return v.DetectionConditionsLinux }).(OsServicesDetectionConditionsLinuxPtrOutput)
}

// Detection rules
func (o OsServicesOutput) DetectionConditionsWindows() OsServicesDetectionConditionsWindowsPtrOutput {
	return o.ApplyT(func(v *OsServices) OsServicesDetectionConditionsWindowsPtrOutput { return v.DetectionConditionsWindows }).(OsServicesDetectionConditionsWindowsPtrOutput)
}

// This setting is enabled (`true`) or disabled (`false`)
func (o OsServicesOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *OsServices) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
func (o OsServicesOutput) InsertAfter() pulumi.StringOutput {
	return o.ApplyT(func(v *OsServices) pulumi.StringOutput { return v.InsertAfter }).(pulumi.StringOutput)
}

// Set of additional key-value properties to be attached to the triggered event.
func (o OsServicesOutput) Metadata() OsServicesMetadataPtrOutput {
	return o.ApplyT(func(v *OsServices) OsServicesMetadataPtrOutput { return v.Metadata }).(OsServicesMetadataPtrOutput)
}

// Toggle the switch in order to enable or disable availability metric monitoring for this policy. Availability metrics produce custom metrics. Refer to [documentation](https://dt-url.net/vl03xzk) for consumption examples. Each monitored service consumes one custom metric.
func (o OsServicesOutput) Monitoring() pulumi.BoolOutput {
	return o.ApplyT(func(v *OsServices) pulumi.BoolOutput { return v.Monitoring }).(pulumi.BoolOutput)
}

// Rule name
func (o OsServicesOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *OsServices) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// By default, Dynatrace does not alert if the service is not installed. Toggle the switch to enable or disable this feature
func (o OsServicesOutput) NotInstalledAlerting() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *OsServices) pulumi.BoolPtrOutput { return v.NotInstalledAlerting }).(pulumi.BoolPtrOutput)
}

// The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
func (o OsServicesOutput) Scope() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OsServices) pulumi.StringPtrOutput { return v.Scope }).(pulumi.StringPtrOutput)
}

// This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk).
func (o OsServicesOutput) StatusConditionLinux() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OsServices) pulumi.StringPtrOutput { return v.StatusConditionLinux }).(pulumi.StringPtrOutput)
}

// This string has to match a required format. See [OS services monitoring](https://dt-url.net/vl03xzk). - `$eq(paused)`
// – Matches services that are in paused state. Available logic operations: - `$not($eq(paused))` – Matches services
// that are in state different from paused. - `$or($eq(paused),$eq(running))` – Matches services that are either in
// paused or running state. Use one of the following values as a parameter for this condition: - `running` - `stopped` -
// `startPending` - `stopPending` - `continuePending` - `pausePending` - `paused`
func (o OsServicesOutput) StatusConditionWindows() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OsServices) pulumi.StringPtrOutput { return v.StatusConditionWindows }).(pulumi.StringPtrOutput)
}

// Possible Values: `LINUX`, `WINDOWS`
func (o OsServicesOutput) System() pulumi.StringOutput {
	return o.ApplyT(func(v *OsServices) pulumi.StringOutput { return v.System }).(pulumi.StringOutput)
}

type OsServicesArrayOutput struct{ *pulumi.OutputState }

func (OsServicesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*OsServices)(nil)).Elem()
}

func (o OsServicesArrayOutput) ToOsServicesArrayOutput() OsServicesArrayOutput {
	return o
}

func (o OsServicesArrayOutput) ToOsServicesArrayOutputWithContext(ctx context.Context) OsServicesArrayOutput {
	return o
}

func (o OsServicesArrayOutput) Index(i pulumi.IntInput) OsServicesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *OsServices {
		return vs[0].([]*OsServices)[vs[1].(int)]
	}).(OsServicesOutput)
}

type OsServicesMapOutput struct{ *pulumi.OutputState }

func (OsServicesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*OsServices)(nil)).Elem()
}

func (o OsServicesMapOutput) ToOsServicesMapOutput() OsServicesMapOutput {
	return o
}

func (o OsServicesMapOutput) ToOsServicesMapOutputWithContext(ctx context.Context) OsServicesMapOutput {
	return o
}

func (o OsServicesMapOutput) MapIndex(k pulumi.StringInput) OsServicesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *OsServices {
		return vs[0].(map[string]*OsServices)[vs[1].(string)]
	}).(OsServicesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*OsServicesInput)(nil)).Elem(), &OsServices{})
	pulumi.RegisterInputType(reflect.TypeOf((*OsServicesArrayInput)(nil)).Elem(), OsServicesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*OsServicesMapInput)(nil)).Elem(), OsServicesMap{})
	pulumi.RegisterOutputType(OsServicesOutput{})
	pulumi.RegisterOutputType(OsServicesArrayOutput{})
	pulumi.RegisterOutputType(OsServicesMapOutput{})
}
