// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-dynatrace/sdk/go/dynatrace/internal"
)

// > **Dynatrace SaaS only**
//
// > To utilize this resource, please define the environment variables `DT_CLIENT_ID`, `DT_CLIENT_SECRET`, `DT_ACCOUNT_ID` with an OAuth client including the following permissions: **View rules** (`automation:rules:read`) and **Create and edit rules** (`automation:rules:write`).
//
// > This resource is excluded by default in the export utility, please explicitly specify the resource to retrieve existing configuration.
//
// ## Dynatrace Documentation
//
// - Dynatrace Workflows - https://www.dynatrace.com/support/help/platform-modules/cloud-automation/workflows
//
// ## Resource Examples
type AutomationSchedulingRule struct {
	pulumi.CustomResourceState

	BusinessCalendar pulumi.StringPtrOutput `pulumi:"businessCalendar"`
	// An optional description for the scheduling rule
	Description    pulumi.StringPtrOutput                          `pulumi:"description"`
	FixedOffset    AutomationSchedulingRuleFixedOffsetPtrOutput    `pulumi:"fixedOffset"`
	Grouping       AutomationSchedulingRuleGroupingPtrOutput       `pulumi:"grouping"`
	Recurrence     AutomationSchedulingRuleRecurrencePtrOutput     `pulumi:"recurrence"`
	RelativeOffset AutomationSchedulingRuleRelativeOffsetPtrOutput `pulumi:"relativeOffset"`
	// The title / name of the scheduling rule
	Title pulumi.StringOutput `pulumi:"title"`
}

// NewAutomationSchedulingRule registers a new resource with the given unique name, arguments, and options.
func NewAutomationSchedulingRule(ctx *pulumi.Context,
	name string, args *AutomationSchedulingRuleArgs, opts ...pulumi.ResourceOption) (*AutomationSchedulingRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Title == nil {
		return nil, errors.New("invalid value for required argument 'Title'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AutomationSchedulingRule
	err := ctx.RegisterResource("dynatrace:index/automationSchedulingRule:AutomationSchedulingRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAutomationSchedulingRule gets an existing AutomationSchedulingRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAutomationSchedulingRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AutomationSchedulingRuleState, opts ...pulumi.ResourceOption) (*AutomationSchedulingRule, error) {
	var resource AutomationSchedulingRule
	err := ctx.ReadResource("dynatrace:index/automationSchedulingRule:AutomationSchedulingRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AutomationSchedulingRule resources.
type automationSchedulingRuleState struct {
	BusinessCalendar *string `pulumi:"businessCalendar"`
	// An optional description for the scheduling rule
	Description    *string                                 `pulumi:"description"`
	FixedOffset    *AutomationSchedulingRuleFixedOffset    `pulumi:"fixedOffset"`
	Grouping       *AutomationSchedulingRuleGrouping       `pulumi:"grouping"`
	Recurrence     *AutomationSchedulingRuleRecurrence     `pulumi:"recurrence"`
	RelativeOffset *AutomationSchedulingRuleRelativeOffset `pulumi:"relativeOffset"`
	// The title / name of the scheduling rule
	Title *string `pulumi:"title"`
}

type AutomationSchedulingRuleState struct {
	BusinessCalendar pulumi.StringPtrInput
	// An optional description for the scheduling rule
	Description    pulumi.StringPtrInput
	FixedOffset    AutomationSchedulingRuleFixedOffsetPtrInput
	Grouping       AutomationSchedulingRuleGroupingPtrInput
	Recurrence     AutomationSchedulingRuleRecurrencePtrInput
	RelativeOffset AutomationSchedulingRuleRelativeOffsetPtrInput
	// The title / name of the scheduling rule
	Title pulumi.StringPtrInput
}

func (AutomationSchedulingRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*automationSchedulingRuleState)(nil)).Elem()
}

type automationSchedulingRuleArgs struct {
	BusinessCalendar *string `pulumi:"businessCalendar"`
	// An optional description for the scheduling rule
	Description    *string                                 `pulumi:"description"`
	FixedOffset    *AutomationSchedulingRuleFixedOffset    `pulumi:"fixedOffset"`
	Grouping       *AutomationSchedulingRuleGrouping       `pulumi:"grouping"`
	Recurrence     *AutomationSchedulingRuleRecurrence     `pulumi:"recurrence"`
	RelativeOffset *AutomationSchedulingRuleRelativeOffset `pulumi:"relativeOffset"`
	// The title / name of the scheduling rule
	Title string `pulumi:"title"`
}

// The set of arguments for constructing a AutomationSchedulingRule resource.
type AutomationSchedulingRuleArgs struct {
	BusinessCalendar pulumi.StringPtrInput
	// An optional description for the scheduling rule
	Description    pulumi.StringPtrInput
	FixedOffset    AutomationSchedulingRuleFixedOffsetPtrInput
	Grouping       AutomationSchedulingRuleGroupingPtrInput
	Recurrence     AutomationSchedulingRuleRecurrencePtrInput
	RelativeOffset AutomationSchedulingRuleRelativeOffsetPtrInput
	// The title / name of the scheduling rule
	Title pulumi.StringInput
}

func (AutomationSchedulingRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*automationSchedulingRuleArgs)(nil)).Elem()
}

type AutomationSchedulingRuleInput interface {
	pulumi.Input

	ToAutomationSchedulingRuleOutput() AutomationSchedulingRuleOutput
	ToAutomationSchedulingRuleOutputWithContext(ctx context.Context) AutomationSchedulingRuleOutput
}

func (*AutomationSchedulingRule) ElementType() reflect.Type {
	return reflect.TypeOf((**AutomationSchedulingRule)(nil)).Elem()
}

func (i *AutomationSchedulingRule) ToAutomationSchedulingRuleOutput() AutomationSchedulingRuleOutput {
	return i.ToAutomationSchedulingRuleOutputWithContext(context.Background())
}

func (i *AutomationSchedulingRule) ToAutomationSchedulingRuleOutputWithContext(ctx context.Context) AutomationSchedulingRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutomationSchedulingRuleOutput)
}

// AutomationSchedulingRuleArrayInput is an input type that accepts AutomationSchedulingRuleArray and AutomationSchedulingRuleArrayOutput values.
// You can construct a concrete instance of `AutomationSchedulingRuleArrayInput` via:
//
//	AutomationSchedulingRuleArray{ AutomationSchedulingRuleArgs{...} }
type AutomationSchedulingRuleArrayInput interface {
	pulumi.Input

	ToAutomationSchedulingRuleArrayOutput() AutomationSchedulingRuleArrayOutput
	ToAutomationSchedulingRuleArrayOutputWithContext(context.Context) AutomationSchedulingRuleArrayOutput
}

type AutomationSchedulingRuleArray []AutomationSchedulingRuleInput

func (AutomationSchedulingRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AutomationSchedulingRule)(nil)).Elem()
}

func (i AutomationSchedulingRuleArray) ToAutomationSchedulingRuleArrayOutput() AutomationSchedulingRuleArrayOutput {
	return i.ToAutomationSchedulingRuleArrayOutputWithContext(context.Background())
}

func (i AutomationSchedulingRuleArray) ToAutomationSchedulingRuleArrayOutputWithContext(ctx context.Context) AutomationSchedulingRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutomationSchedulingRuleArrayOutput)
}

// AutomationSchedulingRuleMapInput is an input type that accepts AutomationSchedulingRuleMap and AutomationSchedulingRuleMapOutput values.
// You can construct a concrete instance of `AutomationSchedulingRuleMapInput` via:
//
//	AutomationSchedulingRuleMap{ "key": AutomationSchedulingRuleArgs{...} }
type AutomationSchedulingRuleMapInput interface {
	pulumi.Input

	ToAutomationSchedulingRuleMapOutput() AutomationSchedulingRuleMapOutput
	ToAutomationSchedulingRuleMapOutputWithContext(context.Context) AutomationSchedulingRuleMapOutput
}

type AutomationSchedulingRuleMap map[string]AutomationSchedulingRuleInput

func (AutomationSchedulingRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AutomationSchedulingRule)(nil)).Elem()
}

func (i AutomationSchedulingRuleMap) ToAutomationSchedulingRuleMapOutput() AutomationSchedulingRuleMapOutput {
	return i.ToAutomationSchedulingRuleMapOutputWithContext(context.Background())
}

func (i AutomationSchedulingRuleMap) ToAutomationSchedulingRuleMapOutputWithContext(ctx context.Context) AutomationSchedulingRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AutomationSchedulingRuleMapOutput)
}

type AutomationSchedulingRuleOutput struct{ *pulumi.OutputState }

func (AutomationSchedulingRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AutomationSchedulingRule)(nil)).Elem()
}

func (o AutomationSchedulingRuleOutput) ToAutomationSchedulingRuleOutput() AutomationSchedulingRuleOutput {
	return o
}

func (o AutomationSchedulingRuleOutput) ToAutomationSchedulingRuleOutputWithContext(ctx context.Context) AutomationSchedulingRuleOutput {
	return o
}

func (o AutomationSchedulingRuleOutput) BusinessCalendar() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AutomationSchedulingRule) pulumi.StringPtrOutput { return v.BusinessCalendar }).(pulumi.StringPtrOutput)
}

// An optional description for the scheduling rule
func (o AutomationSchedulingRuleOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AutomationSchedulingRule) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

func (o AutomationSchedulingRuleOutput) FixedOffset() AutomationSchedulingRuleFixedOffsetPtrOutput {
	return o.ApplyT(func(v *AutomationSchedulingRule) AutomationSchedulingRuleFixedOffsetPtrOutput { return v.FixedOffset }).(AutomationSchedulingRuleFixedOffsetPtrOutput)
}

func (o AutomationSchedulingRuleOutput) Grouping() AutomationSchedulingRuleGroupingPtrOutput {
	return o.ApplyT(func(v *AutomationSchedulingRule) AutomationSchedulingRuleGroupingPtrOutput { return v.Grouping }).(AutomationSchedulingRuleGroupingPtrOutput)
}

func (o AutomationSchedulingRuleOutput) Recurrence() AutomationSchedulingRuleRecurrencePtrOutput {
	return o.ApplyT(func(v *AutomationSchedulingRule) AutomationSchedulingRuleRecurrencePtrOutput { return v.Recurrence }).(AutomationSchedulingRuleRecurrencePtrOutput)
}

func (o AutomationSchedulingRuleOutput) RelativeOffset() AutomationSchedulingRuleRelativeOffsetPtrOutput {
	return o.ApplyT(func(v *AutomationSchedulingRule) AutomationSchedulingRuleRelativeOffsetPtrOutput {
		return v.RelativeOffset
	}).(AutomationSchedulingRuleRelativeOffsetPtrOutput)
}

// The title / name of the scheduling rule
func (o AutomationSchedulingRuleOutput) Title() pulumi.StringOutput {
	return o.ApplyT(func(v *AutomationSchedulingRule) pulumi.StringOutput { return v.Title }).(pulumi.StringOutput)
}

type AutomationSchedulingRuleArrayOutput struct{ *pulumi.OutputState }

func (AutomationSchedulingRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AutomationSchedulingRule)(nil)).Elem()
}

func (o AutomationSchedulingRuleArrayOutput) ToAutomationSchedulingRuleArrayOutput() AutomationSchedulingRuleArrayOutput {
	return o
}

func (o AutomationSchedulingRuleArrayOutput) ToAutomationSchedulingRuleArrayOutputWithContext(ctx context.Context) AutomationSchedulingRuleArrayOutput {
	return o
}

func (o AutomationSchedulingRuleArrayOutput) Index(i pulumi.IntInput) AutomationSchedulingRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AutomationSchedulingRule {
		return vs[0].([]*AutomationSchedulingRule)[vs[1].(int)]
	}).(AutomationSchedulingRuleOutput)
}

type AutomationSchedulingRuleMapOutput struct{ *pulumi.OutputState }

func (AutomationSchedulingRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AutomationSchedulingRule)(nil)).Elem()
}

func (o AutomationSchedulingRuleMapOutput) ToAutomationSchedulingRuleMapOutput() AutomationSchedulingRuleMapOutput {
	return o
}

func (o AutomationSchedulingRuleMapOutput) ToAutomationSchedulingRuleMapOutputWithContext(ctx context.Context) AutomationSchedulingRuleMapOutput {
	return o
}

func (o AutomationSchedulingRuleMapOutput) MapIndex(k pulumi.StringInput) AutomationSchedulingRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AutomationSchedulingRule {
		return vs[0].(map[string]*AutomationSchedulingRule)[vs[1].(string)]
	}).(AutomationSchedulingRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AutomationSchedulingRuleInput)(nil)).Elem(), &AutomationSchedulingRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*AutomationSchedulingRuleArrayInput)(nil)).Elem(), AutomationSchedulingRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AutomationSchedulingRuleMapInput)(nil)).Elem(), AutomationSchedulingRuleMap{})
	pulumi.RegisterOutputType(AutomationSchedulingRuleOutput{})
	pulumi.RegisterOutputType(AutomationSchedulingRuleArrayOutput{})
	pulumi.RegisterOutputType(AutomationSchedulingRuleMapOutput{})
}
