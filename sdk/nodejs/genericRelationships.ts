// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export class GenericRelationships extends pulumi.CustomResource {
    /**
     * Get an existing GenericRelationships resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: GenericRelationshipsState, opts?: pulumi.CustomResourceOptions): GenericRelationships {
        return new GenericRelationships(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'dynatrace:index/genericRelationships:GenericRelationships';

    /**
     * Returns true if the given object is an instance of GenericRelationships.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is GenericRelationships {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === GenericRelationships.__pulumiType;
    }

    /**
     * The user or extension that created this relationship.
     */
    public readonly createdBy!: pulumi.Output<string>;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    public readonly enabled!: pulumi.Output<boolean>;
    /**
     * Specify a role for the source entity. If both source and destination type are the same, referring different roles will allow identification of a relationships direction. If role is left blank, any role of the source type is considered for the relationship.
     */
    public readonly fromRole!: pulumi.Output<string | undefined>;
    /**
     * Define an entity type as the source of the relationship.
     */
    public readonly fromType!: pulumi.Output<string>;
    /**
     * Specify all sources which should be evaluated for this relationship rule. The relationship is only created when any of the filters match.
     */
    public readonly sources!: pulumi.Output<outputs.GenericRelationshipsSources>;
    /**
     * Specify a role for the destination entity. If both source and destination type are the same, referring different roles will allow identification of a relationships direction. If role is left blank, any role of the destination type is considered for the relationship.
     */
    public readonly toRole!: pulumi.Output<string | undefined>;
    /**
     * Define an entity type as the destination of the relationship. You can choose the same type as the source type. In this case you also may assign different roles for source and destination for having directed relationships.
     */
    public readonly toType!: pulumi.Output<string>;
    /**
     * Possible Values: `CALLS`, `CHILD_OF`, `INSTANCE_OF`, `PART_OF`, `RUNS_ON`, `SAME_AS`
     */
    public readonly typeOfRelation!: pulumi.Output<string>;

    /**
     * Create a GenericRelationships resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: GenericRelationshipsArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: GenericRelationshipsArgs | GenericRelationshipsState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as GenericRelationshipsState | undefined;
            resourceInputs["createdBy"] = state ? state.createdBy : undefined;
            resourceInputs["enabled"] = state ? state.enabled : undefined;
            resourceInputs["fromRole"] = state ? state.fromRole : undefined;
            resourceInputs["fromType"] = state ? state.fromType : undefined;
            resourceInputs["sources"] = state ? state.sources : undefined;
            resourceInputs["toRole"] = state ? state.toRole : undefined;
            resourceInputs["toType"] = state ? state.toType : undefined;
            resourceInputs["typeOfRelation"] = state ? state.typeOfRelation : undefined;
        } else {
            const args = argsOrState as GenericRelationshipsArgs | undefined;
            if ((!args || args.createdBy === undefined) && !opts.urn) {
                throw new Error("Missing required property 'createdBy'");
            }
            if ((!args || args.enabled === undefined) && !opts.urn) {
                throw new Error("Missing required property 'enabled'");
            }
            if ((!args || args.fromType === undefined) && !opts.urn) {
                throw new Error("Missing required property 'fromType'");
            }
            if ((!args || args.sources === undefined) && !opts.urn) {
                throw new Error("Missing required property 'sources'");
            }
            if ((!args || args.toType === undefined) && !opts.urn) {
                throw new Error("Missing required property 'toType'");
            }
            if ((!args || args.typeOfRelation === undefined) && !opts.urn) {
                throw new Error("Missing required property 'typeOfRelation'");
            }
            resourceInputs["createdBy"] = args ? args.createdBy : undefined;
            resourceInputs["enabled"] = args ? args.enabled : undefined;
            resourceInputs["fromRole"] = args ? args.fromRole : undefined;
            resourceInputs["fromType"] = args ? args.fromType : undefined;
            resourceInputs["sources"] = args ? args.sources : undefined;
            resourceInputs["toRole"] = args ? args.toRole : undefined;
            resourceInputs["toType"] = args ? args.toType : undefined;
            resourceInputs["typeOfRelation"] = args ? args.typeOfRelation : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(GenericRelationships.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering GenericRelationships resources.
 */
export interface GenericRelationshipsState {
    /**
     * The user or extension that created this relationship.
     */
    createdBy?: pulumi.Input<string>;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Specify a role for the source entity. If both source and destination type are the same, referring different roles will allow identification of a relationships direction. If role is left blank, any role of the source type is considered for the relationship.
     */
    fromRole?: pulumi.Input<string>;
    /**
     * Define an entity type as the source of the relationship.
     */
    fromType?: pulumi.Input<string>;
    /**
     * Specify all sources which should be evaluated for this relationship rule. The relationship is only created when any of the filters match.
     */
    sources?: pulumi.Input<inputs.GenericRelationshipsSources>;
    /**
     * Specify a role for the destination entity. If both source and destination type are the same, referring different roles will allow identification of a relationships direction. If role is left blank, any role of the destination type is considered for the relationship.
     */
    toRole?: pulumi.Input<string>;
    /**
     * Define an entity type as the destination of the relationship. You can choose the same type as the source type. In this case you also may assign different roles for source and destination for having directed relationships.
     */
    toType?: pulumi.Input<string>;
    /**
     * Possible Values: `CALLS`, `CHILD_OF`, `INSTANCE_OF`, `PART_OF`, `RUNS_ON`, `SAME_AS`
     */
    typeOfRelation?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a GenericRelationships resource.
 */
export interface GenericRelationshipsArgs {
    /**
     * The user or extension that created this relationship.
     */
    createdBy: pulumi.Input<string>;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: pulumi.Input<boolean>;
    /**
     * Specify a role for the source entity. If both source and destination type are the same, referring different roles will allow identification of a relationships direction. If role is left blank, any role of the source type is considered for the relationship.
     */
    fromRole?: pulumi.Input<string>;
    /**
     * Define an entity type as the source of the relationship.
     */
    fromType: pulumi.Input<string>;
    /**
     * Specify all sources which should be evaluated for this relationship rule. The relationship is only created when any of the filters match.
     */
    sources: pulumi.Input<inputs.GenericRelationshipsSources>;
    /**
     * Specify a role for the destination entity. If both source and destination type are the same, referring different roles will allow identification of a relationships direction. If role is left blank, any role of the destination type is considered for the relationship.
     */
    toRole?: pulumi.Input<string>;
    /**
     * Define an entity type as the destination of the relationship. You can choose the same type as the source type. In this case you also may assign different roles for source and destination for having directed relationships.
     */
    toType: pulumi.Input<string>;
    /**
     * Possible Values: `CALLS`, `CHILD_OF`, `INSTANCE_OF`, `PART_OF`, `RUNS_ON`, `SAME_AS`
     */
    typeOfRelation: pulumi.Input<string>;
}
