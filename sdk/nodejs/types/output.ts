// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AlertingFilters {
    /**
     * A conditions for the metric usage
     */
    filters?: outputs.AlertingFiltersFilter[];
}

export interface AlertingFiltersFilter {
    custom?: outputs.AlertingFiltersFilterCustom;
    predefined?: outputs.AlertingFiltersFilterPredefined;
}

export interface AlertingFiltersFilterCustom {
    description?: outputs.AlertingFiltersFilterCustomDescription;
    metadata?: outputs.AlertingFiltersFilterCustomMetadata;
    title?: outputs.AlertingFiltersFilterCustomTitle;
}

export interface AlertingFiltersFilterCustomDescription {
    caseSensitive?: boolean;
    enabled?: boolean;
    negate?: boolean;
    operator: string;
    value: string;
}

export interface AlertingFiltersFilterCustomMetadata {
    items: outputs.AlertingFiltersFilterCustomMetadataItems;
}

export interface AlertingFiltersFilterCustomMetadataItems {
    filters: outputs.AlertingFiltersFilterCustomMetadataItemsFilter[];
}

export interface AlertingFiltersFilterCustomMetadataItemsFilter {
    key: string;
    value: string;
}

export interface AlertingFiltersFilterCustomTitle {
    caseSensitive?: boolean;
    enabled?: boolean;
    negate?: boolean;
    operator: string;
    value: string;
}

export interface AlertingFiltersFilterPredefined {
    negate?: boolean;
    type: string;
}

export interface AlertingProfileEventTypeFilter {
    /**
     * Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
     */
    customEventFilters?: outputs.AlertingProfileEventTypeFilterCustomEventFilter[];
    /**
     * Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
     */
    predefinedEventFilters?: outputs.AlertingProfileEventTypeFilterPredefinedEventFilter[];
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface AlertingProfileEventTypeFilterCustomEventFilter {
    customDescriptionFilters?: outputs.AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter[];
    customTitleFilters?: outputs.AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter[];
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter {
    caseInsensitive?: boolean;
    enabled?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    value: string;
}

export interface AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter {
    caseInsensitive?: boolean;
    enabled?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    value: string;
}

export interface AlertingProfileEventTypeFilterPredefinedEventFilter {
    eventType: string;
    negate?: boolean;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface AlertingProfileMetadata {
    /**
     * Dynatrace server version
     */
    clusterVersion?: string;
    /**
     * A Sorted list of the version numbers of the configuration
     */
    configurationVersions?: number[];
    /**
     * A Sorted list of the version numbers of the configuration
     */
    currentConfigurationVersions?: string[];
}

export interface AlertingProfileRule {
    /**
     * Send a notification if a problem remains open longer than *X* minutes
     */
    delayInMinutes: number;
    /**
     * The severity level to trigger the alert. Possible values are `AVAILABILITY`,	`CUSTOM_ALERT`,	`ERROR`,`MONITORING_UNAVAILABLE`,`PERFORMANCE` and `RESOURCE_CONTENTION`.
     */
    severityLevel: string;
    /**
     * Configuration of the tag filtering of the alerting profile
     */
    tagFilters: outputs.AlertingProfileRuleTagFilter[];
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface AlertingProfileRuleTagFilter {
    includeMode: string;
    tagFilters?: outputs.AlertingProfileRuleTagFilterTagFilter[];
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface AlertingProfileRuleTagFilterTagFilter {
    context: string;
    key: string;
    value?: string;
}

export interface AlertingRules {
    /**
     * A conditions for the metric usage
     */
    rules?: outputs.AlertingRulesRule[];
}

export interface AlertingRulesRule {
    delayInMinutes: number;
    includeMode: string;
    severityLevel: string;
    tags?: string[];
}

export interface ApiDetectionConditions {
    conditions: outputs.ApiDetectionConditionsCondition[];
}

export interface ApiDetectionConditionsCondition {
    base: string;
    matcher: string;
    pattern: string;
}

export interface ApplicationAnomaliesFailureRate {
    /**
     * Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
     */
    auto?: outputs.ApplicationAnomaliesFailureRateAuto;
    /**
     * Fixed thresholds for failure rate increase detection
     */
    thresholds?: outputs.ApplicationAnomaliesFailureRateThresholds;
}

export interface ApplicationAnomaliesFailureRateAuto {
    absolute: number;
    relative: number;
    unknowns?: string;
}

export interface ApplicationAnomaliesFailureRateThresholds {
    sensitivity: string;
    threshold: number;
    unknowns?: string;
}

export interface ApplicationAnomaliesResponseTime {
    /**
     * Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
     */
    auto?: outputs.ApplicationAnomaliesResponseTimeAuto;
    /**
     * Fixed thresholds for response time degradation detection
     */
    thresholds?: outputs.ApplicationAnomaliesResponseTimeThresholds;
}

export interface ApplicationAnomaliesResponseTimeAuto {
    load: string;
    milliseconds: number;
    percent: number;
    slowestMilliseconds: number;
    slowestPercent: number;
    unknowns?: string;
}

export interface ApplicationAnomaliesResponseTimeThresholds {
    load: string;
    milliseconds: number;
    sensitivity: string;
    slowestMilliseconds: number;
    unknowns?: string;
}

export interface ApplicationAnomaliesTraffic {
    /**
     * The configuration of traffic drops detection
     */
    drops?: outputs.ApplicationAnomaliesTrafficDrops;
    /**
     * The configuration of traffic spikes detection
     */
    spikes?: outputs.ApplicationAnomaliesTrafficSpikes;
}

export interface ApplicationAnomaliesTrafficDrops {
    enabled: boolean;
    percent?: number;
}

export interface ApplicationAnomaliesTrafficSpikes {
    enabled: boolean;
    percent?: number;
}

export interface ApplicationDataPrivacySessionReplayDataPrivacy {
    /**
     * (Field has overlap with `dynatrace.SessionReplayWebPrivacy`) Content masking settings for Session Replay.
     */
    contentMaskingSettings: outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettings;
    optIn?: boolean;
    urlExclusionRules?: string[];
}

export interface ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettings {
    playback: outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlayback;
    recording: outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecording;
}

export interface ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlayback {
    preset: string;
    rules?: outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRules;
}

export interface ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRules {
    rules: outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule[];
}

export interface ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule {
    selector: string;
    type: string;
    userInteractionHidden?: boolean;
}

export interface ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecording {
    preset: string;
    rules?: outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRules;
}

export interface ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRules {
    rules: outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule[];
}

export interface ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule {
    selector: string;
    type: string;
    userInteractionHidden?: boolean;
}

export interface ApplicationDetectionRuleFilterConfig {
    /**
     * Where to look for the pattern value, possible values are `DOMAIN` or `URL`
     */
    applicationMatchTarget: string;
    /**
     * The operator used for matching the application detection rule, possible values are `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`, `MATCHES`
     */
    applicationMatchType: string;
    /**
     * The value to look for with the application detection rule
     */
    pattern: string;
}

export interface ApplicationErrorRulesCustomErrors {
    /**
     * Configuration of the custom error in the web application
     */
    rules: outputs.ApplicationErrorRulesCustomErrorsRule[];
}

export interface ApplicationErrorRulesCustomErrorsRule {
    capture?: boolean;
    customAlerting?: boolean;
    impactApdex?: boolean;
    keyMatcher?: string;
    keyPattern?: string;
    valueMatcher?: string;
    valuePattern?: string;
}

export interface ApplicationErrorRulesHttpErrors {
    /**
     * Configuration of the HTTP error in the web application
     */
    rules: outputs.ApplicationErrorRulesHttpErrorsRule[];
}

export interface ApplicationErrorRulesHttpErrorsRule {
    capture?: boolean;
    considerBlockedRequests?: boolean;
    considerForAi?: boolean;
    considerUnknownErrorCode?: boolean;
    errorCodes?: string;
    filter?: string;
    filterByUrl?: boolean;
    impactApdex?: boolean;
    url?: string;
}

export interface AutotagEntitySelectorBasedRule {
    enabled?: boolean;
    normalization?: string;
    selector?: string;
    unknowns?: string;
    valueFormat?: string;
}

export interface AutotagRule {
    conditions?: outputs.AutotagRuleCondition[];
    enabled?: boolean;
    normalization?: string;
    propagationTypes?: string[];
    type: string;
    unknowns?: string;
    valueFormat?: string;
}

export interface AutotagRuleCondition {
    /**
     * @deprecated You should use 'application_type' instead of 'application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    applicationTypeComparisons?: outputs.AutotagRuleConditionApplicationTypeComparison[];
    applicationTypes?: outputs.AutotagRuleConditionApplicationType[];
    azureComputeModeComparisons?: outputs.AutotagRuleConditionAzureComputeModeComparison[];
    /**
     * @deprecated You should use 'azure_compute_mode' instead of 'azure_compute_mode_comparison'. This attribute still exists for backwards compatibility.
     */
    azureComputeModes?: outputs.AutotagRuleConditionAzureComputeMode[];
    /**
     * @deprecated You should use 'azure_sku' instead of 'azure_sku_comparision'. This attribute still exists for backwards compatibility.
     */
    azureSkuComparisions?: outputs.AutotagRuleConditionAzureSkuComparision[];
    azureSkus?: outputs.AutotagRuleConditionAzureSkus[];
    /**
     * @deprecated You should use 'comparison' instead of 'base_comparison_basic'. This attribute still exists for backwards compatibility.
     */
    baseComparisonBasics?: outputs.AutotagRuleConditionBaseComparisonBasic[];
    /**
     * @deprecated 'base_condition_key' is deprecated. You should use 'key'
     */
    baseConditionKeys?: outputs.AutotagRuleConditionBaseConditionKey[];
    /**
     * @deprecated You should use 'bitness' instead of 'bitness_comparision'. This attribute still exists for backwards compatibility.
     */
    bitnessComparisions?: outputs.AutotagRuleConditionBitnessComparision[];
    bitnesses?: outputs.AutotagRuleConditionBitness[];
    /**
     * @deprecated You should use 'cloud_type' instead of 'cloud_type_comparison'. This attribute still exists for backwards compatibility.
     */
    cloudTypeComparisons?: outputs.AutotagRuleConditionCloudTypeComparison[];
    cloudTypes?: outputs.AutotagRuleConditionCloudType[];
    comparisons?: outputs.AutotagRuleConditionComparison[];
    /**
     * @deprecated You should use 'custom_application_type' instead of 'custom_application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    customApplicationTypeComparisons?: outputs.AutotagRuleConditionCustomApplicationTypeComparison[];
    customApplicationTypes?: outputs.AutotagRuleConditionCustomApplicationType[];
    /**
     * @deprecated 'custom_host_metadata_condition_key' is deprecated. You should use 'custom_host_metadata'
     */
    customHostMetadataConditionKeys?: outputs.AutotagRuleConditionCustomHostMetadataConditionKey[];
    customHostMetadatas?: outputs.AutotagRuleConditionCustomHostMetadata[];
    /**
     * @deprecated 'custom_process_metadata_condition_key' is deprecated. You should use 'custom_process_metadata'
     */
    customProcessMetadataConditionKeys?: outputs.AutotagRuleConditionCustomProcessMetadataConditionKey[];
    customProcessMetadatas?: outputs.AutotagRuleConditionCustomProcessMetadata[];
    databaseTopologies?: outputs.AutotagRuleConditionDatabaseTopology[];
    /**
     * @deprecated You should use 'database_topology' instead of 'database_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    databaseTopologyComparisons?: outputs.AutotagRuleConditionDatabaseTopologyComparison[];
    /**
     * @deprecated You should use 'dcrum_decoder' instead of 'dcrum_decoder_comparison'. This attribute still exists for backwards compatibility.
     */
    dcrumDecoderComparisons?: outputs.AutotagRuleConditionDcrumDecoderComparison[];
    dcrumDecoders?: outputs.AutotagRuleConditionDcrumDecoder[];
    entities?: outputs.AutotagRuleConditionEntity[];
    /**
     * @deprecated You should use 'entity' instead of 'entity_id_comparison'. This attribute still exists for backwards compatibility.
     */
    entityIdComparisons?: outputs.AutotagRuleConditionEntityIdComparison[];
    hostTeches?: outputs.AutotagRuleConditionHostTech[];
    /**
     * @deprecated `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
     */
    hypervisorTypeComparisions?: outputs.AutotagRuleConditionHypervisorTypeComparision[];
    hypervisors?: outputs.AutotagRuleConditionHypervisor[];
    /**
     * @deprecated You should use 'indexed_name' instead of 'indexed_name_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedNameComparisons?: outputs.AutotagRuleConditionIndexedNameComparison[];
    indexedNames?: outputs.AutotagRuleConditionIndexedName[];
    /**
     * @deprecated You should use 'indexed_string' instead of 'indexed_string_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedStringComparisons?: outputs.AutotagRuleConditionIndexedStringComparison[];
    indexedStrings?: outputs.AutotagRuleConditionIndexedString[];
    /**
     * @deprecated You should use 'indexed_tag' instead of 'indexed_tag_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedTagComparisons?: outputs.AutotagRuleConditionIndexedTagComparison[];
    indexedTags?: outputs.AutotagRuleConditionIndexedTag[];
    /**
     * @deprecated You should use 'integer' instead of 'integer_comparison'. This attribute still exists for backwards compatibility.
     */
    integerComparisons?: outputs.AutotagRuleConditionIntegerComparison[];
    integers?: outputs.AutotagRuleConditionInteger[];
    /**
     * @deprecated You should use 'ipaddress' instead of 'ipaddress_comparison'. This attribute still exists for backwards compatibility.
     */
    ipaddressComparisons?: outputs.AutotagRuleConditionIpaddressComparison[];
    ipaddresses?: outputs.AutotagRuleConditionIpaddress[];
    keys?: outputs.AutotagRuleConditionKey[];
    /**
     * @deprecated You should use 'mobile_platform' instead of 'mobile_platform_comparison'. This attribute still exists for backwards compatibility.
     */
    mobilePlatformComparisons?: outputs.AutotagRuleConditionMobilePlatformComparison[];
    mobilePlatforms?: outputs.AutotagRuleConditionMobilePlatform[];
    osArches?: outputs.AutotagRuleConditionOsArch[];
    osTypes?: outputs.AutotagRuleConditionOsType[];
    /**
     * @deprecated You should use 'os_arch' instead of 'osarchitecture_comparison'. This attribute still exists for backwards compatibility.
     */
    osarchitectureComparisons?: outputs.AutotagRuleConditionOsarchitectureComparison[];
    /**
     * @deprecated You should use 'os_type' instead of 'ostype_comparison'. This attribute still exists for backwards compatibility.
     */
    ostypeComparisons?: outputs.AutotagRuleConditionOstypeComparison[];
    /**
     * @deprecated You should use 'paas_type' instead of 'paas_type_comparison'. This attribute still exists for backwards compatibility.
     */
    paasTypeComparisons?: outputs.AutotagRuleConditionPaasTypeComparison[];
    paasTypes?: outputs.AutotagRuleConditionPaasType[];
    /**
     * @deprecated 'process_metadata_condition_key' is deprecated. You should use 'process_metadata'
     */
    processMetadataConditionKeys?: outputs.AutotagRuleConditionProcessMetadataConditionKey[];
    processMetadatas?: outputs.AutotagRuleConditionProcessMetadata[];
    serviceTopologies?: outputs.AutotagRuleConditionServiceTopology[];
    /**
     * @deprecated You should use 'service_topology' instead of 'service_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTopologyComparisons?: outputs.AutotagRuleConditionServiceTopologyComparison[];
    /**
     * @deprecated You should use 'service_type' instead of 'service_type_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTypeComparisons?: outputs.AutotagRuleConditionServiceTypeComparison[];
    serviceTypes?: outputs.AutotagRuleConditionServiceType[];
    /**
     * @deprecated You should use 'host_tech' instead of 'simple_host_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleHostTechComparisons?: outputs.AutotagRuleConditionSimpleHostTechComparison[];
    /**
     * @deprecated You should use 'tech' instead of 'simple_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleTechComparisons?: outputs.AutotagRuleConditionSimpleTechComparison[];
    /**
     * @deprecated You should use 'string' instead of 'string_comparison'. This attribute still exists for backwards compatibility.
     */
    stringComparisons?: outputs.AutotagRuleConditionStringComparison[];
    /**
     * @deprecated 'string_condition_key' is deprecated. You should use 'string_key'
     */
    stringConditionKeys?: outputs.AutotagRuleConditionStringConditionKey[];
    stringKeys?: outputs.AutotagRuleConditionStringKey[];
    strings?: outputs.AutotagRuleConditionString[];
    /**
     * @deprecated You should use 'synthetic_engine' instead of 'synthetic_engine_type_comparison'. This attribute still exists for backwards compatibility.
     */
    syntheticEngineTypeComparisons?: outputs.AutotagRuleConditionSyntheticEngineTypeComparison[];
    syntheticEngines?: outputs.AutotagRuleConditionSyntheticEngine[];
    /**
     * @deprecated You should use 'tag' instead of 'tag_comparison'. This attribute still exists for backwards compatibility.
     */
    tagComparisons?: outputs.AutotagRuleConditionTagComparison[];
    tags?: outputs.AutotagRuleConditionTag[];
    teches?: outputs.AutotagRuleConditionTech[];
    unknowns?: string;
}

export interface AutotagRuleConditionApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionAzureComputeMode {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionAzureComputeModeComparison {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionAzureSkuComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionAzureSkus {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionBaseComparisonBasic {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface AutotagRuleConditionBaseConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface AutotagRuleConditionBitness {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionBitnessComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionCloudType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionCloudTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionComparison {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface AutotagRuleConditionCustomApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionCustomApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionCustomHostMetadata {
    attribute: string;
    dynamicKey: outputs.AutotagRuleConditionCustomHostMetadataDynamicKey;
    unknowns?: string;
}

export interface AutotagRuleConditionCustomHostMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.AutotagRuleConditionCustomHostMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface AutotagRuleConditionCustomHostMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface AutotagRuleConditionCustomHostMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface AutotagRuleConditionCustomProcessMetadata {
    attribute: string;
    dynamicKey: outputs.AutotagRuleConditionCustomProcessMetadataDynamicKey;
    unknowns?: string;
}

export interface AutotagRuleConditionCustomProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.AutotagRuleConditionCustomProcessMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface AutotagRuleConditionCustomProcessMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface AutotagRuleConditionCustomProcessMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface AutotagRuleConditionDatabaseTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionDatabaseTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionDcrumDecoder {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionDcrumDecoderComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionEntity {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionEntityIdComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionHostTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.AutotagRuleConditionHostTechValue;
}

export interface AutotagRuleConditionHostTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface AutotagRuleConditionHypervisor {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionHypervisorTypeComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionIndexedName {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionIndexedNameComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionIndexedString {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionIndexedStringComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionIndexedTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.AutotagRuleConditionIndexedTagValue;
}

export interface AutotagRuleConditionIndexedTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.AutotagRuleConditionIndexedTagComparisonValue;
}

export interface AutotagRuleConditionIndexedTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionIndexedTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionInteger {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: number;
}

export interface AutotagRuleConditionIntegerComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: number;
}

export interface AutotagRuleConditionIpaddress {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionIpaddressComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface AutotagRuleConditionMobilePlatform {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionMobilePlatformComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionOsArch {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionOsType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionOsarchitectureComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionOstypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionPaasType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionPaasTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionProcessMetadata {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface AutotagRuleConditionProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface AutotagRuleConditionServiceTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionServiceTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionServiceType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionServiceTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionSimpleHostTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.AutotagRuleConditionSimpleHostTechComparisonValue;
}

export interface AutotagRuleConditionSimpleHostTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface AutotagRuleConditionSimpleTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.AutotagRuleConditionSimpleTechComparisonValue;
}

export interface AutotagRuleConditionSimpleTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface AutotagRuleConditionString {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionStringComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionStringConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface AutotagRuleConditionStringKey {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface AutotagRuleConditionSyntheticEngine {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionSyntheticEngineTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.AutotagRuleConditionTagValue;
}

export interface AutotagRuleConditionTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.AutotagRuleConditionTagComparisonValue;
}

export interface AutotagRuleConditionTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.AutotagRuleConditionTechValue;
}

export interface AutotagRuleConditionTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface AutotagV2Rules {
    rules: outputs.AutotagV2RulesRule[];
}

export interface AutotagV2RulesRule {
    attributeRule?: outputs.AutotagV2RulesRuleAttributeRule;
    enabled: boolean;
    entitySelector?: string;
    type: string;
    valueFormat?: string;
    valueNormalization: string;
}

export interface AutotagV2RulesRuleAttributeRule {
    azureToPgpropagation?: boolean;
    azureToServicePropagation?: boolean;
    conditions: outputs.AutotagV2RulesRuleAttributeRuleConditions;
    entityType: string;
    hostToPgpropagation?: boolean;
    pgToHostPropagation?: boolean;
    pgToServicePropagation?: boolean;
    serviceToHostPropagation?: boolean;
    serviceToPgpropagation?: boolean;
}

export interface AutotagV2RulesRuleAttributeRuleConditions {
    conditions: outputs.AutotagV2RulesRuleAttributeRuleConditionsCondition[];
}

export interface AutotagV2RulesRuleAttributeRuleConditionsCondition {
    caseSensitive?: boolean;
    dynamicKey?: string;
    dynamicKeySource?: string;
    entityId?: string;
    enumValue?: string;
    integerValue?: number;
    key: string;
    operator: string;
    stringValue?: string;
    tag?: string;
}

export interface AwsAnomaliesEc2CandidateHighCpuDetection {
    /**
     * Alert if the condition is met in 3 out of 5 samples
     */
    customThresholds?: outputs.AwsAnomaliesEc2CandidateHighCpuDetectionCustomThresholds;
    /**
     * Possible Values: `Auto`, `Custom`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface AwsAnomaliesEc2CandidateHighCpuDetectionCustomThresholds {
    cpuUsage: number;
}

export interface AwsAnomaliesElbHighConnectionErrorsDetection {
    /**
     * Alert if the condition is met in 3 out of 5 samples
     */
    customThresholds?: outputs.AwsAnomaliesElbHighConnectionErrorsDetectionCustomThresholds;
    /**
     * Possible Values: `Auto`, `Custom`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface AwsAnomaliesElbHighConnectionErrorsDetectionCustomThresholds {
    connectionErrorsPerMinute: number;
}

export interface AwsAnomaliesLambdaHighErrorRateDetection {
    /**
     * Alert if the condition is met in 3 out of 5 samples
     */
    customThresholds?: outputs.AwsAnomaliesLambdaHighErrorRateDetectionCustomThresholds;
    /**
     * Possible Values: `Auto`, `Custom`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface AwsAnomaliesLambdaHighErrorRateDetectionCustomThresholds {
    failedInvocationsRate: number;
}

export interface AwsAnomaliesRdsHighCpuDetection {
    /**
     * Alert if the condition is met in 3 out of 5 samples
     */
    customThresholds?: outputs.AwsAnomaliesRdsHighCpuDetectionCustomThresholds;
    /**
     * Possible Values: `Auto`, `Custom`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface AwsAnomaliesRdsHighCpuDetectionCustomThresholds {
    cpuUsage: number;
}

export interface AwsAnomaliesRdsHighMemoryDetection {
    /**
     * Alert if **both** conditions is met in 3 out of 5 samples
     */
    customThresholds?: outputs.AwsAnomaliesRdsHighMemoryDetectionCustomThresholds;
    /**
     * Possible Values: `Auto`, `Custom`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface AwsAnomaliesRdsHighMemoryDetectionCustomThresholds {
    freeMemory: number;
    swapUsage: number;
}

export interface AwsAnomaliesRdsHighWriteReadLatencyDetection {
    /**
     * Alert if the condition is met in 3 out of 5 samples
     */
    customThresholds?: outputs.AwsAnomaliesRdsHighWriteReadLatencyDetectionCustomThresholds;
    /**
     * Possible Values: `Auto`, `Custom`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface AwsAnomaliesRdsHighWriteReadLatencyDetectionCustomThresholds {
    readWriteLatency: number;
}

export interface AwsAnomaliesRdsLowStorageDetection {
    /**
     * Alert if the condition is met in 3 out of 5 samples
     */
    customThresholds?: outputs.AwsAnomaliesRdsLowStorageDetectionCustomThresholds;
    /**
     * Possible Values: `Auto`, `Custom`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface AwsAnomaliesRdsLowStorageDetectionCustomThresholds {
    freeStoragePercentage: number;
}

export interface AwsAnomaliesRdsRestartsSequenceDetection {
    /**
     * Alert if the condition is met in 2 out of 20 samples
     */
    customThresholds?: outputs.AwsAnomaliesRdsRestartsSequenceDetectionCustomThresholds;
    /**
     * Possible Values: `Auto`, `Custom`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface AwsAnomaliesRdsRestartsSequenceDetectionCustomThresholds {
    restartsPerMinute: number;
}

export interface AwsCredentialsAuthenticationData {
    /**
     * the access key
     */
    accessKey?: string;
    /**
     * the ID of the Amazon account
     */
    accountId?: string;
    /**
     * (Read only) the external ID token for setting an IAM role. You can obtain it with the `GET /aws/iamExternalId` request
     */
    externalId: string;
    /**
     * the IAM role to be used by Dynatrace to get monitoring data
     */
    iamRole?: string;
    /**
     * the secret access key
     */
    secretKey?: string;
    /**
     * Any attributes that aren't yet supported by this provider
     */
    unknowns?: string;
}

export interface AwsCredentialsSupportingServicesToMonitor {
    /**
     * a list of metrics to be monitored for this service
     */
    monitoredMetrics?: outputs.AwsCredentialsSupportingServicesToMonitorMonitoredMetric[];
    /**
     * the name of the supporting service
     */
    name?: string;
    /**
     * Any attributes that aren't yet supported by this provider
     */
    unknowns?: string;
}

export interface AwsCredentialsSupportingServicesToMonitorMonitoredMetric {
    dimensions?: string[];
    name?: string;
    statistic?: string;
    /**
     * Any attributes that aren't yet supported by this provider
     */
    unknowns?: string;
}

export interface AwsCredentialsTagsToMonitor {
    /**
     * the key of the AWS tag.
     */
    name?: string;
    /**
     * Any attributes that aren't yet supported by this provider
     */
    unknowns?: string;
    /**
     * the value of the AWS tag
     */
    value?: string;
}

export interface AzureCredentialsMonitorOnlyExcludingTagPair {
    /**
     * The name of the tag.
     */
    name?: string;
    /**
     * Any attributes that aren't yet supported by this provider
     */
    unknowns?: string;
    /**
     * The value of the tag.   If set to `null`, then resources with any value of the tag are monitored.
     */
    value?: string;
}

export interface AzureCredentialsMonitorOnlyTagPair {
    /**
     * The name of the tag.
     */
    name?: string;
    /**
     * Any attributes that aren't yet supported by this provider
     */
    unknowns?: string;
    /**
     * The value of the tag.   If set to `null`, then resources with any value of the tag are monitored.
     */
    value?: string;
}

export interface AzureCredentialsSupportingService {
    /**
     * A list of Azure tags to be monitored.  You can specify up to 10 tags. A resource tagged with *any* of the specified tags is monitored.  Only applicable when the **monitorOnlyTaggedEntities** parameter is set to `true`
     */
    monitoredMetrics?: outputs.AzureCredentialsSupportingServiceMonitoredMetric[];
    /**
     * The name of the supporting service.
     */
    name?: string;
    /**
     * Any attributes that aren't yet supported by this provider
     */
    unknowns?: string;
}

export interface AzureCredentialsSupportingServiceMonitoredMetric {
    dimensions?: string[];
    name?: string;
    /**
     * Any attributes that aren't yet supported by this provider
     */
    unknowns?: string;
}

export interface BrowserMonitorAnomalyDetection {
    /**
     * Thresholds for loading times
     */
    loadingTimeThresholds?: outputs.BrowserMonitorAnomalyDetectionLoadingTimeThreshold[];
    /**
     * Outage handling configuration
     */
    outageHandlings?: outputs.BrowserMonitorAnomalyDetectionOutageHandling[];
}

export interface BrowserMonitorAnomalyDetectionLoadingTimeThreshold {
    enabled?: boolean;
    thresholds?: outputs.BrowserMonitorAnomalyDetectionLoadingTimeThresholdThreshold[];
}

export interface BrowserMonitorAnomalyDetectionLoadingTimeThresholdThreshold {
    thresholds: outputs.BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold[];
}

export interface BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold {
    eventIndex?: number;
    requestIndex?: number;
    type?: string;
    valueMs: number;
}

export interface BrowserMonitorAnomalyDetectionOutageHandling {
    globalOutage?: boolean;
    globalOutagePolicies?: outputs.BrowserMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy[];
    localOutage?: boolean;
    localOutagePolicies?: outputs.BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy[];
    retryOnError?: boolean;
}

export interface BrowserMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy {
    consecutiveRuns: number;
}

export interface BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy {
    affectedLocations: number;
    consecutiveRuns: number;
}

export interface BrowserMonitorKeyPerformanceMetrics {
    /**
     * Defines the key performance metric for load actions. Supported values are `VISUALLY_COMPLETE`, `SPEED_INDEX`, `USER_ACTION_DURATION`, `TIME_TO_FIRST_BYTE`, `HTML_DOWNLOADED`, `DOM_INTERACTIVE`, `LOAD_EVENT_START` and `LOAD_EVENT_END`.
     */
    loadActionKpm: string;
    /**
     * Defines the key performance metric for XHR actions. Supported values are `VISUALLY_COMPLETE`, `USER_ACTION_DURATION`, `TIME_TO_FIRST_BYTE` and `RESPONSE_END`.
     */
    xhrActionKpm: string;
}

export interface BrowserMonitorPerformanceThresholds {
    thresholds: outputs.BrowserMonitorPerformanceThresholdsThreshold[];
}

export interface BrowserMonitorPerformanceThresholdsThreshold {
    event: string;
    threshold: number;
}

export interface BrowserMonitorScript {
    /**
     * The setup of the monitor
     */
    configuration?: outputs.BrowserMonitorScriptConfiguration;
    /**
     * Steps of the clickpathâ€”the first step must always be of the `navigate` type
     */
    events?: outputs.BrowserMonitorScriptEvents;
    /**
     * The type of monitor. Possible values are `clickpath` for clickpath monitors and `availability` for single-URL browser monitors. These monitors are only allowed to have one event of the `navigate` type
     */
    type: string;
}

export interface BrowserMonitorScriptConfiguration {
    bandwidth?: outputs.BrowserMonitorScriptConfigurationBandwidth;
    blocks?: string[];
    bypassCsp?: boolean;
    cookies?: outputs.BrowserMonitorScriptConfigurationCookies;
    device?: outputs.BrowserMonitorScriptConfigurationDevice;
    disableWebSecurity?: boolean;
    headers?: outputs.BrowserMonitorScriptConfigurationHeaders;
    ignoredErrorCodes?: outputs.BrowserMonitorScriptConfigurationIgnoredErrorCodes;
    javascriptSetttings?: outputs.BrowserMonitorScriptConfigurationJavascriptSetttings;
    monitorFrames?: boolean;
    userAgent?: string;
}

export interface BrowserMonitorScriptConfigurationBandwidth {
    download?: number;
    latency?: number;
    networkType?: string;
    upload?: number;
}

export interface BrowserMonitorScriptConfigurationCookies {
    cookies: outputs.BrowserMonitorScriptConfigurationCookiesCookie[];
}

export interface BrowserMonitorScriptConfigurationCookiesCookie {
    domain: string;
    name: string;
    path?: string;
    value: string;
}

export interface BrowserMonitorScriptConfigurationDevice {
    height?: number;
    mobile?: boolean;
    name?: string;
    orientation?: string;
    scaleFactor?: number;
    touchEnabled?: boolean;
    width?: number;
}

export interface BrowserMonitorScriptConfigurationHeaders {
    headers: outputs.BrowserMonitorScriptConfigurationHeadersHeader[];
    restrictions?: string[];
}

export interface BrowserMonitorScriptConfigurationHeadersHeader {
    name: string;
    value: string;
}

export interface BrowserMonitorScriptConfigurationIgnoredErrorCodes {
    matchingDocumentRequests?: string;
    statusCodes: string;
}

export interface BrowserMonitorScriptConfigurationJavascriptSetttings {
    customProperties?: string;
    timeoutSettings?: outputs.BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings;
    visuallyCompleteOptions?: outputs.BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions;
}

export interface BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings {
    actionLimit: number;
    totalTimeout: number;
}

export interface BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions {
    excludedElements?: string[];
    excludedUrls?: string[];
    imageSizeThreshold: number;
    inactivityTimeout: number;
    mutationTimeout: number;
}

export interface BrowserMonitorScriptEvents {
    events?: outputs.BrowserMonitorScriptEventsEvent[];
}

export interface BrowserMonitorScriptEventsEvent {
    click?: outputs.BrowserMonitorScriptEventsEventClick;
    cookie?: outputs.BrowserMonitorScriptEventsEventCookie;
    description: string;
    javascript?: outputs.BrowserMonitorScriptEventsEventJavascript;
    keystrokes?: outputs.BrowserMonitorScriptEventsEventKeystrokes;
    navigate?: outputs.BrowserMonitorScriptEventsEventNavigate;
    select?: outputs.BrowserMonitorScriptEventsEventSelect;
    tap?: outputs.BrowserMonitorScriptEventsEventTap;
}

export interface BrowserMonitorScriptEventsEventClick {
    button: number;
    target?: outputs.BrowserMonitorScriptEventsEventClickTarget;
    validate?: outputs.BrowserMonitorScriptEventsEventClickValidate;
    wait?: outputs.BrowserMonitorScriptEventsEventClickWait;
}

export interface BrowserMonitorScriptEventsEventClickTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventClickTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventClickTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventClickTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventClickTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventClickValidate {
    validations: outputs.BrowserMonitorScriptEventsEventClickValidateValidation[];
}

export interface BrowserMonitorScriptEventsEventClickValidateValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventClickValidateValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventClickValidateValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventClickValidateValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventClickValidateValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventClickValidateValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventClickValidateValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventClickWait {
    milliseconds?: number;
    timeout?: number;
    validation?: outputs.BrowserMonitorScriptEventsEventClickWaitValidation;
    waitFor: string;
}

export interface BrowserMonitorScriptEventsEventClickWaitValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventClickWaitValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventClickWaitValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventClickWaitValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventClickWaitValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventClickWaitValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventClickWaitValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventCookie {
    cookies: outputs.BrowserMonitorScriptEventsEventCookieCookies;
}

export interface BrowserMonitorScriptEventsEventCookieCookies {
    cookies: outputs.BrowserMonitorScriptEventsEventCookieCookiesCookie[];
}

export interface BrowserMonitorScriptEventsEventCookieCookiesCookie {
    domain: string;
    name: string;
    path?: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventJavascript {
    code: string;
    target?: outputs.BrowserMonitorScriptEventsEventJavascriptTarget;
    wait?: outputs.BrowserMonitorScriptEventsEventJavascriptWait;
}

export interface BrowserMonitorScriptEventsEventJavascriptTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventJavascriptTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventJavascriptTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventJavascriptTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventJavascriptTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventJavascriptWait {
    milliseconds?: number;
    timeout?: number;
    validation?: outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidation;
    waitFor: string;
}

export interface BrowserMonitorScriptEventsEventJavascriptWaitValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventJavascriptWaitValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokes {
    credential?: outputs.BrowserMonitorScriptEventsEventKeystrokesCredential;
    masked?: boolean;
    simulateBlurEvent?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventKeystrokesTarget;
    text?: string;
    validate?: outputs.BrowserMonitorScriptEventsEventKeystrokesValidate;
    wait?: outputs.BrowserMonitorScriptEventsEventKeystrokesWait;
}

export interface BrowserMonitorScriptEventsEventKeystrokesCredential {
    field: string;
    vaultId: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokesTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventKeystrokesTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokesTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventKeystrokesTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventKeystrokesTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokesValidate {
    validations: outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidation[];
}

export interface BrowserMonitorScriptEventsEventKeystrokesValidateValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokesValidateValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokesWait {
    milliseconds?: number;
    timeout?: number;
    validation?: outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidation;
    waitFor: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokesWaitValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokesWaitValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventNavigate {
    authentication?: outputs.BrowserMonitorScriptEventsEventNavigateAuthentication;
    target?: outputs.BrowserMonitorScriptEventsEventNavigateTarget;
    url: string;
    validate?: outputs.BrowserMonitorScriptEventsEventNavigateValidate;
    wait?: outputs.BrowserMonitorScriptEventsEventNavigateWait;
}

export interface BrowserMonitorScriptEventsEventNavigateAuthentication {
    creds: string;
    type: string;
}

export interface BrowserMonitorScriptEventsEventNavigateTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventNavigateTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventNavigateTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventNavigateTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventNavigateTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventNavigateValidate {
    validations: outputs.BrowserMonitorScriptEventsEventNavigateValidateValidation[];
}

export interface BrowserMonitorScriptEventsEventNavigateValidateValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventNavigateValidateValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventNavigateWait {
    milliseconds?: number;
    timeout?: number;
    validation?: outputs.BrowserMonitorScriptEventsEventNavigateWaitValidation;
    waitFor: string;
}

export interface BrowserMonitorScriptEventsEventNavigateWaitValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventNavigateWaitValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventSelect {
    selections: outputs.BrowserMonitorScriptEventsEventSelectSelections;
    target?: outputs.BrowserMonitorScriptEventsEventSelectTarget;
    validate?: outputs.BrowserMonitorScriptEventsEventSelectValidate;
    wait?: outputs.BrowserMonitorScriptEventsEventSelectWait;
}

export interface BrowserMonitorScriptEventsEventSelectSelections {
    options: outputs.BrowserMonitorScriptEventsEventSelectSelectionsOption[];
}

export interface BrowserMonitorScriptEventsEventSelectSelectionsOption {
    index: number;
    value: string;
}

export interface BrowserMonitorScriptEventsEventSelectTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventSelectTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventSelectTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventSelectTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventSelectTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventSelectValidate {
    validations: outputs.BrowserMonitorScriptEventsEventSelectValidateValidation[];
}

export interface BrowserMonitorScriptEventsEventSelectValidateValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventSelectValidateValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventSelectWait {
    milliseconds?: number;
    timeout?: number;
    validation?: outputs.BrowserMonitorScriptEventsEventSelectWaitValidation;
    waitFor: string;
}

export interface BrowserMonitorScriptEventsEventSelectWaitValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventSelectWaitValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventTap {
    button: number;
    target?: outputs.BrowserMonitorScriptEventsEventTapTarget;
    validate?: outputs.BrowserMonitorScriptEventsEventTapValidate;
    wait?: outputs.BrowserMonitorScriptEventsEventTapWait;
}

export interface BrowserMonitorScriptEventsEventTapTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventTapTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventTapTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventTapTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventTapTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventTapValidate {
    validations: outputs.BrowserMonitorScriptEventsEventTapValidateValidation[];
}

export interface BrowserMonitorScriptEventsEventTapValidateValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventTapValidateValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventTapValidateValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventTapValidateValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventTapValidateValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventTapValidateValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventTapValidateValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventTapWait {
    milliseconds?: number;
    timeout?: number;
    validation?: outputs.BrowserMonitorScriptEventsEventTapWaitValidation;
    waitFor: string;
}

export interface BrowserMonitorScriptEventsEventTapWaitValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventTapWaitValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventTapWaitValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventTapWaitValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventTapWaitValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventTapWaitValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventTapWaitValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorTag {
    /**
     * Tag with source of a Dynatrace entity.
     */
    tags?: outputs.BrowserMonitorTagTag[];
}

export interface BrowserMonitorTagTag {
    context: string;
    key: string;
    source?: string;
    value?: string;
}

export interface BusinessEventsOneagentEvent {
    /**
     * Event category
     */
    category: outputs.BusinessEventsOneagentEventCategory;
    /**
     * Additional attributes for the business event.
     */
    data?: outputs.BusinessEventsOneagentEventData;
    /**
     * Event provider
     */
    provider: outputs.BusinessEventsOneagentEventProvider;
    /**
     * Event type
     */
    type: outputs.BusinessEventsOneagentEventType;
}

export interface BusinessEventsOneagentEventCategory {
    path?: string;
    source?: string;
    sourceType: string;
}

export interface BusinessEventsOneagentEventData {
    eventDataFieldComplexes: outputs.BusinessEventsOneagentEventDataEventDataFieldComplex[];
}

export interface BusinessEventsOneagentEventDataEventDataFieldComplex {
    name: string;
    source: outputs.BusinessEventsOneagentEventDataEventDataFieldComplexSource;
}

export interface BusinessEventsOneagentEventDataEventDataFieldComplexSource {
    path?: string;
    source?: string;
    sourceType: string;
}

export interface BusinessEventsOneagentEventProvider {
    path?: string;
    source?: string;
    sourceType: string;
}

export interface BusinessEventsOneagentEventType {
    path?: string;
    source?: string;
    sourceType: string;
}

export interface BusinessEventsOneagentTriggers {
    triggers: outputs.BusinessEventsOneagentTriggersTrigger[];
}

export interface BusinessEventsOneagentTriggersTrigger {
    caseSensitive?: boolean;
    source: outputs.BusinessEventsOneagentTriggersTriggerSource;
    type: string;
    value?: string;
}

export interface BusinessEventsOneagentTriggersTriggerSource {
    dataSource: string;
    path?: string;
}

export interface BusinessEventsProcessingRuleTesting {
    sampleEvent: string;
}

export interface BusinessEventsProcessingTransformationFields {
    transformationFields: outputs.BusinessEventsProcessingTransformationFieldsTransformationField[];
}

export interface BusinessEventsProcessingTransformationFieldsTransformationField {
    array: boolean;
    name: string;
    optional: boolean;
    readonly: boolean;
    type: string;
}

export interface CalculatedServiceMetricCondition {
    conditions?: outputs.CalculatedServiceMetricConditionCondition[];
}

export interface CalculatedServiceMetricConditionCondition {
    attribute: string;
    comparison: outputs.CalculatedServiceMetricConditionConditionComparison;
    unknowns?: string;
}

export interface CalculatedServiceMetricConditionConditionComparison {
    boolean?: outputs.CalculatedServiceMetricConditionConditionComparisonBoolean;
    esbInputNodeType?: outputs.CalculatedServiceMetricConditionConditionComparisonEsbInputNodeType;
    failedState?: outputs.CalculatedServiceMetricConditionConditionComparisonFailedState;
    failureReason?: outputs.CalculatedServiceMetricConditionConditionComparisonFailureReason;
    fastString?: outputs.CalculatedServiceMetricConditionConditionComparisonFastString;
    flawState?: outputs.CalculatedServiceMetricConditionConditionComparisonFlawState;
    generic?: outputs.CalculatedServiceMetricConditionConditionComparisonGeneric;
    httpMethod?: outputs.CalculatedServiceMetricConditionConditionComparisonHttpMethod;
    httpStatusClass?: outputs.CalculatedServiceMetricConditionConditionComparisonHttpStatusClass;
    iibInputNodeType?: outputs.CalculatedServiceMetricConditionConditionComparisonIibInputNodeType;
    negate?: boolean;
    number?: outputs.CalculatedServiceMetricConditionConditionComparisonNumber;
    numberRequestAttribute?: outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute;
    serviceType?: outputs.CalculatedServiceMetricConditionConditionComparisonServiceType;
    string?: outputs.CalculatedServiceMetricConditionConditionComparisonString;
    stringRequestAttribute?: outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute;
    tag?: outputs.CalculatedServiceMetricConditionConditionComparisonTag;
    zosCallType?: outputs.CalculatedServiceMetricConditionConditionComparisonZosCallType;
}

export interface CalculatedServiceMetricConditionConditionComparisonBoolean {
    operator?: string;
    unknowns?: string;
    value: boolean;
    values?: boolean[];
}

export interface CalculatedServiceMetricConditionConditionComparisonEsbInputNodeType {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonFailedState {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonFailureReason {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonFastString {
    caseSensitive?: boolean;
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonFlawState {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonGeneric {
    type: string;
    unknowns?: string;
}

export interface CalculatedServiceMetricConditionConditionComparisonHttpMethod {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonHttpStatusClass {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonIibInputNodeType {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonNumber {
    operator?: string;
    unknowns?: string;
    value?: number;
    values?: number[];
}

export interface CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute {
    matchOnChildCalls?: boolean;
    operator?: string;
    requestAttribute: string;
    source?: outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource;
    unknowns?: string;
    value?: number;
    values?: number[];
}

export interface CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource {
    managementZone?: string;
    serviceTag?: outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag;
    unknowns?: string;
}

export interface CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag {
    context?: string;
    key: string;
    tagKey?: outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTagTagKey;
    value?: string;
}

export interface CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTagTagKey {
    context?: string;
    key?: string;
}

export interface CalculatedServiceMetricConditionConditionComparisonServiceType {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonString {
    caseSensitive?: boolean;
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute {
    caseSensitive?: boolean;
    matchOnChildCalls?: boolean;
    operator?: string;
    requestAttribute: string;
    source?: outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource {
    managementZone?: string;
    serviceTag?: outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag;
    unknowns?: string;
}

export interface CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag {
    context?: string;
    key: string;
    tagKey?: outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTagTagKey;
    value?: string;
}

export interface CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTagTagKey {
    context?: string;
    key?: string;
}

export interface CalculatedServiceMetricConditionConditionComparisonTag {
    operator?: string;
    unknowns?: string;
    value?: outputs.CalculatedServiceMetricConditionConditionComparisonTagValue;
    values?: outputs.CalculatedServiceMetricConditionConditionComparisonTagValues;
}

export interface CalculatedServiceMetricConditionConditionComparisonTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface CalculatedServiceMetricConditionConditionComparisonTagValues {
    values?: outputs.CalculatedServiceMetricConditionConditionComparisonTagValuesValue[];
}

export interface CalculatedServiceMetricConditionConditionComparisonTagValuesValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface CalculatedServiceMetricConditionConditionComparisonZosCallType {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricDimensionDefinition {
    dimension: string;
    name: string;
    placeholders?: outputs.CalculatedServiceMetricDimensionDefinitionPlaceholders;
    topX: number;
    topXAggregation: string;
    topXDirection: string;
    unknowns?: string;
}

export interface CalculatedServiceMetricDimensionDefinitionPlaceholders {
    placeholders?: outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder[];
}

export interface CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder {
    aggregation?: string;
    attribute: string;
    delimiterOrRegex?: string;
    endDelimiter?: string;
    kind: string;
    name: string;
    normalization?: string;
    requestAttribute?: string;
    source?: outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource;
    unknowns?: string;
    useFromChildCalls?: boolean;
}

export interface CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource {
    managementZone?: string;
    serviceTag?: outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag;
    unknowns?: string;
}

export interface CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag {
    context?: string;
    key: string;
    tagKey?: outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKey;
    value?: string;
}

export interface CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKey {
    context?: string;
    key?: string;
}

export interface CalculatedServiceMetricMetricDefinition {
    metric: string;
    requestAttribute?: string;
}

export interface CloudappWorkloaddetectionCloudFoundry {
    enabled: boolean;
}

export interface CloudappWorkloaddetectionDocker {
    enabled: boolean;
}

export interface CloudappWorkloaddetectionKubernetes {
    enabled: boolean;
    filters?: outputs.CloudappWorkloaddetectionKubernetesFilters;
}

export interface CloudappWorkloaddetectionKubernetesFilters {
    filters: outputs.CloudappWorkloaddetectionKubernetesFiltersFilter[];
}

export interface CloudappWorkloaddetectionKubernetesFiltersFilter {
    enabled: boolean;
    inclusionToggles: outputs.CloudappWorkloaddetectionKubernetesFiltersFilterInclusionToggles;
    matchFilter: outputs.CloudappWorkloaddetectionKubernetesFiltersFilterMatchFilter;
}

export interface CloudappWorkloaddetectionKubernetesFiltersFilterInclusionToggles {
    incBasepod: boolean;
    incContainer: boolean;
    incNamespace: boolean;
    incProduct: boolean;
    incStage: boolean;
}

export interface CloudappWorkloaddetectionKubernetesFiltersFilterMatchFilter {
    matchOperator: string;
    namespace?: string;
}

export interface CredentialsCredentialUsageSummary {
    /**
     * The number of uses
     */
    count: number;
    /**
     * Type of usage, `HTTP_MONITOR` or `BROWSER_MONITOR`
     */
    type: string;
}

export interface CredentialsExternal {
    /**
     * Required for Hashicorp Certificate. The ID of Credentials within the Certificate Vault holding the certificate
     */
    certificate?: string;
    /**
     * Required for Azure Client Secret. No further documentation available
     */
    clientSecret?: string;
    /**
     * Required for Azure Client Secret. No further documentation available
     */
    clientid?: string;
    /**
     * No documentation available
     */
    credentialsUsedForExternalSynchronizations?: string[];
    /**
     * No documentation available
     */
    passwordSecretName?: string;
    /**
     * Required for Hashicorp App Role or Hashicorp Certificate. No further documentation available
     */
    pathToCredentials?: string;
    /**
     * Required for Hashicorp App Role. No further documentation available
     */
    roleid?: string;
    /**
     * Required for Hashicorp App Role. The ID of Credentials within the Certificate Vault holding the secret id
     */
    secretid?: string;
    /**
     * Required for Azure Client Secret. No further documentation available
     */
    tenantid?: string;
    /**
     * No documentation available
     */
    tokenSecretName?: string;
    /**
     * No documentation available
     */
    usernameSecretName?: string;
    /**
     * Required for Hashicorp App Role. No further documentation available
     */
    vaultNamespace?: string;
    /**
     * No documentation available
     */
    vaultUrl?: string;
}

export interface CustomAnomaliesDimension {
    /**
     * A generic definition for a filter
     */
    dimensions?: outputs.CustomAnomaliesDimensionDimension[];
    /**
     * A filter for the metrics entity dimensions
     */
    entities?: outputs.CustomAnomaliesDimensionEntity[];
    /**
     * A filter for the metrics string dimensions
     */
    strings?: outputs.CustomAnomaliesDimensionString[];
}

export interface CustomAnomaliesDimensionDimension {
    index?: number;
    key?: string;
    /**
     * The name of the metric event displayed in the UI
     */
    name?: string;
    type: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesDimensionEntity {
    filter: outputs.CustomAnomaliesDimensionEntityFilter;
    key?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesDimensionEntityFilter {
    operator: string;
    value: string;
}

export interface CustomAnomaliesDimensionString {
    filter: outputs.CustomAnomaliesDimensionStringFilter;
    index?: number;
    key?: string;
    /**
     * The name of the metric event displayed in the UI
     */
    name?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesDimensionStringFilter {
    operator: string;
    value: string;
}

export interface CustomAnomaliesScope {
    /**
     * A scope filter for the related custom device group name
     */
    customDeviceGroupNames?: outputs.CustomAnomaliesScopeCustomDeviceGroupName[];
    /**
     * A scope filter for a monitored entity identifier
     */
    entities?: outputs.CustomAnomaliesScopeEntity[];
    /**
     * A scope filter for the related host group name
     */
    hostGroupNames?: outputs.CustomAnomaliesScopeHostGroupName[];
    /**
     * A scope filter for the related host name
     */
    hostNames?: outputs.CustomAnomaliesScopeHostName[];
    /**
     * A scope filter for a management zone identifier
     */
    managementZones?: outputs.CustomAnomaliesScopeManagementZone[];
    /**
     * A scope filter for a monitored entity name
     */
    names?: outputs.CustomAnomaliesScopeName[];
    /**
     * A scope filter for a process group identifier
     */
    processGroupIds?: outputs.CustomAnomaliesScopeProcessGroupId[];
    /**
     * A scope filter for the related process group name
     */
    processGroupNames?: outputs.CustomAnomaliesScopeProcessGroupName[];
    /**
     * A generic scope filter
     */
    scopes?: outputs.CustomAnomaliesScopeScope[];
    /**
     * A scope filter for tags on entities
     */
    tags?: outputs.CustomAnomaliesScopeTag[];
}

export interface CustomAnomaliesScopeCustomDeviceGroupName {
    filter: outputs.CustomAnomaliesScopeCustomDeviceGroupNameFilter;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeCustomDeviceGroupNameFilter {
    operator: string;
    value: string;
}

export interface CustomAnomaliesScopeEntity {
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeHostGroupName {
    filter: outputs.CustomAnomaliesScopeHostGroupNameFilter;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeHostGroupNameFilter {
    operator: string;
    value: string;
}

export interface CustomAnomaliesScopeHostName {
    filter: outputs.CustomAnomaliesScopeHostNameFilter;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeHostNameFilter {
    operator: string;
    value: string;
}

export interface CustomAnomaliesScopeManagementZone {
    /**
     * The ID of this resource.
     */
    id?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeName {
    filter: outputs.CustomAnomaliesScopeNameFilter;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeNameFilter {
    operator: string;
    value: string;
}

export interface CustomAnomaliesScopeProcessGroupId {
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeProcessGroupName {
    filter: outputs.CustomAnomaliesScopeProcessGroupNameFilter;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeProcessGroupNameFilter {
    operator: string;
    value: string;
}

export interface CustomAnomaliesScopeScope {
    type: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeTag {
    filter: outputs.CustomAnomaliesScopeTagFilter;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeTagFilter {
    context: string;
    key: string;
    value?: string;
}

export interface CustomAnomaliesStrategy {
    /**
     * An auto-adaptive baseline strategy to detect anomalies within metrics that show a regular change over time, as the baseline is also updated automatically. An example is to detect an anomaly in the number of received network packets or within the number of user actions over time
     */
    auto?: outputs.CustomAnomaliesStrategyAuto;
    /**
     * A generic monitoring strategy
     */
    generics?: outputs.CustomAnomaliesStrategyGeneric[];
    /**
     * A static threshold monitoring strategy to alert on hard limits within a given metric. An example is the violation of a critical memory limit
     */
    static?: outputs.CustomAnomaliesStrategyStatic;
}

export interface CustomAnomaliesStrategyAuto {
    alertCondition: string;
    alertingOnMissingData?: boolean;
    dealertingSamples: number;
    samples: number;
    signalFluctuations: number;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    violatingSamples: number;
}

export interface CustomAnomaliesStrategyGeneric {
    type: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesStrategyStatic {
    alertCondition: string;
    alertingOnMissingData?: boolean;
    dealertingSamples: number;
    samples: number;
    threshold: number;
    unit: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    violatingSamples: number;
}

export interface CustomAppAnomaliesErrorRateIncrease {
    /**
     * Possible Values: `Auto`, `Fixed`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * Alert if the percentage of user actions affected by reported errors exceeds **both** the absolute threshold and the relative threshold
     */
    errorRateIncreaseAuto?: outputs.CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto;
    /**
     * Alert if the custom reported error rate threshold is exceeded during any 5-minute period
     */
    errorRateIncreaseFixed?: outputs.CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed;
}

export interface CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto {
    thresholdAbsolute: number;
    thresholdRelative: number;
}

export interface CustomAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed {
    sensitivity: string;
    thresholdAbsolute: number;
}

export interface CustomAppAnomaliesSlowUserActions {
    /**
     * Possible Values: `Auto`, `Fixed`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * no documentation available
     */
    slowUserActionsAuto?: outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAuto;
    /**
     * no documentation available
     */
    slowUserActionsFixed?: outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixed;
}

export interface CustomAppAnomaliesSlowUserActionsSlowUserActionsAuto {
    durationAvoidOveralerting: outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting;
    durationThresholdAll: outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll;
    durationThresholdSlowest: outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest;
}

export interface CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting {
    minActionRate: number;
}

export interface CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll {
    durationThreshold: number;
    slowdownPercentage: number;
}

export interface CustomAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest {
    durationThreshold: number;
    slowdownPercentage: number;
}

export interface CustomAppAnomaliesSlowUserActionsSlowUserActionsFixed {
    durationAvoidOveralerting: outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting;
    durationThresholdAllFixed: outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed;
    durationThresholdSlowest: outputs.CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest;
    sensitivity: string;
}

export interface CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting {
    minActionRate: number;
}

export interface CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed {
    durationThreshold: number;
}

export interface CustomAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest {
    durationThreshold: number;
}

export interface CustomAppAnomaliesUnexpectedHighLoad {
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic spikes within your application.
     */
    thresholdPercentage?: number;
}

export interface CustomAppAnomaliesUnexpectedLowLoad {
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic drops within your application.
     */
    thresholdPercentage?: number;
}

export interface CustomAppCrashRateCrashRateIncrease {
    /**
     * Alert crash rate increases when auto-detected baseline is exceeded by a certain number of users
     */
    crashRateIncreaseAuto?: outputs.CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto;
    /**
     * Alert crash rate increases when the defined threshold is exceeded by a certain number of users
     */
    crashRateIncreaseFixed?: outputs.CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed;
    /**
     * Possible Values: `Auto`, `Fixed`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto {
    baselineViolationPercentage: number;
    concurrentUsers: number;
    sensitivity: string;
}

export interface CustomAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed {
    absoluteCrashRate: number;
    concurrentUsers: number;
}

export interface CustomAppEnablementRum {
    /**
     * (Field has overlap with `dynatrace.MobileApplication`) Percentage of user sessions captured and analyzed. By default, Dynatrace captures all user actions and user sessions for analysis. This approach ensures complete insight into your applicationâ€™s performance and customer experience. You can optionally reduce the granularity of user-action and user-session analysis by capturing a lower percentage of user sessions. While this approach can reduce monitoring costs, it also results in lower visibility into how your customers are using your applications. For example, a setting of 10% results in Dynatrace analyzing only every tenth user session.
     */
    costAndTrafficControl: number;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface CustomServiceRule {
    /**
     * Additional annotations filter of the rule. Only classes where all listed annotations are available in the class itself or any of its superclasses are instrumented. Not applicable to PHP
     */
    annotations?: string[];
    /**
     * The fully qualified class or interface to instrument (or a substring if matching to a string). Required for Java and .NET custom services. Not applicable to PHP
     */
    class?: outputs.CustomServiceRuleClass;
    /**
     * Rule enabled/disabled
     */
    enabled: boolean;
    /**
     * The PHP file containing the class or methods to instrument. Required for PHP custom service. Not applicable to Java and .NET
     */
    file?: outputs.CustomServiceRuleFile;
    /**
     * methods to instrument
     */
    methods: outputs.CustomServiceRuleMethod[];
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomServiceRuleClass {
    match?: string;
    /**
     * The name of the custom service, displayed in the UI
     */
    name: string;
}

export interface CustomServiceRuleFile {
    match?: string;
    /**
     * The name of the custom service, displayed in the UI
     */
    name: string;
}

export interface CustomServiceRuleMethod {
    arguments?: string[];
    /**
     * The ID of this resource.
     */
    id: string;
    modifiers?: string[];
    /**
     * The name of the custom service, displayed in the UI
     */
    name: string;
    returns?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    visibility?: string;
}

export interface CustomTagsTags {
    /**
     * A Tag Filter
     */
    filters?: outputs.CustomTagsTagsFilter[];
}

export interface CustomTagsTagsFilter {
    context: string;
    key: string;
    value?: string;
}

export interface DashboardDashboardMetadata {
    /**
     * The tile uses consistent colors when rendering its content
     */
    consistentColors?: boolean;
    /**
     * Dashboard filter configuration of a dashboard
     */
    dynamicFilters?: outputs.DashboardDashboardMetadataDynamicFilters;
    /**
     * Global filter Settings for the Dashboard
     */
    filter?: outputs.DashboardDashboardMetadataFilter;
    /**
     * the name of the dashboard
     */
    name: string;
    /**
     * the owner of the dashboard
     */
    owner: string;
    /**
     * the dashboard is a preset (`true`) or not (`false`). Default is `false`.
     */
    preset?: boolean;
    /**
     * the dashboard is shared (`true`) or private (`false`)
     *
     * @deprecated Please use the resource `dynatrace_dashboard_sharing` to configure share settings
     */
    shared?: boolean;
    /**
     * represents sharing configuration of a dashboard
     *
     * @deprecated Please use the resource `dynatrace_dashboard_sharing` to configure share settings
     */
    sharingDetails?: outputs.DashboardDashboardMetadataSharingDetails;
    /**
     * a set of tags assigned to the dashboard
     */
    tags?: string[];
    /**
     * No documentation available
     */
    tilesNameSize?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * a set of all possible global dashboard filters that can be applied to dashboard
     */
    validFilterKeys?: string[];
}

export interface DashboardDashboardMetadataDynamicFilters {
    filters: string[];
    genericTagFilters?: outputs.DashboardDashboardMetadataDynamicFiltersGenericTagFilters;
    tagSuggestionTypes?: string[];
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardDashboardMetadataDynamicFiltersGenericTagFilters {
    filters: outputs.DashboardDashboardMetadataDynamicFiltersGenericTagFiltersFilter[];
}

export interface DashboardDashboardMetadataDynamicFiltersGenericTagFiltersFilter {
    entityTypes: string[];
    name?: string;
    suggestionsFromEntityType?: string;
    tagKey?: string;
}

export interface DashboardDashboardMetadataFilter {
    managementZones?: outputs.DashboardDashboardMetadataFilterManagementZone[];
    timeframe?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardDashboardMetadataFilterManagementZone {
    description?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    name?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardDashboardMetadataSharingDetails {
    linkShared?: boolean;
    published?: boolean;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardMetadata {
    /**
     * Dynatrace server version
     */
    clusterVersion?: string;
    /**
     * A Sorted list of the version numbers of the configuration
     */
    configurationVersions?: number[];
    /**
     * A Sorted list of the version numbers of the configuration
     */
    currentConfigurationVersions?: string[];
}

export interface DashboardSharingPermissions {
    /**
     * Access permissions of the dashboard
     */
    permissions?: outputs.DashboardSharingPermissionsPermission[];
}

export interface DashboardSharingPermissionsPermission {
    /**
     * The ID of this resource.
     */
    id?: string;
    level: string;
    type: string;
}

export interface DashboardSharingPublic {
    /**
     * A list of management zones that can display data on the publicly shared dashboard.
     */
    managementZones: string[];
    urls: {[key: string]: string};
}

export interface DashboardTile {
    /**
     * The list of Dynatrace entities, assigned to the tile
     */
    assignedEntities?: string[];
    /**
     * Auto Refresh is disabled (`true`)
     */
    autoRefreshDisabled?: boolean;
    /**
     * the position and size of a tile
     */
    bounds?: outputs.DashboardTileBounds;
    chartVisible?: boolean;
    /**
     * The tile is configured and ready to use (`true`) or just placed on the dashboard (`false`)
     */
    configured?: boolean;
    /**
     * The name of the tile, set by user
     */
    customName?: string;
    /**
     * Include (`false') or exclude (`true`) maintenance windows from availability calculations
     */
    excludeMaintenanceWindows?: boolean;
    /**
     * is filter applied to a tile. It overrides dashboard's filter
     */
    filter?: outputs.DashboardTileFilter;
    /**
     * the position and size of a tile
     */
    filterConfig?: outputs.DashboardTileFilterConfig;
    /**
     * The limit of the results, if not set will use the default value of the system
     */
    limit?: number;
    /**
     * The markdown-formatted content of the tile
     */
    markdown?: string;
    /**
     * The metric assigned to the tile
     */
    metric?: string;
    /**
     * the name of the tile
     */
    name: string;
    /**
     * The size of the tile name. Possible values are `small`, `medium` and `large`.
     */
    nameSize?: string;
    /**
     * A [user session query](https://www.dynatrace.com/support/help/shortlink/usql-info) executed by the tile
     */
    query?: string;
    /**
     * the type of the tile. Must be either `APPLICATION_WORLDMAP`, `RESOURCES`, `THIRD_PARTY_MOST_ACTIVE`, `UEM_CONVERSIONS_PER_GOAL`, `PROCESS_GROUPS_ONE` or `HOST` .
     */
    tileType: string;
    /**
     * The comparison timeframe of the query. If specified, you additionally get the results of the same query with the specified time shift
     */
    timeFrameShift?: string;
    /**
     * The attribute `type` exists for backwards compatibilty. Usage is discouraged. You should use `visualization` instead.
     */
    type?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * The visualization of the tile. Possible values are: `COLUMN_CHART`, `FUNNEL`, `LINE_CHART`, `PIE_CHART`, `SINGLE_VALUE`, `TABLE`
     */
    visualization?: string;
    /**
     * Configuration of a User session query visualization tile
     */
    visualizationConfig?: outputs.DashboardTileVisualizationConfig;
}

export interface DashboardTileBounds {
    height: number;
    left: number;
    top: number;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    width: number;
}

export interface DashboardTileFilter {
    managementZones?: outputs.DashboardTileFilterManagementZone[];
    timeframe?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardTileFilterConfig {
    chartConfig?: outputs.DashboardTileFilterConfigChartConfig;
    customName: string;
    defaultName: string;
    filters?: outputs.DashboardTileFilterConfigFilters;
    type: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardTileFilterConfigChartConfig {
    axisLimits?: {[key: string]: number};
    leftAxisCustomUnit?: string;
    legend?: boolean;
    resultMetadatas?: outputs.DashboardTileFilterConfigChartConfigResultMetadata[];
    rightAxisCustomUnit?: string;
    series?: outputs.DashboardTileFilterConfigChartConfigSeries[];
    type: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardTileFilterConfigChartConfigResultMetadata {
    configs?: outputs.DashboardTileFilterConfigChartConfigResultMetadataConfig[];
}

export interface DashboardTileFilterConfigChartConfigResultMetadataConfig {
    customColor?: string;
    key?: string;
    lastModified?: number;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardTileFilterConfigChartConfigSeries {
    aggregation: string;
    aggregationRate?: string;
    dimensions?: outputs.DashboardTileFilterConfigChartConfigSeriesDimension[];
    entityType: string;
    metric: string;
    percentile?: number;
    sortAscending?: boolean;
    sortColumn?: boolean;
    type: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardTileFilterConfigChartConfigSeriesDimension {
    entityDimension?: boolean;
    /**
     * The ID of this resource.
     */
    id: string;
    name?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    values?: string[];
}

export interface DashboardTileFilterConfigFilters {
    filters?: outputs.DashboardTileFilterConfigFiltersFilter[];
}

export interface DashboardTileFilterConfigFiltersFilter {
    entityType: string;
    matches?: outputs.DashboardTileFilterConfigFiltersFilterMatch[];
}

export interface DashboardTileFilterConfigFiltersFilterMatch {
    key: string;
    values?: string[];
}

export interface DashboardTileFilterManagementZone {
    description?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    name?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardTileVisualizationConfig {
    hasAxisBucketing?: boolean;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardsAllowlistAllowlist {
    urlpatterns: outputs.DashboardsAllowlistAllowlistUrlpattern[];
}

export interface DashboardsAllowlistAllowlistUrlpattern {
    rule: string;
    template: string;
}

export interface DashboardsGeneralDefaultDashboardList {
    defaultDashboards: outputs.DashboardsGeneralDefaultDashboardListDefaultDashboard[];
}

export interface DashboardsGeneralDefaultDashboardListDefaultDashboard {
    dashboard: string;
    userGroup: string;
}

export interface DashboardsPresetsDashboardPresetsList {
    dashboardPresets: outputs.DashboardsPresetsDashboardPresetsListDashboardPreset[];
}

export interface DashboardsPresetsDashboardPresetsListDashboardPreset {
    dashboardPreset: string;
    userGroup: string;
}

export interface DataPrivacyDataCollection {
    /**
     * With [Data-collection and opt-in mode](https://dt-url.net/7l3p0p3h) enabled, Real User Monitoring data isn't captured until dtrum.enable() is called for specific user sessions.
     */
    optInModeEnabled: boolean;
}

export interface DataPrivacyDoNotTrack {
    /**
     * Comply with "Do Not Track" browser settings
     */
    complyWithDoNotTrack: boolean;
    /**
     * Possible Values: `Anonymous`, `Disable_rum`
     */
    doNotTrack?: string;
}

export interface DataPrivacyMasking {
    ipAddressMasking?: string;
    /**
     * Dynatrace captures the IP addresses of your end-users to determine the regions from which they access your application. To learn more, visit [Mask IPs and GPS coordinates](https://dt-url.net/mask-end-users-ip-addresses).. Dynatrace also captures GPS data from mobile apps that provide their users with the option of sharing geolocation data. On the server side, Dynatrace captures IP addresses to enable detailed troubleshooting for Dynatrace service calls.
     */
    ipAddressMaskingEnabled: boolean;
    personalDataUriMaskingEnabled: boolean;
    userActionMaskingEnabled: boolean;
}

export interface DataPrivacyUserTracking {
    /**
     * When enabled, Dynatrace places a [persistent cookie](https://dt-url.net/313o0p4n) on all end-user devices to identify returning users.
     */
    persistentCookieEnabled: boolean;
}

export interface DatabaseAnomaliesDbConnectFailures {
    /**
     * Number of failed database connections during any **eval_period** minutes period to trigger an alert
     */
    connectionFailsCount?: number;
    /**
     * The *X* minutes time period during which the **connection*fails*count** is evaluated
     */
    evalPeriod?: number;
}

export interface DatabaseAnomaliesFailureRate {
    /**
     * Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
     */
    auto?: outputs.DatabaseAnomaliesFailureRateAuto;
    /**
     * Fixed thresholds for failure rate increase detection
     */
    thresholds?: outputs.DatabaseAnomaliesFailureRateThresholds;
}

export interface DatabaseAnomaliesFailureRateAuto {
    absolute: number;
    relative: number;
    unknowns?: string;
}

export interface DatabaseAnomaliesFailureRateThresholds {
    sensitivity: string;
    threshold: number;
    unknowns?: string;
}

export interface DatabaseAnomaliesLoad {
    /**
     * The configuration of traffic drops detection
     */
    drops?: outputs.DatabaseAnomaliesLoadDrops;
    /**
     * The configuration of traffic spikes detection
     */
    spikes?: outputs.DatabaseAnomaliesLoadSpikes;
}

export interface DatabaseAnomaliesLoadDrops {
    minutes?: number;
    percent?: number;
}

export interface DatabaseAnomaliesLoadSpikes {
    minutes?: number;
    percent?: number;
    unknowns?: string;
}

export interface DatabaseAnomaliesResponseTime {
    /**
     * Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
     */
    auto?: outputs.DatabaseAnomaliesResponseTimeAuto;
    /**
     * Fixed thresholds for response time degradation detection
     */
    thresholds?: outputs.DatabaseAnomaliesResponseTimeThresholds;
}

export interface DatabaseAnomaliesResponseTimeAuto {
    /**
     * Configuration for anomalies regarding load drops and spikes
     */
    load: string;
    milliseconds: number;
    percent: number;
    slowestMilliseconds: number;
    slowestPercent: number;
    unknowns?: string;
}

export interface DatabaseAnomaliesResponseTimeThresholds {
    /**
     * Configuration for anomalies regarding load drops and spikes
     */
    load: string;
    milliseconds: number;
    sensitivity: string;
    slowestMilliseconds: number;
    unknowns?: string;
}

export interface DatabaseAnomaliesV2DatabaseConnections {
    /**
     * Detect failed database connects
     */
    enabled: boolean;
    /**
     * Threshold
     */
    maxFailedConnects?: number;
    /**
     * Time span
     */
    timePeriod?: number;
}

export interface DatabaseAnomaliesV2FailureRate {
    /**
     * Alert if the percentage of failing service calls increases by **both** the absolute and relative thresholds:
     */
    autoDetection?: outputs.DatabaseAnomaliesV2FailureRateAutoDetection;
    /**
     * Detection mode for increases in failure rate
     */
    detectionMode?: string;
    /**
     * Detect increases in failure rate
     */
    enabled: boolean;
    /**
     * Alert if a given failure rate is exceeded during any 5-minute-period
     */
    fixedDetection?: outputs.DatabaseAnomaliesV2FailureRateFixedDetection;
}

export interface DatabaseAnomaliesV2FailureRateAutoDetection {
    absoluteIncrease: number;
    overAlertingProtection: outputs.DatabaseAnomaliesV2FailureRateAutoDetectionOverAlertingProtection;
    relativeIncrease: number;
}

export interface DatabaseAnomaliesV2FailureRateAutoDetectionOverAlertingProtection {
    minutesAbnormalState: number;
    requestsPerMinute: number;
}

export interface DatabaseAnomaliesV2FailureRateFixedDetection {
    overAlertingProtection: outputs.DatabaseAnomaliesV2FailureRateFixedDetectionOverAlertingProtection;
    sensitivity: string;
    threshold: number;
}

export interface DatabaseAnomaliesV2FailureRateFixedDetectionOverAlertingProtection {
    minutesAbnormalState: number;
    requestsPerMinute: number;
}

export interface DatabaseAnomaliesV2LoadDrops {
    /**
     * Detect service load drops
     */
    enabled: boolean;
    /**
     * Threshold
     */
    loadDropPercent?: number;
    /**
     * Time span
     */
    minutesAbnormalState?: number;
}

export interface DatabaseAnomaliesV2LoadSpikes {
    /**
     * Detect service load spikes
     */
    enabled: boolean;
    /**
     * Threshold
     */
    loadSpikePercent?: number;
    /**
     * Time span
     */
    minutesAbnormalState?: number;
}

export interface DatabaseAnomaliesV2ResponseTime {
    /**
     * no documentation available
     */
    autoDetection?: outputs.DatabaseAnomaliesV2ResponseTimeAutoDetection;
    /**
     * Detection mode for response time degradations
     */
    detectionMode?: string;
    /**
     * Detect response time degradations
     */
    enabled: boolean;
    /**
     * no documentation available
     */
    fixedDetection?: outputs.DatabaseAnomaliesV2ResponseTimeFixedDetection;
}

export interface DatabaseAnomaliesV2ResponseTimeAutoDetection {
    overAlertingProtection: outputs.DatabaseAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection;
    responseTimeAll: outputs.DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll;
    responseTimeSlowest: outputs.DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest;
}

export interface DatabaseAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection {
    minutesAbnormalState: number;
    requestsPerMinute: number;
}

export interface DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll {
    degradationMilliseconds: number;
    degradationPercent: number;
}

export interface DatabaseAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest {
    slowestDegradationMilliseconds: number;
    slowestDegradationPercent: number;
}

export interface DatabaseAnomaliesV2ResponseTimeFixedDetection {
    overAlertingProtection: outputs.DatabaseAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection;
    responseTimeAll: outputs.DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll;
    responseTimeSlowest: outputs.DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest;
    sensitivity: string;
}

export interface DatabaseAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection {
    minutesAbnormalState: number;
    requestsPerMinute: number;
}

export interface DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll {
    degradationMilliseconds: number;
}

export interface DatabaseAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest {
    slowestDegradationMilliseconds: number;
}

export interface DduPoolEvents {
    /**
     * Is the limit configuration enabled
     */
    enabled: boolean;
    /**
     * Type of the limit applied: MONTHLY or ANNUAL
     */
    type?: string;
    /**
     * Value of the DDU limit applied for provided timerange
     */
    value?: number;
}

export interface DduPoolLogMonitoring {
    /**
     * Is the limit configuration enabled
     */
    enabled: boolean;
    /**
     * Type of the limit applied: MONTHLY or ANNUAL
     */
    type?: string;
    /**
     * Value of the DDU limit applied for provided timerange
     */
    value?: number;
}

export interface DduPoolMetrics {
    /**
     * Is the limit configuration enabled
     */
    enabled: boolean;
    /**
     * Type of the limit applied: MONTHLY or ANNUAL
     */
    type?: string;
    /**
     * Value of the DDU limit applied for provided timerange
     */
    value?: number;
}

export interface DduPoolServerless {
    /**
     * Is the limit configuration enabled
     */
    enabled: boolean;
    /**
     * Type of the limit applied: MONTHLY or ANNUAL
     */
    type?: string;
    /**
     * Value of the DDU limit applied for provided timerange
     */
    value?: number;
}

export interface DduPoolTraces {
    /**
     * Is the limit configuration enabled
     */
    enabled: boolean;
    /**
     * Type of the limit applied: MONTHLY or ANNUAL
     */
    type?: string;
    /**
     * Value of the DDU limit applied for provided timerange
     */
    value?: number;
}

export interface DeclarativeGroupingDetection {
    processDefinitions: outputs.DeclarativeGroupingDetectionProcessDefinition[];
}

export interface DeclarativeGroupingDetectionProcessDefinition {
    id: string;
    processGroupName: string;
    report: string;
    rules?: outputs.DeclarativeGroupingDetectionProcessDefinitionRules;
}

export interface DeclarativeGroupingDetectionProcessDefinitionRules {
    rules: outputs.DeclarativeGroupingDetectionProcessDefinitionRulesRule[];
}

export interface DeclarativeGroupingDetectionProcessDefinitionRulesRule {
    condition: string;
    property: string;
}

export interface DiskAnomaliesDiskName {
    /**
     * Possible values are: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_EQUAL`, `DOES_NOT_START_WITH`, `EQUALS` and `STARTS_WITH`
     */
    operator: string;
    /**
     * Value to compare to
     */
    value: string;
}

export interface DiskAnomaliesTags {
    /**
     * A Tag Filter
     */
    filters?: outputs.DiskAnomaliesTagsFilter[];
}

export interface DiskAnomaliesTagsFilter {
    context: string;
    key: string;
    value?: string;
}

export interface DiskAnomaliesV2Disk {
    /**
     * no documentation available
     */
    diskLowInodesDetection: outputs.DiskAnomaliesV2DiskDiskLowInodesDetection;
    /**
     * no documentation available
     */
    diskLowSpaceDetection: outputs.DiskAnomaliesV2DiskDiskLowSpaceDetection;
    /**
     * no documentation available
     */
    diskSlowWritesAndReadsDetection: outputs.DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetection;
}

export interface DiskAnomaliesV2DiskDiskLowInodesDetection {
    customThresholds?: outputs.DiskAnomaliesV2DiskDiskLowInodesDetectionCustomThresholds;
    detectionMode?: string;
    enabled: boolean;
}

export interface DiskAnomaliesV2DiskDiskLowInodesDetectionCustomThresholds {
    freeInodesPercentage: number;
}

export interface DiskAnomaliesV2DiskDiskLowSpaceDetection {
    customThresholds?: outputs.DiskAnomaliesV2DiskDiskLowSpaceDetectionCustomThresholds;
    detectionMode?: string;
    enabled: boolean;
}

export interface DiskAnomaliesV2DiskDiskLowSpaceDetectionCustomThresholds {
    freeSpacePercentage: number;
}

export interface DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetection {
    customThresholds?: outputs.DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionCustomThresholds;
    detectionMode?: string;
    enabled: boolean;
}

export interface DiskAnomaliesV2DiskDiskSlowWritesAndReadsDetectionCustomThresholds {
    writeAndReadTime: number;
}

export interface DiskAnomalyRulesDiskNameFilter {
    /**
     * Possible Values: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_EQUAL`, `DOES_NOT_START_WITH`, `EQUALS`, `STARTS_WITH`
     */
    operator: string;
    /**
     * Matching text
     */
    value?: string;
}

export interface DiskAnomalyRulesSampleLimit {
    /**
     * .. within the last
     */
    samples: number;
    /**
     * Minimum number of violating samples
     */
    violatingSamples: number;
}

export interface DiskOptionsExclusions {
    exclusions: outputs.DiskOptionsExclusionsExclusion[];
}

export interface DiskOptionsExclusionsExclusion {
    filesystem?: string;
    mountpoint?: string;
    os: string;
}

export interface DiskSpecificAnomaliesV2DiskLowInodesDetection {
    /**
     * no documentation available
     */
    customThresholds?: outputs.DiskSpecificAnomaliesV2DiskLowInodesDetectionCustomThresholds;
    /**
     * Detection mode for low inodes number available
     */
    detectionMode?: string;
    /**
     * Detect low inodes number available
     */
    enabled: boolean;
}

export interface DiskSpecificAnomaliesV2DiskLowInodesDetectionCustomThresholds {
    freeInodesPercentage: number;
}

export interface DiskSpecificAnomaliesV2DiskLowSpaceDetection {
    /**
     * no documentation available
     */
    customThresholds?: outputs.DiskSpecificAnomaliesV2DiskLowSpaceDetectionCustomThresholds;
    /**
     * Detection mode for low disk space
     */
    detectionMode?: string;
    /**
     * Detect low disk space
     */
    enabled: boolean;
}

export interface DiskSpecificAnomaliesV2DiskLowSpaceDetectionCustomThresholds {
    freeSpacePercentage: number;
}

export interface DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetection {
    /**
     * no documentation available
     */
    customThresholds?: outputs.DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetectionCustomThresholds;
    /**
     * Detection mode for slow running disks
     */
    detectionMode?: string;
    /**
     * Detect slow-running disks
     */
    enabled: boolean;
}

export interface DiskSpecificAnomaliesV2DiskSlowWritesAndReadsDetectionCustomThresholds {
    writeAndReadTime: number;
}

export interface EnvironmentQuotas {
    /**
     * Davis Data Units consumption and quota information on environment level. Not set (and not editable) if Davis data units is not enabled
     */
    ddus?: outputs.EnvironmentQuotasDdus;
    /**
     * DEM units consumption and quota information on environment level
     */
    demUnits?: outputs.EnvironmentQuotasDemUnits;
    /**
     * Host units consumption and quota information on environment level
     */
    hostUnits?: number;
    /**
     * Log Monitoring consumption and quota information on environment level. Not set (and not editable) if Log monitoring is not enabled. Not set (and not editable) if Log monitoring is migrated to Davis data on license level
     */
    logs?: outputs.EnvironmentQuotasLogs;
    /**
     * Synthetic monitors consumption and quota information on environment level. Not set (and not editable) if neither Synthetic nor DEM units is enabled
     */
    synthetic?: outputs.EnvironmentQuotasSynthetic;
    /**
     * User sessions consumption and quota information on environment level
     */
    userSessions?: outputs.EnvironmentQuotasUserSessions;
}

export interface EnvironmentQuotasDdus {
    annual?: number;
    monthly?: number;
}

export interface EnvironmentQuotasDemUnits {
    annual?: number;
    monthly?: number;
}

export interface EnvironmentQuotasLogs {
    annual?: number;
    monthly?: number;
}

export interface EnvironmentQuotasSynthetic {
    annual?: number;
    monthly?: number;
}

export interface EnvironmentQuotasUserSessions {
    annual?: number;
    monthly?: number;
}

export interface EnvironmentStorage {
    limits?: outputs.EnvironmentStorageLimits;
    retention?: outputs.EnvironmentStorageRetention;
    /**
     * Maximum number of newly monitored entry point PurePaths captured per process/minute on environment level. Can be set to any value from 100 to 100000
     */
    transactions: number;
    /**
     * Maximum number of user actions generated per minute on environment level. Can be set to any value from 1 to 2147483646 or left unlimited by omitting this property
     */
    userActions?: number;
}

export interface EnvironmentStorageLimits {
    logs?: number;
    sessionReplay?: number;
    symbolFiles?: number;
    transactions?: number;
}

export interface EnvironmentStorageRetention {
    logs?: number;
    rum: number;
    serviceCodeLevel: number;
    serviceRequestLevel: number;
    sessionReplay: number;
    synthetic: number;
}

export interface FailureDetectionParametersBrokenLinks {
    /**
     * If your application relies on other hosts at other domains, add the associated domain names here. Once configured, Dynatrace will consider 404s thrown by hosts at these domains to be service failures related to your application.
     */
    brokenLinkDomains?: string[];
    /**
     * Consider 404 HTTP response codes as failures
     */
    http404NotFoundFailures: boolean;
}

export interface FailureDetectionParametersExceptionRules {
    /**
     * Some custom error situations are only detectable via a return value or other means. To support such cases, [define a request attribute](https://dt-url.net/ys5k0p4y) that captures the required data. Then define a custom error rule that determines if the request has failed based on the value of the request attribute.
     */
    customErrorRules?: outputs.FailureDetectionParametersExceptionRulesCustomErrorRules;
    /**
     * There may be situations where your application code handles exceptions gracefully in a manner that these failures aren't detected by Dynatrace. Use this setting to define specific gracefully-handled exceptions that should be treated as service failures.
     */
    customHandledExceptions?: outputs.FailureDetectionParametersExceptionRulesCustomHandledExceptions;
    /**
     * Ignore all exceptions
     */
    ignoreAllExceptions: boolean;
    /**
     * Ignore span failure detection
     */
    ignoreSpanFailureDetection: boolean;
    /**
     * Some exceptions that are thrown by legacy or 3rd-party code indicate a specific response, not an error. Use this setting to instruct Dynatrace to treat such exceptions as non-failed requests.. If an exception matching any of the defined patterns occurs in a request, it will not be considered as a failure. Other exceptions occurring at the same request might still mark the request as failed.
     */
    ignoredExceptions?: outputs.FailureDetectionParametersExceptionRulesIgnoredExceptions;
    /**
     * Define exceptions which indicate that a service call should not be considered as failed. E.g. an exception indicating that the client aborted the operation.. If an exception matching any of the defined patterns occurs on the entry node of the service, it will be considered successful. Compared to ignored exceptions, the request will be considered successful even if other exceptions occur in the same request.
     */
    successForcingExceptions?: outputs.FailureDetectionParametersExceptionRulesSuccessForcingExceptions;
}

export interface FailureDetectionParametersExceptionRulesCustomErrorRules {
    customErrorRules: outputs.FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRule[];
}

export interface FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRule {
    condition: outputs.FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRuleCondition;
    requestAttribute: string;
}

export interface FailureDetectionParametersExceptionRulesCustomErrorRulesCustomErrorRuleCondition {
    caseSensitive?: boolean;
    compareOperationType: string;
    doubleValue?: number;
    intValue?: number;
    textValue?: string;
}

export interface FailureDetectionParametersExceptionRulesCustomHandledExceptions {
    customHandledExceptions: outputs.FailureDetectionParametersExceptionRulesCustomHandledExceptionsCustomHandledException[];
}

export interface FailureDetectionParametersExceptionRulesCustomHandledExceptionsCustomHandledException {
    classPattern?: string;
    messagePattern?: string;
}

export interface FailureDetectionParametersExceptionRulesIgnoredExceptions {
    customHandledExceptions: outputs.FailureDetectionParametersExceptionRulesIgnoredExceptionsCustomHandledException[];
}

export interface FailureDetectionParametersExceptionRulesIgnoredExceptionsCustomHandledException {
    classPattern?: string;
    messagePattern?: string;
}

export interface FailureDetectionParametersExceptionRulesSuccessForcingExceptions {
    customHandledExceptions: outputs.FailureDetectionParametersExceptionRulesSuccessForcingExceptionsCustomHandledException[];
}

export interface FailureDetectionParametersExceptionRulesSuccessForcingExceptionsCustomHandledException {
    classPattern?: string;
    messagePattern?: string;
}

export interface FailureDetectionParametersHttpResponseCodes {
    /**
     * HTTP response codes which indicate client side errors
     */
    clientSideErrors: string;
    /**
     * Treat missing HTTP response code as client side error
     */
    failOnMissingResponseCodeClientSide: boolean;
    /**
     * Treat missing HTTP response code as server side errors
     */
    failOnMissingResponseCodeServerSide: boolean;
    /**
     * HTTP response codes which indicate an error on the server side
     */
    serverSideErrors: string;
}

export interface FailureDetectionRulesConditions {
    conditions: outputs.FailureDetectionRulesConditionsCondition[];
}

export interface FailureDetectionRulesConditionsCondition {
    attribute: string;
    predicate: outputs.FailureDetectionRulesConditionsConditionPredicate;
}

export interface FailureDetectionRulesConditionsConditionPredicate {
    caseSensitive?: boolean;
    managementZones?: string[];
    predicateType: string;
    serviceTypes?: string[];
    tagKeys?: string[];
    tags?: string[];
    textValues?: string[];
}

export interface GenericRelationshipsSources {
    sources: outputs.GenericRelationshipsSourcesSource[];
}

export interface GenericRelationshipsSourcesSource {
    condition?: string;
    mappingRules?: outputs.GenericRelationshipsSourcesSourceMappingRules;
    sourceType: string;
}

export interface GenericRelationshipsSourcesSourceMappingRules {
    mappingRules: outputs.GenericRelationshipsSourcesSourceMappingRulesMappingRule[];
}

export interface GenericRelationshipsSourcesSourceMappingRulesMappingRule {
    destinationProperty: string;
    destinationTransformation: string;
    sourceProperty: string;
    sourceTransformation: string;
}

export interface GenericTypesRules {
    rules: outputs.GenericTypesRulesRule[];
}

export interface GenericTypesRulesRule {
    attributes?: outputs.GenericTypesRulesRuleAttributes;
    iconPattern?: string;
    idPattern: string;
    instanceNamePattern?: string;
    requiredDimensions?: outputs.GenericTypesRulesRuleRequiredDimensions;
    role?: string;
    sources: outputs.GenericTypesRulesRuleSources;
}

export interface GenericTypesRulesRuleAttributes {
    attributes: outputs.GenericTypesRulesRuleAttributesAttribute[];
}

export interface GenericTypesRulesRuleAttributesAttribute {
    /**
     * The human readable type name for this entity type.
     */
    displayName?: string;
    key: string;
    pattern: string;
}

export interface GenericTypesRulesRuleRequiredDimensions {
    requiredDimensions: outputs.GenericTypesRulesRuleRequiredDimensionsRequiredDimension[];
}

export interface GenericTypesRulesRuleRequiredDimensionsRequiredDimension {
    key: string;
    valuePattern?: string;
}

export interface GenericTypesRulesRuleSources {
    sources: outputs.GenericTypesRulesRuleSourcesSource[];
}

export interface GenericTypesRulesRuleSourcesSource {
    condition?: string;
    sourceType: string;
}

export interface GetAlertingProfilesValue {
    /**
     * The ID of this resource.
     */
    id: string;
    legacyId: string;
    managementZoneId: string;
    managementZoneLegacyId: string;
    name: string;
}

export interface GetEntitiesEntities {
    /**
     * A list of monitored entities.
     */
    entities?: outputs.GetEntitiesEntitiesEntity[];
}

export interface GetEntitiesEntitiesEntity {
    displayName?: string;
    entityId?: string;
    tags?: outputs.GetEntitiesEntitiesEntityTag[];
    type?: string;
}

export interface GetEntitiesEntitiesEntityTag {
    tags?: outputs.GetEntitiesEntitiesEntityTagTag[];
}

export interface GetEntitiesEntitiesEntityTagTag {
    context: string;
    key: string;
    stringRepresentation?: string;
    value?: string;
}

export interface GetManagementZonesValue {
    description: string;
    /**
     * The ID of this resource.
     */
    id: string;
    legacyId: string;
    name: string;
}

export interface GetSyntheticLocationsLocations {
    /**
     * The cloud provider where the location is hosted.
     */
    cloudPlatform: string;
    entityId?: string;
    ips: string[];
    name?: string;
    stage: string;
    status: string;
    type?: string;
}

export interface HostAnomaliesConnections {
    /**
     * The detection is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * Alert (`true`) on graceful host shutdowns
     */
    enabledOnGracefulShutdowns: boolean;
}

export interface HostAnomaliesCpu {
    /**
     * The detection is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * Custom thresholds for high CPU saturation. If not set then the automatic mode is used
     */
    thresholds?: outputs.HostAnomaliesCpuThresholds;
}

export interface HostAnomaliesCpuThresholds {
    saturation: number;
}

export interface HostAnomaliesDisks {
    /**
     * Configuration of low disk inodes number detection
     */
    inodes?: outputs.HostAnomaliesDisksInodes;
    /**
     * Configuration of low disk space detection
     */
    space?: outputs.HostAnomaliesDisksSpace;
    /**
     * Configuration of slow running disks detection
     */
    speed?: outputs.HostAnomaliesDisksSpeed;
}

export interface HostAnomaliesDisksInodes {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesDisksInodesThresholds;
}

export interface HostAnomaliesDisksInodesThresholds {
    percentage: number;
}

export interface HostAnomaliesDisksSpace {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesDisksSpaceThresholds;
}

export interface HostAnomaliesDisksSpaceThresholds {
    percentage: number;
}

export interface HostAnomaliesDisksSpeed {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesDisksSpeedThresholds;
}

export interface HostAnomaliesDisksSpeedThresholds {
    writeAndReadTime: number;
}

export interface HostAnomaliesGc {
    /**
     * The detection is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * Custom thresholds for high GC activity. If not set, automatic mode is used.   Meeting **any** of these conditions triggers an alert
     */
    thresholds?: outputs.HostAnomaliesGcThresholds;
}

export interface HostAnomaliesGcThresholds {
    suspensionPercentage: number;
    timePercentage: number;
}

export interface HostAnomaliesJava {
    /**
     * Configuration of Java out of memory problems detection
     */
    outOfMemory?: outputs.HostAnomaliesJavaOutOfMemory;
    /**
     * Configuration of Java out of threads problems detection
     */
    outOfThreads?: outputs.HostAnomaliesJavaOutOfThreads;
}

export interface HostAnomaliesJavaOutOfMemory {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesJavaOutOfMemoryThresholds;
}

export interface HostAnomaliesJavaOutOfMemoryThresholds {
    exceptionCount: number;
}

export interface HostAnomaliesJavaOutOfThreads {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesJavaOutOfThreadsThresholds;
}

export interface HostAnomaliesJavaOutOfThreadsThresholds {
    exceptionCount: number;
}

export interface HostAnomaliesMemory {
    /**
     * The detection is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * Custom thresholds for high memory usage. If not set then the automatic mode is used. **Both** conditions must be met to trigger an alert
     */
    thresholds?: outputs.HostAnomaliesMemoryThresholds;
}

export interface HostAnomaliesMemoryThresholds {
    linux: outputs.HostAnomaliesMemoryThresholdsLinux;
    windows: outputs.HostAnomaliesMemoryThresholdsWindows;
}

export interface HostAnomaliesMemoryThresholdsLinux {
    pageFaults: number;
    usage: number;
}

export interface HostAnomaliesMemoryThresholdsWindows {
    pageFaults: number;
    usage: number;
}

export interface HostAnomaliesNetwork {
    /**
     * Configuration of TCP connectivity problems detection
     */
    connectivity?: outputs.HostAnomaliesNetworkConnectivity;
    /**
     * Configuration of high number of dropped packets detection
     */
    droppedPackets?: outputs.HostAnomaliesNetworkDroppedPackets;
    /**
     * Configuration of high number of network errors detection
     */
    errors?: outputs.HostAnomaliesNetworkErrors;
    /**
     * Configuration of high retransmission rate detection
     */
    retransmission?: outputs.HostAnomaliesNetworkRetransmission;
    /**
     * Configuration of high network utilization detection
     */
    utilization?: outputs.HostAnomaliesNetworkUtilization;
}

export interface HostAnomaliesNetworkConnectivity {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesNetworkConnectivityThresholds;
}

export interface HostAnomaliesNetworkConnectivityThresholds {
    failedConnections: number;
    newConnectionFailures: number;
}

export interface HostAnomaliesNetworkDroppedPackets {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesNetworkDroppedPacketsThresholds;
}

export interface HostAnomaliesNetworkDroppedPacketsThresholds {
    droppedPackets: number;
    totalPacketsRate: number;
}

export interface HostAnomaliesNetworkErrors {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesNetworkErrorsThresholds;
}

export interface HostAnomaliesNetworkErrorsThresholds {
    errorsPercentage: number;
    totalPacketsRate: number;
}

export interface HostAnomaliesNetworkRetransmission {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesNetworkRetransmissionThresholds;
}

export interface HostAnomaliesNetworkRetransmissionThresholds {
    retransmissionRate: number;
    retransmittedPackets: number;
}

export interface HostAnomaliesNetworkUtilization {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesNetworkUtilizationThresholds;
}

export interface HostAnomaliesNetworkUtilizationThresholds {
    utilization: number;
}

export interface HostAnomaliesV2Host {
    /**
     * no documentation available
     */
    connectionLostDetection: outputs.HostAnomaliesV2HostConnectionLostDetection;
    /**
     * no documentation available
     */
    highCpuSaturationDetection: outputs.HostAnomaliesV2HostHighCpuSaturationDetection;
    /**
     * no documentation available
     */
    highGcActivityDetection: outputs.HostAnomaliesV2HostHighGcActivityDetection;
    /**
     * no documentation available
     */
    highMemoryDetection: outputs.HostAnomaliesV2HostHighMemoryDetection;
    /**
     * no documentation available
     */
    highSystemLoadDetection: outputs.HostAnomaliesV2HostHighSystemLoadDetection;
    /**
     * no documentation available
     */
    outOfMemoryDetection: outputs.HostAnomaliesV2HostOutOfMemoryDetection;
    /**
     * no documentation available
     */
    outOfThreadsDetection: outputs.HostAnomaliesV2HostOutOfThreadsDetection;
}

export interface HostAnomaliesV2HostConnectionLostDetection {
    enabled: boolean;
    onGracefulShutdowns?: string;
}

export interface HostAnomaliesV2HostHighCpuSaturationDetection {
    customThresholds?: outputs.HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholds;
    detectionMode?: string;
    enabled: boolean;
}

export interface HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholds {
    cpuSaturation: number;
    eventThresholds: outputs.HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholdsEventThresholds;
}

export interface HostAnomaliesV2HostHighCpuSaturationDetectionCustomThresholdsEventThresholds {
    dealertingEvaluationWindow: number;
    dealertingSamples: number;
    violatingEvaluationWindow: number;
    violatingSamples: number;
}

export interface HostAnomaliesV2HostHighGcActivityDetection {
    customThresholds?: outputs.HostAnomaliesV2HostHighGcActivityDetectionCustomThresholds;
    detectionMode?: string;
    enabled: boolean;
}

export interface HostAnomaliesV2HostHighGcActivityDetectionCustomThresholds {
    eventThresholds: outputs.HostAnomaliesV2HostHighGcActivityDetectionCustomThresholdsEventThresholds;
    gcSuspensionPercentage: number;
    gcTimePercentage: number;
}

export interface HostAnomaliesV2HostHighGcActivityDetectionCustomThresholdsEventThresholds {
    dealertingEvaluationWindow: number;
    dealertingSamples: number;
    violatingEvaluationWindow: number;
    violatingSamples: number;
}

export interface HostAnomaliesV2HostHighMemoryDetection {
    customThresholds?: outputs.HostAnomaliesV2HostHighMemoryDetectionCustomThresholds;
    detectionMode?: string;
    enabled: boolean;
}

export interface HostAnomaliesV2HostHighMemoryDetectionCustomThresholds {
    eventThresholds: outputs.HostAnomaliesV2HostHighMemoryDetectionCustomThresholdsEventThresholds;
    pageFaultsPerSecondNonWindows: number;
    pageFaultsPerSecondWindows: number;
    usedMemoryPercentageNonWindows: number;
    usedMemoryPercentageWindows: number;
}

export interface HostAnomaliesV2HostHighMemoryDetectionCustomThresholdsEventThresholds {
    dealertingEvaluationWindow: number;
    dealertingSamples: number;
    violatingEvaluationWindow: number;
    violatingSamples: number;
}

export interface HostAnomaliesV2HostHighSystemLoadDetection {
    customThresholds?: outputs.HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholds;
    detectionMode?: string;
    enabled: boolean;
}

export interface HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholds {
    eventThresholds: outputs.HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholdsEventThresholds;
    systemLoad: number;
}

export interface HostAnomaliesV2HostHighSystemLoadDetectionCustomThresholdsEventThresholds {
    dealertingEvaluationWindow: number;
    dealertingSamples: number;
    violatingEvaluationWindow: number;
    violatingSamples: number;
}

export interface HostAnomaliesV2HostOutOfMemoryDetection {
    customThresholds?: outputs.HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholds;
    detectionMode?: string;
    enabled: boolean;
}

export interface HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholds {
    eventThresholds: outputs.HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholdsEventThresholds;
    outOfMemoryExceptionsNumber: number;
}

export interface HostAnomaliesV2HostOutOfMemoryDetectionCustomThresholdsEventThresholds {
    dealertingEvaluationWindow: number;
    dealertingSamples: number;
    violatingEvaluationWindow: number;
    violatingSamples: number;
}

export interface HostAnomaliesV2HostOutOfThreadsDetection {
    customThresholds?: outputs.HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholds;
    detectionMode?: string;
    enabled: boolean;
}

export interface HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholds {
    eventThresholds: outputs.HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholdsEventThresholds;
    outOfThreadsExceptionsNumber: number;
}

export interface HostAnomaliesV2HostOutOfThreadsDetectionCustomThresholdsEventThresholds {
    dealertingEvaluationWindow: number;
    dealertingSamples: number;
    violatingEvaluationWindow: number;
    violatingSamples: number;
}

export interface HostAnomaliesV2Network {
    /**
     * no documentation available
     */
    highNetworkDetection: outputs.HostAnomaliesV2NetworkHighNetworkDetection;
    /**
     * no documentation available
     */
    networkDroppedPacketsDetection: outputs.HostAnomaliesV2NetworkNetworkDroppedPacketsDetection;
    /**
     * no documentation available
     */
    networkErrorsDetection: outputs.HostAnomaliesV2NetworkNetworkErrorsDetection;
    /**
     * no documentation available
     */
    networkHighRetransmissionDetection: outputs.HostAnomaliesV2NetworkNetworkHighRetransmissionDetection;
    /**
     * no documentation available
     */
    networkTcpProblemsDetection: outputs.HostAnomaliesV2NetworkNetworkTcpProblemsDetection;
}

export interface HostAnomaliesV2NetworkHighNetworkDetection {
    customThresholds?: outputs.HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholds;
    detectionMode?: string;
    enabled: boolean;
}

export interface HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholds {
    errorsPercentage: number;
    eventThresholds: outputs.HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholdsEventThresholds;
}

export interface HostAnomaliesV2NetworkHighNetworkDetectionCustomThresholdsEventThresholds {
    dealertingEvaluationWindow: number;
    dealertingSamples: number;
    violatingEvaluationWindow: number;
    violatingSamples: number;
}

export interface HostAnomaliesV2NetworkNetworkDroppedPacketsDetection {
    customThresholds?: outputs.HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholds;
    detectionMode?: string;
    enabled: boolean;
}

export interface HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholds {
    droppedPacketsPercentage: number;
    eventThresholds: outputs.HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholdsEventThresholds;
    totalPacketsRate: number;
}

export interface HostAnomaliesV2NetworkNetworkDroppedPacketsDetectionCustomThresholdsEventThresholds {
    dealertingEvaluationWindow: number;
    dealertingSamples: number;
    violatingEvaluationWindow: number;
    violatingSamples: number;
}

export interface HostAnomaliesV2NetworkNetworkErrorsDetection {
    customThresholds?: outputs.HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholds;
    detectionMode?: string;
    enabled: boolean;
}

export interface HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholds {
    errorsPercentage: number;
    eventThresholds: outputs.HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholdsEventThresholds;
    totalPacketsRate: number;
}

export interface HostAnomaliesV2NetworkNetworkErrorsDetectionCustomThresholdsEventThresholds {
    dealertingEvaluationWindow: number;
    dealertingSamples: number;
    violatingEvaluationWindow: number;
    violatingSamples: number;
}

export interface HostAnomaliesV2NetworkNetworkHighRetransmissionDetection {
    customThresholds?: outputs.HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholds;
    detectionMode?: string;
    enabled: boolean;
}

export interface HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholds {
    eventThresholds: outputs.HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholdsEventThresholds;
    retransmissionRatePercentage: number;
    retransmittedPacketsNumberPerMinute: number;
}

export interface HostAnomaliesV2NetworkNetworkHighRetransmissionDetectionCustomThresholdsEventThresholds {
    dealertingEvaluationWindow: number;
    dealertingSamples: number;
    violatingEvaluationWindow: number;
    violatingSamples: number;
}

export interface HostAnomaliesV2NetworkNetworkTcpProblemsDetection {
    customThresholds?: outputs.HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholds;
    detectionMode?: string;
    enabled: boolean;
}

export interface HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholds {
    eventThresholds: outputs.HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholdsEventThresholds;
    failedConnectionsNumberPerMinute: number;
    newConnectionFailuresPercentage: number;
}

export interface HostAnomaliesV2NetworkNetworkTcpProblemsDetectionCustomThresholdsEventThresholds {
    dealertingEvaluationWindow: number;
    dealertingSamples: number;
    violatingEvaluationWindow: number;
    violatingSamples: number;
}

export interface HostNamingCondition {
    conditions?: outputs.HostNamingConditionCondition[];
}

export interface HostNamingConditionCondition {
    /**
     * @deprecated You should use 'application_type' instead of 'application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    applicationTypeComparisons?: outputs.HostNamingConditionConditionApplicationTypeComparison[];
    applicationTypes?: outputs.HostNamingConditionConditionApplicationType[];
    azureComputeModeComparisons?: outputs.HostNamingConditionConditionAzureComputeModeComparison[];
    /**
     * @deprecated You should use 'azure_compute_mode' instead of 'azure_compute_mode_comparison'. This attribute still exists for backwards compatibility.
     */
    azureComputeModes?: outputs.HostNamingConditionConditionAzureComputeMode[];
    /**
     * @deprecated You should use 'azure_sku' instead of 'azure_sku_comparision'. This attribute still exists for backwards compatibility.
     */
    azureSkuComparisions?: outputs.HostNamingConditionConditionAzureSkuComparision[];
    azureSkus?: outputs.HostNamingConditionConditionAzureSkus[];
    /**
     * @deprecated You should use 'comparison' instead of 'base_comparison_basic'. This attribute still exists for backwards compatibility.
     */
    baseComparisonBasics?: outputs.HostNamingConditionConditionBaseComparisonBasic[];
    /**
     * @deprecated 'base_condition_key' is deprecated. You should use 'key'
     */
    baseConditionKeys?: outputs.HostNamingConditionConditionBaseConditionKey[];
    /**
     * @deprecated You should use 'bitness' instead of 'bitness_comparision'. This attribute still exists for backwards compatibility.
     */
    bitnessComparisions?: outputs.HostNamingConditionConditionBitnessComparision[];
    bitnesses?: outputs.HostNamingConditionConditionBitness[];
    /**
     * @deprecated You should use 'cloud_type' instead of 'cloud_type_comparison'. This attribute still exists for backwards compatibility.
     */
    cloudTypeComparisons?: outputs.HostNamingConditionConditionCloudTypeComparison[];
    cloudTypes?: outputs.HostNamingConditionConditionCloudType[];
    comparisons?: outputs.HostNamingConditionConditionComparison[];
    /**
     * @deprecated You should use 'custom_application_type' instead of 'custom_application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    customApplicationTypeComparisons?: outputs.HostNamingConditionConditionCustomApplicationTypeComparison[];
    customApplicationTypes?: outputs.HostNamingConditionConditionCustomApplicationType[];
    /**
     * @deprecated 'custom_host_metadata_condition_key' is deprecated. You should use 'custom_host_metadata'
     */
    customHostMetadataConditionKeys?: outputs.HostNamingConditionConditionCustomHostMetadataConditionKey[];
    customHostMetadatas?: outputs.HostNamingConditionConditionCustomHostMetadata[];
    /**
     * @deprecated 'custom_process_metadata_condition_key' is deprecated. You should use 'custom_process_metadata'
     */
    customProcessMetadataConditionKeys?: outputs.HostNamingConditionConditionCustomProcessMetadataConditionKey[];
    customProcessMetadatas?: outputs.HostNamingConditionConditionCustomProcessMetadata[];
    databaseTopologies?: outputs.HostNamingConditionConditionDatabaseTopology[];
    /**
     * @deprecated You should use 'database_topology' instead of 'database_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    databaseTopologyComparisons?: outputs.HostNamingConditionConditionDatabaseTopologyComparison[];
    /**
     * @deprecated You should use 'dcrum_decoder' instead of 'dcrum_decoder_comparison'. This attribute still exists for backwards compatibility.
     */
    dcrumDecoderComparisons?: outputs.HostNamingConditionConditionDcrumDecoderComparison[];
    dcrumDecoders?: outputs.HostNamingConditionConditionDcrumDecoder[];
    entities?: outputs.HostNamingConditionConditionEntity[];
    /**
     * @deprecated You should use 'entity' instead of 'entity_id_comparison'. This attribute still exists for backwards compatibility.
     */
    entityIdComparisons?: outputs.HostNamingConditionConditionEntityIdComparison[];
    hostTeches?: outputs.HostNamingConditionConditionHostTech[];
    /**
     * @deprecated `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
     */
    hypervisorTypeComparisions?: outputs.HostNamingConditionConditionHypervisorTypeComparision[];
    hypervisors?: outputs.HostNamingConditionConditionHypervisor[];
    /**
     * @deprecated You should use 'indexed_name' instead of 'indexed_name_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedNameComparisons?: outputs.HostNamingConditionConditionIndexedNameComparison[];
    indexedNames?: outputs.HostNamingConditionConditionIndexedName[];
    /**
     * @deprecated You should use 'indexed_string' instead of 'indexed_string_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedStringComparisons?: outputs.HostNamingConditionConditionIndexedStringComparison[];
    indexedStrings?: outputs.HostNamingConditionConditionIndexedString[];
    /**
     * @deprecated You should use 'indexed_tag' instead of 'indexed_tag_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedTagComparisons?: outputs.HostNamingConditionConditionIndexedTagComparison[];
    indexedTags?: outputs.HostNamingConditionConditionIndexedTag[];
    /**
     * @deprecated You should use 'integer' instead of 'integer_comparison'. This attribute still exists for backwards compatibility.
     */
    integerComparisons?: outputs.HostNamingConditionConditionIntegerComparison[];
    integers?: outputs.HostNamingConditionConditionInteger[];
    /**
     * @deprecated You should use 'ipaddress' instead of 'ipaddress_comparison'. This attribute still exists for backwards compatibility.
     */
    ipaddressComparisons?: outputs.HostNamingConditionConditionIpaddressComparison[];
    ipaddresses?: outputs.HostNamingConditionConditionIpaddress[];
    keys?: outputs.HostNamingConditionConditionKey[];
    /**
     * @deprecated You should use 'mobile_platform' instead of 'mobile_platform_comparison'. This attribute still exists for backwards compatibility.
     */
    mobilePlatformComparisons?: outputs.HostNamingConditionConditionMobilePlatformComparison[];
    mobilePlatforms?: outputs.HostNamingConditionConditionMobilePlatform[];
    osArches?: outputs.HostNamingConditionConditionOsArch[];
    osTypes?: outputs.HostNamingConditionConditionOsType[];
    /**
     * @deprecated You should use 'os_arch' instead of 'osarchitecture_comparison'. This attribute still exists for backwards compatibility.
     */
    osarchitectureComparisons?: outputs.HostNamingConditionConditionOsarchitectureComparison[];
    /**
     * @deprecated You should use 'os_type' instead of 'ostype_comparison'. This attribute still exists for backwards compatibility.
     */
    ostypeComparisons?: outputs.HostNamingConditionConditionOstypeComparison[];
    /**
     * @deprecated You should use 'paas_type' instead of 'paas_type_comparison'. This attribute still exists for backwards compatibility.
     */
    paasTypeComparisons?: outputs.HostNamingConditionConditionPaasTypeComparison[];
    paasTypes?: outputs.HostNamingConditionConditionPaasType[];
    /**
     * @deprecated 'process_metadata_condition_key' is deprecated. You should use 'process_metadata'
     */
    processMetadataConditionKeys?: outputs.HostNamingConditionConditionProcessMetadataConditionKey[];
    processMetadatas?: outputs.HostNamingConditionConditionProcessMetadata[];
    serviceTopologies?: outputs.HostNamingConditionConditionServiceTopology[];
    /**
     * @deprecated You should use 'service_topology' instead of 'service_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTopologyComparisons?: outputs.HostNamingConditionConditionServiceTopologyComparison[];
    /**
     * @deprecated You should use 'service_type' instead of 'service_type_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTypeComparisons?: outputs.HostNamingConditionConditionServiceTypeComparison[];
    serviceTypes?: outputs.HostNamingConditionConditionServiceType[];
    /**
     * @deprecated You should use 'host_tech' instead of 'simple_host_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleHostTechComparisons?: outputs.HostNamingConditionConditionSimpleHostTechComparison[];
    /**
     * @deprecated You should use 'tech' instead of 'simple_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleTechComparisons?: outputs.HostNamingConditionConditionSimpleTechComparison[];
    /**
     * @deprecated You should use 'string' instead of 'string_comparison'. This attribute still exists for backwards compatibility.
     */
    stringComparisons?: outputs.HostNamingConditionConditionStringComparison[];
    /**
     * @deprecated 'string_condition_key' is deprecated. You should use 'string_key'
     */
    stringConditionKeys?: outputs.HostNamingConditionConditionStringConditionKey[];
    stringKeys?: outputs.HostNamingConditionConditionStringKey[];
    strings?: outputs.HostNamingConditionConditionString[];
    /**
     * @deprecated You should use 'synthetic_engine' instead of 'synthetic_engine_type_comparison'. This attribute still exists for backwards compatibility.
     */
    syntheticEngineTypeComparisons?: outputs.HostNamingConditionConditionSyntheticEngineTypeComparison[];
    syntheticEngines?: outputs.HostNamingConditionConditionSyntheticEngine[];
    /**
     * @deprecated You should use 'tag' instead of 'tag_comparison'. This attribute still exists for backwards compatibility.
     */
    tagComparisons?: outputs.HostNamingConditionConditionTagComparison[];
    tags?: outputs.HostNamingConditionConditionTag[];
    teches?: outputs.HostNamingConditionConditionTech[];
    unknowns?: string;
}

export interface HostNamingConditionConditionApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionAzureComputeMode {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionAzureComputeModeComparison {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionAzureSkuComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionAzureSkus {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionBaseComparisonBasic {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionBaseConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionBitness {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionBitnessComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionCloudType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionCloudTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionComparison {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionCustomApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionCustomApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionCustomHostMetadata {
    attribute: string;
    dynamicKey: outputs.HostNamingConditionConditionCustomHostMetadataDynamicKey;
    unknowns?: string;
}

export interface HostNamingConditionConditionCustomHostMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.HostNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionCustomHostMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionCustomProcessMetadata {
    attribute: string;
    dynamicKey: outputs.HostNamingConditionConditionCustomProcessMetadataDynamicKey;
    unknowns?: string;
}

export interface HostNamingConditionConditionCustomProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.HostNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionCustomProcessMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionDatabaseTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionDatabaseTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionDcrumDecoder {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionDcrumDecoderComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionEntity {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionEntityIdComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionHostTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.HostNamingConditionConditionHostTechValue;
}

export interface HostNamingConditionConditionHostTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface HostNamingConditionConditionHypervisor {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionHypervisorTypeComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionIndexedName {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionIndexedNameComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionIndexedString {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionIndexedStringComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionIndexedTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.HostNamingConditionConditionIndexedTagValue;
}

export interface HostNamingConditionConditionIndexedTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.HostNamingConditionConditionIndexedTagComparisonValue;
}

export interface HostNamingConditionConditionIndexedTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionIndexedTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionInteger {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: number;
}

export interface HostNamingConditionConditionIntegerComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: number;
}

export interface HostNamingConditionConditionIpaddress {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionIpaddressComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionMobilePlatform {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionMobilePlatformComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionOsArch {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionOsType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionOsarchitectureComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionOstypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionPaasType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionPaasTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionProcessMetadata {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionServiceTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionServiceTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionServiceType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionServiceTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionSimpleHostTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.HostNamingConditionConditionSimpleHostTechComparisonValue;
}

export interface HostNamingConditionConditionSimpleHostTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface HostNamingConditionConditionSimpleTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.HostNamingConditionConditionSimpleTechComparisonValue;
}

export interface HostNamingConditionConditionSimpleTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface HostNamingConditionConditionString {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionStringComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionStringConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionStringKey {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionSyntheticEngine {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionSyntheticEngineTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.HostNamingConditionConditionTagValue;
}

export interface HostNamingConditionConditionTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.HostNamingConditionConditionTagComparisonValue;
}

export interface HostNamingConditionConditionTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.HostNamingConditionConditionTechValue;
}

export interface HostNamingConditionConditionTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface HttpMonitorAnomalyDetection {
    /**
     * Thresholds for loading times
     */
    loadingTimeThresholds?: outputs.HttpMonitorAnomalyDetectionLoadingTimeThreshold[];
    /**
     * Outage handling configuration
     */
    outageHandlings?: outputs.HttpMonitorAnomalyDetectionOutageHandling[];
}

export interface HttpMonitorAnomalyDetectionLoadingTimeThreshold {
    enabled?: boolean;
    thresholds?: outputs.HttpMonitorAnomalyDetectionLoadingTimeThresholdThreshold[];
}

export interface HttpMonitorAnomalyDetectionLoadingTimeThresholdThreshold {
    thresholds: outputs.HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold[];
}

export interface HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold {
    eventIndex?: number;
    requestIndex?: number;
    type?: string;
    valueMs: number;
}

export interface HttpMonitorAnomalyDetectionOutageHandling {
    globalOutage?: boolean;
    globalOutagePolicies?: outputs.HttpMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy[];
    localOutage?: boolean;
    localOutagePolicies?: outputs.HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy[];
    retryOnError?: boolean;
}

export interface HttpMonitorAnomalyDetectionOutageHandlingGlobalOutagePolicy {
    consecutiveRuns: number;
}

export interface HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy {
    affectedLocations: number;
    consecutiveRuns: number;
}

export interface HttpMonitorCookiesCookies {
    cookies: outputs.HttpMonitorCookiesCookiesCookie[];
}

export interface HttpMonitorCookiesCookiesCookie {
    domain: string;
    name: string;
    path?: string;
    value: string;
}

export interface HttpMonitorPerformanceThresholds {
    thresholds: outputs.HttpMonitorPerformanceThresholdsThreshold[];
}

export interface HttpMonitorPerformanceThresholdsThreshold {
    event: string;
    threshold: number;
}

export interface HttpMonitorScript {
    /**
     * A HTTP request to be performed by the monitor.
     */
    requests: outputs.HttpMonitorScriptRequest[];
}

export interface HttpMonitorScriptRequest {
    authentication?: outputs.HttpMonitorScriptRequestAuthentication;
    body?: string;
    configuration?: outputs.HttpMonitorScriptRequestConfiguration;
    description?: string;
    method: string;
    postProcessing?: string;
    preProcessing?: string;
    requestTimeout?: number;
    url: string;
    validation?: outputs.HttpMonitorScriptRequestValidation;
}

export interface HttpMonitorScriptRequestAuthentication {
    credentials: string;
    kdcIp?: string;
    realmName?: string;
    type: string;
}

export interface HttpMonitorScriptRequestConfiguration {
    acceptAnyCertificate?: boolean;
    clientCertificate?: string;
    followRedirects?: boolean;
    headers?: outputs.HttpMonitorScriptRequestConfigurationHeaders;
    sensitiveData?: boolean;
    userAgent?: string;
}

export interface HttpMonitorScriptRequestConfigurationHeaders {
    headers: outputs.HttpMonitorScriptRequestConfigurationHeadersHeader[];
}

export interface HttpMonitorScriptRequestConfigurationHeadersHeader {
    name: string;
    value: string;
}

export interface HttpMonitorScriptRequestValidation {
    rules: outputs.HttpMonitorScriptRequestValidationRule[];
}

export interface HttpMonitorScriptRequestValidationRule {
    passIfFound?: boolean;
    type: string;
    value: string;
}

export interface HttpMonitorTag {
    /**
     * Tag with source of a Dynatrace entity.
     */
    tags?: outputs.HttpMonitorTagTag[];
}

export interface HttpMonitorTagTag {
    context: string;
    key: string;
    source?: string;
    value?: string;
}

export interface IamGroupPermissions {
    /**
     * A Permission
     */
    permissions: outputs.IamGroupPermissionsPermission[];
}

export interface IamGroupPermissionsPermission {
    name: string;
    scope: string;
    type: string;
}

export interface ImsBridgesQueueManager {
    /**
     * Queue manager definition for IMS bridge
     */
    queueManagers?: outputs.ImsBridgesQueueManagerQueueManager[];
}

export interface ImsBridgesQueueManagerQueueManager {
    /**
     * The name of the IMS bridge
     */
    name: string;
    queueManagerQueues?: string[];
}

export interface K8sClusterAnomaliesCpuRequestsSaturation {
    /**
     * Alert if
     */
    configuration?: outputs.K8sClusterAnomaliesCpuRequestsSaturationConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sClusterAnomaliesCpuRequestsSaturationConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
    threshold: number;
}

export interface K8sClusterAnomaliesMemoryRequestsSaturation {
    /**
     * Alert if
     */
    configuration?: outputs.K8sClusterAnomaliesMemoryRequestsSaturationConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sClusterAnomaliesMemoryRequestsSaturationConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
    threshold: number;
}

export interface K8sClusterAnomaliesMonitoringIssues {
    /**
     * Alert if
     */
    configuration?: outputs.K8sClusterAnomaliesMonitoringIssuesConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sClusterAnomaliesMonitoringIssuesConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
}

export interface K8sClusterAnomaliesPodsSaturation {
    /**
     * Alert if
     */
    configuration?: outputs.K8sClusterAnomaliesPodsSaturationConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sClusterAnomaliesPodsSaturationConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
    threshold: number;
}

export interface K8sClusterAnomaliesReadinessIssues {
    /**
     * Alert if
     */
    configuration?: outputs.K8sClusterAnomaliesReadinessIssuesConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sClusterAnomaliesReadinessIssuesConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
}

export interface K8sCredentialsEventsFieldSelector {
    /**
     * Whether subscription to this events field selector is enabled (value set to `true`). If disabled (value set to `false`), Dynatrace will stop fetching events from the Kubernetes API for this events field selector
     */
    active: boolean;
    /**
     * The field selector string (url decoding is applied) when storing it.
     */
    fieldSelector: string;
    /**
     * A label of the events field selector.
     */
    label: string;
    /**
     * Any attributes that aren't yet supported by this provider
     */
    unknowns?: string;
}

export interface K8sNamespaceAnomaliesCpuLimitsQuotaSaturation {
    /**
     * Alert if
     */
    configuration?: outputs.K8sNamespaceAnomaliesCpuLimitsQuotaSaturationConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sNamespaceAnomaliesCpuLimitsQuotaSaturationConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
    threshold: number;
}

export interface K8sNamespaceAnomaliesCpuRequestsQuotaSaturation {
    /**
     * Alert if
     */
    configuration?: outputs.K8sNamespaceAnomaliesCpuRequestsQuotaSaturationConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sNamespaceAnomaliesCpuRequestsQuotaSaturationConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
    threshold: number;
}

export interface K8sNamespaceAnomaliesMemoryLimitsQuotaSaturation {
    /**
     * Alert if
     */
    configuration?: outputs.K8sNamespaceAnomaliesMemoryLimitsQuotaSaturationConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sNamespaceAnomaliesMemoryLimitsQuotaSaturationConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
    threshold: number;
}

export interface K8sNamespaceAnomaliesMemoryRequestsQuotaSaturation {
    /**
     * Alert if
     */
    configuration?: outputs.K8sNamespaceAnomaliesMemoryRequestsQuotaSaturationConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sNamespaceAnomaliesMemoryRequestsQuotaSaturationConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
    threshold: number;
}

export interface K8sNamespaceAnomaliesPodsQuotaSaturation {
    /**
     * Alert if
     */
    configuration?: outputs.K8sNamespaceAnomaliesPodsQuotaSaturationConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sNamespaceAnomaliesPodsQuotaSaturationConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
    threshold: number;
}

export interface K8sNodeAnomaliesCpuRequestsSaturation {
    /**
     * Alert if
     */
    configuration?: outputs.K8sNodeAnomaliesCpuRequestsSaturationConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sNodeAnomaliesCpuRequestsSaturationConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
    threshold: number;
}

export interface K8sNodeAnomaliesMemoryRequestsSaturation {
    /**
     * Alert if
     */
    configuration?: outputs.K8sNodeAnomaliesMemoryRequestsSaturationConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sNodeAnomaliesMemoryRequestsSaturationConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
    threshold: number;
}

export interface K8sNodeAnomaliesNodeProblematicCondition {
    /**
     * Alert if
     */
    configuration?: outputs.K8sNodeAnomaliesNodeProblematicConditionConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sNodeAnomaliesNodeProblematicConditionConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
}

export interface K8sNodeAnomaliesPodsSaturation {
    /**
     * Alert if
     */
    configuration?: outputs.K8sNodeAnomaliesPodsSaturationConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sNodeAnomaliesPodsSaturationConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
    threshold: number;
}

export interface K8sNodeAnomaliesReadinessIssues {
    /**
     * Alert if
     */
    configuration?: outputs.K8sNodeAnomaliesReadinessIssuesConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sNodeAnomaliesReadinessIssuesConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
}

export interface K8sPvcAnomaliesLowDiskSpaceCritical {
    /**
     * Alert if
     */
    configuration?: outputs.K8sPvcAnomaliesLowDiskSpaceCriticalConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sPvcAnomaliesLowDiskSpaceCriticalConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
    threshold: number;
}

export interface K8sPvcAnomaliesLowDiskSpaceCriticalPercentage {
    /**
     * Alert if
     */
    configuration?: outputs.K8sPvcAnomaliesLowDiskSpaceCriticalPercentageConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sPvcAnomaliesLowDiskSpaceCriticalPercentageConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
    threshold: number;
}

export interface K8sWorkloadAnomaliesContainerRestarts {
    /**
     * Alert if
     */
    configuration?: outputs.K8sWorkloadAnomaliesContainerRestartsConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sWorkloadAnomaliesContainerRestartsConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
    threshold: number;
}

export interface K8sWorkloadAnomaliesDeploymentStuck {
    /**
     * Alert if
     */
    configuration?: outputs.K8sWorkloadAnomaliesDeploymentStuckConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sWorkloadAnomaliesDeploymentStuckConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
}

export interface K8sWorkloadAnomaliesHighCpuThrottling {
    /**
     * Alert if
     */
    configuration?: outputs.K8sWorkloadAnomaliesHighCpuThrottlingConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sWorkloadAnomaliesHighCpuThrottlingConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
    threshold: number;
}

export interface K8sWorkloadAnomaliesHighCpuUsage {
    /**
     * Alert if
     */
    configuration?: outputs.K8sWorkloadAnomaliesHighCpuUsageConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sWorkloadAnomaliesHighCpuUsageConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
    threshold: number;
}

export interface K8sWorkloadAnomaliesHighMemoryUsage {
    /**
     * Alert if
     */
    configuration?: outputs.K8sWorkloadAnomaliesHighMemoryUsageConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sWorkloadAnomaliesHighMemoryUsageConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
    threshold: number;
}

export interface K8sWorkloadAnomaliesNotAllPodsReady {
    /**
     * Alert if
     */
    configuration?: outputs.K8sWorkloadAnomaliesNotAllPodsReadyConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sWorkloadAnomaliesNotAllPodsReadyConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
}

export interface K8sWorkloadAnomaliesPendingPods {
    /**
     * Alert if
     */
    configuration?: outputs.K8sWorkloadAnomaliesPendingPodsConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sWorkloadAnomaliesPendingPodsConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
    threshold: number;
}

export interface K8sWorkloadAnomaliesPodStuckInTerminating {
    /**
     * Alert if
     */
    configuration?: outputs.K8sWorkloadAnomaliesPodStuckInTerminatingConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sWorkloadAnomaliesPodStuckInTerminatingConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
}

export interface K8sWorkloadAnomaliesWorkloadWithoutReadyPods {
    /**
     * Alert if
     */
    configuration?: outputs.K8sWorkloadAnomaliesWorkloadWithoutReadyPodsConfiguration;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface K8sWorkloadAnomaliesWorkloadWithoutReadyPodsConfiguration {
    observationPeriodInMinutes: number;
    samplePeriodInMinutes: number;
}

export interface KubernetesEventPatterns {
    eventPatterns: outputs.KubernetesEventPatternsEventPattern[];
}

export interface KubernetesEventPatternsEventPattern {
    active: boolean;
    label: string;
    pattern: string;
}

export interface LogCustomSourceContext {
    /**
     * Define Custom Log Source only within context if provided
     */
    contexts: outputs.LogCustomSourceContextContext[];
}

export interface LogCustomSourceContextContext {
    attribute: string;
    values: string[];
}

export interface LogCustomSourceCustomLogSource {
    /**
     * Possible Values: `LOG_PATH_PATTERN`, `WINDOWS_EVENT_LOG`
     */
    type: string;
    /**
     * It might be either an absolute path to log(s) with optional wildcards or Windows Event Log name.
     */
    values: string[];
}

export interface LogEventsEventTemplate {
    /**
     * DavisÂ® AI will try to merge this event into existing problems, otherwise a new problem will always be created.
     */
    davisMerge?: boolean;
    /**
     * The description of the event to trigger.
     */
    description: string;
    /**
     * Possible Values: `AVAILABILITY`, `CUSTOM_ALERT`, `CUSTOM_ANNOTATION`, `CUSTOM_CONFIGURATION`, `CUSTOM_DEPLOYMENT`, `ERROR`, `INFO`, `MARKED_FOR_TERMINATION`, `RESOURCE`, `SLOWDOWN`
     */
    eventType: string;
    /**
     * Set of additional key-value properties to be attached to the triggered event.
     */
    metadata?: outputs.LogEventsEventTemplateMetadata;
    /**
     * The title of the event to trigger.
     */
    title: string;
}

export interface LogEventsEventTemplateMetadata {
    items: outputs.LogEventsEventTemplateMetadataItem[];
}

export interface LogEventsEventTemplateMetadataItem {
    metadataKey: string;
    metadataValue: string;
}

export interface LogProcessingProcessorDefinition {
    rule: string;
}

export interface LogProcessingRuleTesting {
    sampleLog: string;
}

export interface LogSensitiveDataMaskingMasking {
    /**
     * Maximum one capture group is allowed. If none was given, the whole expression will be treated as a capture group.
     */
    expression: string;
    /**
     * The string to replace the masked expression with. Irrelevant if `type` is `SHA1`.
     */
    replacement?: string;
    /**
     * Possible Values: `SHA1`, `STRING`
     */
    type: string;
}

export interface LogSensitiveDataMaskingMatchers {
    matchers: outputs.LogSensitiveDataMaskingMatchersMatcher[];
}

export interface LogSensitiveDataMaskingMatchersMatcher {
    attribute: string;
    operator: string;
    values: string[];
}

export interface LogStorageMatchers {
    matchers: outputs.LogStorageMatchersMatcher[];
}

export interface LogStorageMatchersMatcher {
    attribute: string;
    operator: string;
    values: string[];
}

export interface LogTimestampMatchers {
    matchers: outputs.LogTimestampMatchersMatcher[];
}

export interface LogTimestampMatchersMatcher {
    attribute: string;
    operator: string;
    values: string[];
}

export interface MaintenanceFilter {
    /**
     * A list of matching rules for dynamic filter formation.  If several rules are set, the OR logic applies
     */
    filters?: outputs.MaintenanceFilterFilter[];
}

export interface MaintenanceFilterFilter {
    entityId?: string;
    entityTags?: string[];
    entityType?: string;
    managementZones?: string[];
}

export interface MaintenanceGeneralProperties {
    /**
     * A short description of the maintenance purpose
     */
    description?: string;
    /**
     * Suppress execution of synthetic monitors during the maintenance
     */
    disableSynthetic?: boolean;
    /**
     * The name of the maintenance window, displayed in the UI
     */
    name: string;
    /**
     * The type of suppression of alerting and problem detection during the maintenance
     */
    suppression: string;
    /**
     * The type of the maintenance: planned or unplanned
     */
    type: string;
}

export interface MaintenanceSchedule {
    /**
     * The configuration for maintenance windows occuring daily
     */
    dailyRecurrence?: outputs.MaintenanceScheduleDailyRecurrence;
    /**
     * The configuration for maintenance windows occuring monthly
     */
    monthlyRecurrence?: outputs.MaintenanceScheduleMonthlyRecurrence;
    /**
     * The configuration for maintenance windows occuring once
     */
    onceRecurrence?: outputs.MaintenanceScheduleOnceRecurrence;
    /**
     * The time window of the maintenance window
     */
    type: string;
    /**
     * The configuration for maintenance windows occuring weekly
     */
    weeklyRecurrence?: outputs.MaintenanceScheduleWeeklyRecurrence;
}

export interface MaintenanceScheduleDailyRecurrence {
    recurrenceRange: outputs.MaintenanceScheduleDailyRecurrenceRecurrenceRange;
    timeWindow: outputs.MaintenanceScheduleDailyRecurrenceTimeWindow;
}

export interface MaintenanceScheduleDailyRecurrenceRecurrenceRange {
    endDate: string;
    startDate: string;
}

export interface MaintenanceScheduleDailyRecurrenceTimeWindow {
    endTime: string;
    startTime: string;
    timeZone: string;
}

export interface MaintenanceScheduleMonthlyRecurrence {
    dayOfMonth: number;
    recurrenceRange: outputs.MaintenanceScheduleMonthlyRecurrenceRecurrenceRange;
    timeWindow: outputs.MaintenanceScheduleMonthlyRecurrenceTimeWindow;
}

export interface MaintenanceScheduleMonthlyRecurrenceRecurrenceRange {
    endDate: string;
    startDate: string;
}

export interface MaintenanceScheduleMonthlyRecurrenceTimeWindow {
    endTime: string;
    startTime: string;
    timeZone: string;
}

export interface MaintenanceScheduleOnceRecurrence {
    endTime: string;
    startTime: string;
    timeZone: string;
}

export interface MaintenanceScheduleWeeklyRecurrence {
    dayOfWeek: string;
    recurrenceRange: outputs.MaintenanceScheduleWeeklyRecurrenceRecurrenceRange;
    timeWindow: outputs.MaintenanceScheduleWeeklyRecurrenceTimeWindow;
}

export interface MaintenanceScheduleWeeklyRecurrenceRecurrenceRange {
    endDate: string;
    startDate: string;
}

export interface MaintenanceScheduleWeeklyRecurrenceTimeWindow {
    endTime: string;
    startTime: string;
    timeZone: string;
}

export interface MaintenanceWindowSchedule {
    /**
     * The end date and time of the maintenance window validity period in yyyy-mm-dd HH:mm format
     */
    end: string;
    /**
     * The recurrence of the maintenance window
     */
    recurrence?: outputs.MaintenanceWindowScheduleRecurrence;
    /**
     * The type of the schedule recurrence. Possible values are `DAILY`, `MONTHLY`, `ONCE` and `WEEKLY`
     */
    recurrenceType: string;
    /**
     * The start date and time of the maintenance window validity period in yyyy-mm-dd HH:mm format
     */
    start: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
     */
    zoneId: string;
}

export interface MaintenanceWindowScheduleRecurrence {
    dayOfMonth?: number;
    dayOfWeek?: string;
    durationMinutes: number;
    startTime: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface MaintenanceWindowScope {
    /**
     * A list of Dynatrace entities (for example, hosts or services) to be included in the scope.  Allowed values are Dynatrace entity IDs
     */
    entities?: string[];
    /**
     * A list of matching rules for dynamic scope formation.  If several rules are set, the OR logic applies
     */
    matches?: outputs.MaintenanceWindowScopeMatch[];
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface MaintenanceWindowScopeMatch {
    mzId?: string;
    tagCombination?: string;
    tags?: outputs.MaintenanceWindowScopeMatchTag[];
    /**
     * The type of the maintenance: planned or unplanned
     */
    type?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface MaintenanceWindowScopeMatchTag {
    context: string;
    key: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneDimensionalRule {
    appliesTo: string;
    conditions?: outputs.ManagementZoneDimensionalRuleCondition[];
    enabled?: boolean;
    unknowns?: string;
}

export interface ManagementZoneDimensionalRuleCondition {
    key: string;
    match: string;
    type: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneEntitySelectorBasedRule {
    enabled?: boolean;
    selector?: string;
    unknowns?: string;
}

export interface ManagementZoneRule {
    conditions?: outputs.ManagementZoneRuleCondition[];
    enabled?: boolean;
    propagationTypes?: string[];
    type: string;
    unknowns?: string;
}

export interface ManagementZoneRuleCondition {
    /**
     * @deprecated You should use 'application_type' instead of 'application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    applicationTypeComparisons?: outputs.ManagementZoneRuleConditionApplicationTypeComparison[];
    applicationTypes?: outputs.ManagementZoneRuleConditionApplicationType[];
    azureComputeModeComparisons?: outputs.ManagementZoneRuleConditionAzureComputeModeComparison[];
    /**
     * @deprecated You should use 'azure_compute_mode' instead of 'azure_compute_mode_comparison'. This attribute still exists for backwards compatibility.
     */
    azureComputeModes?: outputs.ManagementZoneRuleConditionAzureComputeMode[];
    /**
     * @deprecated You should use 'azure_sku' instead of 'azure_sku_comparision'. This attribute still exists for backwards compatibility.
     */
    azureSkuComparisions?: outputs.ManagementZoneRuleConditionAzureSkuComparision[];
    azureSkus?: outputs.ManagementZoneRuleConditionAzureSkus[];
    /**
     * @deprecated You should use 'comparison' instead of 'base_comparison_basic'. This attribute still exists for backwards compatibility.
     */
    baseComparisonBasics?: outputs.ManagementZoneRuleConditionBaseComparisonBasic[];
    /**
     * @deprecated 'base_condition_key' is deprecated. You should use 'key'
     */
    baseConditionKeys?: outputs.ManagementZoneRuleConditionBaseConditionKey[];
    /**
     * @deprecated You should use 'bitness' instead of 'bitness_comparision'. This attribute still exists for backwards compatibility.
     */
    bitnessComparisions?: outputs.ManagementZoneRuleConditionBitnessComparision[];
    bitnesses?: outputs.ManagementZoneRuleConditionBitness[];
    /**
     * @deprecated You should use 'cloud_type' instead of 'cloud_type_comparison'. This attribute still exists for backwards compatibility.
     */
    cloudTypeComparisons?: outputs.ManagementZoneRuleConditionCloudTypeComparison[];
    cloudTypes?: outputs.ManagementZoneRuleConditionCloudType[];
    comparisons?: outputs.ManagementZoneRuleConditionComparison[];
    /**
     * @deprecated You should use 'custom_application_type' instead of 'custom_application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    customApplicationTypeComparisons?: outputs.ManagementZoneRuleConditionCustomApplicationTypeComparison[];
    customApplicationTypes?: outputs.ManagementZoneRuleConditionCustomApplicationType[];
    /**
     * @deprecated 'custom_host_metadata_condition_key' is deprecated. You should use 'custom_host_metadata'
     */
    customHostMetadataConditionKeys?: outputs.ManagementZoneRuleConditionCustomHostMetadataConditionKey[];
    customHostMetadatas?: outputs.ManagementZoneRuleConditionCustomHostMetadata[];
    /**
     * @deprecated 'custom_process_metadata_condition_key' is deprecated. You should use 'custom_process_metadata'
     */
    customProcessMetadataConditionKeys?: outputs.ManagementZoneRuleConditionCustomProcessMetadataConditionKey[];
    customProcessMetadatas?: outputs.ManagementZoneRuleConditionCustomProcessMetadata[];
    databaseTopologies?: outputs.ManagementZoneRuleConditionDatabaseTopology[];
    /**
     * @deprecated You should use 'database_topology' instead of 'database_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    databaseTopologyComparisons?: outputs.ManagementZoneRuleConditionDatabaseTopologyComparison[];
    /**
     * @deprecated You should use 'dcrum_decoder' instead of 'dcrum_decoder_comparison'. This attribute still exists for backwards compatibility.
     */
    dcrumDecoderComparisons?: outputs.ManagementZoneRuleConditionDcrumDecoderComparison[];
    dcrumDecoders?: outputs.ManagementZoneRuleConditionDcrumDecoder[];
    entities?: outputs.ManagementZoneRuleConditionEntity[];
    /**
     * @deprecated You should use 'entity' instead of 'entity_id_comparison'. This attribute still exists for backwards compatibility.
     */
    entityIdComparisons?: outputs.ManagementZoneRuleConditionEntityIdComparison[];
    hostTeches?: outputs.ManagementZoneRuleConditionHostTech[];
    /**
     * @deprecated `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
     */
    hypervisorTypeComparisions?: outputs.ManagementZoneRuleConditionHypervisorTypeComparision[];
    hypervisors?: outputs.ManagementZoneRuleConditionHypervisor[];
    /**
     * @deprecated You should use 'indexed_name' instead of 'indexed_name_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedNameComparisons?: outputs.ManagementZoneRuleConditionIndexedNameComparison[];
    indexedNames?: outputs.ManagementZoneRuleConditionIndexedName[];
    /**
     * @deprecated You should use 'indexed_string' instead of 'indexed_string_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedStringComparisons?: outputs.ManagementZoneRuleConditionIndexedStringComparison[];
    indexedStrings?: outputs.ManagementZoneRuleConditionIndexedString[];
    /**
     * @deprecated You should use 'indexed_tag' instead of 'indexed_tag_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedTagComparisons?: outputs.ManagementZoneRuleConditionIndexedTagComparison[];
    indexedTags?: outputs.ManagementZoneRuleConditionIndexedTag[];
    /**
     * @deprecated You should use 'integer' instead of 'integer_comparison'. This attribute still exists for backwards compatibility.
     */
    integerComparisons?: outputs.ManagementZoneRuleConditionIntegerComparison[];
    integers?: outputs.ManagementZoneRuleConditionInteger[];
    /**
     * @deprecated You should use 'ipaddress' instead of 'ipaddress_comparison'. This attribute still exists for backwards compatibility.
     */
    ipaddressComparisons?: outputs.ManagementZoneRuleConditionIpaddressComparison[];
    ipaddresses?: outputs.ManagementZoneRuleConditionIpaddress[];
    keys?: outputs.ManagementZoneRuleConditionKey[];
    /**
     * @deprecated You should use 'mobile_platform' instead of 'mobile_platform_comparison'. This attribute still exists for backwards compatibility.
     */
    mobilePlatformComparisons?: outputs.ManagementZoneRuleConditionMobilePlatformComparison[];
    mobilePlatforms?: outputs.ManagementZoneRuleConditionMobilePlatform[];
    osArches?: outputs.ManagementZoneRuleConditionOsArch[];
    osTypes?: outputs.ManagementZoneRuleConditionOsType[];
    /**
     * @deprecated You should use 'os_arch' instead of 'osarchitecture_comparison'. This attribute still exists for backwards compatibility.
     */
    osarchitectureComparisons?: outputs.ManagementZoneRuleConditionOsarchitectureComparison[];
    /**
     * @deprecated You should use 'os_type' instead of 'ostype_comparison'. This attribute still exists for backwards compatibility.
     */
    ostypeComparisons?: outputs.ManagementZoneRuleConditionOstypeComparison[];
    /**
     * @deprecated You should use 'paas_type' instead of 'paas_type_comparison'. This attribute still exists for backwards compatibility.
     */
    paasTypeComparisons?: outputs.ManagementZoneRuleConditionPaasTypeComparison[];
    paasTypes?: outputs.ManagementZoneRuleConditionPaasType[];
    /**
     * @deprecated 'process_metadata_condition_key' is deprecated. You should use 'process_metadata'
     */
    processMetadataConditionKeys?: outputs.ManagementZoneRuleConditionProcessMetadataConditionKey[];
    processMetadatas?: outputs.ManagementZoneRuleConditionProcessMetadata[];
    serviceTopologies?: outputs.ManagementZoneRuleConditionServiceTopology[];
    /**
     * @deprecated You should use 'service_topology' instead of 'service_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTopologyComparisons?: outputs.ManagementZoneRuleConditionServiceTopologyComparison[];
    /**
     * @deprecated You should use 'service_type' instead of 'service_type_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTypeComparisons?: outputs.ManagementZoneRuleConditionServiceTypeComparison[];
    serviceTypes?: outputs.ManagementZoneRuleConditionServiceType[];
    /**
     * @deprecated You should use 'host_tech' instead of 'simple_host_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleHostTechComparisons?: outputs.ManagementZoneRuleConditionSimpleHostTechComparison[];
    /**
     * @deprecated You should use 'tech' instead of 'simple_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleTechComparisons?: outputs.ManagementZoneRuleConditionSimpleTechComparison[];
    /**
     * @deprecated You should use 'string' instead of 'string_comparison'. This attribute still exists for backwards compatibility.
     */
    stringComparisons?: outputs.ManagementZoneRuleConditionStringComparison[];
    /**
     * @deprecated 'string_condition_key' is deprecated. You should use 'string_key'
     */
    stringConditionKeys?: outputs.ManagementZoneRuleConditionStringConditionKey[];
    stringKeys?: outputs.ManagementZoneRuleConditionStringKey[];
    strings?: outputs.ManagementZoneRuleConditionString[];
    /**
     * @deprecated You should use 'synthetic_engine' instead of 'synthetic_engine_type_comparison'. This attribute still exists for backwards compatibility.
     */
    syntheticEngineTypeComparisons?: outputs.ManagementZoneRuleConditionSyntheticEngineTypeComparison[];
    syntheticEngines?: outputs.ManagementZoneRuleConditionSyntheticEngine[];
    /**
     * @deprecated You should use 'tag' instead of 'tag_comparison'. This attribute still exists for backwards compatibility.
     */
    tagComparisons?: outputs.ManagementZoneRuleConditionTagComparison[];
    tags?: outputs.ManagementZoneRuleConditionTag[];
    teches?: outputs.ManagementZoneRuleConditionTech[];
    unknowns?: string;
}

export interface ManagementZoneRuleConditionApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionAzureComputeMode {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionAzureComputeModeComparison {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionAzureSkuComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionAzureSkus {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionBaseComparisonBasic {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionBaseConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionBitness {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionBitnessComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionCloudType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionCloudTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionComparison {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionCustomApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionCustomApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionCustomHostMetadata {
    attribute: string;
    dynamicKey: outputs.ManagementZoneRuleConditionCustomHostMetadataDynamicKey;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionCustomHostMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.ManagementZoneRuleConditionCustomHostMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionCustomHostMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionCustomHostMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionCustomProcessMetadata {
    attribute: string;
    dynamicKey: outputs.ManagementZoneRuleConditionCustomProcessMetadataDynamicKey;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionCustomProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.ManagementZoneRuleConditionCustomProcessMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionCustomProcessMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionCustomProcessMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionDatabaseTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionDatabaseTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionDcrumDecoder {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionDcrumDecoderComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionEntity {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionEntityIdComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionHostTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ManagementZoneRuleConditionHostTechValue;
}

export interface ManagementZoneRuleConditionHostTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ManagementZoneRuleConditionHypervisor {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionHypervisorTypeComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionIndexedName {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionIndexedNameComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionIndexedString {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionIndexedStringComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionIndexedTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ManagementZoneRuleConditionIndexedTagValue;
}

export interface ManagementZoneRuleConditionIndexedTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ManagementZoneRuleConditionIndexedTagComparisonValue;
}

export interface ManagementZoneRuleConditionIndexedTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionIndexedTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionInteger {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: number;
}

export interface ManagementZoneRuleConditionIntegerComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: number;
}

export interface ManagementZoneRuleConditionIpaddress {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionIpaddressComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionMobilePlatform {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionMobilePlatformComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionOsArch {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionOsType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionOsarchitectureComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionOstypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionPaasType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionPaasTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionProcessMetadata {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionServiceTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionServiceTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionServiceType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionServiceTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionSimpleHostTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ManagementZoneRuleConditionSimpleHostTechComparisonValue;
}

export interface ManagementZoneRuleConditionSimpleHostTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ManagementZoneRuleConditionSimpleTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ManagementZoneRuleConditionSimpleTechComparisonValue;
}

export interface ManagementZoneRuleConditionSimpleTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ManagementZoneRuleConditionString {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionStringComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionStringConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionStringKey {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionSyntheticEngine {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionSyntheticEngineTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ManagementZoneRuleConditionTagValue;
}

export interface ManagementZoneRuleConditionTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ManagementZoneRuleConditionTagComparisonValue;
}

export interface ManagementZoneRuleConditionTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ManagementZoneRuleConditionTechValue;
}

export interface ManagementZoneRuleConditionTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ManagementZoneV2Rules {
    /**
     * A management zone rule
     */
    rules?: outputs.ManagementZoneV2RulesRule[];
}

export interface ManagementZoneV2RulesRule {
    attributeRule?: outputs.ManagementZoneV2RulesRuleAttributeRule;
    dimensionRule?: outputs.ManagementZoneV2RulesRuleDimensionRule;
    enabled: boolean;
    entitySelector?: string;
    type: string;
}

export interface ManagementZoneV2RulesRuleAttributeRule {
    attributeConditions: outputs.ManagementZoneV2RulesRuleAttributeRuleAttributeConditions;
    azureToPgpropagation?: boolean;
    azureToServicePropagation?: boolean;
    customDeviceGroupToCustomDevicePropagation?: boolean;
    entityType: string;
    hostToPgpropagation?: boolean;
    pgToHostPropagation?: boolean;
    pgToServicePropagation?: boolean;
    serviceToHostPropagation?: boolean;
    serviceToPgpropagation?: boolean;
}

export interface ManagementZoneV2RulesRuleAttributeRuleAttributeConditions {
    conditions?: outputs.ManagementZoneV2RulesRuleAttributeRuleAttributeConditionsCondition[];
}

export interface ManagementZoneV2RulesRuleAttributeRuleAttributeConditionsCondition {
    caseSensitive?: boolean;
    dynamicKey?: string;
    dynamicKeySource?: string;
    entityId?: string;
    enumValue?: string;
    integerValue?: number;
    key: string;
    operator: string;
    stringValue?: string;
    tag?: string;
}

export interface ManagementZoneV2RulesRuleDimensionRule {
    appliesTo: string;
    dimensionConditions?: outputs.ManagementZoneV2RulesRuleDimensionRuleDimensionConditions;
}

export interface ManagementZoneV2RulesRuleDimensionRuleDimensionConditions {
    conditions?: outputs.ManagementZoneV2RulesRuleDimensionRuleDimensionConditionsCondition[];
}

export interface ManagementZoneV2RulesRuleDimensionRuleDimensionConditionsCondition {
    conditionType: string;
    key?: string;
    ruleMatcher: string;
    value: string;
}

export interface MetricEventsEventTemplate {
    /**
     * DavisÂ® AI will try to merge this event into existing problems, otherwise a new problem will always be created.
     */
    davisMerge?: boolean;
    /**
     * The description of the event to trigger.
     */
    description: string;
    /**
     * The event type to trigger.
     */
    eventType: string;
    /**
     * Set of additional key-value properties to be attached to the triggered event.
     */
    metadatas?: outputs.MetricEventsEventTemplateMetadata[];
    /**
     * The title of the event to trigger.
     */
    title: string;
}

export interface MetricEventsEventTemplateMetadata {
    metadataKey: string;
    metadataValue: string;
}

export interface MetricEventsModelProperties {
    /**
     * The alert condition of the model properties
     */
    alertCondition: string;
    /**
     * The ability to set an alert on missing data in a metric. When enabled, missing data samples will contribute as violating samples defined in advanced model properties. We recommend to not alert on missing data for sparse timeseries as this leads to alert spam.
     */
    alertOnNoData: boolean;
    /**
     * The number of one-minute samples within the evaluation window that must go back to normal to close the event.
     */
    dealertingSamples: number;
    /**
     * The number of one-minute samples that form the sliding evaluation window.
     */
    samples: number;
    /**
     * Controls how many times the signal fluctuation is added to the baseline to produce the actual threshold for alerting
     */
    signalFluctuation?: number;
    /**
     * Raise an event if this value is violated
     */
    threshold?: number;
    /**
     * Controls the width of the confidence band and larger values lead to a less sensitive model
     */
    tolerance?: number;
    /**
     * Metric-key-based query definitions only support static thresholds.
     */
    type: string;
    /**
     * The number of one-minute samples within the evaluation window that must violate to trigger an event.
     */
    violatingSamples: number;
}

export interface MetricEventsQueryDefinition {
    /**
     * The aggregation of the query definition
     */
    aggregation?: string;
    /**
     * The dimension filters of the query definition
     */
    dimensionFilter?: outputs.MetricEventsQueryDefinitionDimensionFilter;
    /**
     * Use rule-based filters to define the scope this event monitors.
     */
    entityFilter?: outputs.MetricEventsQueryDefinitionEntityFilter;
    /**
     * The metric key of the query definition
     */
    metricKey: string;
    /**
     * To learn more, visit [Metric Selector](https://dt-url.net/metselad)
     */
    metricSelector?: string;
    /**
     * Minute offset of sliding evaluation window for metrics with latency
     */
    queryOffset?: number;
    /**
     * The type of query definition
     */
    type: string;
}

export interface MetricEventsQueryDefinitionDimensionFilter {
    filters?: outputs.MetricEventsQueryDefinitionDimensionFilterFilter[];
}

export interface MetricEventsQueryDefinitionDimensionFilterFilter {
    dimensionKey: string;
    dimensionValue: string;
}

export interface MetricEventsQueryDefinitionEntityFilter {
    conditions?: outputs.MetricEventsQueryDefinitionEntityFilterCondition[];
    dimensionKey?: string;
}

export interface MetricEventsQueryDefinitionEntityFilterCondition {
    conditions?: outputs.MetricEventsQueryDefinitionEntityFilterConditionCondition[];
}

export interface MetricEventsQueryDefinitionEntityFilterConditionCondition {
    operator: string;
    type: string;
    value: string;
}

export interface MetricMetadataDimensions {
    dimensions: outputs.MetricMetadataDimensionsDimension[];
}

export interface MetricMetadataDimensionsDimension {
    /**
     * Display name
     */
    displayName?: string;
    key: string;
}

export interface MetricMetadataMetricProperties {
    /**
     * Whether (true or false) the metric is relevant to a problem's impact.
     */
    impactRelevant?: boolean;
    latency?: number;
    maxValue?: number;
    minValue?: number;
    rootCauseRelevant?: boolean;
    /**
     * Possible Values: `Error`, `Score`, `Unknown`
     */
    valueType: string;
}

export interface MobileAppAnomaliesErrorRateIncrease {
    /**
     * Possible Values: `Auto`, `Fixed`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * Alert if the percentage of user actions affected by reported errors exceeds **both** the absolute threshold and the relative threshold
     */
    errorRateIncreaseAuto?: outputs.MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto;
    /**
     * Alert if the custom reported error rate threshold is exceeded during any 5-minute period
     */
    errorRateIncreaseFixed?: outputs.MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed;
}

export interface MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseAuto {
    thresholdAbsolute: number;
    thresholdRelative: number;
}

export interface MobileAppAnomaliesErrorRateIncreaseErrorRateIncreaseFixed {
    sensitivity: string;
    thresholdAbsolute: number;
}

export interface MobileAppAnomaliesSlowUserActions {
    /**
     * Possible Values: `Auto`, `Fixed`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * no documentation available
     */
    slowUserActionsAuto?: outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAuto;
    /**
     * no documentation available
     */
    slowUserActionsFixed?: outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixed;
}

export interface MobileAppAnomaliesSlowUserActionsSlowUserActionsAuto {
    durationAvoidOveralerting: outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting;
    durationThresholdAll: outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll;
    durationThresholdSlowest: outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest;
}

export interface MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationAvoidOveralerting {
    minActionRate: number;
}

export interface MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdAll {
    durationThreshold: number;
    slowdownPercentage: number;
}

export interface MobileAppAnomaliesSlowUserActionsSlowUserActionsAutoDurationThresholdSlowest {
    durationThreshold: number;
    slowdownPercentage: number;
}

export interface MobileAppAnomaliesSlowUserActionsSlowUserActionsFixed {
    durationAvoidOveralerting: outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting;
    durationThresholdAllFixed: outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed;
    durationThresholdSlowest: outputs.MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest;
    sensitivity: string;
}

export interface MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationAvoidOveralerting {
    minActionRate: number;
}

export interface MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdAllFixed {
    durationThreshold: number;
}

export interface MobileAppAnomaliesSlowUserActionsSlowUserActionsFixedDurationThresholdSlowest {
    durationThreshold: number;
}

export interface MobileAppAnomaliesUnexpectedHighLoad {
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic spikes within your application.
     */
    thresholdPercentage?: number;
}

export interface MobileAppAnomaliesUnexpectedLowLoad {
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * Dynatrace learns your typical application traffic over an observation period of one week. Depending on this expected value Dynatrace detects abnormal traffic drops within your application.
     */
    thresholdPercentage?: number;
}

export interface MobileAppCrashRateCrashRateIncrease {
    /**
     * Alert crash rate increases when auto-detected baseline is exceeded by a certain number of users
     */
    crashRateIncreaseAuto?: outputs.MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto;
    /**
     * Alert crash rate increases when the defined threshold is exceeded by a certain number of users
     */
    crashRateIncreaseFixed?: outputs.MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed;
    /**
     * Possible Values: `Auto`, `Fixed`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseAuto {
    baselineViolationPercentage: number;
    concurrentUsers: number;
    sensitivity: string;
}

export interface MobileAppCrashRateCrashRateIncreaseCrashRateIncreaseFixed {
    absoluteCrashRate: number;
    concurrentUsers: number;
}

export interface MobileAppEnablementRum {
    /**
     * Percentage of user sessions captured and analyzed. By default, Dynatrace captures all user actions and user sessions for analysis. This approach ensures complete insight into your applicationâ€™s performance and customer experience. You can optionally reduce the granularity of user-action and user-session analysis by capturing a lower percentage of user sessions. While this approach can reduce monitoring costs, it also results in lower visibility into how your customers are using your applications. For example, a setting of 10% results in Dynatrace analyzing only every tenth user session.
     */
    costAndTrafficControl: number;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface MobileAppEnablementSessionReplay {
    /**
     * Before enabling, Dynatrace checks your system against the [prerequisites for Session Replay](https://dt-url.net/t23s0ppi).
     */
    onCrash: boolean;
}

export interface MobileAppRequestErrorsErrorRules {
    errorRules: outputs.MobileAppRequestErrorsErrorRulesErrorRule[];
}

export interface MobileAppRequestErrorsErrorRulesErrorRule {
    errorCodes: string;
}

export interface MobileApplicationApdex {
    /**
     * Apdex **frustrated** threshold, in milliseconds: a duration greater than or equal to this value is considered frustrated
     */
    frustrated: number;
    /**
     * Apdex error condition: if `true` the user session is considered frustrated when an error is reported
     */
    frustratedOnError?: boolean;
    /**
     * Apdex **tolerable** threshold, in milliseconds: a duration greater than or equal to this value is considered tolerable
     */
    tolerable: number;
}

export interface MobileApplicationProperties {
    /**
     * A User Action / Session Property based on a value reported by the API
     */
    apiValues?: outputs.MobileApplicationPropertiesApiValue[];
    /**
     * A User Action / Session Property based on a Server Side Request Attribute
     */
    requestAttributes?: outputs.MobileApplicationPropertiesRequestAttribute[];
}

export interface MobileApplicationPropertiesApiValue {
    aggregation?: string;
    cleanupRule?: string;
    displayName?: string;
    key: string;
    /**
     * The name of the application
     */
    name?: string;
    storeAsSessionProperty?: boolean;
    storeAsUserActionProperty?: boolean;
    type: string;
}

export interface MobileApplicationPropertiesRequestAttribute {
    aggregation?: string;
    cleanupRule?: string;
    displayName?: string;
    id: string;
    key: string;
    storeAsSessionProperty?: boolean;
    storeAsUserActionProperty?: boolean;
    type: string;
}

export interface NetworkTrafficExcludeIp {
    ipAddressForms: outputs.NetworkTrafficExcludeIpIpAddressForm[];
}

export interface NetworkTrafficExcludeIpIpAddressForm {
    ipAddress: string;
}

export interface NetworkTrafficExcludeNic {
    nicForms: outputs.NetworkTrafficExcludeNicNicForm[];
}

export interface NetworkTrafficExcludeNicNicForm {
    interface: string;
    os: string;
}

export interface NotificationAnsibleTower {
    /**
     * Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
     */
    acceptAnyCertificate: boolean;
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The custom message of the notification.   This message will be displayed in the extra variables **Message** field of your job template.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
     */
    customMessage: string;
    /**
     * The ID of the target Ansible Tower job template
     */
    jobTemplateId: number;
    /**
     * The URL of the target Ansible Tower job template
     */
    jobTemplateUrl: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * The password for the Ansible Tower account
     */
    password?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * The username of the Ansible Tower account
     */
    username: string;
}

export interface NotificationConfig {
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * Defines the actual set of fields depending on the value. See one of the following objects:  * `EMAIL` > EmailNotificationConfig  * `PAGER_DUTY` > PagerDutyNotificationConfig  * `WEBHOOK` > WebHookNotificationConfig  * `SLACK` > SlackNotificationConfig  * `HIPCHAT` > HipChatNotificationConfig  * `VICTOROPS` > VictorOpsNotificationConfig  * `SERVICE_NOW` > ServiceNowNotificationConfig  * `XMATTERS` > XMattersNotificationConfig  * `ANSIBLETOWER` > AnsibleTowerNotificationConfig  * `OPS_GENIE` > OpsGenieNotificationConfig  * `JIRA` > JiraNotificationConfig  * `TRELLO` > TrelloNotificationConfig
     */
    type: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface NotificationEmail {
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The list of the email BCC-recipients
     */
    bccReceivers?: string[];
    /**
     * The template of the email notification.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
     */
    body: string;
    /**
     * The list of the email CC-recipients
     */
    ccReceivers?: string[];
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * The list of the email recipients
     */
    receivers?: string[];
    /**
     * The subject of the email notifications
     */
    subject: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface NotificationJira {
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The description of the Jira issue to be created by this notification.   You can use same placeholders as in issue summary
     */
    description: string;
    /**
     * The type of the Jira issue to be created by this notification
     */
    issueType: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * The password for the Jira profile
     */
    password?: string;
    /**
     * The project key of the Jira issue to be created by this notification
     */
    projectKey: string;
    /**
     * The summary of the Jira issue to be created by this notification.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
     */
    summary: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * The URL of the Jira API endpoint
     */
    url: string;
    /**
     * The username of the Jira profile
     */
    username: string;
}

export interface NotificationOpsGenie {
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The API key to access OpsGenie
     */
    apiKey?: string;
    /**
     * The region domain of the OpsGenie
     */
    domain: string;
    /**
     * The content of the message.  You can use the following placeholders:  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem
     */
    message: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface NotificationPagerDuty {
    /**
     * The name of the PagerDuty account
     */
    account: string;
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * The API key to access PagerDuty
     */
    serviceApiKey?: string;
    /**
     * The name of the service
     */
    serviceName: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface NotificationServiceNow {
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The ServiceNow instance identifier. It refers to the first part of your own ServiceNow URL.   This field is mutually exclusive with the **url** field. You can only use one of them
     */
    instanceName?: string;
    /**
     * The content of the ServiceNow description.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
     */
    message: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * The username to the ServiceNow account
     */
    password?: string;
    /**
     * Send events into ServiceNow ITOM (`true`)
     */
    sendEvents: boolean;
    /**
     * Send incidents into ServiceNow ITSM (`true`)
     */
    sendIncidents: boolean;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * The URL of the on-premise ServiceNow installation.   This field is mutually exclusive with the **instanceName** field. You can only use one of them
     */
    url?: string;
    /**
     * The username of the ServiceNow account.   Make sure that your user account has the `restService`, `webRequestAdmin`, and `x_dynat_ruxit.Integration` roles
     */
    username: string;
}

export interface NotificationSlack {
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The channel (for example, `#general`) or the user (for example, `@john.smith`) to send the message to
     */
    channel: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * The content of the message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
     */
    title: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * The URL of the Slack WebHook.  This is confidential information, therefore GET requests return this field with the `null` value, and it is optional for PUT requests
     */
    url?: string;
}

export interface NotificationTrello {
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The application key for the Trello account
     */
    applicationKey: string;
    /**
     * The application token for the Trello account
     */
    authorizationToken?: string;
    /**
     * The Trello board to which the card should be assigned
     */
    boardId: string;
    /**
     * The description of the Trello card.   You can use same placeholders as in card text
     */
    description: string;
    /**
     * The Trello list to which the card should be assigned
     */
    listId: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * The Trello list to which the card of the resolved problem should be assigned
     */
    resolvedListId: string;
    /**
     * The text of the generated Trello card.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
     */
    text: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface NotificationVictorOps {
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The API key for the target VictorOps account
     */
    apiKey?: string;
    /**
     * The content of the message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`
     */
    message: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * The routing key, defining the group to be notified
     */
    routingKey: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface NotificationWebHook {
    /**
     * Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
     */
    acceptAnyCertificate: boolean;
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * A list of the additional HTTP headers
     */
    headers?: outputs.NotificationWebHookHeader[];
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * Call webhook if new events merge into existing problems
     */
    notifyEventMerges?: boolean;
    /**
     * The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
     */
    payload: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * The URL of the WebHook endpoint
     */
    url: string;
}

export interface NotificationWebHookHeader {
    name: string;
    value?: string;
}

export interface NotificationXmatters {
    /**
     * Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
     */
    acceptAnyCertificate: boolean;
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * A list of the additional HTTP headers
     */
    headers?: outputs.NotificationXmattersHeader[];
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
     */
    payload: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * The URL of the xMatters WebHook
     */
    url: string;
}

export interface NotificationXmattersHeader {
    name: string;
    value?: string;
}

export interface OneagentUpdatesMaintenanceWindows {
    maintenanceWindows: outputs.OneagentUpdatesMaintenanceWindowsMaintenanceWindow[];
}

export interface OneagentUpdatesMaintenanceWindowsMaintenanceWindow {
    maintenanceWindow: string;
}

export interface OpentelemetryMetricsAdditionalAttributes {
    additionalAttributes: outputs.OpentelemetryMetricsAdditionalAttributesAdditionalAttribute[];
}

export interface OpentelemetryMetricsAdditionalAttributesAdditionalAttribute {
    attributeKey: string;
    enabled: boolean;
}

export interface OpentelemetryMetricsToDropAttributes {
    toDropAttributes: outputs.OpentelemetryMetricsToDropAttributesToDropAttribute[];
}

export interface OpentelemetryMetricsToDropAttributesToDropAttribute {
    attributeKey: string;
    enabled: boolean;
}

export interface OsServicesDetectionConditionsLinux {
    linuxDetectionConditions: outputs.OsServicesDetectionConditionsLinuxLinuxDetectionCondition[];
}

export interface OsServicesDetectionConditionsLinuxLinuxDetectionCondition {
    condition?: string;
    property: string;
    startupCondition?: string;
}

export interface OsServicesDetectionConditionsWindows {
    detectionConditionsWindows: outputs.OsServicesDetectionConditionsWindowsDetectionConditionsWindow[];
}

export interface OsServicesDetectionConditionsWindowsDetectionConditionsWindow {
    condition?: string;
    property: string;
    startupCondition?: string;
}

export interface OsServicesMetadata {
    items: outputs.OsServicesMetadataItem[];
}

export interface OsServicesMetadataItem {
    metadataKey: string;
    metadataValue: string;
}

export interface OwnershipConfigOwnershipIdentifiers {
    ownershipIdentifiers: outputs.OwnershipConfigOwnershipIdentifiersOwnershipIdentifier[];
}

export interface OwnershipConfigOwnershipIdentifiersOwnershipIdentifier {
    enabled: boolean;
    key: string;
}

export interface OwnershipTeamsAdditionalInformation {
    /**
     * Define key/value pairs that further describe this team â€” for example, cost center, solution type, or business unit assignments.
     */
    additionalInformations: outputs.OwnershipTeamsAdditionalInformationAdditionalInformation[];
}

export interface OwnershipTeamsAdditionalInformationAdditionalInformation {
    key: string;
    url?: string;
    value: string;
}

export interface OwnershipTeamsContactDetails {
    contactDetails: outputs.OwnershipTeamsContactDetailsContactDetail[];
}

export interface OwnershipTeamsContactDetailsContactDetail {
    email?: string;
    integrationType: string;
    jira?: outputs.OwnershipTeamsContactDetailsContactDetailJira;
    msTeams?: string;
    slackChannel?: string;
    url?: string;
}

export interface OwnershipTeamsContactDetailsContactDetailJira {
    defaultAssignee: string;
    project: string;
}

export interface OwnershipTeamsLinks {
    links: outputs.OwnershipTeamsLinksLink[];
}

export interface OwnershipTeamsLinksLink {
    linkType: string;
    url: string;
}

export interface OwnershipTeamsResponsibilities {
    /**
     * Responsible for developing and maintaining high quality software. Development teams are responsible for making code changes to address performance regressions, errors, or security vulnerabilities.
     */
    development: boolean;
    /**
     * Responsible for the administration, management, and support of the IT infrastructure including physical servers, virtualization, and cloud. Teams with infrastructure responsibility are responsible for addressing hardware issues, resource limits, and operating system vulnerabilities.
     */
    infrastructure: boolean;
    /**
     * Responsible for ensuring that applications in development align with business needs and meet the usability requirements of users, stakeholders, customers, and external partners. Teams with line of business responsibility are responsible for understanding the customer experience and how it affects business goals.
     */
    lineOfBusiness: boolean;
    /**
     * Responsible for deploying and managing software, with a focus on high availability and performance. Teams with operations responsibilities needs to understand the impact, priority, and team responsible for addressing problems detected by Dynatrace.
     */
    operations: boolean;
    /**
     * Responsible for the security posture of the organization. Teams with security responsibility must understand the impact, priority, and team responsible for addressing security vulnerabilities.
     */
    security: boolean;
}

export interface OwnershipTeamsSupplementaryIdentifiers {
    supplementaryIdentifiers: outputs.OwnershipTeamsSupplementaryIdentifiersSupplementaryIdentifier[];
}

export interface OwnershipTeamsSupplementaryIdentifiersSupplementaryIdentifier {
    supplementaryIdentifier: string;
}

export interface PgAnomaliesAvailability {
    /**
     * How to monitor the availability of the process group:  * `PROCESS_IMPACT`: Alert if any process of the group becomes unavailable.  * `MINIMUM_THRESHOLD`: Alert if the number of active processes in the group falls below the specified threshold.  * `OFF`: Availability monitoring is disabled.
     */
    method: string;
    /**
     * Alert if the number of active processes in the group is lower than this value.
     */
    minimumThreshold?: number;
}

export interface ProcessAvailabilityMetadata {
    items: outputs.ProcessAvailabilityMetadataItem[];
}

export interface ProcessAvailabilityMetadataItem {
    key: string;
    value: string;
}

export interface ProcessAvailabilityRules {
    rules: outputs.ProcessAvailabilityRulesRule[];
}

export interface ProcessAvailabilityRulesRule {
    condition: string;
    property: string;
}

export interface ProcessGroupDetectionGroupExtraction {
    /**
     * Optionally delimit this property between *From* and *To*.
     */
    delimiter: outputs.ProcessGroupDetectionGroupExtractionDelimiter;
    /**
     * Possible values: `DOTNET_COMMAND`, `DOTNET_COMMAND_PATH`, `ASP_NET_CORE_APPLICATION_PATH`, `AWS_ECR_ACCOUNT_ID`, `AWS_ECR_REGION`, `AWS_ECS_CLUSTER`, `AWS_ECS_CONTAINERNAME`, `AWS_ECS_FAMILY`, `AWS_ECS_REVISION`, `AWS_LAMBDA_FUNCTION_NAME`, `AWS_REGION`, `APACHE_SPARK_MASTER_IP_ADDRESS`, `APACHE_CONFIG_PATH`, `CATALINA_BASE`, `CATALINA_HOME`, `CLOUD_FOUNDRY_APP_NAME`, `CLOUD_FOUNDRY_APPLICATION_ID`, `CLOUD_FOUNDRY_INSTANCE_INDEX`, `CLOUD_FOUNDRY_SPACE_NAME`, `CLOUD_FOUNDRY_SPACE_ID`, `COLDFUSION_JVM_CONFIG_FILE`, `SERVICE_NAME`, `COMMAND_LINE_ARGS`, `CONTAINER_ID`, `CONTAINER_IMAGE_VERSION`, `CONTAINER_NAME`, `DECLARATIVE_ID`, `CONTAINER_IMAGE_NAME`, `RUXIT_CLUSTER_ID`, `RUXIT_NODE_ID`, `EXE_NAME`, `EXE_PATH`, `ELASTIC_SEARCH_CLUSTER_NAME`, `ELASTIC_SEARCH_NODE_NAME`, `EQUINOX_CONFIG_PATH`, `GLASSFISH_DOMAIN_NAME`, `GLASSFISH_INSTANCE_NAME`, `PG_ID_CALC_INPUT_KEY_LINKAGE`, `GAE_INSTANCE`, `GAE_SERVICE`, `GOOGLE_CLOUD_PROJECT`, `HYBRIS_BIN_DIR`, `HYBRIS_CONFIG_DIR`, `HYBRIS_DATA_DIR`, `IBM_CICS_REGION`, `IBM_CICS_IMS_APPLID`, `IBM_CICS_IMS_JOBNAME`, `IBM_CTG_NAME`, `IBM_IMS_CONNECT`, `IBM_IMS_CONTROL`, `IBM_IMS_MPR`, `IBM_IMS_SOAP_GW_NAME`, `IIB_BROKER_NAME`, `IIB_EXECUTION_GROUP_NAME`, `IIS_APP_POOL`, `IIS_ROLE_NAME`, `JBOSS_HOME`, `JBOSS_MODE`, `JBOSS_SERVER_NAME`, `JAVA_JAR_FILE`, `JAVA_JAR_PATH`, `JAVA_MAIN_CLASS`, `KUBERNETES_BASEPODNAME`, `KUBERNETES_CONTAINERNAME`, `KUBERNETES_FULLPODNAME`, `KUBERNETES_NAMESPACE`, `KUBERNETES_PODUID`, `MSSQL_INSTANCE_NAME`, `NODEJS_APP_NAME`, `NODEJS_APP_BASE_DIR`, `NODEJS_SCRIPT_NAME`, `ORACLE_SID`, `PHP_CLI_SCRIPT_PATH`, `PHP_CLI_WORKING_DIR`, `SOFTWAREAG_INSTALL_ROOT`, `SOFTWAREAG_PRODUCTPROPNAME`, `SPRINGBOOT_APP_NAME`, `SPRINGBOOT_PROFILE_NAME`, `SPRINGBOOT_STARTUP_CLASS`, `TIBCO_BUSINESSWORKS_CE_APP_NAME`, `TIBCO_BUSINESSWORKS_CE_VERSION`, `TIBCO_BUSINESSWORKS_APP_NODE_NAME`, `TIBCO_BUSINESSWORKS_APP_SPACE_NAME`, `TIBCO_BUSINESSWORKS_DOMAIN_NAME`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE_PATH`, `TIBCO_BUSINESSWORKS_HOME`, `VARNISH_INSTANCE_NAME`, `WEBLOGIC_NAME`, `WEBLOGIC_CLUSTER_NAME`, `WEBLOGIC_DOMAIN_NAME`, `WEBLOGIC_HOME`, `WEBSPHERE_LIBERTY_SERVER_NAME`, `WEBSPHERE_CELL_NAME`, `WEBSPHERE_CLUSTER_NAME`, `WEBSPHERE_NODE_NAME`, `WEBSPHERE_SERVER_NAME`
     */
    property: string;
    /**
     * If this option is selected, the default Dynatrace behavior is disabled for these detected processes. Only this rule is used to separate the process group.
     */
    standaloneRule?: boolean;
}

export interface ProcessGroupDetectionGroupExtractionDelimiter {
    from?: string;
    removeIds: boolean;
    to?: string;
}

export interface ProcessGroupDetectionInstanceExtraction {
    /**
     * Optionally delimit this property between *From* and *To*.
     */
    delimiter?: outputs.ProcessGroupDetectionInstanceExtractionDelimiter;
    /**
     * Possible values: `DOTNET_COMMAND`, `DOTNET_COMMAND_PATH`, `ASP_NET_CORE_APPLICATION_PATH`, `AWS_ECR_ACCOUNT_ID`, `AWS_ECR_REGION`, `AWS_ECS_CLUSTER`, `AWS_ECS_CONTAINERNAME`, `AWS_ECS_FAMILY`, `AWS_ECS_REVISION`, `AWS_LAMBDA_FUNCTION_NAME`, `AWS_REGION`, `APACHE_SPARK_MASTER_IP_ADDRESS`, `APACHE_CONFIG_PATH`, `CATALINA_BASE`, `CATALINA_HOME`, `CLOUD_FOUNDRY_APP_NAME`, `CLOUD_FOUNDRY_APPLICATION_ID`, `CLOUD_FOUNDRY_INSTANCE_INDEX`, `CLOUD_FOUNDRY_SPACE_NAME`, `CLOUD_FOUNDRY_SPACE_ID`, `COLDFUSION_JVM_CONFIG_FILE`, `SERVICE_NAME`, `COMMAND_LINE_ARGS`, `CONTAINER_ID`, `CONTAINER_IMAGE_VERSION`, `CONTAINER_NAME`, `DECLARATIVE_ID`, `CONTAINER_IMAGE_NAME`, `RUXIT_CLUSTER_ID`, `RUXIT_NODE_ID`, `EXE_NAME`, `EXE_PATH`, `ELASTIC_SEARCH_CLUSTER_NAME`, `ELASTIC_SEARCH_NODE_NAME`, `EQUINOX_CONFIG_PATH`, `GLASSFISH_DOMAIN_NAME`, `GLASSFISH_INSTANCE_NAME`, `PG_ID_CALC_INPUT_KEY_LINKAGE`, `GAE_INSTANCE`, `GAE_SERVICE`, `GOOGLE_CLOUD_PROJECT`, `HYBRIS_BIN_DIR`, `HYBRIS_CONFIG_DIR`, `HYBRIS_DATA_DIR`, `IBM_CICS_REGION`, `IBM_CICS_IMS_APPLID`, `IBM_CICS_IMS_JOBNAME`, `IBM_CTG_NAME`, `IBM_IMS_CONNECT`, `IBM_IMS_CONTROL`, `IBM_IMS_MPR`, `IBM_IMS_SOAP_GW_NAME`, `IIB_BROKER_NAME`, `IIB_EXECUTION_GROUP_NAME`, `IIS_APP_POOL`, `IIS_ROLE_NAME`, `JBOSS_HOME`, `JBOSS_MODE`, `JBOSS_SERVER_NAME`, `JAVA_JAR_FILE`, `JAVA_JAR_PATH`, `JAVA_MAIN_CLASS`, `KUBERNETES_BASEPODNAME`, `KUBERNETES_CONTAINERNAME`, `KUBERNETES_FULLPODNAME`, `KUBERNETES_NAMESPACE`, `KUBERNETES_PODUID`, `MSSQL_INSTANCE_NAME`, `NODEJS_APP_NAME`, `NODEJS_APP_BASE_DIR`, `NODEJS_SCRIPT_NAME`, `ORACLE_SID`, `PHP_CLI_SCRIPT_PATH`, `PHP_CLI_WORKING_DIR`, `SOFTWAREAG_INSTALL_ROOT`, `SOFTWAREAG_PRODUCTPROPNAME`, `SPRINGBOOT_APP_NAME`, `SPRINGBOOT_PROFILE_NAME`, `SPRINGBOOT_STARTUP_CLASS`, `TIBCO_BUSINESSWORKS_CE_APP_NAME`, `TIBCO_BUSINESSWORKS_CE_VERSION`, `TIBCO_BUSINESSWORKS_APP_NODE_NAME`, `TIBCO_BUSINESSWORKS_APP_SPACE_NAME`, `TIBCO_BUSINESSWORKS_DOMAIN_NAME`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE_PATH`, `TIBCO_BUSINESSWORKS_HOME`, `VARNISH_INSTANCE_NAME`, `WEBLOGIC_NAME`, `WEBLOGIC_CLUSTER_NAME`, `WEBLOGIC_DOMAIN_NAME`, `WEBLOGIC_HOME`, `WEBSPHERE_LIBERTY_SERVER_NAME`, `WEBSPHERE_CELL_NAME`, `WEBSPHERE_CLUSTER_NAME`, `WEBSPHERE_NODE_NAME`, `WEBSPHERE_SERVER_NAME`
     */
    property?: string;
}

export interface ProcessGroupDetectionInstanceExtractionDelimiter {
    from?: string;
    removeIds: boolean;
    to?: string;
}

export interface ProcessGroupDetectionProcessDetection {
    /**
     * The substring to be contained in the value `property` refers to. Case Sensitive
     */
    containedString: string;
    /**
     * Possible values: `DOTNET_COMMAND`, `DOTNET_COMMAND_PATH`, `ASP_NET_CORE_APPLICATION_PATH`, `AWS_ECR_ACCOUNT_ID`, `AWS_ECR_REGION`, `AWS_ECS_CLUSTER`, `AWS_ECS_CONTAINERNAME`, `AWS_ECS_FAMILY`, `AWS_ECS_REVISION`, `AWS_LAMBDA_FUNCTION_NAME`, `AWS_REGION`, `APACHE_SPARK_MASTER_IP_ADDRESS`, `APACHE_CONFIG_PATH`, `CATALINA_BASE`, `CATALINA_HOME`, `CLOUD_FOUNDRY_APP_NAME`, `CLOUD_FOUNDRY_APPLICATION_ID`, `CLOUD_FOUNDRY_INSTANCE_INDEX`, `CLOUD_FOUNDRY_SPACE_NAME`, `CLOUD_FOUNDRY_SPACE_ID`, `COLDFUSION_JVM_CONFIG_FILE`, `SERVICE_NAME`, `COMMAND_LINE_ARGS`, `CONTAINER_ID`, `CONTAINER_IMAGE_VERSION`, `CONTAINER_NAME`, `DECLARATIVE_ID`, `CONTAINER_IMAGE_NAME`, `RUXIT_CLUSTER_ID`, `RUXIT_NODE_ID`, `EXE_NAME`, `EXE_PATH`, `ELASTIC_SEARCH_CLUSTER_NAME`, `ELASTIC_SEARCH_NODE_NAME`, `EQUINOX_CONFIG_PATH`, `GLASSFISH_DOMAIN_NAME`, `GLASSFISH_INSTANCE_NAME`, `PG_ID_CALC_INPUT_KEY_LINKAGE`, `GAE_INSTANCE`, `GAE_SERVICE`, `GOOGLE_CLOUD_PROJECT`, `HYBRIS_BIN_DIR`, `HYBRIS_CONFIG_DIR`, `HYBRIS_DATA_DIR`, `IBM_CICS_REGION`, `IBM_CICS_IMS_APPLID`, `IBM_CICS_IMS_JOBNAME`, `IBM_CTG_NAME`, `IBM_IMS_CONNECT`, `IBM_IMS_CONTROL`, `IBM_IMS_MPR`, `IBM_IMS_SOAP_GW_NAME`, `IIB_BROKER_NAME`, `IIB_EXECUTION_GROUP_NAME`, `IIS_APP_POOL`, `IIS_ROLE_NAME`, `JBOSS_HOME`, `JBOSS_MODE`, `JBOSS_SERVER_NAME`, `JAVA_JAR_FILE`, `JAVA_JAR_PATH`, `JAVA_MAIN_CLASS`, `KUBERNETES_BASEPODNAME`, `KUBERNETES_CONTAINERNAME`, `KUBERNETES_FULLPODNAME`, `KUBERNETES_NAMESPACE`, `KUBERNETES_PODUID`, `MSSQL_INSTANCE_NAME`, `NODEJS_APP_NAME`, `NODEJS_APP_BASE_DIR`, `NODEJS_SCRIPT_NAME`, `ORACLE_SID`, `PHP_CLI_SCRIPT_PATH`, `PHP_CLI_WORKING_DIR`, `SOFTWAREAG_INSTALL_ROOT`, `SOFTWAREAG_PRODUCTPROPNAME`, `SPRINGBOOT_APP_NAME`, `SPRINGBOOT_PROFILE_NAME`, `SPRINGBOOT_STARTUP_CLASS`, `TIBCO_BUSINESSWORKS_CE_APP_NAME`, `TIBCO_BUSINESSWORKS_CE_VERSION`, `TIBCO_BUSINESSWORKS_APP_NODE_NAME`, `TIBCO_BUSINESSWORKS_APP_SPACE_NAME`, `TIBCO_BUSINESSWORKS_DOMAIN_NAME`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE`, `TIPCO_BUSINESSWORKS_PROPERTY_FILE_PATH`, `TIBCO_BUSINESSWORKS_HOME`, `VARNISH_INSTANCE_NAME`, `WEBLOGIC_NAME`, `WEBLOGIC_CLUSTER_NAME`, `WEBLOGIC_DOMAIN_NAME`, `WEBLOGIC_HOME`, `WEBSPHERE_LIBERTY_SERVER_NAME`, `WEBSPHERE_CELL_NAME`, `WEBSPHERE_CLUSTER_NAME`, `WEBSPHERE_NODE_NAME`, `WEBSPHERE_SERVER_NAME`
     */
    property: string;
    /**
     * Restrict this rule to specific process types. Note: Not all types can be detected at startup. Possible values: `PROCESS_TYPE_APACHE_HTTPD`, `PROCESS_TYPE_GLASSFISH`, `PROCESS_TYPE_GO`, `PROCESS_TYPE_IIS_APP_POOL`, `PROCESS_TYPE_JBOSS`, `PROCESS_TYPE_JAVA`, `PROCESS_TYPE_NGINX`, `PROCESS_TYPE_NODE_JS`, `PROCESS_TYPE_PHP`, `PROCESS_TYPE_TOMCAT`, `PROCESS_TYPE_WEBLOGIC`, `PROCESS_TYPE_WEBSPHERE`
     */
    restrictToProcessType?: string;
}

export interface ProcessMonitoringRuleCondition {
    /**
     * supported only with OneAgent 1.167+
     */
    envVar?: string;
    /**
     * Condition target
     */
    item: string;
    /**
     * Condition operator
     */
    operator: string;
    /**
     * Condition value
     */
    value?: string;
}

export interface ProcessgroupNamingCondition {
    conditions?: outputs.ProcessgroupNamingConditionCondition[];
}

export interface ProcessgroupNamingConditionCondition {
    /**
     * @deprecated You should use 'application_type' instead of 'application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    applicationTypeComparisons?: outputs.ProcessgroupNamingConditionConditionApplicationTypeComparison[];
    applicationTypes?: outputs.ProcessgroupNamingConditionConditionApplicationType[];
    azureComputeModeComparisons?: outputs.ProcessgroupNamingConditionConditionAzureComputeModeComparison[];
    /**
     * @deprecated You should use 'azure_compute_mode' instead of 'azure_compute_mode_comparison'. This attribute still exists for backwards compatibility.
     */
    azureComputeModes?: outputs.ProcessgroupNamingConditionConditionAzureComputeMode[];
    /**
     * @deprecated You should use 'azure_sku' instead of 'azure_sku_comparision'. This attribute still exists for backwards compatibility.
     */
    azureSkuComparisions?: outputs.ProcessgroupNamingConditionConditionAzureSkuComparision[];
    azureSkus?: outputs.ProcessgroupNamingConditionConditionAzureSkus[];
    /**
     * @deprecated You should use 'comparison' instead of 'base_comparison_basic'. This attribute still exists for backwards compatibility.
     */
    baseComparisonBasics?: outputs.ProcessgroupNamingConditionConditionBaseComparisonBasic[];
    /**
     * @deprecated 'base_condition_key' is deprecated. You should use 'key'
     */
    baseConditionKeys?: outputs.ProcessgroupNamingConditionConditionBaseConditionKey[];
    /**
     * @deprecated You should use 'bitness' instead of 'bitness_comparision'. This attribute still exists for backwards compatibility.
     */
    bitnessComparisions?: outputs.ProcessgroupNamingConditionConditionBitnessComparision[];
    bitnesses?: outputs.ProcessgroupNamingConditionConditionBitness[];
    /**
     * @deprecated You should use 'cloud_type' instead of 'cloud_type_comparison'. This attribute still exists for backwards compatibility.
     */
    cloudTypeComparisons?: outputs.ProcessgroupNamingConditionConditionCloudTypeComparison[];
    cloudTypes?: outputs.ProcessgroupNamingConditionConditionCloudType[];
    comparisons?: outputs.ProcessgroupNamingConditionConditionComparison[];
    /**
     * @deprecated You should use 'custom_application_type' instead of 'custom_application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    customApplicationTypeComparisons?: outputs.ProcessgroupNamingConditionConditionCustomApplicationTypeComparison[];
    customApplicationTypes?: outputs.ProcessgroupNamingConditionConditionCustomApplicationType[];
    /**
     * @deprecated 'custom_host_metadata_condition_key' is deprecated. You should use 'custom_host_metadata'
     */
    customHostMetadataConditionKeys?: outputs.ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey[];
    customHostMetadatas?: outputs.ProcessgroupNamingConditionConditionCustomHostMetadata[];
    /**
     * @deprecated 'custom_process_metadata_condition_key' is deprecated. You should use 'custom_process_metadata'
     */
    customProcessMetadataConditionKeys?: outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey[];
    customProcessMetadatas?: outputs.ProcessgroupNamingConditionConditionCustomProcessMetadata[];
    databaseTopologies?: outputs.ProcessgroupNamingConditionConditionDatabaseTopology[];
    /**
     * @deprecated You should use 'database_topology' instead of 'database_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    databaseTopologyComparisons?: outputs.ProcessgroupNamingConditionConditionDatabaseTopologyComparison[];
    /**
     * @deprecated You should use 'dcrum_decoder' instead of 'dcrum_decoder_comparison'. This attribute still exists for backwards compatibility.
     */
    dcrumDecoderComparisons?: outputs.ProcessgroupNamingConditionConditionDcrumDecoderComparison[];
    dcrumDecoders?: outputs.ProcessgroupNamingConditionConditionDcrumDecoder[];
    entities?: outputs.ProcessgroupNamingConditionConditionEntity[];
    /**
     * @deprecated You should use 'entity' instead of 'entity_id_comparison'. This attribute still exists for backwards compatibility.
     */
    entityIdComparisons?: outputs.ProcessgroupNamingConditionConditionEntityIdComparison[];
    hostTeches?: outputs.ProcessgroupNamingConditionConditionHostTech[];
    /**
     * @deprecated `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
     */
    hypervisorTypeComparisions?: outputs.ProcessgroupNamingConditionConditionHypervisorTypeComparision[];
    hypervisors?: outputs.ProcessgroupNamingConditionConditionHypervisor[];
    /**
     * @deprecated You should use 'indexed_name' instead of 'indexed_name_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedNameComparisons?: outputs.ProcessgroupNamingConditionConditionIndexedNameComparison[];
    indexedNames?: outputs.ProcessgroupNamingConditionConditionIndexedName[];
    /**
     * @deprecated You should use 'indexed_string' instead of 'indexed_string_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedStringComparisons?: outputs.ProcessgroupNamingConditionConditionIndexedStringComparison[];
    indexedStrings?: outputs.ProcessgroupNamingConditionConditionIndexedString[];
    /**
     * @deprecated You should use 'indexed_tag' instead of 'indexed_tag_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedTagComparisons?: outputs.ProcessgroupNamingConditionConditionIndexedTagComparison[];
    indexedTags?: outputs.ProcessgroupNamingConditionConditionIndexedTag[];
    /**
     * @deprecated You should use 'integer' instead of 'integer_comparison'. This attribute still exists for backwards compatibility.
     */
    integerComparisons?: outputs.ProcessgroupNamingConditionConditionIntegerComparison[];
    integers?: outputs.ProcessgroupNamingConditionConditionInteger[];
    /**
     * @deprecated You should use 'ipaddress' instead of 'ipaddress_comparison'. This attribute still exists for backwards compatibility.
     */
    ipaddressComparisons?: outputs.ProcessgroupNamingConditionConditionIpaddressComparison[];
    ipaddresses?: outputs.ProcessgroupNamingConditionConditionIpaddress[];
    keys?: outputs.ProcessgroupNamingConditionConditionKey[];
    /**
     * @deprecated You should use 'mobile_platform' instead of 'mobile_platform_comparison'. This attribute still exists for backwards compatibility.
     */
    mobilePlatformComparisons?: outputs.ProcessgroupNamingConditionConditionMobilePlatformComparison[];
    mobilePlatforms?: outputs.ProcessgroupNamingConditionConditionMobilePlatform[];
    osArches?: outputs.ProcessgroupNamingConditionConditionOsArch[];
    osTypes?: outputs.ProcessgroupNamingConditionConditionOsType[];
    /**
     * @deprecated You should use 'os_arch' instead of 'osarchitecture_comparison'. This attribute still exists for backwards compatibility.
     */
    osarchitectureComparisons?: outputs.ProcessgroupNamingConditionConditionOsarchitectureComparison[];
    /**
     * @deprecated You should use 'os_type' instead of 'ostype_comparison'. This attribute still exists for backwards compatibility.
     */
    ostypeComparisons?: outputs.ProcessgroupNamingConditionConditionOstypeComparison[];
    /**
     * @deprecated You should use 'paas_type' instead of 'paas_type_comparison'. This attribute still exists for backwards compatibility.
     */
    paasTypeComparisons?: outputs.ProcessgroupNamingConditionConditionPaasTypeComparison[];
    paasTypes?: outputs.ProcessgroupNamingConditionConditionPaasType[];
    /**
     * @deprecated 'process_metadata_condition_key' is deprecated. You should use 'process_metadata'
     */
    processMetadataConditionKeys?: outputs.ProcessgroupNamingConditionConditionProcessMetadataConditionKey[];
    processMetadatas?: outputs.ProcessgroupNamingConditionConditionProcessMetadata[];
    serviceTopologies?: outputs.ProcessgroupNamingConditionConditionServiceTopology[];
    /**
     * @deprecated You should use 'service_topology' instead of 'service_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTopologyComparisons?: outputs.ProcessgroupNamingConditionConditionServiceTopologyComparison[];
    /**
     * @deprecated You should use 'service_type' instead of 'service_type_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTypeComparisons?: outputs.ProcessgroupNamingConditionConditionServiceTypeComparison[];
    serviceTypes?: outputs.ProcessgroupNamingConditionConditionServiceType[];
    /**
     * @deprecated You should use 'host_tech' instead of 'simple_host_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleHostTechComparisons?: outputs.ProcessgroupNamingConditionConditionSimpleHostTechComparison[];
    /**
     * @deprecated You should use 'tech' instead of 'simple_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleTechComparisons?: outputs.ProcessgroupNamingConditionConditionSimpleTechComparison[];
    /**
     * @deprecated You should use 'string' instead of 'string_comparison'. This attribute still exists for backwards compatibility.
     */
    stringComparisons?: outputs.ProcessgroupNamingConditionConditionStringComparison[];
    /**
     * @deprecated 'string_condition_key' is deprecated. You should use 'string_key'
     */
    stringConditionKeys?: outputs.ProcessgroupNamingConditionConditionStringConditionKey[];
    stringKeys?: outputs.ProcessgroupNamingConditionConditionStringKey[];
    strings?: outputs.ProcessgroupNamingConditionConditionString[];
    /**
     * @deprecated You should use 'synthetic_engine' instead of 'synthetic_engine_type_comparison'. This attribute still exists for backwards compatibility.
     */
    syntheticEngineTypeComparisons?: outputs.ProcessgroupNamingConditionConditionSyntheticEngineTypeComparison[];
    syntheticEngines?: outputs.ProcessgroupNamingConditionConditionSyntheticEngine[];
    /**
     * @deprecated You should use 'tag' instead of 'tag_comparison'. This attribute still exists for backwards compatibility.
     */
    tagComparisons?: outputs.ProcessgroupNamingConditionConditionTagComparison[];
    tags?: outputs.ProcessgroupNamingConditionConditionTag[];
    teches?: outputs.ProcessgroupNamingConditionConditionTech[];
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionAzureComputeMode {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionAzureComputeModeComparison {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionAzureSkuComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionAzureSkus {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionBaseComparisonBasic {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionBaseConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionBitness {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionBitnessComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionCloudType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionCloudTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionComparison {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionCustomApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionCustomApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionCustomHostMetadata {
    attribute: string;
    dynamicKey: outputs.ProcessgroupNamingConditionConditionCustomHostMetadataDynamicKey;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.ProcessgroupNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionCustomHostMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionCustomProcessMetadata {
    attribute: string;
    dynamicKey: outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataDynamicKey;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionCustomProcessMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionDatabaseTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionDatabaseTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionDcrumDecoder {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionDcrumDecoderComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionEntity {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionEntityIdComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionHostTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ProcessgroupNamingConditionConditionHostTechValue;
}

export interface ProcessgroupNamingConditionConditionHostTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ProcessgroupNamingConditionConditionHypervisor {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionHypervisorTypeComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionIndexedName {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionIndexedNameComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionIndexedString {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionIndexedStringComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionIndexedTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ProcessgroupNamingConditionConditionIndexedTagValue;
}

export interface ProcessgroupNamingConditionConditionIndexedTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ProcessgroupNamingConditionConditionIndexedTagComparisonValue;
}

export interface ProcessgroupNamingConditionConditionIndexedTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionIndexedTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionInteger {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: number;
}

export interface ProcessgroupNamingConditionConditionIntegerComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: number;
}

export interface ProcessgroupNamingConditionConditionIpaddress {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionIpaddressComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionMobilePlatform {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionMobilePlatformComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionOsArch {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionOsType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionOsarchitectureComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionOstypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionPaasType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionPaasTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionProcessMetadata {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionServiceTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionServiceTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionServiceType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionServiceTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionSimpleHostTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue;
}

export interface ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ProcessgroupNamingConditionConditionSimpleTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ProcessgroupNamingConditionConditionSimpleTechComparisonValue;
}

export interface ProcessgroupNamingConditionConditionSimpleTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ProcessgroupNamingConditionConditionString {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionStringComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionStringConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionStringKey {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionSyntheticEngine {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionSyntheticEngineTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ProcessgroupNamingConditionConditionTagValue;
}

export interface ProcessgroupNamingConditionConditionTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ProcessgroupNamingConditionConditionTagComparisonValue;
}

export interface ProcessgroupNamingConditionConditionTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ProcessgroupNamingConditionConditionTechValue;
}

export interface ProcessgroupNamingConditionConditionTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface QueueManagerAliasQueue {
    /**
     * Alias queue definitions for queue manager
     */
    aliasQueues?: outputs.QueueManagerAliasQueueAliasQueue[];
}

export interface QueueManagerAliasQueueAliasQueue {
    aliasQueueName: string;
    baseQueueName: string;
    clusterVisibilities?: string[];
}

export interface QueueManagerClusterQueue {
    /**
     * Cluster queue definitions for queue manager
     */
    clusterQueues?: outputs.QueueManagerClusterQueueClusterQueue[];
}

export interface QueueManagerClusterQueueClusterQueue {
    clusterVisibilities?: string[];
    localQueueName: string;
}

export interface QueueManagerRemoteQueue {
    /**
     * Remote queue definitions for queue manager
     */
    remoteQueues?: outputs.QueueManagerRemoteQueueRemoteQueue[];
}

export interface QueueManagerRemoteQueueRemoteQueue {
    clusterVisibilities?: string[];
    localQueueName: string;
    remoteQueueManager: string;
    remoteQueueName: string;
}

export interface RequestAttributeDataSource {
    /**
     * Specifies the location where the values are captured and stored.  Required if the **source** is one of the following: `GET_PARAMETER`, `URI`, `REQUEST_HEADER`, `RESPONSE_HEADER`.   Not applicable in other cases.   If the **source** value is `REQUEST_HEADER` or `RESPONSE_HEADER`, the `CAPTURE_AND_STORE_ON_BOTH` location is not allowed
     */
    capturingAndStorageLocation?: string;
    /**
     * IBM integration bus label node name condition for which the value is captured
     */
    cicsSdkMethodNodeCondition?: outputs.RequestAttributeDataSourceCicsSdkMethodNodeCondition;
    /**
     * The data source is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * IBM integration bus label node name condition for which the value is captured
     */
    iibLabelMethodNodeCondition?: outputs.RequestAttributeDataSourceIibLabelMethodNodeCondition;
    /**
     * IBM integration bus label node name condition for which the value is captured
     */
    iibMethodNodeCondition?: outputs.RequestAttributeDataSourceIibMethodNodeCondition;
    /**
     * The IBM integration bus node type for which the value is captured.  This or `iibMethodNodeCondition` is required if the **source** is: `IIB_NODE`.  Not applicable in other cases
     */
    iibNodeType?: string;
    /**
     * The method specification if the **source** value is `METHOD_PARAM`.   Not applicable in other cases
     */
    methods?: outputs.RequestAttributeDataSourceMethod[];
    /**
     * The name of the web request parameter to capture.  Required if the **source** is one of the following: `POST_PARAMETER`, `GET_PARAMETER`, `REQUEST_HEADER`, `RESPONSE_HEADER`, `CUSTOM_ATTRIBUTE`.  Not applicable in other cases
     */
    parameterName?: string;
    /**
     * Conditions for data capturing
     */
    scope?: outputs.RequestAttributeDataSourceScope;
    /**
     * The technology of the session attribute to capture if the **source** value is `SESSION_ATTRIBUTE`.
     */
    sessionAttributeTechnology?: string;
    /**
     * The source of the attribute to capture. Works in conjunction with **parameterName** or **methods** and **technology**
     */
    source: string;
    technology?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    valueProcessing?: outputs.RequestAttributeDataSourceValueProcessing;
}

export interface RequestAttributeDataSourceCicsSdkMethodNodeCondition {
    negate?: boolean;
    operator: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    value: string;
}

export interface RequestAttributeDataSourceIibLabelMethodNodeCondition {
    negate?: boolean;
    operator: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    value: string;
}

export interface RequestAttributeDataSourceIibMethodNodeCondition {
    negate?: boolean;
    operator: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    value: string;
}

export interface RequestAttributeDataSourceMethod {
    argumentIndex?: number;
    capture: string;
    deepObjectAccess?: string;
    method?: outputs.RequestAttributeDataSourceMethodMethod;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface RequestAttributeDataSourceMethodMethod {
    argumentTypes?: string[];
    className?: string;
    fileName?: string;
    fileNameMatcher?: string;
    methodName: string;
    modifiers?: string[];
    returnType: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    visibility: string;
}

export interface RequestAttributeDataSourceScope {
    hostGroup?: string;
    processGroup?: string;
    serviceTechnology?: string;
    tagOfProcessGroup?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface RequestAttributeDataSourceValueProcessing {
    extractSubstring?: outputs.RequestAttributeDataSourceValueProcessingExtractSubstring;
    splitAt?: string;
    trim?: boolean;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    valueCondition?: outputs.RequestAttributeDataSourceValueProcessingValueCondition;
    valueExtractorRegex?: string;
}

export interface RequestAttributeDataSourceValueProcessingExtractSubstring {
    delimiter: string;
    endDelimiter?: string;
    position: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface RequestAttributeDataSourceValueProcessingValueCondition {
    negate?: boolean;
    operator: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    value: string;
}

export interface RequestNamingConditions {
    conditions?: outputs.RequestNamingConditionsCondition[];
}

export interface RequestNamingConditionsCondition {
    attribute: string;
    comparison: outputs.RequestNamingConditionsConditionComparison;
    unknowns?: string;
}

export interface RequestNamingConditionsConditionComparison {
    boolean?: outputs.RequestNamingConditionsConditionComparisonBoolean;
    esbInputNodeType?: outputs.RequestNamingConditionsConditionComparisonEsbInputNodeType;
    failedState?: outputs.RequestNamingConditionsConditionComparisonFailedState;
    failureReason?: outputs.RequestNamingConditionsConditionComparisonFailureReason;
    fastString?: outputs.RequestNamingConditionsConditionComparisonFastString;
    flawState?: outputs.RequestNamingConditionsConditionComparisonFlawState;
    generic?: outputs.RequestNamingConditionsConditionComparisonGeneric;
    httpMethod?: outputs.RequestNamingConditionsConditionComparisonHttpMethod;
    httpStatusClass?: outputs.RequestNamingConditionsConditionComparisonHttpStatusClass;
    iibInputNodeType?: outputs.RequestNamingConditionsConditionComparisonIibInputNodeType;
    negate?: boolean;
    number?: outputs.RequestNamingConditionsConditionComparisonNumber;
    numberRequestAttribute?: outputs.RequestNamingConditionsConditionComparisonNumberRequestAttribute;
    serviceType?: outputs.RequestNamingConditionsConditionComparisonServiceType;
    string?: outputs.RequestNamingConditionsConditionComparisonString;
    stringRequestAttribute?: outputs.RequestNamingConditionsConditionComparisonStringRequestAttribute;
    tag?: outputs.RequestNamingConditionsConditionComparisonTag;
    zosCallType?: outputs.RequestNamingConditionsConditionComparisonZosCallType;
}

export interface RequestNamingConditionsConditionComparisonBoolean {
    operator?: string;
    unknowns?: string;
    value: boolean;
    values?: boolean[];
}

export interface RequestNamingConditionsConditionComparisonEsbInputNodeType {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonFailedState {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonFailureReason {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonFastString {
    caseSensitive?: boolean;
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonFlawState {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonGeneric {
    type: string;
    unknowns?: string;
}

export interface RequestNamingConditionsConditionComparisonHttpMethod {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonHttpStatusClass {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonIibInputNodeType {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonNumber {
    operator?: string;
    unknowns?: string;
    value?: number;
    values?: number[];
}

export interface RequestNamingConditionsConditionComparisonNumberRequestAttribute {
    matchOnChildCalls?: boolean;
    operator?: string;
    requestAttribute: string;
    source?: outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSource;
    unknowns?: string;
    value?: number;
    values?: number[];
}

export interface RequestNamingConditionsConditionComparisonNumberRequestAttributeSource {
    managementZone?: string;
    serviceTag?: outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag;
    unknowns?: string;
}

export interface RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag {
    context?: string;
    key: string;
    tagKey?: outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey;
    value?: string;
}

export interface RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey {
    context?: string;
    key?: string;
}

export interface RequestNamingConditionsConditionComparisonServiceType {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonString {
    caseSensitive?: boolean;
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonStringRequestAttribute {
    caseSensitive?: boolean;
    matchOnChildCalls?: boolean;
    operator?: string;
    requestAttribute: string;
    source?: outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSource;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonStringRequestAttributeSource {
    managementZone?: string;
    serviceTag?: outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag;
    unknowns?: string;
}

export interface RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag {
    context?: string;
    key: string;
    tagKey?: outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey;
    value?: string;
}

export interface RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey {
    context?: string;
    key?: string;
}

export interface RequestNamingConditionsConditionComparisonTag {
    operator?: string;
    unknowns?: string;
    value?: outputs.RequestNamingConditionsConditionComparisonTagValue;
    values?: outputs.RequestNamingConditionsConditionComparisonTagValues;
}

export interface RequestNamingConditionsConditionComparisonTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface RequestNamingConditionsConditionComparisonTagValues {
    values?: outputs.RequestNamingConditionsConditionComparisonTagValuesValue[];
}

export interface RequestNamingConditionsConditionComparisonTagValuesValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface RequestNamingConditionsConditionComparisonZosCallType {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingPlaceholders {
    placeholders?: outputs.RequestNamingPlaceholdersPlaceholder[];
}

export interface RequestNamingPlaceholdersPlaceholder {
    aggregation?: string;
    attribute: string;
    delimiterOrRegex?: string;
    endDelimiter?: string;
    kind: string;
    name: string;
    normalization?: string;
    requestAttribute?: string;
    source?: outputs.RequestNamingPlaceholdersPlaceholderSource;
    unknowns?: string;
    useFromChildCalls?: boolean;
}

export interface RequestNamingPlaceholdersPlaceholderSource {
    managementZone?: string;
    serviceTag?: outputs.RequestNamingPlaceholdersPlaceholderSourceServiceTag;
    unknowns?: string;
}

export interface RequestNamingPlaceholdersPlaceholderSourceServiceTag {
    context?: string;
    key: string;
    tagKey?: outputs.RequestNamingPlaceholdersPlaceholderSourceServiceTagTagKey;
    value?: string;
}

export interface RequestNamingPlaceholdersPlaceholderSourceServiceTagTagKey {
    context?: string;
    key?: string;
}

export interface ResourceAttributesKeys {
    rules?: outputs.ResourceAttributesKeysRule[];
}

export interface ResourceAttributesKeysRule {
    attributeKey: string;
    enabled: boolean;
    masking: string;
}

export interface RumProviderBreakdownDomainNamePatternList {
    domainNamePatterns: outputs.RumProviderBreakdownDomainNamePatternListDomainNamePattern[];
}

export interface RumProviderBreakdownDomainNamePatternListDomainNamePattern {
    pattern: string;
}

export interface ServiceAnomaliesFailureRates {
    /**
     * Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
     */
    auto?: outputs.ServiceAnomaliesFailureRatesAuto;
    /**
     * Fixed thresholds for failure rate increase detection
     */
    thresholds?: outputs.ServiceAnomaliesFailureRatesThresholds;
}

export interface ServiceAnomaliesFailureRatesAuto {
    absolute: number;
    relative: number;
    unknowns?: string;
}

export interface ServiceAnomaliesFailureRatesThresholds {
    sensitivity: string;
    threshold: number;
    unknowns?: string;
}

export interface ServiceAnomaliesLoad {
    /**
     * The configuration of traffic drops detection
     */
    drops?: outputs.ServiceAnomaliesLoadDrops;
    /**
     * The configuration of traffic spikes detection
     */
    spikes?: outputs.ServiceAnomaliesLoadSpikes;
}

export interface ServiceAnomaliesLoadDrops {
    /**
     * Alert if the service stays in abnormal state for at least *X* minutes
     */
    minutes?: number;
    /**
     * Alert if the observed load is more than *X* % of the expected value
     */
    percent?: number;
}

export interface ServiceAnomaliesLoadSpikes {
    minutes?: number;
    percent?: number;
    unknowns?: string;
}

export interface ServiceAnomaliesResponseTimes {
    /**
     * Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
     */
    auto?: outputs.ServiceAnomaliesResponseTimesAuto;
    /**
     * Fixed thresholds for response time degradation detection
     */
    thresholds?: outputs.ServiceAnomaliesResponseTimesThresholds;
}

export interface ServiceAnomaliesResponseTimesAuto {
    /**
     * The configuration of load spikes detection. Detecting load spikes will be disabled if this block is omitted.
     */
    load: string;
    milliseconds: number;
    percent: number;
    slowestMilliseconds: number;
    slowestPercent: number;
    unknowns?: string;
}

export interface ServiceAnomaliesResponseTimesThresholds {
    /**
     * The configuration of load spikes detection. Detecting load spikes will be disabled if this block is omitted.
     */
    load: string;
    milliseconds: number;
    sensitivity: string;
    slowestMilliseconds: number;
    unknowns?: string;
}

export interface ServiceAnomaliesV2FailureRate {
    /**
     * . Alert if the percentage of failing service calls increases by **both** the absolute and relative thresholds:
     */
    autoDetection?: outputs.ServiceAnomaliesV2FailureRateAutoDetection;
    /**
     * Detection mode for increases in failure rate
     */
    detectionMode?: string;
    /**
     * Detect increases in failure rate
     */
    enabled: boolean;
    /**
     * . Alert if a given failure rate is exceeded during any 5-minute-period
     */
    fixedDetection?: outputs.ServiceAnomaliesV2FailureRateFixedDetection;
}

export interface ServiceAnomaliesV2FailureRateAutoDetection {
    absoluteIncrease: number;
    overAlertingProtection: outputs.ServiceAnomaliesV2FailureRateAutoDetectionOverAlertingProtection;
    relativeIncrease: number;
}

export interface ServiceAnomaliesV2FailureRateAutoDetectionOverAlertingProtection {
    minutesAbnormalState: number;
    requestsPerMinute: number;
}

export interface ServiceAnomaliesV2FailureRateFixedDetection {
    overAlertingProtection: outputs.ServiceAnomaliesV2FailureRateFixedDetectionOverAlertingProtection;
    sensitivity: string;
    threshold: number;
}

export interface ServiceAnomaliesV2FailureRateFixedDetectionOverAlertingProtection {
    minutesAbnormalState: number;
    requestsPerMinute: number;
}

export interface ServiceAnomaliesV2LoadDrops {
    /**
     * Detect service load drops
     */
    enabled: boolean;
    /**
     * Threshold
     */
    loadDropPercent?: number;
    /**
     * Time span
     */
    minutesAbnormalState?: number;
}

export interface ServiceAnomaliesV2LoadSpikes {
    /**
     * Detect service load spikes
     */
    enabled: boolean;
    /**
     * Threshold
     */
    loadSpikePercent?: number;
    /**
     * Time span
     */
    minutesAbnormalState?: number;
}

export interface ServiceAnomaliesV2ResponseTime {
    /**
     * No documentation available
     */
    autoDetection?: outputs.ServiceAnomaliesV2ResponseTimeAutoDetection;
    /**
     * Detection mode for response time degradations
     */
    detectionMode?: string;
    /**
     * Detect response time degradations
     */
    enabled: boolean;
    /**
     * No documentation available
     */
    fixedDetection?: outputs.ServiceAnomaliesV2ResponseTimeFixedDetection;
}

export interface ServiceAnomaliesV2ResponseTimeAutoDetection {
    overAlertingProtection: outputs.ServiceAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection;
    responseTimeAll: outputs.ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll;
    responseTimeSlowest: outputs.ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest;
}

export interface ServiceAnomaliesV2ResponseTimeAutoDetectionOverAlertingProtection {
    minutesAbnormalState: number;
    requestsPerMinute: number;
}

export interface ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeAll {
    degradationMilliseconds: number;
    degradationPercent: number;
}

export interface ServiceAnomaliesV2ResponseTimeAutoDetectionResponseTimeSlowest {
    slowestDegradationMilliseconds: number;
    slowestDegradationPercent: number;
}

export interface ServiceAnomaliesV2ResponseTimeFixedDetection {
    overAlertingProtection: outputs.ServiceAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection;
    responseTimeAll: outputs.ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll;
    responseTimeSlowest: outputs.ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest;
    sensitivity: string;
}

export interface ServiceAnomaliesV2ResponseTimeFixedDetectionOverAlertingProtection {
    minutesAbnormalState: number;
    requestsPerMinute: number;
}

export interface ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeAll {
    degradationMilliseconds: number;
}

export interface ServiceAnomaliesV2ResponseTimeFixedDetectionResponseTimeSlowest {
    slowestDegradationMilliseconds: number;
}

export interface ServiceExternalWebRequestConditions {
    conditions: outputs.ServiceExternalWebRequestConditionsCondition[];
}

export interface ServiceExternalWebRequestConditionsCondition {
    attribute: string;
    compareOperationType: string;
    frameworks?: string[];
    ignoreCase?: boolean;
    intValue?: number;
    intValues?: number[];
    ipRangeFrom?: string;
    ipRangeTo?: string;
    tagValues?: string[];
    textValues?: string[];
}

export interface ServiceExternalWebRequestIdContributors {
    /**
     * Application identifier
     */
    applicationId: outputs.ServiceExternalWebRequestIdContributorsApplicationId;
    /**
     * URL context root
     */
    contextRoot: outputs.ServiceExternalWebRequestIdContributorsContextRoot;
    /**
     * Let the Port contribute to the Service Id
     */
    portForServiceId: boolean;
    /**
     * Public domain name
     */
    publicDomainName: outputs.ServiceExternalWebRequestIdContributorsPublicDomainName;
}

export interface ServiceExternalWebRequestIdContributorsApplicationId {
    enableIdContributor: boolean;
    serviceIdContributor?: outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributor;
}

export interface ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributor {
    contributionType: string;
    transformations?: outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformations;
    valueOverride?: outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride;
}

export interface ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformations {
    transformations: outputs.ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation[];
}

export interface ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation {
    includeHexNumbers?: boolean;
    minDigitCount?: number;
    prefix?: string;
    replacementValue?: string;
    segmentCount?: number;
    selectIndex?: number;
    splitDelimiter?: string;
    suffix?: string;
    takeFromEnd?: boolean;
    transformationType: string;
}

export interface ServiceExternalWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride {
    value: string;
}

export interface ServiceExternalWebRequestIdContributorsContextRoot {
    enableIdContributor: boolean;
    serviceIdContributor?: outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributor;
}

export interface ServiceExternalWebRequestIdContributorsContextRootServiceIdContributor {
    contributionType: string;
    segmentCount?: number;
    transformations?: outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformations;
    valueOverride?: outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorValueOverride;
}

export interface ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformations {
    transformations: outputs.ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation[];
}

export interface ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation {
    includeHexNumbers?: boolean;
    minDigitCount?: number;
    prefix?: string;
    replacementValue?: string;
    suffix?: string;
    transformationType: string;
}

export interface ServiceExternalWebRequestIdContributorsContextRootServiceIdContributorValueOverride {
    value: string;
}

export interface ServiceExternalWebRequestIdContributorsPublicDomainName {
    enableIdContributor: boolean;
    serviceIdContributor?: outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributor;
}

export interface ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributor {
    contributionType: string;
    copyFromHostName?: boolean;
    transformations?: outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformations;
    valueOverride?: outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorValueOverride;
}

export interface ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformations {
    transformations: outputs.ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformationsTransformation[];
}

export interface ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorTransformationsTransformation {
    includeHexNumbers?: boolean;
    minDigitCount?: number;
    prefix?: string;
    replacementValue?: string;
    segmentCount?: number;
    selectIndex?: number;
    splitDelimiter?: string;
    suffix?: string;
    takeFromEnd?: boolean;
    transformationType: string;
}

export interface ServiceExternalWebRequestIdContributorsPublicDomainNameServiceIdContributorValueOverride {
    value: string;
}

export interface ServiceExternalWebServiceConditions {
    conditions: outputs.ServiceExternalWebServiceConditionsCondition[];
}

export interface ServiceExternalWebServiceConditionsCondition {
    attribute: string;
    compareOperationType: string;
    frameworks?: string[];
    ignoreCase?: boolean;
    intValue?: number;
    intValues?: number[];
    ipRangeFrom?: string;
    ipRangeTo?: string;
    tagValues?: string[];
    textValues?: string[];
}

export interface ServiceExternalWebServiceIdContributors {
    /**
     * Detect the matching requests as web request services instead of web services.
     */
    detectAsWebRequestService: boolean;
    portForServiceId?: boolean;
    urlPath?: outputs.ServiceExternalWebServiceIdContributorsUrlPath;
}

export interface ServiceExternalWebServiceIdContributorsUrlPath {
    enableIdContributor: boolean;
    serviceIdContributor?: outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributor;
}

export interface ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributor {
    contributionType: string;
    transformations?: outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformations;
    valueOverride?: outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorValueOverride;
}

export interface ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformations {
    transformations: outputs.ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformationsTransformation[];
}

export interface ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorTransformationsTransformation {
    includeHexNumbers?: boolean;
    minDigitCount?: number;
    prefix?: string;
    replacementValue?: string;
    segmentCount?: number;
    selectIndex?: number;
    splitDelimiter?: string;
    suffix?: string;
    takeFromEnd?: boolean;
    transformationType: string;
}

export interface ServiceExternalWebServiceIdContributorsUrlPathServiceIdContributorValueOverride {
    value: string;
}

export interface ServiceFailureExceptionRules {
    /**
     * Some custom error situations are only detectable via a return value or other means. To support such cases, [define a request attribute](https://dt-url.net/ys5k0p4y) that captures the required data. Then define a custom error rule that determines if the request has failed based on the value of the request attribute.
     */
    customErrorRules?: outputs.ServiceFailureExceptionRulesCustomErrorRules;
    /**
     * There may be situations where your application code handles exceptions gracefully in a manner that these failures aren't detected by Dynatrace. Use this setting to define specific gracefully-handled exceptions that should be treated as service failures.
     */
    customHandledExceptions?: outputs.ServiceFailureExceptionRulesCustomHandledExceptions;
    /**
     * Ignore all exceptions
     */
    ignoreAllExceptions: boolean;
    /**
     * Ignore span failure detection
     */
    ignoreSpanFailureDetection: boolean;
    /**
     * Some exceptions that are thrown by legacy or 3rd-party code indicate a specific response, not an error. Use this setting to instruct Dynatrace to treat such exceptions as non-failed requests.. If an exception matching any of the defined patterns occurs in a request, it will not be considered as a failure. Other exceptions occurring at the same request might still mark the request as failed.
     */
    ignoredExceptions?: outputs.ServiceFailureExceptionRulesIgnoredExceptions;
    /**
     * Define exceptions which indicate that a service call should not be considered as failed. E.g. an exception indicating that the client aborted the operation.. If an exception matching any of the defined patterns occurs on the entry node of the service, it will be considered successful. Compared to ignored exceptions, the request will be considered successful even if other exceptions occur in the same request.
     */
    successForcingExceptions?: outputs.ServiceFailureExceptionRulesSuccessForcingExceptions;
}

export interface ServiceFailureExceptionRulesCustomErrorRules {
    customErrorRules: outputs.ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRule[];
}

export interface ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRule {
    condition: outputs.ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRuleCondition;
    requestAttribute: string;
}

export interface ServiceFailureExceptionRulesCustomErrorRulesCustomErrorRuleCondition {
    caseSensitive?: boolean;
    compareOperationType: string;
    doubleValue?: number;
    intValue?: number;
    textValue?: string;
}

export interface ServiceFailureExceptionRulesCustomHandledExceptions {
    customHandledExceptions: outputs.ServiceFailureExceptionRulesCustomHandledExceptionsCustomHandledException[];
}

export interface ServiceFailureExceptionRulesCustomHandledExceptionsCustomHandledException {
    classPattern?: string;
    messagePattern?: string;
}

export interface ServiceFailureExceptionRulesIgnoredExceptions {
    customHandledExceptions: outputs.ServiceFailureExceptionRulesIgnoredExceptionsCustomHandledException[];
}

export interface ServiceFailureExceptionRulesIgnoredExceptionsCustomHandledException {
    classPattern?: string;
    messagePattern?: string;
}

export interface ServiceFailureExceptionRulesSuccessForcingExceptions {
    customHandledExceptions: outputs.ServiceFailureExceptionRulesSuccessForcingExceptionsCustomHandledException[];
}

export interface ServiceFailureExceptionRulesSuccessForcingExceptionsCustomHandledException {
    classPattern?: string;
    messagePattern?: string;
}

export interface ServiceFullWebRequestConditions {
    conditions: outputs.ServiceFullWebRequestConditionsCondition[];
}

export interface ServiceFullWebRequestConditionsCondition {
    attribute: string;
    compareOperationType: string;
    frameworks?: string[];
    ignoreCase?: boolean;
    intValue?: number;
    intValues?: number[];
    ipRangeFrom?: string;
    ipRangeTo?: string;
    tagValues?: string[];
    textValues?: string[];
}

export interface ServiceFullWebRequestIdContributors {
    /**
     * Application identifier
     */
    applicationId: outputs.ServiceFullWebRequestIdContributorsApplicationId;
    /**
     * The context root is the first segment of the request URL after the Server name. For example, in the `www.dynatrace.com/support/help/dynatrace-api/` URL the context root is `/support`. The context root value can be found on the Service screen under **Properties and tags**.
     */
    contextRoot: outputs.ServiceFullWebRequestIdContributorsContextRoot;
    /**
     * Server Name
     */
    serverName: outputs.ServiceFullWebRequestIdContributorsServerName;
}

export interface ServiceFullWebRequestIdContributorsApplicationId {
    enableIdContributor: boolean;
    serviceIdContributor?: outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributor;
}

export interface ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributor {
    contributionType: string;
    transformations?: outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformations;
    valueOverride?: outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride;
}

export interface ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformations {
    transformations: outputs.ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation[];
}

export interface ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorTransformationsTransformation {
    includeHexNumbers?: boolean;
    minDigitCount?: number;
    prefix?: string;
    replacementValue?: string;
    segmentCount?: number;
    selectIndex?: number;
    splitDelimiter?: string;
    suffix?: string;
    takeFromEnd?: boolean;
    transformationType: string;
}

export interface ServiceFullWebRequestIdContributorsApplicationIdServiceIdContributorValueOverride {
    value: string;
}

export interface ServiceFullWebRequestIdContributorsContextRoot {
    enableIdContributor: boolean;
    serviceIdContributor?: outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributor;
}

export interface ServiceFullWebRequestIdContributorsContextRootServiceIdContributor {
    contributionType: string;
    segmentCount?: number;
    transformations?: outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformations;
    valueOverride?: outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributorValueOverride;
}

export interface ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformations {
    transformations: outputs.ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation[];
}

export interface ServiceFullWebRequestIdContributorsContextRootServiceIdContributorTransformationsTransformation {
    includeHexNumbers?: boolean;
    minDigitCount?: number;
    prefix?: string;
    replacementValue?: string;
    suffix?: string;
    transformationType: string;
}

export interface ServiceFullWebRequestIdContributorsContextRootServiceIdContributorValueOverride {
    value: string;
}

export interface ServiceFullWebRequestIdContributorsServerName {
    enableIdContributor: boolean;
    serviceIdContributor?: outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributor;
}

export interface ServiceFullWebRequestIdContributorsServerNameServiceIdContributor {
    contributionType: string;
    transformations?: outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformations;
    valueOverride?: outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributorValueOverride;
}

export interface ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformations {
    transformations: outputs.ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformationsTransformation[];
}

export interface ServiceFullWebRequestIdContributorsServerNameServiceIdContributorTransformationsTransformation {
    includeHexNumbers?: boolean;
    minDigitCount?: number;
    prefix?: string;
    replacementValue?: string;
    segmentCount?: number;
    selectIndex?: number;
    splitDelimiter?: string;
    suffix?: string;
    takeFromEnd?: boolean;
    transformationType: string;
}

export interface ServiceFullWebRequestIdContributorsServerNameServiceIdContributorValueOverride {
    value: string;
}

export interface ServiceFullWebServiceConditions {
    conditions: outputs.ServiceFullWebServiceConditionsCondition[];
}

export interface ServiceFullWebServiceConditionsCondition {
    attribute: string;
    compareOperationType: string;
    frameworks?: string[];
    ignoreCase?: boolean;
    intValue?: number;
    intValues?: number[];
    ipRangeFrom?: string;
    ipRangeTo?: string;
    tagValues?: string[];
    textValues?: string[];
}

export interface ServiceFullWebServiceIdContributors {
    applicationId?: outputs.ServiceFullWebServiceIdContributorsApplicationId;
    contextRoot?: outputs.ServiceFullWebServiceIdContributorsContextRoot;
    /**
     * Detect the matching requests as full web services (false) or web request services (true).
     */
    detectAsWebRequestService: boolean;
    serverName?: outputs.ServiceFullWebServiceIdContributorsServerName;
    webServiceName?: outputs.ServiceFullWebServiceIdContributorsWebServiceName;
    webServiceNamespace?: outputs.ServiceFullWebServiceIdContributorsWebServiceNamespace;
}

export interface ServiceFullWebServiceIdContributorsApplicationId {
    enableIdContributor: boolean;
    serviceIdContributor?: outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributor;
}

export interface ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributor {
    contributionType: string;
    transformations?: outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformations;
    valueOverride?: outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorValueOverride;
}

export interface ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformations {
    transformations: outputs.ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformationsTransformation[];
}

export interface ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorTransformationsTransformation {
    includeHexNumbers?: boolean;
    minDigitCount?: number;
    prefix?: string;
    replacementValue?: string;
    segmentCount?: number;
    selectIndex?: number;
    splitDelimiter?: string;
    suffix?: string;
    takeFromEnd?: boolean;
    transformationType: string;
}

export interface ServiceFullWebServiceIdContributorsApplicationIdServiceIdContributorValueOverride {
    value: string;
}

export interface ServiceFullWebServiceIdContributorsContextRoot {
    enableIdContributor: boolean;
    serviceIdContributor?: outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributor;
}

export interface ServiceFullWebServiceIdContributorsContextRootServiceIdContributor {
    contributionType: string;
    segmentCount?: number;
    transformations?: outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformations;
    valueOverride?: outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributorValueOverride;
}

export interface ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformations {
    transformations: outputs.ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformationsTransformation[];
}

export interface ServiceFullWebServiceIdContributorsContextRootServiceIdContributorTransformationsTransformation {
    includeHexNumbers?: boolean;
    minDigitCount?: number;
    prefix?: string;
    replacementValue?: string;
    suffix?: string;
    transformationType: string;
}

export interface ServiceFullWebServiceIdContributorsContextRootServiceIdContributorValueOverride {
    value: string;
}

export interface ServiceFullWebServiceIdContributorsServerName {
    enableIdContributor: boolean;
    serviceIdContributor?: outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributor;
}

export interface ServiceFullWebServiceIdContributorsServerNameServiceIdContributor {
    contributionType: string;
    transformations?: outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformations;
    valueOverride?: outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributorValueOverride;
}

export interface ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformations {
    transformations: outputs.ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformationsTransformation[];
}

export interface ServiceFullWebServiceIdContributorsServerNameServiceIdContributorTransformationsTransformation {
    includeHexNumbers?: boolean;
    minDigitCount?: number;
    prefix?: string;
    replacementValue?: string;
    segmentCount?: number;
    selectIndex?: number;
    splitDelimiter?: string;
    suffix?: string;
    takeFromEnd?: boolean;
    transformationType: string;
}

export interface ServiceFullWebServiceIdContributorsServerNameServiceIdContributorValueOverride {
    value: string;
}

export interface ServiceFullWebServiceIdContributorsWebServiceName {
    enableIdContributor: boolean;
    serviceIdContributor?: outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributor;
}

export interface ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributor {
    contributionType: string;
    transformations?: outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformations;
    valueOverride?: outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorValueOverride;
}

export interface ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformations {
    transformations: outputs.ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformationsTransformation[];
}

export interface ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorTransformationsTransformation {
    includeHexNumbers?: boolean;
    minDigitCount?: number;
    prefix?: string;
    replacementValue?: string;
    segmentCount?: number;
    selectIndex?: number;
    splitDelimiter?: string;
    suffix?: string;
    takeFromEnd?: boolean;
    transformationType: string;
}

export interface ServiceFullWebServiceIdContributorsWebServiceNameServiceIdContributorValueOverride {
    value: string;
}

export interface ServiceFullWebServiceIdContributorsWebServiceNamespace {
    enableIdContributor: boolean;
    serviceIdContributor?: outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributor;
}

export interface ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributor {
    contributionType: string;
    transformations?: outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformations;
    valueOverride?: outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorValueOverride;
}

export interface ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformations {
    transformations: outputs.ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformationsTransformation[];
}

export interface ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorTransformationsTransformation {
    includeHexNumbers?: boolean;
    minDigitCount?: number;
    prefix?: string;
    replacementValue?: string;
    segmentCount?: number;
    selectIndex?: number;
    splitDelimiter?: string;
    suffix?: string;
    takeFromEnd?: boolean;
    transformationType: string;
}

export interface ServiceFullWebServiceIdContributorsWebServiceNamespaceServiceIdContributorValueOverride {
    value: string;
}

export interface ServiceHttpFailureBrokenLinks {
    /**
     * If your application relies on other hosts at other domains, add the associated domain names here. Once configured, Dynatrace will consider 404s thrown by hosts at these domains to be service failures related to your application.
     */
    brokenLinkDomains?: string[];
    /**
     * Consider 404 HTTP response codes as failures
     */
    http404NotFoundFailures: boolean;
}

export interface ServiceHttpFailureHttpResponseCodes {
    /**
     * HTTP response codes which indicate client side errors
     */
    clientSideErrors: string;
    /**
     * Treat missing HTTP response code as client side error
     */
    failOnMissingResponseCodeClientSide: boolean;
    /**
     * Treat missing HTTP response code as server side errors
     */
    failOnMissingResponseCodeServerSide: boolean;
    /**
     * HTTP response codes which indicate an error on the server side
     */
    serverSideErrors: string;
}

export interface ServiceNamingCondition {
    conditions?: outputs.ServiceNamingConditionCondition[];
}

export interface ServiceNamingConditionCondition {
    /**
     * @deprecated You should use 'application_type' instead of 'application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    applicationTypeComparisons?: outputs.ServiceNamingConditionConditionApplicationTypeComparison[];
    applicationTypes?: outputs.ServiceNamingConditionConditionApplicationType[];
    azureComputeModeComparisons?: outputs.ServiceNamingConditionConditionAzureComputeModeComparison[];
    /**
     * @deprecated You should use 'azure_compute_mode' instead of 'azure_compute_mode_comparison'. This attribute still exists for backwards compatibility.
     */
    azureComputeModes?: outputs.ServiceNamingConditionConditionAzureComputeMode[];
    /**
     * @deprecated You should use 'azure_sku' instead of 'azure_sku_comparision'. This attribute still exists for backwards compatibility.
     */
    azureSkuComparisions?: outputs.ServiceNamingConditionConditionAzureSkuComparision[];
    azureSkus?: outputs.ServiceNamingConditionConditionAzureSkus[];
    /**
     * @deprecated You should use 'comparison' instead of 'base_comparison_basic'. This attribute still exists for backwards compatibility.
     */
    baseComparisonBasics?: outputs.ServiceNamingConditionConditionBaseComparisonBasic[];
    /**
     * @deprecated 'base_condition_key' is deprecated. You should use 'key'
     */
    baseConditionKeys?: outputs.ServiceNamingConditionConditionBaseConditionKey[];
    /**
     * @deprecated You should use 'bitness' instead of 'bitness_comparision'. This attribute still exists for backwards compatibility.
     */
    bitnessComparisions?: outputs.ServiceNamingConditionConditionBitnessComparision[];
    bitnesses?: outputs.ServiceNamingConditionConditionBitness[];
    /**
     * @deprecated You should use 'cloud_type' instead of 'cloud_type_comparison'. This attribute still exists for backwards compatibility.
     */
    cloudTypeComparisons?: outputs.ServiceNamingConditionConditionCloudTypeComparison[];
    cloudTypes?: outputs.ServiceNamingConditionConditionCloudType[];
    comparisons?: outputs.ServiceNamingConditionConditionComparison[];
    /**
     * @deprecated You should use 'custom_application_type' instead of 'custom_application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    customApplicationTypeComparisons?: outputs.ServiceNamingConditionConditionCustomApplicationTypeComparison[];
    customApplicationTypes?: outputs.ServiceNamingConditionConditionCustomApplicationType[];
    /**
     * @deprecated 'custom_host_metadata_condition_key' is deprecated. You should use 'custom_host_metadata'
     */
    customHostMetadataConditionKeys?: outputs.ServiceNamingConditionConditionCustomHostMetadataConditionKey[];
    customHostMetadatas?: outputs.ServiceNamingConditionConditionCustomHostMetadata[];
    /**
     * @deprecated 'custom_process_metadata_condition_key' is deprecated. You should use 'custom_process_metadata'
     */
    customProcessMetadataConditionKeys?: outputs.ServiceNamingConditionConditionCustomProcessMetadataConditionKey[];
    customProcessMetadatas?: outputs.ServiceNamingConditionConditionCustomProcessMetadata[];
    databaseTopologies?: outputs.ServiceNamingConditionConditionDatabaseTopology[];
    /**
     * @deprecated You should use 'database_topology' instead of 'database_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    databaseTopologyComparisons?: outputs.ServiceNamingConditionConditionDatabaseTopologyComparison[];
    /**
     * @deprecated You should use 'dcrum_decoder' instead of 'dcrum_decoder_comparison'. This attribute still exists for backwards compatibility.
     */
    dcrumDecoderComparisons?: outputs.ServiceNamingConditionConditionDcrumDecoderComparison[];
    dcrumDecoders?: outputs.ServiceNamingConditionConditionDcrumDecoder[];
    entities?: outputs.ServiceNamingConditionConditionEntity[];
    /**
     * @deprecated You should use 'entity' instead of 'entity_id_comparison'. This attribute still exists for backwards compatibility.
     */
    entityIdComparisons?: outputs.ServiceNamingConditionConditionEntityIdComparison[];
    hostTeches?: outputs.ServiceNamingConditionConditionHostTech[];
    /**
     * @deprecated `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
     */
    hypervisorTypeComparisions?: outputs.ServiceNamingConditionConditionHypervisorTypeComparision[];
    hypervisors?: outputs.ServiceNamingConditionConditionHypervisor[];
    /**
     * @deprecated You should use 'indexed_name' instead of 'indexed_name_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedNameComparisons?: outputs.ServiceNamingConditionConditionIndexedNameComparison[];
    indexedNames?: outputs.ServiceNamingConditionConditionIndexedName[];
    /**
     * @deprecated You should use 'indexed_string' instead of 'indexed_string_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedStringComparisons?: outputs.ServiceNamingConditionConditionIndexedStringComparison[];
    indexedStrings?: outputs.ServiceNamingConditionConditionIndexedString[];
    /**
     * @deprecated You should use 'indexed_tag' instead of 'indexed_tag_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedTagComparisons?: outputs.ServiceNamingConditionConditionIndexedTagComparison[];
    indexedTags?: outputs.ServiceNamingConditionConditionIndexedTag[];
    /**
     * @deprecated You should use 'integer' instead of 'integer_comparison'. This attribute still exists for backwards compatibility.
     */
    integerComparisons?: outputs.ServiceNamingConditionConditionIntegerComparison[];
    integers?: outputs.ServiceNamingConditionConditionInteger[];
    /**
     * @deprecated You should use 'ipaddress' instead of 'ipaddress_comparison'. This attribute still exists for backwards compatibility.
     */
    ipaddressComparisons?: outputs.ServiceNamingConditionConditionIpaddressComparison[];
    ipaddresses?: outputs.ServiceNamingConditionConditionIpaddress[];
    keys?: outputs.ServiceNamingConditionConditionKey[];
    /**
     * @deprecated You should use 'mobile_platform' instead of 'mobile_platform_comparison'. This attribute still exists for backwards compatibility.
     */
    mobilePlatformComparisons?: outputs.ServiceNamingConditionConditionMobilePlatformComparison[];
    mobilePlatforms?: outputs.ServiceNamingConditionConditionMobilePlatform[];
    osArches?: outputs.ServiceNamingConditionConditionOsArch[];
    osTypes?: outputs.ServiceNamingConditionConditionOsType[];
    /**
     * @deprecated You should use 'os_arch' instead of 'osarchitecture_comparison'. This attribute still exists for backwards compatibility.
     */
    osarchitectureComparisons?: outputs.ServiceNamingConditionConditionOsarchitectureComparison[];
    /**
     * @deprecated You should use 'os_type' instead of 'ostype_comparison'. This attribute still exists for backwards compatibility.
     */
    ostypeComparisons?: outputs.ServiceNamingConditionConditionOstypeComparison[];
    /**
     * @deprecated You should use 'paas_type' instead of 'paas_type_comparison'. This attribute still exists for backwards compatibility.
     */
    paasTypeComparisons?: outputs.ServiceNamingConditionConditionPaasTypeComparison[];
    paasTypes?: outputs.ServiceNamingConditionConditionPaasType[];
    /**
     * @deprecated 'process_metadata_condition_key' is deprecated. You should use 'process_metadata'
     */
    processMetadataConditionKeys?: outputs.ServiceNamingConditionConditionProcessMetadataConditionKey[];
    processMetadatas?: outputs.ServiceNamingConditionConditionProcessMetadata[];
    serviceTopologies?: outputs.ServiceNamingConditionConditionServiceTopology[];
    /**
     * @deprecated You should use 'service_topology' instead of 'service_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTopologyComparisons?: outputs.ServiceNamingConditionConditionServiceTopologyComparison[];
    /**
     * @deprecated You should use 'service_type' instead of 'service_type_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTypeComparisons?: outputs.ServiceNamingConditionConditionServiceTypeComparison[];
    serviceTypes?: outputs.ServiceNamingConditionConditionServiceType[];
    /**
     * @deprecated You should use 'host_tech' instead of 'simple_host_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleHostTechComparisons?: outputs.ServiceNamingConditionConditionSimpleHostTechComparison[];
    /**
     * @deprecated You should use 'tech' instead of 'simple_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleTechComparisons?: outputs.ServiceNamingConditionConditionSimpleTechComparison[];
    /**
     * @deprecated You should use 'string' instead of 'string_comparison'. This attribute still exists for backwards compatibility.
     */
    stringComparisons?: outputs.ServiceNamingConditionConditionStringComparison[];
    /**
     * @deprecated 'string_condition_key' is deprecated. You should use 'string_key'
     */
    stringConditionKeys?: outputs.ServiceNamingConditionConditionStringConditionKey[];
    stringKeys?: outputs.ServiceNamingConditionConditionStringKey[];
    strings?: outputs.ServiceNamingConditionConditionString[];
    /**
     * @deprecated You should use 'synthetic_engine' instead of 'synthetic_engine_type_comparison'. This attribute still exists for backwards compatibility.
     */
    syntheticEngineTypeComparisons?: outputs.ServiceNamingConditionConditionSyntheticEngineTypeComparison[];
    syntheticEngines?: outputs.ServiceNamingConditionConditionSyntheticEngine[];
    /**
     * @deprecated You should use 'tag' instead of 'tag_comparison'. This attribute still exists for backwards compatibility.
     */
    tagComparisons?: outputs.ServiceNamingConditionConditionTagComparison[];
    tags?: outputs.ServiceNamingConditionConditionTag[];
    teches?: outputs.ServiceNamingConditionConditionTech[];
    unknowns?: string;
}

export interface ServiceNamingConditionConditionApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionAzureComputeMode {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionAzureComputeModeComparison {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionAzureSkuComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionAzureSkus {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionBaseComparisonBasic {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionBaseConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionBitness {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionBitnessComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionCloudType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionCloudTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionComparison {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionCustomApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionCustomApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionCustomHostMetadata {
    attribute: string;
    dynamicKey: outputs.ServiceNamingConditionConditionCustomHostMetadataDynamicKey;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionCustomHostMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.ServiceNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionCustomHostMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionCustomProcessMetadata {
    attribute: string;
    dynamicKey: outputs.ServiceNamingConditionConditionCustomProcessMetadataDynamicKey;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionCustomProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.ServiceNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionCustomProcessMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionDatabaseTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionDatabaseTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionDcrumDecoder {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionDcrumDecoderComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionEntity {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionEntityIdComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionHostTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ServiceNamingConditionConditionHostTechValue;
}

export interface ServiceNamingConditionConditionHostTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ServiceNamingConditionConditionHypervisor {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionHypervisorTypeComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionIndexedName {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionIndexedNameComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionIndexedString {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionIndexedStringComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionIndexedTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ServiceNamingConditionConditionIndexedTagValue;
}

export interface ServiceNamingConditionConditionIndexedTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ServiceNamingConditionConditionIndexedTagComparisonValue;
}

export interface ServiceNamingConditionConditionIndexedTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionIndexedTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionInteger {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: number;
}

export interface ServiceNamingConditionConditionIntegerComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: number;
}

export interface ServiceNamingConditionConditionIpaddress {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionIpaddressComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionMobilePlatform {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionMobilePlatformComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionOsArch {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionOsType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionOsarchitectureComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionOstypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionPaasType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionPaasTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionProcessMetadata {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionServiceTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionServiceTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionServiceType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionServiceTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionSimpleHostTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ServiceNamingConditionConditionSimpleHostTechComparisonValue;
}

export interface ServiceNamingConditionConditionSimpleHostTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ServiceNamingConditionConditionSimpleTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ServiceNamingConditionConditionSimpleTechComparisonValue;
}

export interface ServiceNamingConditionConditionSimpleTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ServiceNamingConditionConditionString {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionStringComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionStringConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionStringKey {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionSyntheticEngine {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionSyntheticEngineTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ServiceNamingConditionConditionTagValue;
}

export interface ServiceNamingConditionConditionTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ServiceNamingConditionConditionTagComparisonValue;
}

export interface ServiceNamingConditionConditionTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ServiceNamingConditionConditionTechValue;
}

export interface ServiceNamingConditionConditionTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface SessionReplayWebPrivacyMaskingPresets {
    /**
     * (Field has overlap with `dynatrace.ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
     */
    playbackMaskingAllowListRules?: outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRules;
    /**
     * (Field has overlap with `dynatrace.ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
     */
    playbackMaskingBlockListRules?: outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRules;
    /**
     * (Field has overlap with `dynatrace.ApplicationDataPrivacy`) Possible Values: `MASK_ALL`, `MASK_USER_INPUT`, `ALLOW_LIST`, `BLOCK_LIST`
     */
    playbackMaskingPreset: string;
    /**
     * (Field has overlap with `dynatrace.ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
     */
    recordingMaskingAllowListRules?: outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRules;
    /**
     * (Field has overlap with `dynatrace.ApplicationDataPrivacy`) The elements are defined by the CSS selector or attribute name.
     */
    recordingMaskingBlockListRules?: outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRules;
    /**
     * (Field has overlap with `dynatrace.ApplicationDataPrivacy`) Possible Values: `MASK_USER_INPUT`, `ALLOW_LIST`, `BLOCK_LIST`, `MASK_ALL`
     */
    recordingMaskingPreset: string;
}

export interface SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRules {
    allowListRules: outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRulesAllowListRule[];
}

export interface SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingAllowListRulesAllowListRule {
    attributeExpression?: string;
    cssExpression?: string;
    target: string;
}

export interface SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRules {
    blockListRules: outputs.SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRulesBlockListRule[];
}

export interface SessionReplayWebPrivacyMaskingPresetsPlaybackMaskingBlockListRulesBlockListRule {
    attributeExpression?: string;
    cssExpression?: string;
    hideUserInteraction?: boolean;
    target: string;
}

export interface SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRules {
    allowListRules: outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRulesAllowListRule[];
}

export interface SessionReplayWebPrivacyMaskingPresetsRecordingMaskingAllowListRulesAllowListRule {
    attributeExpression?: string;
    cssExpression?: string;
    target: string;
}

export interface SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRules {
    blockListRules: outputs.SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRulesBlockListRule[];
}

export interface SessionReplayWebPrivacyMaskingPresetsRecordingMaskingBlockListRulesBlockListRule {
    attributeExpression?: string;
    cssExpression?: string;
    hideUserInteraction?: boolean;
    target: string;
}

export interface SloV2ErrorBudgetBurnRate {
    /**
     * Burn rate visualization enabled
     */
    burnRateVisualizationEnabled: boolean;
    /**
     * The threshold defines when a burn rate is marked as fast-burning (high-emergency). Burn rates lower than this threshold (and greater than 1) are highlighted as slow-burn (low-emergency).
     */
    fastBurnThreshold?: number;
}

export interface SpanCaptureRuleMatches {
    /**
     * Matching strategies for the Span
     */
    matches: outputs.SpanCaptureRuleMatchesMatch[];
}

export interface SpanCaptureRuleMatchesMatch {
    caseSensitive?: boolean;
    comparison: string;
    key?: string;
    source: string;
    value?: string;
}

export interface SpanContextPropagationMatches {
    /**
     * Matching strategies for the Span
     */
    matches: outputs.SpanContextPropagationMatchesMatch[];
}

export interface SpanContextPropagationMatchesMatch {
    caseSensitive?: boolean;
    comparison: string;
    key?: string;
    source: string;
    value?: string;
}

export interface SpanEntryPointMatches {
    /**
     * Matching strategies for the Span
     */
    matches: outputs.SpanEntryPointMatchesMatch[];
}

export interface SpanEntryPointMatchesMatch {
    caseSensitive?: boolean;
    comparison: string;
    key?: string;
    source: string;
    value?: string;
}

export interface UpdateWindowsDailyRecurrence {
    every: number;
    recurrenceRange: outputs.UpdateWindowsDailyRecurrenceRecurrenceRange;
    updateTime: outputs.UpdateWindowsDailyRecurrenceUpdateTime;
}

export interface UpdateWindowsDailyRecurrenceRecurrenceRange {
    end: string;
    start: string;
}

export interface UpdateWindowsDailyRecurrenceUpdateTime {
    duration: number;
    startTime: string;
    timeZone: string;
}

export interface UpdateWindowsMonthlyRecurrence {
    every: number;
    recurrenceRange: outputs.UpdateWindowsMonthlyRecurrenceRecurrenceRange;
    selectedMonthDay: number;
    updateTime: outputs.UpdateWindowsMonthlyRecurrenceUpdateTime;
}

export interface UpdateWindowsMonthlyRecurrenceRecurrenceRange {
    end: string;
    start: string;
}

export interface UpdateWindowsMonthlyRecurrenceUpdateTime {
    duration: number;
    startTime: string;
    timeZone: string;
}

export interface UpdateWindowsOnceRecurrence {
    recurrenceRange: outputs.UpdateWindowsOnceRecurrenceRecurrenceRange;
}

export interface UpdateWindowsOnceRecurrenceRecurrenceRange {
    end: string;
    start: string;
}

export interface UpdateWindowsWeeklyRecurrence {
    every: number;
    recurrenceRange: outputs.UpdateWindowsWeeklyRecurrenceRecurrenceRange;
    selectedWeekDays: outputs.UpdateWindowsWeeklyRecurrenceSelectedWeekDays;
    updateTime: outputs.UpdateWindowsWeeklyRecurrenceUpdateTime;
}

export interface UpdateWindowsWeeklyRecurrenceRecurrenceRange {
    end: string;
    start: string;
}

export interface UpdateWindowsWeeklyRecurrenceSelectedWeekDays {
    friday: boolean;
    monday: boolean;
    saturday: boolean;
    sunday: boolean;
    thursday: boolean;
    tuesday: boolean;
    wednesday: boolean;
}

export interface UpdateWindowsWeeklyRecurrenceUpdateTime {
    duration: number;
    startTime: string;
    timeZone: string;
}

export interface UserActionMetricsFilters {
    filters: outputs.UserActionMetricsFiltersFilter[];
}

export interface UserActionMetricsFiltersFilter {
    fieldName: string;
    operator: string;
    /**
     * Defines the type of value to be extracted from the user action. When using **user action counter**, the number of user actions is counted (similar to count(*) when using USQL). When using **user action field value**, the value of a user action field is extracted.
     */
    value?: string;
    valueIns?: string[];
}

export interface UserActionMetricsValue {
    /**
     * Field name
     */
    fieldName?: string;
    /**
     * Possible Values: `COUNTER`, `FIELD`
     */
    type: string;
}

export interface UserGroupPermissions {
    /**
     * A permission granted to one or multiple environments
     */
    grants: outputs.UserGroupPermissionsGrant[];
}

export interface UserGroupPermissionsGrant {
    environments?: string[];
    permission: string;
}

export interface UserSessionMetricsFilters {
    filters: outputs.UserSessionMetricsFiltersFilter[];
}

export interface UserSessionMetricsFiltersFilter {
    fieldName: string;
    operator: string;
    /**
     * Defines the type of value to be extracted from the user session. When using **User session counter**, the number of user sessions is counted (similar to count(*) when using USQL). When using **User session field value**, the value of a user session field is extracted.
     */
    value?: string;
    valueIns?: string[];
}

export interface UserSessionMetricsValue {
    /**
     * Field name
     */
    fieldName?: string;
    /**
     * Possible Values: `COUNTER`, `FIELD`
     */
    type: string;
}

export interface VmwareAnomaliesDroppedPacketsDetection {
    /**
     * Alert if the condition is met in 3 out of 5 samples
     */
    customThresholds?: outputs.VmwareAnomaliesDroppedPacketsDetectionCustomThresholds;
    /**
     * Possible Values: `Auto`, `Custom`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface VmwareAnomaliesDroppedPacketsDetectionCustomThresholds {
    droppedPacketsPerSecond: number;
}

export interface VmwareAnomaliesEsxiHighCpuDetection {
    /**
     * Alert if **all three** conditions are met in 3 out of 5 samples
     */
    customThresholds?: outputs.VmwareAnomaliesEsxiHighCpuDetectionCustomThresholds;
    /**
     * Possible Values: `Auto`, `Custom`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface VmwareAnomaliesEsxiHighCpuDetectionCustomThresholds {
    cpuPeakPercentage: number;
    cpuUsagePercentage: number;
    vmCpuReadyPercentage: number;
}

export interface VmwareAnomaliesEsxiHighMemoryDetection {
    /**
     * Alert if the condition is met in 3 out of 5 samples
     */
    customThresholds?: outputs.VmwareAnomaliesEsxiHighMemoryDetectionCustomThresholds;
    /**
     * Possible Values: `Auto`, `Custom`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface VmwareAnomaliesEsxiHighMemoryDetectionCustomThresholds {
    compressionDecompressionRate: number;
}

export interface VmwareAnomaliesGuestCpuLimitDetection {
    /**
     * Alert if **all three** conditions are met in 3 out of 5 samples
     */
    customThresholds?: outputs.VmwareAnomaliesGuestCpuLimitDetectionCustomThresholds;
    /**
     * Possible Values: `Auto`, `Custom`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface VmwareAnomaliesGuestCpuLimitDetectionCustomThresholds {
    hostCpuUsagePercentage: number;
    vmCpuReadyPercentage: number;
    vmCpuUsagePercentage: number;
}

export interface VmwareAnomaliesLowDatastoreSpaceDetection {
    /**
     * Alert if the condition is met in 1 out of 5 samples
     */
    customThresholds?: outputs.VmwareAnomaliesLowDatastoreSpaceDetectionCustomThresholds;
    /**
     * Possible Values: `Auto`, `Custom`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface VmwareAnomaliesLowDatastoreSpaceDetectionCustomThresholds {
    freeSpacePercentage: number;
}

export interface VmwareAnomaliesOverloadedStorageDetection {
    /**
     * Alert if the condition is met in 3 out of 5 samples
     */
    customThresholds?: outputs.VmwareAnomaliesOverloadedStorageDetectionCustomThresholds;
    /**
     * Possible Values: `Auto`, `Custom`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface VmwareAnomaliesOverloadedStorageDetectionCustomThresholds {
    commandAbortsNumber: number;
}

export interface VmwareAnomaliesSlowPhysicalStorageDetection {
    /**
     * Alert if **any** condition is met in 4 out of 5 samples
     */
    customThresholds?: outputs.VmwareAnomaliesSlowPhysicalStorageDetectionCustomThresholds;
    /**
     * Possible Values: `Auto`, `Custom`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface VmwareAnomaliesSlowPhysicalStorageDetectionCustomThresholds {
    avgReadWriteLatency: number;
    peakReadWriteLatency: number;
}

export interface VmwareAnomaliesUndersizedStorageDetection {
    /**
     * Alert if **any** condition is met in 3 out of 5 samples
     */
    customThresholds?: outputs.VmwareAnomaliesUndersizedStorageDetectionCustomThresholds;
    /**
     * Possible Values: `Auto`, `Custom`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface VmwareAnomaliesUndersizedStorageDetectionCustomThresholds {
    averageQueueCommandLatency: number;
    peakQueueCommandLatency: number;
}

export interface WebAppAnomaliesErrorRate {
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * Alert if the percentage of failing user actions increases by **both** the absolute and relative thresholds:
     */
    errorRateAuto?: outputs.WebAppAnomaliesErrorRateErrorRateAuto;
    /**
     * Possible Values: `Auto`, `Fixed`
     */
    errorRateDetectionMode?: string;
    /**
     * no documentation available
     */
    errorRateFixed?: outputs.WebAppAnomaliesErrorRateErrorRateFixed;
}

export interface WebAppAnomaliesErrorRateErrorRateAuto {
    absoluteIncrease: number;
    overAlertingProtection: outputs.WebAppAnomaliesErrorRateErrorRateAutoOverAlertingProtection;
    relativeIncrease: number;
}

export interface WebAppAnomaliesErrorRateErrorRateAutoOverAlertingProtection {
    actionsPerMinute: number;
    minutesAbnormalState: number;
}

export interface WebAppAnomaliesErrorRateErrorRateFixed {
    errorRateReqPerMin: number;
    errorRateSensitivity: string;
    maxFailureRateIncrease: number;
    minutesAbnormalState: number;
}

export interface WebAppAnomaliesResponseTime {
    /**
     * Possible Values: `Auto`, `Fixed`
     */
    detectionMode?: string;
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * no documentation available
     */
    responseTimeAuto?: outputs.WebAppAnomaliesResponseTimeResponseTimeAuto;
    /**
     * no documentation available
     */
    responseTimeFixed?: outputs.WebAppAnomaliesResponseTimeResponseTimeFixed;
}

export interface WebAppAnomaliesResponseTimeResponseTimeAuto {
    overAlertingProtection: outputs.WebAppAnomaliesResponseTimeResponseTimeAutoOverAlertingProtection;
    responseTimeAll: outputs.WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeAll;
    responseTimeSlowest: outputs.WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeSlowest;
}

export interface WebAppAnomaliesResponseTimeResponseTimeAutoOverAlertingProtection {
    actionsPerMinute: number;
    minutesAbnormalState: number;
}

export interface WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeAll {
    degradationMilliseconds: number;
    degradationPercent: number;
}

export interface WebAppAnomaliesResponseTimeResponseTimeAutoResponseTimeSlowest {
    slowestDegradationMilliseconds: number;
    slowestDegradationPercent: number;
}

export interface WebAppAnomaliesResponseTimeResponseTimeFixed {
    overAlertingProtection: outputs.WebAppAnomaliesResponseTimeResponseTimeFixedOverAlertingProtection;
    responseTimeAll: outputs.WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeAll;
    responseTimeSlowest: outputs.WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeSlowest;
    sensitivity: string;
}

export interface WebAppAnomaliesResponseTimeResponseTimeFixedOverAlertingProtection {
    actionsPerMinute: number;
    minutesAbnormalState: number;
}

export interface WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeAll {
    degradationMilliseconds: number;
}

export interface WebAppAnomaliesResponseTimeResponseTimeFixedResponseTimeSlowest {
    slowestDegradationMilliseconds: number;
}

export interface WebAppAnomaliesTrafficDrops {
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * Dynatrace learns your typical application traffic over an observation period of one week.
     */
    trafficDrops?: outputs.WebAppAnomaliesTrafficDropsTrafficDrops;
}

export interface WebAppAnomaliesTrafficDropsTrafficDrops {
    abnormalStateAbnormalState: number;
    trafficDropPercentage: number;
}

export interface WebAppAnomaliesTrafficSpikes {
    /**
     * This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * Dynatrace learns your typical application traffic over an observation period of one week.
     */
    trafficSpikes?: outputs.WebAppAnomaliesTrafficSpikesTrafficSpikes;
}

export interface WebAppAnomaliesTrafficSpikesTrafficSpikes {
    minutesAbnormalState: number;
    trafficSpikePercentage: number;
}

export interface WebAppCustomErrorsErrorRules {
    errorRules: outputs.WebAppCustomErrorsErrorRulesErrorRule[];
}

export interface WebAppCustomErrorsErrorRulesErrorRule {
    captureSettings: outputs.WebAppCustomErrorsErrorRulesErrorRuleCaptureSettings;
    keyMatcher: string;
    keyPattern?: string;
    valueMatcher: string;
    valuePattern?: string;
}

export interface WebAppCustomErrorsErrorRulesErrorRuleCaptureSettings {
    capture: boolean;
    considerForAi?: boolean;
    impactApdex?: boolean;
}

export interface WebAppEnablementRum {
    /**
     * (Field has overlap with `dynatrace.WebApplication`) Percentage of user sessions captured and analyzed
     */
    costAndTrafficControl: number;
    /**
     * (Field has overlap with `dynatrace.WebApplication`) This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface WebAppEnablementSessionReplay {
    /**
     * (Field has overlap with `dynatrace.WebApplication`) [Percentage of user sessions recorded with Session Replay](https://dt-url.net/sr-cost-traffic-control). For example, if you have 50% for RUM and 50% for Session Replay, it results in 25% of sessions recorded with Session Replay.
     */
    costAndTrafficControl: number;
    /**
     * (Field has overlap with `dynatrace.WebApplication`) This setting is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
}

export interface WebAppRequestErrorsErrorRules {
    errorRules: outputs.WebAppRequestErrorsErrorRulesErrorRule[];
}

export interface WebAppRequestErrorsErrorRulesErrorRule {
    captureSettings: outputs.WebAppRequestErrorsErrorRulesErrorRuleCaptureSettings;
    considerCspViolations: boolean;
    considerFailedImages: boolean;
    errorCodes?: string;
    filterSettings: outputs.WebAppRequestErrorsErrorRulesErrorRuleFilterSettings;
}

export interface WebAppRequestErrorsErrorRulesErrorRuleCaptureSettings {
    capture: boolean;
    considerForAi?: boolean;
    impactApdex?: boolean;
}

export interface WebAppRequestErrorsErrorRulesErrorRuleFilterSettings {
    filter?: string;
    url?: string;
}

export interface WebApplicationConversionGoals {
    /**
     * A conversion goal of the application
     */
    goals: outputs.WebApplicationConversionGoalsGoal[];
}

export interface WebApplicationConversionGoalsGoal {
    destination?: outputs.WebApplicationConversionGoalsGoalDestination;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of the web application, displayed in the UI
     */
    name: string;
    /**
     * The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
     */
    type?: string;
    userAction?: outputs.WebApplicationConversionGoalsGoalUserAction;
    visitDuration?: outputs.WebApplicationConversionGoalsGoalVisitDuration;
    visitNumAction?: outputs.WebApplicationConversionGoalsGoalVisitNumAction;
}

export interface WebApplicationConversionGoalsGoalDestination {
    caseSensitive?: boolean;
    matchType?: string;
    urlOrPath: string;
}

export interface WebApplicationConversionGoalsGoalUserAction {
    actionType?: string;
    caseSensitive?: boolean;
    matchEntity?: string;
    matchType?: string;
    value?: string;
}

export interface WebApplicationConversionGoalsGoalVisitDuration {
    duration: number;
}

export interface WebApplicationConversionGoalsGoalVisitNumAction {
    numUserActions?: number;
}

export interface WebApplicationCustomActionApdexSettings {
    /**
     * Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
     */
    frustratingFallbackThreshold?: number;
    /**
     * Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
     */
    frustratingThreshold?: number;
    /**
     * no documentation available
     */
    threshold?: number;
    /**
     * Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
     */
    toleratedFallbackThreshold?: number;
    /**
     * Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
     */
    toleratedThreshold?: number;
}

export interface WebApplicationKeyUserAction {
    /**
     * Configuration of the key user action
     */
    actions: outputs.WebApplicationKeyUserActionAction[];
}

export interface WebApplicationKeyUserActionAction {
    domain?: string;
    /**
     * The name of the web application, displayed in the UI
     */
    name: string;
    /**
     * The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
     */
    type: string;
}

export interface WebApplicationLoadActionApdexSettings {
    /**
     * Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
     */
    frustratingFallbackThreshold?: number;
    /**
     * Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
     */
    frustratingThreshold?: number;
    /**
     * no documentation available
     */
    threshold?: number;
    /**
     * Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
     */
    toleratedFallbackThreshold?: number;
    /**
     * Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
     */
    toleratedThreshold?: number;
}

export interface WebApplicationMetaDataCaptureSettings {
    /**
     * Java script agent meta data capture settings
     */
    captures?: outputs.WebApplicationMetaDataCaptureSettingsCapture[];
}

export interface WebApplicationMetaDataCaptureSettingsCapture {
    capturingName: string;
    /**
     * The name of the web application, displayed in the UI
     */
    name: string;
    publicMetadata?: boolean;
    /**
     * The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
     */
    type: string;
    uniqueId?: number;
    useLastValue?: boolean;
}

export interface WebApplicationMonitoringSettings {
    /**
     * Add the cross origin = anonymous attribute to capture JavaScript error messages and W3C resource timings
     */
    addCrossOriginAnonymousAttribute?: boolean;
    /**
     * Advanced JavaScript tag settings
     */
    advancedJavascriptTagSettings?: outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings;
    /**
     * The name of the angular package
     */
    angularPackageName?: string;
    /**
     * Settings for restricting certain browser type, version, platform and, comparator. It also restricts the mode
     */
    browserRestrictionSettings?: outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettings;
    /**
     * Optimize the value of cache control headers for use with Dynatrace real user monitoring enabled/disabled
     */
    cacheControlHeaderOptimizations?: boolean;
    /**
     * Settings for content capture
     */
    contentCapture: outputs.WebApplicationMonitoringSettingsContentCapture;
    /**
     * Domain for cookie placement. Maximum 150 characters.
     */
    cookiePlacementDomain?: string;
    /**
     * To enable RUM for XHR calls to AWS Lambda, define a regular expression matching these calls, Dynatrace can then automatically add a custom header (`x-dtc`) to each such request to the respective endpoints in AWS.
     */
    correlationHeaderInclusionRegex?: string;
    customConfigurationProperties?: string;
    excludeXhrRegex?: string;
    fetchRequests?: boolean;
    /**
     * Possible valures are `CODE_SNIPPET`, `CODE_SNIPPET_ASYNC`, `INLINE_CODE` and `JAVASCRIPT_TAG`.
     */
    injectionMode: string;
    ipAddressRestrictionSettings?: outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettings;
    javascriptFrameworkSupport?: outputs.WebApplicationMonitoringSettingsJavascriptFrameworkSupport;
    javascriptInjectionRules?: outputs.WebApplicationMonitoringSettingsJavascriptInjectionRules;
    libraryFileLocation?: string;
    monitoringDataPath?: string;
    scriptTagCacheDurationInHours?: number;
    secureCookieAttribute?: boolean;
    serverRequestPathId?: string;
    xmlHttpRequest?: boolean;
}

export interface WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings {
    additionalEventHandlers?: outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers;
    eventWrapperSettings?: outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings;
    globalEventCaptureSettings?: outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings;
    instrumentUnsupportedAjaxFrameworks?: boolean;
    maxActionNameLength: number;
    maxErrorsToCapture: number;
    specialCharactersToEscape?: string;
    syncBeaconFirefox?: boolean;
    syncBeaconInternetExplorer?: boolean;
}

export interface WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers {
    blur?: boolean;
    change?: boolean;
    click?: boolean;
    maxDomNodes: number;
    mouseup?: boolean;
    toStringMethod?: boolean;
    useMouseUpEventForClicks?: boolean;
}

export interface WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings {
    blur?: boolean;
    change?: boolean;
    click?: boolean;
    mouseup?: boolean;
    touchEnd?: boolean;
    touchStart?: boolean;
}

export interface WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings {
    additionalEventCapturedAsUserInput?: string;
    click?: boolean;
    doubleclick?: boolean;
    keydown?: boolean;
    keyup?: boolean;
    mousedown?: boolean;
    mouseup?: boolean;
    scroll?: boolean;
}

export interface WebApplicationMonitoringSettingsBrowserRestrictionSettings {
    mode: string;
    restrictions?: outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictions;
}

export interface WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictions {
    restrictions: outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction[];
}

export interface WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction {
    browserType: string;
    browserVersion?: string;
    comparator?: string;
    platform?: string;
}

export interface WebApplicationMonitoringSettingsContentCapture {
    javascriptErrors?: boolean;
    resourceTimingSettings?: outputs.WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings;
    timeoutSettings?: outputs.WebApplicationMonitoringSettingsContentCaptureTimeoutSettings;
    visuallyCompleteAndSpeedIndex?: boolean;
    visuallyCompleteSettings?: outputs.WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings;
}

export interface WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings {
    instrumentationDelay: number;
    nonW3cResourceTimings?: boolean;
    resourceTimingCaptureType?: string;
    resourceTimingsDomainLimit?: number;
    w3cResourceTimings?: boolean;
}

export interface WebApplicationMonitoringSettingsContentCaptureTimeoutSettings {
    temporaryActionLimit: number;
    temporaryActionTotalTimeout: number;
    timedActionSupport?: boolean;
}

export interface WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings {
    excludeUrlRegex?: string;
    ignoredMutationsList?: string;
    inactivityTimeout?: number;
    mutationTimeout?: number;
    threshold?: number;
}

export interface WebApplicationMonitoringSettingsIpAddressRestrictionSettings {
    mode: string;
    restrictions?: outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictions;
}

export interface WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictions {
    ranges: outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange[];
}

export interface WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange {
    address: string;
    addressTo?: string;
    subnetMask?: number;
}

export interface WebApplicationMonitoringSettingsJavascriptFrameworkSupport {
    activeXObject?: boolean;
    angular?: boolean;
    dojo?: boolean;
    extjs?: boolean;
    icefaces?: boolean;
    jquery?: boolean;
    mooTools?: boolean;
    prototype?: boolean;
}

export interface WebApplicationMonitoringSettingsJavascriptInjectionRules {
    rules: outputs.WebApplicationMonitoringSettingsJavascriptInjectionRulesRule[];
}

export interface WebApplicationMonitoringSettingsJavascriptInjectionRulesRule {
    enabled?: boolean;
    htmlPattern?: string;
    rule: string;
    target?: string;
    urlOperator: string;
    urlPattern?: string;
}

export interface WebApplicationSessionReplayConfig {
    /**
     * (Field has overlap with `dynatrace.WebAppEnablement`) Session replay sampling rating in percent
     */
    costControlPercentage: number;
    /**
     * (Field has overlap with `dynatrace.SessionReplayResourceCapture`) A list of URLs to be excluded from CSS resource capturing
     */
    cssResourceCapturingExclusionRules?: string[];
    /**
     * (Field has overlap with `dynatrace.SessionReplayResourceCapture`) Capture (`true`) or don't capture (`false`) CSS resources from the session
     */
    enableCssResourceCapturing?: boolean;
    /**
     * (Field has overlap with `dynatrace.WebAppEnablement`) SessionReplay Enabled/Disabled
     */
    enabled?: boolean;
}

export interface WebApplicationUserActionAndSessionProperties {
    /**
     * User action and session properties settings
     */
    properties?: outputs.WebApplicationUserActionAndSessionPropertiesProperty[];
}

export interface WebApplicationUserActionAndSessionPropertiesProperty {
    aggregation?: string;
    cleanupRule?: string;
    displayName?: string;
    /**
     * The ID of this resource.
     */
    id: number;
    ignoreCase?: boolean;
    key: string;
    longStringLength?: number;
    metadataId?: number;
    origin: string;
    serverSideRequestAttribute?: string;
    storeAsSessionProperty?: boolean;
    storeAsUserActionProperty?: boolean;
    /**
     * The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
     */
    type: string;
}

export interface WebApplicationUserActionNamingSettings {
    /**
     * User action naming rules for custom actions
     */
    customActionNamingRules?: outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRules;
    /**
     * Case insensitive naming
     */
    ignoreCase?: boolean;
    /**
     * User action naming rules for loading actions
     */
    loadActionNamingRules?: outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRules;
    /**
     * User action placeholders
     */
    placeholders?: outputs.WebApplicationUserActionNamingSettingsPlaceholders;
    /**
     * User action naming rules for custom actions
     */
    queryParameterCleanups?: string[];
    /**
     * Deactivate this setting if different domains should not result in separate user actions
     */
    splitUserActionsByDomain?: boolean;
    /**
     * First load action found under an XHR action should be used when true. Else the deepest one under the xhr action is used
     */
    useFirstDetectedLoadAction?: boolean;
    /**
     * User action naming rules for XHR actions
     */
    xhrActionNamingRules?: outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRules;
}

export interface WebApplicationUserActionNamingSettingsCustomActionNamingRules {
    rules: outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule[];
}

export interface WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule {
    conditions?: outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditions;
    template: string;
    useOrConditions?: boolean;
}

export interface WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditions {
    conditions: outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCondition[];
}

export interface WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCondition {
    operand1: string;
    operand2?: string;
    operator: string;
}

export interface WebApplicationUserActionNamingSettingsLoadActionNamingRules {
    rules: outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule[];
}

export interface WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule {
    conditions?: outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditions;
    template: string;
    useOrConditions?: boolean;
}

export interface WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditions {
    conditions: outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCondition[];
}

export interface WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCondition {
    operand1: string;
    operand2?: string;
    operator: string;
}

export interface WebApplicationUserActionNamingSettingsPlaceholders {
    placeholders: outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder[];
}

export interface WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder {
    input: string;
    metadataId?: number;
    /**
     * The name of the web application, displayed in the UI
     */
    name: string;
    processingPart: string;
    processingSteps?: outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps;
    useGuessedElementIdentifier?: boolean;
}

export interface WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps {
    steps: outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep[];
}

export interface WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep {
    fallbackToInput?: boolean;
    patternAfter?: string;
    patternAfterSearchType?: string;
    patternBefore?: string;
    patternBeforeSearchType?: string;
    patternToReplace?: string;
    regularExpression?: string;
    replacement?: string;
    /**
     * The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
     */
    type: string;
}

export interface WebApplicationUserActionNamingSettingsXhrActionNamingRules {
    rules: outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule[];
}

export interface WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule {
    conditions?: outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditions;
    template: string;
    useOrConditions?: boolean;
}

export interface WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditions {
    conditions: outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCondition[];
}

export interface WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCondition {
    operand1: string;
    operand2?: string;
    operator: string;
}

export interface WebApplicationUserTags {
    /**
     * User tag settings
     */
    tags: outputs.WebApplicationUserTagsTag[];
}

export interface WebApplicationUserTagsTag {
    cleanupRule?: string;
    /**
     * The ID of this resource.
     */
    id?: number;
    ignoreCase?: boolean;
    metadataId?: number;
    serverSideRequestAttribute?: string;
    uniqueId: number;
}

export interface WebApplicationWaterfallSettings {
    /**
     * Warn about resources with a lower browser cache rate above *X*%. Values between 1 and 100 are allowed.
     */
    resourceBrowserCachingThreshold: number;
    /**
     * Warn about resources larger than *X* bytes. Values between 0 and 99999000 are allowed.
     */
    resourcesThreshold: number;
    /**
     * Warn about slow CDN resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
     */
    slowCndResourcesThreshold: number;
    /**
     * Warn about slow 1st party resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
     */
    slowFirstPartyResourcesThreshold: number;
    /**
     * Warn about slow 3rd party resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
     */
    slowThirdPartyResourcesThreshold: number;
    /**
     * Warn if Speed index exceeds *X* % of Visually complete. Values between 1 and 99 are allowed.
     */
    speedIndexVisuallyCompleteRatioThreshold: number;
    /**
     * Warn about uncompressed resources larger than *X* bytes. Values between 0 and 99999 are allowed.
     */
    uncompressedResourcesThreshold: number;
}

export interface WebApplicationXhrActionApdexSettings {
    /**
     * Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
     */
    frustratingFallbackThreshold?: number;
    /**
     * Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
     */
    frustratingThreshold?: number;
    /**
     * no documentation available
     */
    threshold?: number;
    /**
     * Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
     */
    toleratedFallbackThreshold?: number;
    /**
     * Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
     */
    toleratedThreshold?: number;
}

export interface WebhookNotificationHeaders {
    /**
     * An additional HTTP Header to include when sending requests
     */
    headers: outputs.WebhookNotificationHeadersHeader[];
}

export interface WebhookNotificationHeadersHeader {
    /**
     * The name of the notification configuration
     */
    name: string;
    secretValue?: string;
    value?: string;
}

export interface XmattersNotificationHeaders {
    /**
     * An additional HTTP Header to include when sending requests
     */
    headers: outputs.XmattersNotificationHeadersHeader[];
}

export interface XmattersNotificationHeadersHeader {
    /**
     * The name of the notification configuration
     */
    name: string;
    secretValue?: string;
    value?: string;
}

