// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AlertingFilters {
    /**
     * A conditions for the metric usage
     */
    filters?: outputs.AlertingFiltersFilter[];
}

export interface AlertingFiltersFilter {
    custom?: outputs.AlertingFiltersFilterCustom;
    predefined?: outputs.AlertingFiltersFilterPredefined;
}

export interface AlertingFiltersFilterCustom {
    description?: outputs.AlertingFiltersFilterCustomDescription;
    title?: outputs.AlertingFiltersFilterCustomTitle;
}

export interface AlertingFiltersFilterCustomDescription {
    caseSensitive?: boolean;
    enabled?: boolean;
    negate?: boolean;
    operator: string;
    value: string;
}

export interface AlertingFiltersFilterCustomTitle {
    caseSensitive?: boolean;
    enabled?: boolean;
    negate?: boolean;
    operator: string;
    value: string;
}

export interface AlertingFiltersFilterPredefined {
    negate?: boolean;
    type: string;
}

export interface AlertingProfileEventTypeFilter {
    /**
     * Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
     */
    customEventFilters?: outputs.AlertingProfileEventTypeFilterCustomEventFilter[];
    /**
     * Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
     */
    predefinedEventFilters?: outputs.AlertingProfileEventTypeFilterPredefinedEventFilter[];
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface AlertingProfileEventTypeFilterCustomEventFilter {
    customDescriptionFilters?: outputs.AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter[];
    customTitleFilters?: outputs.AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter[];
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter {
    caseInsensitive?: boolean;
    enabled?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    value: string;
}

export interface AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter {
    caseInsensitive?: boolean;
    enabled?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    value: string;
}

export interface AlertingProfileEventTypeFilterPredefinedEventFilter {
    eventType: string;
    negate?: boolean;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface AlertingProfileMetadata {
    /**
     * Dynatrace server version
     */
    clusterVersion?: string;
    /**
     * A Sorted list of the version numbers of the configuration
     */
    configurationVersions?: number[];
    /**
     * A Sorted list of the version numbers of the configuration
     */
    currentConfigurationVersions?: string[];
}

export interface AlertingProfileRule {
    /**
     * Send a notification if a problem remains open longer than *X* minutes
     */
    delayInMinutes: number;
    /**
     * The severity level to trigger the alert. Possible values are `AVAILABILITY`,	`CUSTOM_ALERT`,	`ERROR`,`MONITORING_UNAVAILABLE`,`PERFORMANCE` and `RESOURCE_CONTENTION`.
     */
    severityLevel: string;
    /**
     * Configuration of the tag filtering of the alerting profile
     */
    tagFilters: outputs.AlertingProfileRuleTagFilter[];
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface AlertingProfileRuleTagFilter {
    includeMode: string;
    tagFilters?: outputs.AlertingProfileRuleTagFilterTagFilter[];
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface AlertingProfileRuleTagFilterTagFilter {
    context: string;
    key: string;
    value?: string;
}

export interface AlertingRules {
    /**
     * A conditions for the metric usage
     */
    rules?: outputs.AlertingRulesRule[];
}

export interface AlertingRulesRule {
    delayInMinutes: number;
    includeMode: string;
    severityLevel: string;
    tags?: string[];
}

export interface ApplicationAnomaliesFailureRate {
    /**
     * Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
     */
    auto?: outputs.ApplicationAnomaliesFailureRateAuto;
    /**
     * Fixed thresholds for failure rate increase detection
     */
    thresholds?: outputs.ApplicationAnomaliesFailureRateThresholds;
}

export interface ApplicationAnomaliesFailureRateAuto {
    absolute: number;
    relative: number;
    unknowns?: string;
}

export interface ApplicationAnomaliesFailureRateThresholds {
    sensitivity: string;
    threshold: number;
    unknowns?: string;
}

export interface ApplicationAnomaliesResponseTime {
    /**
     * Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
     */
    auto?: outputs.ApplicationAnomaliesResponseTimeAuto;
    /**
     * Fixed thresholds for response time degradation detection
     */
    thresholds?: outputs.ApplicationAnomaliesResponseTimeThresholds;
}

export interface ApplicationAnomaliesResponseTimeAuto {
    load: string;
    milliseconds: number;
    percent: number;
    slowestMilliseconds: number;
    slowestPercent: number;
    unknowns?: string;
}

export interface ApplicationAnomaliesResponseTimeThresholds {
    load: string;
    milliseconds: number;
    sensitivity: string;
    slowestMilliseconds: number;
    unknowns?: string;
}

export interface ApplicationAnomaliesTraffic {
    /**
     * The configuration of traffic drops detection
     */
    drops?: outputs.ApplicationAnomaliesTrafficDrops;
    /**
     * The configuration of traffic spikes detection
     */
    spikes?: outputs.ApplicationAnomaliesTrafficSpikes;
}

export interface ApplicationAnomaliesTrafficDrops {
    enabled: boolean;
    percent?: number;
}

export interface ApplicationAnomaliesTrafficSpikes {
    enabled: boolean;
    percent?: number;
}

export interface ApplicationDataPrivacySessionReplayDataPrivacy {
    /**
     * Content masking settings for Session Replay.
     */
    contentMaskingSettings: outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettings;
    optIn?: boolean;
    urlExclusionRules?: string[];
}

export interface ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettings {
    playback: outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlayback;
    recording: outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecording;
}

export interface ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlayback {
    preset: string;
    rules?: outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRules;
}

export interface ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRules {
    rules: outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule[];
}

export interface ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule {
    selector: string;
    type: string;
    userInteractionHidden?: boolean;
}

export interface ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecording {
    preset: string;
    rules?: outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRules;
}

export interface ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRules {
    rules: outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule[];
}

export interface ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule {
    selector: string;
    type: string;
    userInteractionHidden?: boolean;
}

export interface ApplicationDetectionRuleFilterConfig {
    /**
     * Where to look for the pattern value, possible values are `DOMAIN` or `URL`
     */
    applicationMatchTarget: string;
    /**
     * The operator used for matching the application detection rule, possible values are `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`, `MATCHES`
     */
    applicationMatchType: string;
    /**
     * The value to look for with the application detection rule
     */
    pattern: string;
}

export interface ApplicationErrorRulesCustomErrors {
    /**
     * Configuration of the custom error in the web application
     */
    rules: outputs.ApplicationErrorRulesCustomErrorsRule[];
}

export interface ApplicationErrorRulesCustomErrorsRule {
    capture?: boolean;
    customAlerting?: boolean;
    impactApdex?: boolean;
    keyMatcher?: string;
    keyPattern?: string;
    valueMatcher?: string;
    valuePattern?: string;
}

export interface ApplicationErrorRulesHttpErrors {
    /**
     * Configuration of the HTTP error in the web application
     */
    rules: outputs.ApplicationErrorRulesHttpErrorsRule[];
}

export interface ApplicationErrorRulesHttpErrorsRule {
    capture?: boolean;
    considerBlockedRequests?: boolean;
    considerForAi?: boolean;
    considerUnknownErrorCode?: boolean;
    errorCodes?: string;
    filter?: string;
    filterByUrl?: boolean;
    impactApdex?: boolean;
    url?: string;
}

export interface AutotagEntitySelectorBasedRule {
    enabled?: boolean;
    normalization?: string;
    selector?: string;
    unknowns?: string;
    valueFormat?: string;
}

export interface AutotagMetadata {
    clusterVersion?: string;
    configurationVersions?: number[];
    currentConfigurationVersions?: string[];
}

export interface AutotagRule {
    conditions?: outputs.AutotagRuleCondition[];
    enabled?: boolean;
    normalization?: string;
    propagationTypes?: string[];
    type: string;
    unknowns?: string;
    valueFormat?: string;
}

export interface AutotagRuleCondition {
    /**
     * @deprecated You should use 'application_type' instead of 'application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    applicationTypeComparisons?: outputs.AutotagRuleConditionApplicationTypeComparison[];
    applicationTypes?: outputs.AutotagRuleConditionApplicationType[];
    azureComputeModeComparisons?: outputs.AutotagRuleConditionAzureComputeModeComparison[];
    /**
     * @deprecated You should use 'azure_compute_mode' instead of 'azure_compute_mode_comparison'. This attribute still exists for backwards compatibility.
     */
    azureComputeModes?: outputs.AutotagRuleConditionAzureComputeMode[];
    /**
     * @deprecated You should use 'azure_sku' instead of 'azure_sku_comparision'. This attribute still exists for backwards compatibility.
     */
    azureSkuComparisions?: outputs.AutotagRuleConditionAzureSkuComparision[];
    azureSkus?: outputs.AutotagRuleConditionAzureSkus[];
    /**
     * @deprecated You should use 'comparison' instead of 'base_comparison_basic'. This attribute still exists for backwards compatibility.
     */
    baseComparisonBasics?: outputs.AutotagRuleConditionBaseComparisonBasic[];
    /**
     * @deprecated 'base_condition_key' is deprecated. You should use 'key'
     */
    baseConditionKeys?: outputs.AutotagRuleConditionBaseConditionKey[];
    /**
     * @deprecated You should use 'bitness' instead of 'bitness_comparision'. This attribute still exists for backwards compatibility.
     */
    bitnessComparisions?: outputs.AutotagRuleConditionBitnessComparision[];
    bitnesses?: outputs.AutotagRuleConditionBitness[];
    /**
     * @deprecated You should use 'cloud_type' instead of 'cloud_type_comparison'. This attribute still exists for backwards compatibility.
     */
    cloudTypeComparisons?: outputs.AutotagRuleConditionCloudTypeComparison[];
    cloudTypes?: outputs.AutotagRuleConditionCloudType[];
    comparisons?: outputs.AutotagRuleConditionComparison[];
    /**
     * @deprecated You should use 'custom_application_type' instead of 'custom_application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    customApplicationTypeComparisons?: outputs.AutotagRuleConditionCustomApplicationTypeComparison[];
    customApplicationTypes?: outputs.AutotagRuleConditionCustomApplicationType[];
    /**
     * @deprecated 'custom_host_metadata_condition_key' is deprecated. You should use 'custom_host_metadata'
     */
    customHostMetadataConditionKeys?: outputs.AutotagRuleConditionCustomHostMetadataConditionKey[];
    customHostMetadatas?: outputs.AutotagRuleConditionCustomHostMetadata[];
    /**
     * @deprecated 'custom_process_metadata_condition_key' is deprecated. You should use 'custom_process_metadata'
     */
    customProcessMetadataConditionKeys?: outputs.AutotagRuleConditionCustomProcessMetadataConditionKey[];
    customProcessMetadatas?: outputs.AutotagRuleConditionCustomProcessMetadata[];
    databaseTopologies?: outputs.AutotagRuleConditionDatabaseTopology[];
    /**
     * @deprecated You should use 'database_topology' instead of 'database_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    databaseTopologyComparisons?: outputs.AutotagRuleConditionDatabaseTopologyComparison[];
    /**
     * @deprecated You should use 'dcrum_decoder' instead of 'dcrum_decoder_comparison'. This attribute still exists for backwards compatibility.
     */
    dcrumDecoderComparisons?: outputs.AutotagRuleConditionDcrumDecoderComparison[];
    dcrumDecoders?: outputs.AutotagRuleConditionDcrumDecoder[];
    entities?: outputs.AutotagRuleConditionEntity[];
    /**
     * @deprecated You should use 'entity' instead of 'entity_id_comparison'. This attribute still exists for backwards compatibility.
     */
    entityIdComparisons?: outputs.AutotagRuleConditionEntityIdComparison[];
    hostTeches?: outputs.AutotagRuleConditionHostTech[];
    /**
     * @deprecated `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
     */
    hypervisorTypeComparisions?: outputs.AutotagRuleConditionHypervisorTypeComparision[];
    hypervisors?: outputs.AutotagRuleConditionHypervisor[];
    /**
     * @deprecated You should use 'indexed_name' instead of 'indexed_name_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedNameComparisons?: outputs.AutotagRuleConditionIndexedNameComparison[];
    indexedNames?: outputs.AutotagRuleConditionIndexedName[];
    /**
     * @deprecated You should use 'indexed_string' instead of 'indexed_string_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedStringComparisons?: outputs.AutotagRuleConditionIndexedStringComparison[];
    indexedStrings?: outputs.AutotagRuleConditionIndexedString[];
    /**
     * @deprecated You should use 'indexed_tag' instead of 'indexed_tag_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedTagComparisons?: outputs.AutotagRuleConditionIndexedTagComparison[];
    indexedTags?: outputs.AutotagRuleConditionIndexedTag[];
    /**
     * @deprecated You should use 'integer' instead of 'integer_comparison'. This attribute still exists for backwards compatibility.
     */
    integerComparisons?: outputs.AutotagRuleConditionIntegerComparison[];
    integers?: outputs.AutotagRuleConditionInteger[];
    /**
     * @deprecated You should use 'ipaddress' instead of 'ipaddress_comparison'. This attribute still exists for backwards compatibility.
     */
    ipaddressComparisons?: outputs.AutotagRuleConditionIpaddressComparison[];
    ipaddresses?: outputs.AutotagRuleConditionIpaddress[];
    keys?: outputs.AutotagRuleConditionKey[];
    /**
     * @deprecated You should use 'mobile_platform' instead of 'mobile_platform_comparison'. This attribute still exists for backwards compatibility.
     */
    mobilePlatformComparisons?: outputs.AutotagRuleConditionMobilePlatformComparison[];
    mobilePlatforms?: outputs.AutotagRuleConditionMobilePlatform[];
    osArches?: outputs.AutotagRuleConditionOsArch[];
    osTypes?: outputs.AutotagRuleConditionOsType[];
    /**
     * @deprecated You should use 'os_arch' instead of 'osarchitecture_comparison'. This attribute still exists for backwards compatibility.
     */
    osarchitectureComparisons?: outputs.AutotagRuleConditionOsarchitectureComparison[];
    /**
     * @deprecated You should use 'os_type' instead of 'ostype_comparison'. This attribute still exists for backwards compatibility.
     */
    ostypeComparisons?: outputs.AutotagRuleConditionOstypeComparison[];
    /**
     * @deprecated You should use 'paas_type' instead of 'paas_type_comparison'. This attribute still exists for backwards compatibility.
     */
    paasTypeComparisons?: outputs.AutotagRuleConditionPaasTypeComparison[];
    paasTypes?: outputs.AutotagRuleConditionPaasType[];
    /**
     * @deprecated 'process_metadata_condition_key' is deprecated. You should use 'process_metadata'
     */
    processMetadataConditionKeys?: outputs.AutotagRuleConditionProcessMetadataConditionKey[];
    processMetadatas?: outputs.AutotagRuleConditionProcessMetadata[];
    serviceTopologies?: outputs.AutotagRuleConditionServiceTopology[];
    /**
     * @deprecated You should use 'service_topology' instead of 'service_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTopologyComparisons?: outputs.AutotagRuleConditionServiceTopologyComparison[];
    /**
     * @deprecated You should use 'service_type' instead of 'service_type_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTypeComparisons?: outputs.AutotagRuleConditionServiceTypeComparison[];
    serviceTypes?: outputs.AutotagRuleConditionServiceType[];
    /**
     * @deprecated You should use 'host_tech' instead of 'simple_host_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleHostTechComparisons?: outputs.AutotagRuleConditionSimpleHostTechComparison[];
    /**
     * @deprecated You should use 'tech' instead of 'simple_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleTechComparisons?: outputs.AutotagRuleConditionSimpleTechComparison[];
    /**
     * @deprecated You should use 'string' instead of 'string_comparison'. This attribute still exists for backwards compatibility.
     */
    stringComparisons?: outputs.AutotagRuleConditionStringComparison[];
    /**
     * @deprecated 'string_condition_key' is deprecated. You should use 'string_key'
     */
    stringConditionKeys?: outputs.AutotagRuleConditionStringConditionKey[];
    stringKeys?: outputs.AutotagRuleConditionStringKey[];
    strings?: outputs.AutotagRuleConditionString[];
    /**
     * @deprecated You should use 'synthetic_engine' instead of 'synthetic_engine_type_comparison'. This attribute still exists for backwards compatibility.
     */
    syntheticEngineTypeComparisons?: outputs.AutotagRuleConditionSyntheticEngineTypeComparison[];
    syntheticEngines?: outputs.AutotagRuleConditionSyntheticEngine[];
    /**
     * @deprecated You should use 'tag' instead of 'tag_comparison'. This attribute still exists for backwards compatibility.
     */
    tagComparisons?: outputs.AutotagRuleConditionTagComparison[];
    tags?: outputs.AutotagRuleConditionTag[];
    teches?: outputs.AutotagRuleConditionTech[];
    unknowns?: string;
}

export interface AutotagRuleConditionApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionAzureComputeMode {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionAzureComputeModeComparison {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionAzureSkuComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionAzureSkus {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionBaseComparisonBasic {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface AutotagRuleConditionBaseConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface AutotagRuleConditionBitness {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionBitnessComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionCloudType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionCloudTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionComparison {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface AutotagRuleConditionCustomApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionCustomApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionCustomHostMetadata {
    attribute: string;
    dynamicKey: outputs.AutotagRuleConditionCustomHostMetadataDynamicKey;
    unknowns?: string;
}

export interface AutotagRuleConditionCustomHostMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.AutotagRuleConditionCustomHostMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface AutotagRuleConditionCustomHostMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface AutotagRuleConditionCustomHostMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface AutotagRuleConditionCustomProcessMetadata {
    attribute: string;
    dynamicKey: outputs.AutotagRuleConditionCustomProcessMetadataDynamicKey;
    unknowns?: string;
}

export interface AutotagRuleConditionCustomProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.AutotagRuleConditionCustomProcessMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface AutotagRuleConditionCustomProcessMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface AutotagRuleConditionCustomProcessMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface AutotagRuleConditionDatabaseTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionDatabaseTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionDcrumDecoder {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionDcrumDecoderComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionEntity {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionEntityIdComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionHostTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.AutotagRuleConditionHostTechValue;
}

export interface AutotagRuleConditionHostTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface AutotagRuleConditionHypervisor {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionHypervisorTypeComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionIndexedName {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionIndexedNameComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionIndexedString {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionIndexedStringComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionIndexedTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.AutotagRuleConditionIndexedTagValue;
}

export interface AutotagRuleConditionIndexedTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.AutotagRuleConditionIndexedTagComparisonValue;
}

export interface AutotagRuleConditionIndexedTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionIndexedTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionInteger {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: number;
}

export interface AutotagRuleConditionIntegerComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: number;
}

export interface AutotagRuleConditionIpaddress {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionIpaddressComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface AutotagRuleConditionMobilePlatform {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionMobilePlatformComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionOsArch {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionOsType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionOsarchitectureComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionOstypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionPaasType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionPaasTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionProcessMetadata {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface AutotagRuleConditionProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface AutotagRuleConditionServiceTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionServiceTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionServiceType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionServiceTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionSimpleHostTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.AutotagRuleConditionSimpleHostTechComparisonValue;
}

export interface AutotagRuleConditionSimpleHostTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface AutotagRuleConditionSimpleTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.AutotagRuleConditionSimpleTechComparisonValue;
}

export interface AutotagRuleConditionSimpleTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface AutotagRuleConditionString {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionStringComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionStringConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface AutotagRuleConditionStringKey {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface AutotagRuleConditionSyntheticEngine {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionSyntheticEngineTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.AutotagRuleConditionTagValue;
}

export interface AutotagRuleConditionTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.AutotagRuleConditionTagComparisonValue;
}

export interface AutotagRuleConditionTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface AutotagRuleConditionTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.AutotagRuleConditionTechValue;
}

export interface AutotagRuleConditionTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface AwsCredentialsAuthenticationData {
    /**
     * the access key
     */
    accessKey?: string;
    /**
     * the ID of the Amazon account
     */
    accountId?: string;
    /**
     * the external ID token for setting an IAM role. You can obtain it with the `GET /aws/iamExternalId` request
     */
    externalId?: string;
    /**
     * the IAM role to be used by Dynatrace to get monitoring data
     */
    iamRole?: string;
    /**
     * the secret access key
     */
    secretKey?: string;
    /**
     * Any attributes that aren't yet supported by this provider
     */
    unknowns?: string;
}

export interface AwsCredentialsSupportingServicesToMonitor {
    /**
     * a list of metrics to be monitored for this service
     */
    monitoredMetrics?: outputs.AwsCredentialsSupportingServicesToMonitorMonitoredMetric[];
    /**
     * the name of the supporting service
     */
    name?: string;
    /**
     * Any attributes that aren't yet supported by this provider
     */
    unknowns?: string;
}

export interface AwsCredentialsSupportingServicesToMonitorMonitoredMetric {
    dimensions?: string[];
    name?: string;
    statistic?: string;
    /**
     * Any attributes that aren't yet supported by this provider
     */
    unknowns?: string;
}

export interface AwsCredentialsTagsToMonitor {
    /**
     * the key of the AWS tag.
     */
    name?: string;
    /**
     * Any attributes that aren't yet supported by this provider
     */
    unknowns?: string;
    /**
     * the value of the AWS tag
     */
    value?: string;
}

export interface AzureCredentialsMonitorOnlyExcludingTagPair {
    /**
     * The name of the tag.
     */
    name?: string;
    /**
     * Any attributes that aren't yet supported by this provider
     */
    unknowns?: string;
    /**
     * The value of the tag.   If set to `null`, then resources with any value of the tag are monitored.
     */
    value?: string;
}

export interface AzureCredentialsMonitorOnlyTagPair {
    /**
     * The name of the tag.
     */
    name?: string;
    /**
     * Any attributes that aren't yet supported by this provider
     */
    unknowns?: string;
    /**
     * The value of the tag.   If set to `null`, then resources with any value of the tag are monitored.
     */
    value?: string;
}

export interface AzureCredentialsSupportingService {
    /**
     * A list of Azure tags to be monitored.  You can specify up to 10 tags. A resource tagged with *any* of the specified tags is monitored.  Only applicable when the **monitorOnlyTaggedEntities** parameter is set to `true`
     */
    monitoredMetrics?: outputs.AzureCredentialsSupportingServiceMonitoredMetric[];
    /**
     * The name of the supporting service.
     */
    name?: string;
    /**
     * Any attributes that aren't yet supported by this provider
     */
    unknowns?: string;
}

export interface AzureCredentialsSupportingServiceMonitoredMetric {
    dimensions?: string[];
    name?: string;
    /**
     * Any attributes that aren't yet supported by this provider
     */
    unknowns?: string;
}

export interface BrowserMonitorAnomalyDetection {
    /**
     * Thresholds for loading times
     */
    loadingTimeThresholds?: outputs.BrowserMonitorAnomalyDetectionLoadingTimeThreshold[];
    /**
     * Outage handling configuration
     */
    outageHandlings?: outputs.BrowserMonitorAnomalyDetectionOutageHandling[];
}

export interface BrowserMonitorAnomalyDetectionLoadingTimeThreshold {
    enabled?: boolean;
    thresholds?: outputs.BrowserMonitorAnomalyDetectionLoadingTimeThresholdThreshold[];
}

export interface BrowserMonitorAnomalyDetectionLoadingTimeThresholdThreshold {
    thresholds: outputs.BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold[];
}

export interface BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold {
    eventIndex?: number;
    requestIndex?: number;
    type?: string;
    valueMs: number;
}

export interface BrowserMonitorAnomalyDetectionOutageHandling {
    globalOutage?: boolean;
    localOutage?: boolean;
    localOutagePolicies?: outputs.BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy[];
    retryOnError?: boolean;
}

export interface BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy {
    affectedLocations: number;
    consecutiveRuns: number;
}

export interface BrowserMonitorKeyPerformanceMetrics {
    /**
     * Defines the key performance metric for load actions. Supported values are `VISUALLY_COMPLETE`, `SPEED_INDEX`, `USER_ACTION_DURATION`, `TIME_TO_FIRST_BYTE`, `HTML_DOWNLOADED`, `DOM_INTERACTIVE`, `LOAD_EVENT_START` and `LOAD_EVENT_END`.
     */
    loadActionKpm: string;
    /**
     * Defines the key performance metric for XHR actions. Supported values are `VISUALLY_COMPLETE`, `USER_ACTION_DURATION`, `TIME_TO_FIRST_BYTE` and `RESPONSE_END`.
     */
    xhrActionKpm: string;
}

export interface BrowserMonitorScript {
    /**
     * The setup of the monitor
     */
    configuration?: outputs.BrowserMonitorScriptConfiguration;
    /**
     * Steps of the clickpathâ€”the first step must always be of the `navigate` type
     */
    events?: outputs.BrowserMonitorScriptEvents;
    /**
     * The type of monitor. Possible values are `clickpath` for clickpath monitors and `availability` for single-URL browser monitors. These monitors are only allowed to have one event of the `navigate` type
     */
    type: string;
}

export interface BrowserMonitorScriptConfiguration {
    bandwidth?: outputs.BrowserMonitorScriptConfigurationBandwidth;
    blocks?: string[];
    bypassCsp?: boolean;
    cookies?: outputs.BrowserMonitorScriptConfigurationCookies;
    device?: outputs.BrowserMonitorScriptConfigurationDevice;
    disableWebSecurity?: boolean;
    headers?: outputs.BrowserMonitorScriptConfigurationHeaders;
    ignoredErrorCodes?: outputs.BrowserMonitorScriptConfigurationIgnoredErrorCodes;
    javascriptSetttings?: outputs.BrowserMonitorScriptConfigurationJavascriptSetttings;
    monitorFrames?: boolean;
    userAgent?: string;
}

export interface BrowserMonitorScriptConfigurationBandwidth {
    download?: number;
    latency?: number;
    networkType?: string;
    upload?: number;
}

export interface BrowserMonitorScriptConfigurationCookies {
    cookies: outputs.BrowserMonitorScriptConfigurationCookiesCookie[];
}

export interface BrowserMonitorScriptConfigurationCookiesCookie {
    domain: string;
    name: string;
    path?: string;
    value: string;
}

export interface BrowserMonitorScriptConfigurationDevice {
    height?: number;
    mobile?: boolean;
    name?: string;
    orientation?: string;
    scaleFactor?: number;
    touchEnabled?: boolean;
    width?: number;
}

export interface BrowserMonitorScriptConfigurationHeaders {
    headers: outputs.BrowserMonitorScriptConfigurationHeadersHeader[];
    restrictions?: string[];
}

export interface BrowserMonitorScriptConfigurationHeadersHeader {
    name: string;
    value: string;
}

export interface BrowserMonitorScriptConfigurationIgnoredErrorCodes {
    matchingDocumentRequests?: string;
    statusCodes: string;
}

export interface BrowserMonitorScriptConfigurationJavascriptSetttings {
    customProperties?: string;
    timeoutSettings?: outputs.BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings;
    visuallyCompleteOptions?: outputs.BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions;
}

export interface BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings {
    actionLimit: number;
    totalTimeout: number;
}

export interface BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions {
    excludedElements?: string[];
    excludedUrls?: string[];
    imageSizeThreshold: number;
    inactivityTimeout: number;
    mutationTimeout: number;
}

export interface BrowserMonitorScriptEvents {
    events?: outputs.BrowserMonitorScriptEventsEvent[];
}

export interface BrowserMonitorScriptEventsEvent {
    click?: outputs.BrowserMonitorScriptEventsEventClick;
    cookie?: outputs.BrowserMonitorScriptEventsEventCookie;
    description: string;
    javascript?: outputs.BrowserMonitorScriptEventsEventJavascript;
    keystrokes?: outputs.BrowserMonitorScriptEventsEventKeystrokes;
    navigate?: outputs.BrowserMonitorScriptEventsEventNavigate;
    select?: outputs.BrowserMonitorScriptEventsEventSelect;
    tap?: outputs.BrowserMonitorScriptEventsEventTap;
}

export interface BrowserMonitorScriptEventsEventClick {
    button: number;
    target?: outputs.BrowserMonitorScriptEventsEventClickTarget;
    validate?: outputs.BrowserMonitorScriptEventsEventClickValidate;
    wait?: outputs.BrowserMonitorScriptEventsEventClickWait;
}

export interface BrowserMonitorScriptEventsEventClickTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventClickTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventClickTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventClickTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventClickTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventClickValidate {
    validations: outputs.BrowserMonitorScriptEventsEventClickValidateValidation[];
}

export interface BrowserMonitorScriptEventsEventClickValidateValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventClickValidateValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventClickValidateValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventClickValidateValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventClickValidateValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventClickValidateValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventClickValidateValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventClickWait {
    milliseconds?: number;
    timeout?: number;
    validation?: outputs.BrowserMonitorScriptEventsEventClickWaitValidation;
    waitFor: string;
}

export interface BrowserMonitorScriptEventsEventClickWaitValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventClickWaitValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventClickWaitValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventClickWaitValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventClickWaitValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventClickWaitValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventClickWaitValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventCookie {
    cookies: outputs.BrowserMonitorScriptEventsEventCookieCookies;
}

export interface BrowserMonitorScriptEventsEventCookieCookies {
    cookies: outputs.BrowserMonitorScriptEventsEventCookieCookiesCookie[];
}

export interface BrowserMonitorScriptEventsEventCookieCookiesCookie {
    domain: string;
    name: string;
    path?: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventJavascript {
    code: string;
    target?: outputs.BrowserMonitorScriptEventsEventJavascriptTarget;
    wait?: outputs.BrowserMonitorScriptEventsEventJavascriptWait;
}

export interface BrowserMonitorScriptEventsEventJavascriptTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventJavascriptTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventJavascriptTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventJavascriptTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventJavascriptTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventJavascriptWait {
    milliseconds?: number;
    timeout?: number;
    validation?: outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidation;
    waitFor: string;
}

export interface BrowserMonitorScriptEventsEventJavascriptWaitValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventJavascriptWaitValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokes {
    credential?: outputs.BrowserMonitorScriptEventsEventKeystrokesCredential;
    masked?: boolean;
    simulateBlurEvent?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventKeystrokesTarget;
    text?: string;
    validate?: outputs.BrowserMonitorScriptEventsEventKeystrokesValidate;
    wait?: outputs.BrowserMonitorScriptEventsEventKeystrokesWait;
}

export interface BrowserMonitorScriptEventsEventKeystrokesCredential {
    field: string;
    vaultId: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokesTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventKeystrokesTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokesTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventKeystrokesTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventKeystrokesTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokesValidate {
    validations: outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidation[];
}

export interface BrowserMonitorScriptEventsEventKeystrokesValidateValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokesValidateValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokesWait {
    milliseconds?: number;
    timeout?: number;
    validation?: outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidation;
    waitFor: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokesWaitValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokesWaitValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventNavigate {
    authentication?: outputs.BrowserMonitorScriptEventsEventNavigateAuthentication;
    target?: outputs.BrowserMonitorScriptEventsEventNavigateTarget;
    url: string;
    validate?: outputs.BrowserMonitorScriptEventsEventNavigateValidate;
    wait?: outputs.BrowserMonitorScriptEventsEventNavigateWait;
}

export interface BrowserMonitorScriptEventsEventNavigateAuthentication {
    creds: string;
    type: string;
}

export interface BrowserMonitorScriptEventsEventNavigateTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventNavigateTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventNavigateTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventNavigateTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventNavigateTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventNavigateValidate {
    validations: outputs.BrowserMonitorScriptEventsEventNavigateValidateValidation[];
}

export interface BrowserMonitorScriptEventsEventNavigateValidateValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventNavigateValidateValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventNavigateWait {
    milliseconds?: number;
    timeout?: number;
    validation?: outputs.BrowserMonitorScriptEventsEventNavigateWaitValidation;
    waitFor: string;
}

export interface BrowserMonitorScriptEventsEventNavigateWaitValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventNavigateWaitValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventSelect {
    selections: outputs.BrowserMonitorScriptEventsEventSelectSelections;
    target?: outputs.BrowserMonitorScriptEventsEventSelectTarget;
    validate?: outputs.BrowserMonitorScriptEventsEventSelectValidate;
    wait?: outputs.BrowserMonitorScriptEventsEventSelectWait;
}

export interface BrowserMonitorScriptEventsEventSelectSelections {
    options: outputs.BrowserMonitorScriptEventsEventSelectSelectionsOption[];
}

export interface BrowserMonitorScriptEventsEventSelectSelectionsOption {
    index: number;
    value: string;
}

export interface BrowserMonitorScriptEventsEventSelectTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventSelectTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventSelectTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventSelectTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventSelectTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventSelectValidate {
    validations: outputs.BrowserMonitorScriptEventsEventSelectValidateValidation[];
}

export interface BrowserMonitorScriptEventsEventSelectValidateValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventSelectValidateValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventSelectWait {
    milliseconds?: number;
    timeout?: number;
    validation?: outputs.BrowserMonitorScriptEventsEventSelectWaitValidation;
    waitFor: string;
}

export interface BrowserMonitorScriptEventsEventSelectWaitValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventSelectWaitValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventTap {
    button: number;
    target?: outputs.BrowserMonitorScriptEventsEventTapTarget;
    validate?: outputs.BrowserMonitorScriptEventsEventTapValidate;
    wait?: outputs.BrowserMonitorScriptEventsEventTapWait;
}

export interface BrowserMonitorScriptEventsEventTapTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventTapTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventTapTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventTapTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventTapTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventTapValidate {
    validations: outputs.BrowserMonitorScriptEventsEventTapValidateValidation[];
}

export interface BrowserMonitorScriptEventsEventTapValidateValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventTapValidateValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventTapValidateValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventTapValidateValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventTapValidateValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventTapValidateValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventTapValidateValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorScriptEventsEventTapWait {
    milliseconds?: number;
    timeout?: number;
    validation?: outputs.BrowserMonitorScriptEventsEventTapWaitValidation;
    waitFor: string;
}

export interface BrowserMonitorScriptEventsEventTapWaitValidation {
    failIfFound?: boolean;
    match?: string;
    regex?: boolean;
    target?: outputs.BrowserMonitorScriptEventsEventTapWaitValidationTarget;
    type: string;
}

export interface BrowserMonitorScriptEventsEventTapWaitValidationTarget {
    locators?: outputs.BrowserMonitorScriptEventsEventTapWaitValidationTargetLocator[];
    window?: string;
}

export interface BrowserMonitorScriptEventsEventTapWaitValidationTargetLocator {
    locators: outputs.BrowserMonitorScriptEventsEventTapWaitValidationTargetLocatorLocator[];
}

export interface BrowserMonitorScriptEventsEventTapWaitValidationTargetLocatorLocator {
    type: string;
    value: string;
}

export interface BrowserMonitorTag {
    /**
     * Tag with source of a Dynatrace entity.
     */
    tags?: outputs.BrowserMonitorTagTag[];
}

export interface BrowserMonitorTagTag {
    context: string;
    key: string;
    source?: string;
    value?: string;
}

export interface CalculatedServiceMetricCondition {
    conditions?: outputs.CalculatedServiceMetricConditionCondition[];
}

export interface CalculatedServiceMetricConditionCondition {
    attribute: string;
    comparison: outputs.CalculatedServiceMetricConditionConditionComparison;
}

export interface CalculatedServiceMetricConditionConditionComparison {
    boolean?: outputs.CalculatedServiceMetricConditionConditionComparisonBoolean;
    esbInputNodeType?: outputs.CalculatedServiceMetricConditionConditionComparisonEsbInputNodeType;
    failedState?: outputs.CalculatedServiceMetricConditionConditionComparisonFailedState;
    failureReason?: outputs.CalculatedServiceMetricConditionConditionComparisonFailureReason;
    fastString?: outputs.CalculatedServiceMetricConditionConditionComparisonFastString;
    flawState?: outputs.CalculatedServiceMetricConditionConditionComparisonFlawState;
    generic?: outputs.CalculatedServiceMetricConditionConditionComparisonGeneric;
    httpMethod?: outputs.CalculatedServiceMetricConditionConditionComparisonHttpMethod;
    httpStatusClass?: outputs.CalculatedServiceMetricConditionConditionComparisonHttpStatusClass;
    iibInputNodeType?: outputs.CalculatedServiceMetricConditionConditionComparisonIibInputNodeType;
    negate?: boolean;
    number?: outputs.CalculatedServiceMetricConditionConditionComparisonNumber;
    numberRequestAttribute?: outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute;
    serviceType?: outputs.CalculatedServiceMetricConditionConditionComparisonServiceType;
    string?: outputs.CalculatedServiceMetricConditionConditionComparisonString;
    stringRequestAttribute?: outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute;
    tag?: outputs.CalculatedServiceMetricConditionConditionComparisonTag;
    zosCallType?: outputs.CalculatedServiceMetricConditionConditionComparisonZosCallType;
}

export interface CalculatedServiceMetricConditionConditionComparisonBoolean {
    operator?: string;
    unknowns?: string;
    value?: boolean;
    values?: boolean[];
}

export interface CalculatedServiceMetricConditionConditionComparisonEsbInputNodeType {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonFailedState {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonFailureReason {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonFastString {
    caseSensitive?: boolean;
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonFlawState {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonGeneric {
    type: string;
    unknowns?: string;
}

export interface CalculatedServiceMetricConditionConditionComparisonHttpMethod {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonHttpStatusClass {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonIibInputNodeType {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonNumber {
    operator?: string;
    unknowns?: string;
    value?: number;
    values?: number[];
}

export interface CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute {
    matchOnChildCalls?: boolean;
    operator?: string;
    requestAttribute: string;
    source?: outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource;
    unknowns?: string;
    value?: number;
    values?: number[];
}

export interface CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource {
    managementZone?: string;
    serviceTag?: outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag;
    unknowns?: string;
}

export interface CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag {
    context?: string;
    key: string;
    tagKey?: outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTagTagKey;
    value?: string;
}

export interface CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTagTagKey {
    context?: string;
    key?: string;
}

export interface CalculatedServiceMetricConditionConditionComparisonServiceType {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonString {
    caseSensitive?: boolean;
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute {
    caseSensitive?: boolean;
    matchOnChildCalls?: boolean;
    operator?: string;
    requestAttribute: string;
    source?: outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource {
    managementZone?: string;
    serviceTag?: outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag;
    unknowns?: string;
}

export interface CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag {
    context?: string;
    key: string;
    tagKey?: outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTagTagKey;
    value?: string;
}

export interface CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTagTagKey {
    context?: string;
    key?: string;
}

export interface CalculatedServiceMetricConditionConditionComparisonTag {
    operator?: string;
    unknowns?: string;
    value?: outputs.CalculatedServiceMetricConditionConditionComparisonTagValue;
    values?: outputs.CalculatedServiceMetricConditionConditionComparisonTagValues;
}

export interface CalculatedServiceMetricConditionConditionComparisonTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface CalculatedServiceMetricConditionConditionComparisonTagValues {
    values?: outputs.CalculatedServiceMetricConditionConditionComparisonTagValuesValue[];
}

export interface CalculatedServiceMetricConditionConditionComparisonTagValuesValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface CalculatedServiceMetricConditionConditionComparisonZosCallType {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface CalculatedServiceMetricDimensionDefinition {
    dimension: string;
    name: string;
    placeholders?: outputs.CalculatedServiceMetricDimensionDefinitionPlaceholders;
    topX: number;
    topXAggregation: string;
    topXDirection: string;
    unknowns?: string;
}

export interface CalculatedServiceMetricDimensionDefinitionPlaceholders {
    placeholders?: outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder[];
}

export interface CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder {
    aggregation?: string;
    attribute: string;
    delimiterOrRegex?: string;
    endDelimiter?: string;
    kind: string;
    name: string;
    normalization?: string;
    requestAttribute?: string;
    source?: outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource;
    unknowns?: string;
    useFromChildCalls?: boolean;
}

export interface CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource {
    managementZone?: string;
    serviceTag?: outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag;
    unknowns?: string;
}

export interface CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag {
    context?: string;
    key: string;
    tagKey?: outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKey;
    value?: string;
}

export interface CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKey {
    context?: string;
    key?: string;
}

export interface CalculatedServiceMetricMetricDefinition {
    metric: string;
    requestAttribute?: string;
}

export interface CustomAnomaliesDimension {
    /**
     * A generic definition for a filter
     */
    dimensions?: outputs.CustomAnomaliesDimensionDimension[];
    /**
     * A filter for the metrics entity dimensions
     */
    entities?: outputs.CustomAnomaliesDimensionEntity[];
    /**
     * A filter for the metrics string dimensions
     */
    strings?: outputs.CustomAnomaliesDimensionString[];
}

export interface CustomAnomaliesDimensionDimension {
    key?: string;
    type: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesDimensionEntity {
    filter: outputs.CustomAnomaliesDimensionEntityFilter;
    key?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesDimensionEntityFilter {
    operator: string;
    value: string;
}

export interface CustomAnomaliesDimensionString {
    filter: outputs.CustomAnomaliesDimensionStringFilter;
    key?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesDimensionStringFilter {
    operator: string;
    value: string;
}

export interface CustomAnomaliesScope {
    /**
     * A scope filter for the related custom device group name
     */
    customDeviceGroupNames?: outputs.CustomAnomaliesScopeCustomDeviceGroupName[];
    /**
     * A scope filter for a monitored entity identifier
     */
    entities?: outputs.CustomAnomaliesScopeEntity[];
    /**
     * A scope filter for the related host group name
     */
    hostGroupNames?: outputs.CustomAnomaliesScopeHostGroupName[];
    /**
     * A scope filter for the related host name
     */
    hostNames?: outputs.CustomAnomaliesScopeHostName[];
    /**
     * A scope filter for a management zone identifier
     */
    managementZones?: outputs.CustomAnomaliesScopeManagementZone[];
    /**
     * A scope filter for a monitored entity name
     */
    names?: outputs.CustomAnomaliesScopeName[];
    /**
     * A scope filter for a process group identifier
     */
    processGroupIds?: outputs.CustomAnomaliesScopeProcessGroupId[];
    /**
     * A scope filter for the related process group name
     */
    processGroupNames?: outputs.CustomAnomaliesScopeProcessGroupName[];
    /**
     * A generic scope filter
     */
    scopes?: outputs.CustomAnomaliesScopeScope[];
    /**
     * A scope filter for tags on entities
     */
    tags?: outputs.CustomAnomaliesScopeTag[];
}

export interface CustomAnomaliesScopeCustomDeviceGroupName {
    filter: outputs.CustomAnomaliesScopeCustomDeviceGroupNameFilter;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeCustomDeviceGroupNameFilter {
    operator: string;
    value: string;
}

export interface CustomAnomaliesScopeEntity {
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeHostGroupName {
    filter: outputs.CustomAnomaliesScopeHostGroupNameFilter;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeHostGroupNameFilter {
    operator: string;
    value: string;
}

export interface CustomAnomaliesScopeHostName {
    filter: outputs.CustomAnomaliesScopeHostNameFilter;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeHostNameFilter {
    operator: string;
    value: string;
}

export interface CustomAnomaliesScopeManagementZone {
    /**
     * The ID of this resource.
     */
    id?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeName {
    filter: outputs.CustomAnomaliesScopeNameFilter;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeNameFilter {
    operator: string;
    value: string;
}

export interface CustomAnomaliesScopeProcessGroupId {
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeProcessGroupName {
    filter: outputs.CustomAnomaliesScopeProcessGroupNameFilter;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeProcessGroupNameFilter {
    operator: string;
    value: string;
}

export interface CustomAnomaliesScopeScope {
    type: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeTag {
    filter: outputs.CustomAnomaliesScopeTagFilter;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesScopeTagFilter {
    context: string;
    key: string;
    value?: string;
}

export interface CustomAnomaliesStrategy {
    /**
     * An auto-adaptive baseline strategy to detect anomalies within metrics that show a regular change over time, as the baseline is also updated automatically. An example is to detect an anomaly in the number of received network packets or within the number of user actions over time
     */
    auto?: outputs.CustomAnomaliesStrategyAuto;
    /**
     * A generic monitoring strategy
     */
    generics?: outputs.CustomAnomaliesStrategyGeneric[];
    /**
     * A static threshold monitoring strategy to alert on hard limits within a given metric. An example is the violation of a critical memory limit
     */
    static?: outputs.CustomAnomaliesStrategyStatic;
}

export interface CustomAnomaliesStrategyAuto {
    alertCondition: string;
    alertingOnMissingData?: boolean;
    dealertingSamples: number;
    samples: number;
    signalFluctuations: number;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    violatingSamples: number;
}

export interface CustomAnomaliesStrategyGeneric {
    type: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomAnomaliesStrategyStatic {
    alertCondition: string;
    alertingOnMissingData?: boolean;
    dealertingSamples: number;
    samples: number;
    threshold: number;
    unit: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    violatingSamples: number;
}

export interface CustomServiceRule {
    /**
     * Additional annotations filter of the rule. Only classes where all listed annotations are available in the class itself or any of its superclasses are instrumented. Not applicable to PHP
     */
    annotations?: string[];
    /**
     * The fully qualified class or interface to instrument (or a substring if matching to a string). Required for Java and .NET custom services. Not applicable to PHP
     */
    class?: outputs.CustomServiceRuleClass;
    /**
     * Rule enabled/disabled
     */
    enabled: boolean;
    /**
     * The PHP file containing the class or methods to instrument. Required for PHP custom service. Not applicable to Java and .NET
     */
    file?: outputs.CustomServiceRuleFile;
    /**
     * The ID of the detection rule
     */
    id: string;
    /**
     * methods to instrument
     */
    methods: outputs.CustomServiceRuleMethod[];
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface CustomServiceRuleClass {
    match?: string;
    /**
     * The name of the custom service, displayed in the UI
     */
    name: string;
}

export interface CustomServiceRuleFile {
    match?: string;
    /**
     * The name of the custom service, displayed in the UI
     */
    name: string;
}

export interface CustomServiceRuleMethod {
    arguments?: string[];
    /**
     * The ID of this resource.
     */
    id: string;
    modifiers?: string[];
    /**
     * The name of the custom service, displayed in the UI
     */
    name: string;
    returns?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    visibility?: string;
}

export interface DashboardDashboardMetadata {
    /**
     * The tile uses consistent colors when rendering its content
     */
    consistentColors?: boolean;
    /**
     * Dashboard filter configuration of a dashboard
     */
    dynamicFilters?: outputs.DashboardDashboardMetadataDynamicFilters;
    /**
     * Global filter Settings for the Dashboard
     */
    filter?: outputs.DashboardDashboardMetadataFilter;
    /**
     * the name of the dashboard
     */
    name: string;
    /**
     * the owner of the dashboard
     */
    owner: string;
    /**
     * the dashboard is a preset (`true`) or not (`false`). Default is `false`.
     */
    preset?: boolean;
    /**
     * the dashboard is shared (`true`) or private (`false`)
     */
    shared?: boolean;
    /**
     * represents sharing configuration of a dashboard
     */
    sharingDetails?: outputs.DashboardDashboardMetadataSharingDetails;
    /**
     * a set of tags assigned to the dashboard
     */
    tags?: string[];
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * a set of all possible global dashboard filters that can be applied to dashboard
     */
    validFilterKeys?: string[];
}

export interface DashboardDashboardMetadataDynamicFilters {
    filters: string[];
    tagSuggestionTypes?: string[];
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardDashboardMetadataFilter {
    managementZones?: outputs.DashboardDashboardMetadataFilterManagementZone[];
    timeframe?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardDashboardMetadataFilterManagementZone {
    description?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    name?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardDashboardMetadataSharingDetails {
    linkShared?: boolean;
    published?: boolean;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardMetadata {
    /**
     * Dynatrace server version
     */
    clusterVersion?: string;
    /**
     * A Sorted list of the version numbers of the configuration
     */
    configurationVersions?: number[];
    /**
     * A Sorted list of the version numbers of the configuration
     */
    currentConfigurationVersions?: string[];
}

export interface DashboardSharingPermissions {
    /**
     * Access permissions of the dashboard
     */
    permissions?: outputs.DashboardSharingPermissionsPermission[];
}

export interface DashboardSharingPermissionsPermission {
    /**
     * The ID of this resource.
     */
    id?: string;
    level: string;
    type: string;
}

export interface DashboardSharingPublic {
    /**
     * A list of management zones that can display data on the publicly shared dashboard.
     */
    managementZones: string[];
}

export interface DashboardTile {
    /**
     * The list of Dynatrace entities, assigned to the tile
     */
    assignedEntities?: string[];
    /**
     * the position and size of a tile
     */
    bounds?: outputs.DashboardTileBounds;
    chartVisible?: boolean;
    /**
     * The tile is configured and ready to use (`true`) or just placed on the dashboard (`false`)
     */
    configured?: boolean;
    /**
     * The name of the tile, set by user
     */
    customName?: string;
    /**
     * Include (`false') or exclude (`true`) maintenance windows from availability calculations
     */
    excludeMaintenanceWindows?: boolean;
    /**
     * is filter applied to a tile. It overrides dashboard's filter
     */
    filter?: outputs.DashboardTileFilter;
    /**
     * the position and size of a tile
     */
    filterConfig?: outputs.DashboardTileFilterConfig;
    /**
     * The limit of the results, if not set will use the default value of the system
     */
    limit?: number;
    /**
     * The markdown-formatted content of the tile
     */
    markdown?: string;
    /**
     * The metric assigned to the tile
     */
    metric?: string;
    /**
     * the name of the tile
     */
    name: string;
    /**
     * The size of the tile name. Possible values are `small`, `medium` and `large`.
     */
    nameSize?: string;
    /**
     * A [user session query](https://www.dynatrace.com/support/help/shortlink/usql-info) executed by the tile
     */
    query?: string;
    /**
     * the type of the tile. Must be either `APPLICATION_WORLDMAP`, `RESOURCES`, `THIRD_PARTY_MOST_ACTIVE`, `UEM_CONVERSIONS_PER_GOAL`, `PROCESS_GROUPS_ONE` or `HOST` .
     */
    tileType: string;
    /**
     * The comparison timeframe of the query. If specified, you additionally get the results of the same query with the specified time shift
     */
    timeFrameShift?: string;
    /**
     * The attribute `type` exists for backwards compatibilty. Usage is discouraged. You should use `visualization` instead.
     */
    type?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * The visualization of the tile. Possible values are: `COLUMN_CHART`, `FUNNEL`, `LINE_CHART`, `PIE_CHART`, `SINGLE_VALUE`, `TABLE`
     */
    visualization?: string;
    /**
     * Configuration of a User session query visualization tile
     */
    visualizationConfig?: outputs.DashboardTileVisualizationConfig;
}

export interface DashboardTileBounds {
    height: number;
    left: number;
    top: number;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    width: number;
}

export interface DashboardTileFilter {
    managementZones?: outputs.DashboardTileFilterManagementZone[];
    timeframe?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardTileFilterConfig {
    chartConfig?: outputs.DashboardTileFilterConfigChartConfig;
    customName: string;
    defaultName: string;
    filters?: outputs.DashboardTileFilterConfigFilters;
    type: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardTileFilterConfigChartConfig {
    axisLimits?: {[key: string]: number};
    leftAxisCustomUnit?: string;
    legend?: boolean;
    resultMetadatas?: outputs.DashboardTileFilterConfigChartConfigResultMetadata[];
    rightAxisCustomUnit?: string;
    series?: outputs.DashboardTileFilterConfigChartConfigSeries[];
    type: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardTileFilterConfigChartConfigResultMetadata {
    configs?: outputs.DashboardTileFilterConfigChartConfigResultMetadataConfig[];
}

export interface DashboardTileFilterConfigChartConfigResultMetadataConfig {
    customColor?: string;
    key?: string;
    lastModified?: number;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardTileFilterConfigChartConfigSeries {
    aggregation: string;
    aggregationRate?: string;
    dimensions?: outputs.DashboardTileFilterConfigChartConfigSeriesDimension[];
    entityType: string;
    metric: string;
    percentile?: number;
    sortAscending?: boolean;
    sortColumn?: boolean;
    type: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardTileFilterConfigChartConfigSeriesDimension {
    entityDimension?: boolean;
    /**
     * The ID of this resource.
     */
    id: string;
    name?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    values?: string[];
}

export interface DashboardTileFilterConfigFilters {
    filters?: outputs.DashboardTileFilterConfigFiltersFilter[];
}

export interface DashboardTileFilterConfigFiltersFilter {
    entityType: string;
    matches?: outputs.DashboardTileFilterConfigFiltersFilterMatch[];
}

export interface DashboardTileFilterConfigFiltersFilterMatch {
    key: string;
    values?: string[];
}

export interface DashboardTileFilterManagementZone {
    description?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    name?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DashboardTileVisualizationConfig {
    hasAxisBucketing?: boolean;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface DatabaseAnomaliesDbConnectFailures {
    /**
     * Number of failed database connections during any **eval_period** minutes period to trigger an alert
     */
    connectionFailsCount?: number;
    /**
     * The *X* minutes time period during which the **connection*fails*count** is evaluated
     */
    evalPeriod?: number;
}

export interface DatabaseAnomaliesFailureRate {
    /**
     * Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
     */
    auto?: outputs.DatabaseAnomaliesFailureRateAuto;
    /**
     * Fixed thresholds for failure rate increase detection
     */
    thresholds?: outputs.DatabaseAnomaliesFailureRateThresholds;
}

export interface DatabaseAnomaliesFailureRateAuto {
    absolute: number;
    relative: number;
    unknowns?: string;
}

export interface DatabaseAnomaliesFailureRateThresholds {
    sensitivity: string;
    threshold: number;
    unknowns?: string;
}

export interface DatabaseAnomaliesLoad {
    /**
     * The configuration of traffic drops detection
     */
    drops?: outputs.DatabaseAnomaliesLoadDrops;
    /**
     * The configuration of traffic spikes detection
     */
    spikes?: outputs.DatabaseAnomaliesLoadSpikes;
}

export interface DatabaseAnomaliesLoadDrops {
    minutes?: number;
    percent?: number;
}

export interface DatabaseAnomaliesLoadSpikes {
    minutes?: number;
    percent?: number;
    unknowns?: string;
}

export interface DatabaseAnomaliesResponseTime {
    /**
     * Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
     */
    auto?: outputs.DatabaseAnomaliesResponseTimeAuto;
    /**
     * Fixed thresholds for response time degradation detection
     */
    thresholds?: outputs.DatabaseAnomaliesResponseTimeThresholds;
}

export interface DatabaseAnomaliesResponseTimeAuto {
    /**
     * Configuration for anomalies regarding load drops and spikes
     */
    load: string;
    milliseconds: number;
    percent: number;
    slowestMilliseconds: number;
    slowestPercent: number;
    unknowns?: string;
}

export interface DatabaseAnomaliesResponseTimeThresholds {
    /**
     * Configuration for anomalies regarding load drops and spikes
     */
    load: string;
    milliseconds: number;
    sensitivity: string;
    slowestMilliseconds: number;
    unknowns?: string;
}

export interface DiskAnomaliesDiskName {
    /**
     * Possible values are: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_EQUAL`, `DOES_NOT_START_WITH`, `EQUALS` and `STARTS_WITH`
     */
    operator: string;
    /**
     * Value to compare to
     */
    value: string;
}

export interface DiskAnomaliesTags {
    /**
     * A Tag Filter
     */
    filters?: outputs.DiskAnomaliesTagsFilter[];
}

export interface DiskAnomaliesTagsFilter {
    context: string;
    key: string;
    value?: string;
}

export interface EnvironmentQuotas {
    /**
     * Davis Data Units consumption and quota information on environment level. Not set (and not editable) if Davis data units is not enabled
     */
    ddus?: outputs.EnvironmentQuotasDdus;
    /**
     * DEM units consumption and quota information on environment level
     */
    demUnits?: outputs.EnvironmentQuotasDemUnits;
    /**
     * Host units consumption and quota information on environment level
     */
    hostUnits?: number;
    /**
     * Log Monitoring consumption and quota information on environment level. Not set (and not editable) if Log monitoring is not enabled. Not set (and not editable) if Log monitoring is migrated to Davis data on license level
     */
    logs?: outputs.EnvironmentQuotasLogs;
    /**
     * Synthetic monitors consumption and quota information on environment level. Not set (and not editable) if neither Synthetic nor DEM units is enabled
     */
    synthetic?: outputs.EnvironmentQuotasSynthetic;
    /**
     * User sessions consumption and quota information on environment level
     */
    userSessions?: outputs.EnvironmentQuotasUserSessions;
}

export interface EnvironmentQuotasDdus {
    annual?: number;
    monthly?: number;
}

export interface EnvironmentQuotasDemUnits {
    annual?: number;
    monthly?: number;
}

export interface EnvironmentQuotasLogs {
    annual?: number;
    monthly?: number;
}

export interface EnvironmentQuotasSynthetic {
    annual?: number;
    monthly?: number;
}

export interface EnvironmentQuotasUserSessions {
    annual?: number;
    monthly?: number;
}

export interface EnvironmentStorage {
    limits?: outputs.EnvironmentStorageLimits;
    retention?: outputs.EnvironmentStorageRetention;
    /**
     * Maximum number of newly monitored entry point PurePaths captured per process/minute on environment level. Can be set to any value from 100 to 100000
     */
    transactions: number;
    /**
     * Maximum number of user actions generated per minute on environment level. Can be set to any value from 1 to 2147483646 or left unlimited by omitting this property
     */
    userActions?: number;
}

export interface EnvironmentStorageLimits {
    logs?: number;
    sessionReplay?: number;
    symbolFiles?: number;
    transactions?: number;
}

export interface EnvironmentStorageRetention {
    logs: number;
    rum: number;
    serviceCodeLevel: number;
    serviceRequestLevel: number;
    sessionReplay: number;
    synthetic: number;
}

export interface GetSyntheticLocationsLocations {
    /**
     * The name of the location
     */
    locations?: outputs.GetSyntheticLocationsLocationsLocation[];
}

export interface GetSyntheticLocationsLocationsLocation {
    cloudPlatform: string;
    /**
     * The ID of this resource.
     */
    id?: string;
    ips: string[];
    name?: string;
    stage: string;
    status: string;
    type?: string;
}

export interface HostAnomaliesConnections {
    /**
     * The detection is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * Alert (`true`) on graceful host shutdowns
     */
    enabledOnGracefulShutdowns: boolean;
}

export interface HostAnomaliesCpu {
    /**
     * The detection is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * Custom thresholds for high CPU saturation. If not set then the automatic mode is used
     */
    thresholds?: outputs.HostAnomaliesCpuThresholds;
}

export interface HostAnomaliesCpuThresholds {
    saturation: number;
}

export interface HostAnomaliesDisks {
    /**
     * Configuration of low disk inodes number detection
     */
    inodes?: outputs.HostAnomaliesDisksInodes;
    /**
     * Configuration of low disk space detection
     */
    space?: outputs.HostAnomaliesDisksSpace;
    /**
     * Configuration of slow running disks detection
     */
    speed?: outputs.HostAnomaliesDisksSpeed;
}

export interface HostAnomaliesDisksInodes {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesDisksInodesThresholds;
}

export interface HostAnomaliesDisksInodesThresholds {
    percentage: number;
}

export interface HostAnomaliesDisksSpace {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesDisksSpaceThresholds;
}

export interface HostAnomaliesDisksSpaceThresholds {
    percentage: number;
}

export interface HostAnomaliesDisksSpeed {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesDisksSpeedThresholds;
}

export interface HostAnomaliesDisksSpeedThresholds {
    writeAndReadTime: number;
}

export interface HostAnomaliesGc {
    /**
     * The detection is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * Custom thresholds for high GC activity. If not set, automatic mode is used.   Meeting **any** of these conditions triggers an alert
     */
    thresholds?: outputs.HostAnomaliesGcThresholds;
}

export interface HostAnomaliesGcThresholds {
    suspensionPercentage: number;
    timePercentage: number;
}

export interface HostAnomaliesJava {
    /**
     * Configuration of Java out of memory problems detection
     */
    outOfMemory?: outputs.HostAnomaliesJavaOutOfMemory;
    /**
     * Configuration of Java out of threads problems detection
     */
    outOfThreads?: outputs.HostAnomaliesJavaOutOfThreads;
}

export interface HostAnomaliesJavaOutOfMemory {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesJavaOutOfMemoryThresholds;
}

export interface HostAnomaliesJavaOutOfMemoryThresholds {
    exceptionCount: number;
}

export interface HostAnomaliesJavaOutOfThreads {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesJavaOutOfThreadsThresholds;
}

export interface HostAnomaliesJavaOutOfThreadsThresholds {
    exceptionCount: number;
}

export interface HostAnomaliesMemory {
    /**
     * The detection is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * Custom thresholds for high memory usage. If not set then the automatic mode is used. **Both** conditions must be met to trigger an alert
     */
    thresholds?: outputs.HostAnomaliesMemoryThresholds;
}

export interface HostAnomaliesMemoryThresholds {
    linux: outputs.HostAnomaliesMemoryThresholdsLinux;
    windows: outputs.HostAnomaliesMemoryThresholdsWindows;
}

export interface HostAnomaliesMemoryThresholdsLinux {
    pageFaults: number;
    usage: number;
}

export interface HostAnomaliesMemoryThresholdsWindows {
    pageFaults: number;
    usage: number;
}

export interface HostAnomaliesNetwork {
    /**
     * Configuration of TCP connectivity problems detection
     */
    connectivity?: outputs.HostAnomaliesNetworkConnectivity;
    /**
     * Configuration of high number of dropped packets detection
     */
    droppedPackets?: outputs.HostAnomaliesNetworkDroppedPackets;
    /**
     * Configuration of high number of network errors detection
     */
    errors?: outputs.HostAnomaliesNetworkErrors;
    /**
     * Configuration of high retransmission rate detection
     */
    retransmission?: outputs.HostAnomaliesNetworkRetransmission;
    /**
     * Configuration of high network utilization detection
     */
    utilization?: outputs.HostAnomaliesNetworkUtilization;
}

export interface HostAnomaliesNetworkConnectivity {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesNetworkConnectivityThresholds;
}

export interface HostAnomaliesNetworkConnectivityThresholds {
    failedConnections: number;
    newConnectionFailures: number;
}

export interface HostAnomaliesNetworkDroppedPackets {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesNetworkDroppedPacketsThresholds;
}

export interface HostAnomaliesNetworkDroppedPacketsThresholds {
    droppedPackets: number;
    totalPacketsRate: number;
}

export interface HostAnomaliesNetworkErrors {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesNetworkErrorsThresholds;
}

export interface HostAnomaliesNetworkErrorsThresholds {
    errorsPercentage: number;
    totalPacketsRate: number;
}

export interface HostAnomaliesNetworkRetransmission {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesNetworkRetransmissionThresholds;
}

export interface HostAnomaliesNetworkRetransmissionThresholds {
    retransmissionRate: number;
    retransmittedPackets: number;
}

export interface HostAnomaliesNetworkUtilization {
    enabled: boolean;
    thresholds?: outputs.HostAnomaliesNetworkUtilizationThresholds;
}

export interface HostAnomaliesNetworkUtilizationThresholds {
    utilization: number;
}

export interface HostNamingCondition {
    conditions?: outputs.HostNamingConditionCondition[];
}

export interface HostNamingConditionCondition {
    /**
     * @deprecated You should use 'application_type' instead of 'application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    applicationTypeComparisons?: outputs.HostNamingConditionConditionApplicationTypeComparison[];
    applicationTypes?: outputs.HostNamingConditionConditionApplicationType[];
    azureComputeModeComparisons?: outputs.HostNamingConditionConditionAzureComputeModeComparison[];
    /**
     * @deprecated You should use 'azure_compute_mode' instead of 'azure_compute_mode_comparison'. This attribute still exists for backwards compatibility.
     */
    azureComputeModes?: outputs.HostNamingConditionConditionAzureComputeMode[];
    /**
     * @deprecated You should use 'azure_sku' instead of 'azure_sku_comparision'. This attribute still exists for backwards compatibility.
     */
    azureSkuComparisions?: outputs.HostNamingConditionConditionAzureSkuComparision[];
    azureSkus?: outputs.HostNamingConditionConditionAzureSkus[];
    /**
     * @deprecated You should use 'comparison' instead of 'base_comparison_basic'. This attribute still exists for backwards compatibility.
     */
    baseComparisonBasics?: outputs.HostNamingConditionConditionBaseComparisonBasic[];
    /**
     * @deprecated 'base_condition_key' is deprecated. You should use 'key'
     */
    baseConditionKeys?: outputs.HostNamingConditionConditionBaseConditionKey[];
    /**
     * @deprecated You should use 'bitness' instead of 'bitness_comparision'. This attribute still exists for backwards compatibility.
     */
    bitnessComparisions?: outputs.HostNamingConditionConditionBitnessComparision[];
    bitnesses?: outputs.HostNamingConditionConditionBitness[];
    /**
     * @deprecated You should use 'cloud_type' instead of 'cloud_type_comparison'. This attribute still exists for backwards compatibility.
     */
    cloudTypeComparisons?: outputs.HostNamingConditionConditionCloudTypeComparison[];
    cloudTypes?: outputs.HostNamingConditionConditionCloudType[];
    comparisons?: outputs.HostNamingConditionConditionComparison[];
    /**
     * @deprecated You should use 'custom_application_type' instead of 'custom_application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    customApplicationTypeComparisons?: outputs.HostNamingConditionConditionCustomApplicationTypeComparison[];
    customApplicationTypes?: outputs.HostNamingConditionConditionCustomApplicationType[];
    /**
     * @deprecated 'custom_host_metadata_condition_key' is deprecated. You should use 'custom_host_metadata'
     */
    customHostMetadataConditionKeys?: outputs.HostNamingConditionConditionCustomHostMetadataConditionKey[];
    customHostMetadatas?: outputs.HostNamingConditionConditionCustomHostMetadata[];
    /**
     * @deprecated 'custom_process_metadata_condition_key' is deprecated. You should use 'custom_process_metadata'
     */
    customProcessMetadataConditionKeys?: outputs.HostNamingConditionConditionCustomProcessMetadataConditionKey[];
    customProcessMetadatas?: outputs.HostNamingConditionConditionCustomProcessMetadata[];
    databaseTopologies?: outputs.HostNamingConditionConditionDatabaseTopology[];
    /**
     * @deprecated You should use 'database_topology' instead of 'database_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    databaseTopologyComparisons?: outputs.HostNamingConditionConditionDatabaseTopologyComparison[];
    /**
     * @deprecated You should use 'dcrum_decoder' instead of 'dcrum_decoder_comparison'. This attribute still exists for backwards compatibility.
     */
    dcrumDecoderComparisons?: outputs.HostNamingConditionConditionDcrumDecoderComparison[];
    dcrumDecoders?: outputs.HostNamingConditionConditionDcrumDecoder[];
    entities?: outputs.HostNamingConditionConditionEntity[];
    /**
     * @deprecated You should use 'entity' instead of 'entity_id_comparison'. This attribute still exists for backwards compatibility.
     */
    entityIdComparisons?: outputs.HostNamingConditionConditionEntityIdComparison[];
    hostTeches?: outputs.HostNamingConditionConditionHostTech[];
    /**
     * @deprecated `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
     */
    hypervisorTypeComparisions?: outputs.HostNamingConditionConditionHypervisorTypeComparision[];
    hypervisors?: outputs.HostNamingConditionConditionHypervisor[];
    /**
     * @deprecated You should use 'indexed_name' instead of 'indexed_name_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedNameComparisons?: outputs.HostNamingConditionConditionIndexedNameComparison[];
    indexedNames?: outputs.HostNamingConditionConditionIndexedName[];
    /**
     * @deprecated You should use 'indexed_string' instead of 'indexed_string_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedStringComparisons?: outputs.HostNamingConditionConditionIndexedStringComparison[];
    indexedStrings?: outputs.HostNamingConditionConditionIndexedString[];
    /**
     * @deprecated You should use 'indexed_tag' instead of 'indexed_tag_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedTagComparisons?: outputs.HostNamingConditionConditionIndexedTagComparison[];
    indexedTags?: outputs.HostNamingConditionConditionIndexedTag[];
    /**
     * @deprecated You should use 'integer' instead of 'integer_comparison'. This attribute still exists for backwards compatibility.
     */
    integerComparisons?: outputs.HostNamingConditionConditionIntegerComparison[];
    integers?: outputs.HostNamingConditionConditionInteger[];
    /**
     * @deprecated You should use 'ipaddress' instead of 'ipaddress_comparison'. This attribute still exists for backwards compatibility.
     */
    ipaddressComparisons?: outputs.HostNamingConditionConditionIpaddressComparison[];
    ipaddresses?: outputs.HostNamingConditionConditionIpaddress[];
    keys?: outputs.HostNamingConditionConditionKey[];
    /**
     * @deprecated You should use 'mobile_platform' instead of 'mobile_platform_comparison'. This attribute still exists for backwards compatibility.
     */
    mobilePlatformComparisons?: outputs.HostNamingConditionConditionMobilePlatformComparison[];
    mobilePlatforms?: outputs.HostNamingConditionConditionMobilePlatform[];
    osArches?: outputs.HostNamingConditionConditionOsArch[];
    osTypes?: outputs.HostNamingConditionConditionOsType[];
    /**
     * @deprecated You should use 'os_arch' instead of 'osarchitecture_comparison'. This attribute still exists for backwards compatibility.
     */
    osarchitectureComparisons?: outputs.HostNamingConditionConditionOsarchitectureComparison[];
    /**
     * @deprecated You should use 'os_type' instead of 'ostype_comparison'. This attribute still exists for backwards compatibility.
     */
    ostypeComparisons?: outputs.HostNamingConditionConditionOstypeComparison[];
    /**
     * @deprecated You should use 'paas_type' instead of 'paas_type_comparison'. This attribute still exists for backwards compatibility.
     */
    paasTypeComparisons?: outputs.HostNamingConditionConditionPaasTypeComparison[];
    paasTypes?: outputs.HostNamingConditionConditionPaasType[];
    /**
     * @deprecated 'process_metadata_condition_key' is deprecated. You should use 'process_metadata'
     */
    processMetadataConditionKeys?: outputs.HostNamingConditionConditionProcessMetadataConditionKey[];
    processMetadatas?: outputs.HostNamingConditionConditionProcessMetadata[];
    serviceTopologies?: outputs.HostNamingConditionConditionServiceTopology[];
    /**
     * @deprecated You should use 'service_topology' instead of 'service_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTopologyComparisons?: outputs.HostNamingConditionConditionServiceTopologyComparison[];
    /**
     * @deprecated You should use 'service_type' instead of 'service_type_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTypeComparisons?: outputs.HostNamingConditionConditionServiceTypeComparison[];
    serviceTypes?: outputs.HostNamingConditionConditionServiceType[];
    /**
     * @deprecated You should use 'host_tech' instead of 'simple_host_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleHostTechComparisons?: outputs.HostNamingConditionConditionSimpleHostTechComparison[];
    /**
     * @deprecated You should use 'tech' instead of 'simple_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleTechComparisons?: outputs.HostNamingConditionConditionSimpleTechComparison[];
    /**
     * @deprecated You should use 'string' instead of 'string_comparison'. This attribute still exists for backwards compatibility.
     */
    stringComparisons?: outputs.HostNamingConditionConditionStringComparison[];
    /**
     * @deprecated 'string_condition_key' is deprecated. You should use 'string_key'
     */
    stringConditionKeys?: outputs.HostNamingConditionConditionStringConditionKey[];
    stringKeys?: outputs.HostNamingConditionConditionStringKey[];
    strings?: outputs.HostNamingConditionConditionString[];
    /**
     * @deprecated You should use 'synthetic_engine' instead of 'synthetic_engine_type_comparison'. This attribute still exists for backwards compatibility.
     */
    syntheticEngineTypeComparisons?: outputs.HostNamingConditionConditionSyntheticEngineTypeComparison[];
    syntheticEngines?: outputs.HostNamingConditionConditionSyntheticEngine[];
    /**
     * @deprecated You should use 'tag' instead of 'tag_comparison'. This attribute still exists for backwards compatibility.
     */
    tagComparisons?: outputs.HostNamingConditionConditionTagComparison[];
    tags?: outputs.HostNamingConditionConditionTag[];
    teches?: outputs.HostNamingConditionConditionTech[];
    unknowns?: string;
}

export interface HostNamingConditionConditionApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionAzureComputeMode {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionAzureComputeModeComparison {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionAzureSkuComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionAzureSkus {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionBaseComparisonBasic {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionBaseConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionBitness {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionBitnessComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionCloudType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionCloudTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionComparison {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionCustomApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionCustomApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionCustomHostMetadata {
    attribute: string;
    dynamicKey: outputs.HostNamingConditionConditionCustomHostMetadataDynamicKey;
    unknowns?: string;
}

export interface HostNamingConditionConditionCustomHostMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.HostNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionCustomHostMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionCustomProcessMetadata {
    attribute: string;
    dynamicKey: outputs.HostNamingConditionConditionCustomProcessMetadataDynamicKey;
    unknowns?: string;
}

export interface HostNamingConditionConditionCustomProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.HostNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionCustomProcessMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionDatabaseTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionDatabaseTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionDcrumDecoder {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionDcrumDecoderComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionEntity {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionEntityIdComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionHostTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.HostNamingConditionConditionHostTechValue;
}

export interface HostNamingConditionConditionHostTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface HostNamingConditionConditionHypervisor {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionHypervisorTypeComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionIndexedName {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionIndexedNameComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionIndexedString {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionIndexedStringComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionIndexedTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.HostNamingConditionConditionIndexedTagValue;
}

export interface HostNamingConditionConditionIndexedTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.HostNamingConditionConditionIndexedTagComparisonValue;
}

export interface HostNamingConditionConditionIndexedTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionIndexedTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionInteger {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: number;
}

export interface HostNamingConditionConditionIntegerComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: number;
}

export interface HostNamingConditionConditionIpaddress {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionIpaddressComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionMobilePlatform {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionMobilePlatformComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionOsArch {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionOsType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionOsarchitectureComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionOstypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionPaasType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionPaasTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionProcessMetadata {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionServiceTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionServiceTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionServiceType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionServiceTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionSimpleHostTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.HostNamingConditionConditionSimpleHostTechComparisonValue;
}

export interface HostNamingConditionConditionSimpleHostTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface HostNamingConditionConditionSimpleTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.HostNamingConditionConditionSimpleTechComparisonValue;
}

export interface HostNamingConditionConditionSimpleTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface HostNamingConditionConditionString {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionStringComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionStringConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionStringKey {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface HostNamingConditionConditionSyntheticEngine {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionSyntheticEngineTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.HostNamingConditionConditionTagValue;
}

export interface HostNamingConditionConditionTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.HostNamingConditionConditionTagComparisonValue;
}

export interface HostNamingConditionConditionTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface HostNamingConditionConditionTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.HostNamingConditionConditionTechValue;
}

export interface HostNamingConditionConditionTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface HttpMonitorAnomalyDetection {
    /**
     * Thresholds for loading times
     */
    loadingTimeThresholds?: outputs.HttpMonitorAnomalyDetectionLoadingTimeThreshold[];
    /**
     * Outage handling configuration
     */
    outageHandlings?: outputs.HttpMonitorAnomalyDetectionOutageHandling[];
}

export interface HttpMonitorAnomalyDetectionLoadingTimeThreshold {
    enabled?: boolean;
    thresholds?: outputs.HttpMonitorAnomalyDetectionLoadingTimeThresholdThreshold[];
}

export interface HttpMonitorAnomalyDetectionLoadingTimeThresholdThreshold {
    thresholds: outputs.HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold[];
}

export interface HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold {
    eventIndex?: number;
    requestIndex?: number;
    type?: string;
    valueMs: number;
}

export interface HttpMonitorAnomalyDetectionOutageHandling {
    globalOutage?: boolean;
    localOutage?: boolean;
    localOutagePolicies?: outputs.HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy[];
    retryOnError?: boolean;
}

export interface HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy {
    affectedLocations: number;
    consecutiveRuns: number;
}

export interface HttpMonitorScript {
    /**
     * A HTTP request to be performed by the monitor.
     */
    requests: outputs.HttpMonitorScriptRequest[];
}

export interface HttpMonitorScriptRequest {
    authentication?: outputs.HttpMonitorScriptRequestAuthentication;
    body?: string;
    configuration?: outputs.HttpMonitorScriptRequestConfiguration;
    description?: string;
    method: string;
    postProcessing?: string;
    preProcessing?: string;
    url: string;
    validation?: outputs.HttpMonitorScriptRequestValidation;
}

export interface HttpMonitorScriptRequestAuthentication {
    credentials: string;
    kdcIp?: string;
    realmName?: string;
    type: string;
}

export interface HttpMonitorScriptRequestConfiguration {
    acceptAnyCertificate?: boolean;
    followRedirects?: boolean;
    headers?: outputs.HttpMonitorScriptRequestConfigurationHeaders;
    userAgent?: string;
}

export interface HttpMonitorScriptRequestConfigurationHeaders {
    headers: outputs.HttpMonitorScriptRequestConfigurationHeadersHeader[];
}

export interface HttpMonitorScriptRequestConfigurationHeadersHeader {
    name: string;
    value: string;
}

export interface HttpMonitorScriptRequestValidation {
    rules: outputs.HttpMonitorScriptRequestValidationRule[];
}

export interface HttpMonitorScriptRequestValidationRule {
    passIfFound?: boolean;
    type: string;
    value: string;
}

export interface HttpMonitorTag {
    /**
     * Tag with source of a Dynatrace entity.
     */
    tags?: outputs.HttpMonitorTagTag[];
}

export interface HttpMonitorTagTag {
    context: string;
    key: string;
    source?: string;
    value?: string;
}

export interface ImsBridgesQueueManager {
    /**
     * Queue manager definition for IMS bridge
     */
    queueManagers?: outputs.ImsBridgesQueueManagerQueueManager[];
}

export interface ImsBridgesQueueManagerQueueManager {
    /**
     * The name of the IMS bridge
     */
    name: string;
    queueManagerQueues?: string[];
}

export interface K8sCredentialsEventsFieldSelector {
    /**
     * Whether subscription to this events field selector is enabled (value set to `true`). If disabled (value set to `false`), Dynatrace will stop fetching events from the Kubernetes API for this events field selector
     */
    active: boolean;
    /**
     * The field selector string (url decoding is applied) when storing it.
     */
    fieldSelector: string;
    /**
     * A label of the events field selector.
     */
    label: string;
    /**
     * Any attributes that aren't yet supported by this provider
     */
    unknowns?: string;
}

export interface MaintenanceFilter {
    /**
     * A list of matching rules for dynamic filter formation.  If several rules are set, the OR logic applies
     */
    filters?: outputs.MaintenanceFilterFilter[];
}

export interface MaintenanceFilterFilter {
    entityId?: string;
    entityTags?: string[];
    entityType?: string;
    managementZones?: string[];
}

export interface MaintenanceGeneralProperties {
    /**
     * A short description of the maintenance purpose
     */
    description?: string;
    /**
     * Suppress execution of synthetic monitors during the maintenance
     */
    disableSynthetic?: boolean;
    /**
     * The name of the maintenance window, displayed in the UI
     */
    name: string;
    /**
     * The type of suppression of alerting and problem detection during the maintenance
     */
    suppression: string;
    /**
     * The type of the maintenance: planned or unplanned
     */
    type: string;
}

export interface MaintenanceSchedule {
    /**
     * The configuration for maintenance windows occuring daily
     */
    dailyRecurrence?: outputs.MaintenanceScheduleDailyRecurrence;
    /**
     * The configuration for maintenance windows occuring monthly
     */
    monthlyRecurrence?: outputs.MaintenanceScheduleMonthlyRecurrence;
    /**
     * The configuration for maintenance windows occuring once
     */
    onceRecurrence?: outputs.MaintenanceScheduleOnceRecurrence;
    /**
     * The time window of the maintenance window
     */
    type: string;
    /**
     * The configuration for maintenance windows occuring weekly
     */
    weeklyRecurrence?: outputs.MaintenanceScheduleWeeklyRecurrence;
}

export interface MaintenanceScheduleDailyRecurrence {
    recurrenceRange: outputs.MaintenanceScheduleDailyRecurrenceRecurrenceRange;
    timeWindow: outputs.MaintenanceScheduleDailyRecurrenceTimeWindow;
}

export interface MaintenanceScheduleDailyRecurrenceRecurrenceRange {
    endDate: string;
    startDate: string;
}

export interface MaintenanceScheduleDailyRecurrenceTimeWindow {
    endTime: string;
    startTime: string;
    timeZone: string;
}

export interface MaintenanceScheduleMonthlyRecurrence {
    dayOfMonth: number;
    recurrenceRange: outputs.MaintenanceScheduleMonthlyRecurrenceRecurrenceRange;
    timeWindow: outputs.MaintenanceScheduleMonthlyRecurrenceTimeWindow;
}

export interface MaintenanceScheduleMonthlyRecurrenceRecurrenceRange {
    endDate: string;
    startDate: string;
}

export interface MaintenanceScheduleMonthlyRecurrenceTimeWindow {
    endTime: string;
    startTime: string;
    timeZone: string;
}

export interface MaintenanceScheduleOnceRecurrence {
    endTime: string;
    startTime: string;
    timeZone: string;
}

export interface MaintenanceScheduleWeeklyRecurrence {
    dayOfWeek: string;
    recurrenceRange: outputs.MaintenanceScheduleWeeklyRecurrenceRecurrenceRange;
    timeWindow: outputs.MaintenanceScheduleWeeklyRecurrenceTimeWindow;
}

export interface MaintenanceScheduleWeeklyRecurrenceRecurrenceRange {
    endDate: string;
    startDate: string;
}

export interface MaintenanceScheduleWeeklyRecurrenceTimeWindow {
    endTime: string;
    startTime: string;
    timeZone: string;
}

export interface MaintenanceWindowMetadata {
    /**
     * Dynatrace server version
     */
    clusterVersion?: string;
    /**
     * A Sorted list of the version numbers of the configuration
     */
    configurationVersions?: number[];
    /**
     * A Sorted list of the version numbers of the configuration
     */
    currentConfigurationVersions?: string[];
}

export interface MaintenanceWindowSchedule {
    /**
     * The end date and time of the maintenance window validity period in yyyy-mm-dd HH:mm format
     */
    end: string;
    /**
     * The recurrence of the maintenance window
     */
    recurrence?: outputs.MaintenanceWindowScheduleRecurrence;
    /**
     * The type of the schedule recurrence. Possible values are `DAILY`, `MONTHLY`, `ONCE` and `WEEKLY`
     */
    recurrenceType: string;
    /**
     * The start date and time of the maintenance window validity period in yyyy-mm-dd HH:mm format
     */
    start: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
     */
    zoneId: string;
}

export interface MaintenanceWindowScheduleRecurrence {
    dayOfMonth?: number;
    dayOfWeek?: string;
    durationMinutes: number;
    startTime: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface MaintenanceWindowScope {
    /**
     * A list of Dynatrace entities (for example, hosts or services) to be included in the scope.  Allowed values are Dynatrace entity IDs
     */
    entities?: string[];
    /**
     * A list of matching rules for dynamic scope formation.  If several rules are set, the OR logic applies
     */
    matches?: outputs.MaintenanceWindowScopeMatch[];
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface MaintenanceWindowScopeMatch {
    mzId?: string;
    tagCombination?: string;
    tags?: outputs.MaintenanceWindowScopeMatchTag[];
    /**
     * The type of the maintenance: planned or unplanned
     */
    type?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface MaintenanceWindowScopeMatchTag {
    context: string;
    key: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneDimensionalRule {
    appliesTo: string;
    conditions?: outputs.ManagementZoneDimensionalRuleCondition[];
    enabled?: boolean;
    unknowns?: string;
}

export interface ManagementZoneDimensionalRuleCondition {
    key: string;
    match: string;
    type: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneEntitySelectorBasedRule {
    enabled?: boolean;
    selector?: string;
    unknowns?: string;
}

export interface ManagementZoneMetadata {
    clusterVersion?: string;
    configurationVersions?: number[];
    currentConfigurationVersions?: string[];
}

export interface ManagementZoneRule {
    conditions?: outputs.ManagementZoneRuleCondition[];
    enabled?: boolean;
    propagationTypes?: string[];
    type: string;
    unknowns?: string;
}

export interface ManagementZoneRuleCondition {
    /**
     * @deprecated You should use 'application_type' instead of 'application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    applicationTypeComparisons?: outputs.ManagementZoneRuleConditionApplicationTypeComparison[];
    applicationTypes?: outputs.ManagementZoneRuleConditionApplicationType[];
    azureComputeModeComparisons?: outputs.ManagementZoneRuleConditionAzureComputeModeComparison[];
    /**
     * @deprecated You should use 'azure_compute_mode' instead of 'azure_compute_mode_comparison'. This attribute still exists for backwards compatibility.
     */
    azureComputeModes?: outputs.ManagementZoneRuleConditionAzureComputeMode[];
    /**
     * @deprecated You should use 'azure_sku' instead of 'azure_sku_comparision'. This attribute still exists for backwards compatibility.
     */
    azureSkuComparisions?: outputs.ManagementZoneRuleConditionAzureSkuComparision[];
    azureSkus?: outputs.ManagementZoneRuleConditionAzureSkus[];
    /**
     * @deprecated You should use 'comparison' instead of 'base_comparison_basic'. This attribute still exists for backwards compatibility.
     */
    baseComparisonBasics?: outputs.ManagementZoneRuleConditionBaseComparisonBasic[];
    /**
     * @deprecated 'base_condition_key' is deprecated. You should use 'key'
     */
    baseConditionKeys?: outputs.ManagementZoneRuleConditionBaseConditionKey[];
    /**
     * @deprecated You should use 'bitness' instead of 'bitness_comparision'. This attribute still exists for backwards compatibility.
     */
    bitnessComparisions?: outputs.ManagementZoneRuleConditionBitnessComparision[];
    bitnesses?: outputs.ManagementZoneRuleConditionBitness[];
    /**
     * @deprecated You should use 'cloud_type' instead of 'cloud_type_comparison'. This attribute still exists for backwards compatibility.
     */
    cloudTypeComparisons?: outputs.ManagementZoneRuleConditionCloudTypeComparison[];
    cloudTypes?: outputs.ManagementZoneRuleConditionCloudType[];
    comparisons?: outputs.ManagementZoneRuleConditionComparison[];
    /**
     * @deprecated You should use 'custom_application_type' instead of 'custom_application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    customApplicationTypeComparisons?: outputs.ManagementZoneRuleConditionCustomApplicationTypeComparison[];
    customApplicationTypes?: outputs.ManagementZoneRuleConditionCustomApplicationType[];
    /**
     * @deprecated 'custom_host_metadata_condition_key' is deprecated. You should use 'custom_host_metadata'
     */
    customHostMetadataConditionKeys?: outputs.ManagementZoneRuleConditionCustomHostMetadataConditionKey[];
    customHostMetadatas?: outputs.ManagementZoneRuleConditionCustomHostMetadata[];
    /**
     * @deprecated 'custom_process_metadata_condition_key' is deprecated. You should use 'custom_process_metadata'
     */
    customProcessMetadataConditionKeys?: outputs.ManagementZoneRuleConditionCustomProcessMetadataConditionKey[];
    customProcessMetadatas?: outputs.ManagementZoneRuleConditionCustomProcessMetadata[];
    databaseTopologies?: outputs.ManagementZoneRuleConditionDatabaseTopology[];
    /**
     * @deprecated You should use 'database_topology' instead of 'database_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    databaseTopologyComparisons?: outputs.ManagementZoneRuleConditionDatabaseTopologyComparison[];
    /**
     * @deprecated You should use 'dcrum_decoder' instead of 'dcrum_decoder_comparison'. This attribute still exists for backwards compatibility.
     */
    dcrumDecoderComparisons?: outputs.ManagementZoneRuleConditionDcrumDecoderComparison[];
    dcrumDecoders?: outputs.ManagementZoneRuleConditionDcrumDecoder[];
    entities?: outputs.ManagementZoneRuleConditionEntity[];
    /**
     * @deprecated You should use 'entity' instead of 'entity_id_comparison'. This attribute still exists for backwards compatibility.
     */
    entityIdComparisons?: outputs.ManagementZoneRuleConditionEntityIdComparison[];
    hostTeches?: outputs.ManagementZoneRuleConditionHostTech[];
    /**
     * @deprecated `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
     */
    hypervisorTypeComparisions?: outputs.ManagementZoneRuleConditionHypervisorTypeComparision[];
    hypervisors?: outputs.ManagementZoneRuleConditionHypervisor[];
    /**
     * @deprecated You should use 'indexed_name' instead of 'indexed_name_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedNameComparisons?: outputs.ManagementZoneRuleConditionIndexedNameComparison[];
    indexedNames?: outputs.ManagementZoneRuleConditionIndexedName[];
    /**
     * @deprecated You should use 'indexed_string' instead of 'indexed_string_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedStringComparisons?: outputs.ManagementZoneRuleConditionIndexedStringComparison[];
    indexedStrings?: outputs.ManagementZoneRuleConditionIndexedString[];
    /**
     * @deprecated You should use 'indexed_tag' instead of 'indexed_tag_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedTagComparisons?: outputs.ManagementZoneRuleConditionIndexedTagComparison[];
    indexedTags?: outputs.ManagementZoneRuleConditionIndexedTag[];
    /**
     * @deprecated You should use 'integer' instead of 'integer_comparison'. This attribute still exists for backwards compatibility.
     */
    integerComparisons?: outputs.ManagementZoneRuleConditionIntegerComparison[];
    integers?: outputs.ManagementZoneRuleConditionInteger[];
    /**
     * @deprecated You should use 'ipaddress' instead of 'ipaddress_comparison'. This attribute still exists for backwards compatibility.
     */
    ipaddressComparisons?: outputs.ManagementZoneRuleConditionIpaddressComparison[];
    ipaddresses?: outputs.ManagementZoneRuleConditionIpaddress[];
    keys?: outputs.ManagementZoneRuleConditionKey[];
    /**
     * @deprecated You should use 'mobile_platform' instead of 'mobile_platform_comparison'. This attribute still exists for backwards compatibility.
     */
    mobilePlatformComparisons?: outputs.ManagementZoneRuleConditionMobilePlatformComparison[];
    mobilePlatforms?: outputs.ManagementZoneRuleConditionMobilePlatform[];
    osArches?: outputs.ManagementZoneRuleConditionOsArch[];
    osTypes?: outputs.ManagementZoneRuleConditionOsType[];
    /**
     * @deprecated You should use 'os_arch' instead of 'osarchitecture_comparison'. This attribute still exists for backwards compatibility.
     */
    osarchitectureComparisons?: outputs.ManagementZoneRuleConditionOsarchitectureComparison[];
    /**
     * @deprecated You should use 'os_type' instead of 'ostype_comparison'. This attribute still exists for backwards compatibility.
     */
    ostypeComparisons?: outputs.ManagementZoneRuleConditionOstypeComparison[];
    /**
     * @deprecated You should use 'paas_type' instead of 'paas_type_comparison'. This attribute still exists for backwards compatibility.
     */
    paasTypeComparisons?: outputs.ManagementZoneRuleConditionPaasTypeComparison[];
    paasTypes?: outputs.ManagementZoneRuleConditionPaasType[];
    /**
     * @deprecated 'process_metadata_condition_key' is deprecated. You should use 'process_metadata'
     */
    processMetadataConditionKeys?: outputs.ManagementZoneRuleConditionProcessMetadataConditionKey[];
    processMetadatas?: outputs.ManagementZoneRuleConditionProcessMetadata[];
    serviceTopologies?: outputs.ManagementZoneRuleConditionServiceTopology[];
    /**
     * @deprecated You should use 'service_topology' instead of 'service_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTopologyComparisons?: outputs.ManagementZoneRuleConditionServiceTopologyComparison[];
    /**
     * @deprecated You should use 'service_type' instead of 'service_type_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTypeComparisons?: outputs.ManagementZoneRuleConditionServiceTypeComparison[];
    serviceTypes?: outputs.ManagementZoneRuleConditionServiceType[];
    /**
     * @deprecated You should use 'host_tech' instead of 'simple_host_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleHostTechComparisons?: outputs.ManagementZoneRuleConditionSimpleHostTechComparison[];
    /**
     * @deprecated You should use 'tech' instead of 'simple_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleTechComparisons?: outputs.ManagementZoneRuleConditionSimpleTechComparison[];
    /**
     * @deprecated You should use 'string' instead of 'string_comparison'. This attribute still exists for backwards compatibility.
     */
    stringComparisons?: outputs.ManagementZoneRuleConditionStringComparison[];
    /**
     * @deprecated 'string_condition_key' is deprecated. You should use 'string_key'
     */
    stringConditionKeys?: outputs.ManagementZoneRuleConditionStringConditionKey[];
    stringKeys?: outputs.ManagementZoneRuleConditionStringKey[];
    strings?: outputs.ManagementZoneRuleConditionString[];
    /**
     * @deprecated You should use 'synthetic_engine' instead of 'synthetic_engine_type_comparison'. This attribute still exists for backwards compatibility.
     */
    syntheticEngineTypeComparisons?: outputs.ManagementZoneRuleConditionSyntheticEngineTypeComparison[];
    syntheticEngines?: outputs.ManagementZoneRuleConditionSyntheticEngine[];
    /**
     * @deprecated You should use 'tag' instead of 'tag_comparison'. This attribute still exists for backwards compatibility.
     */
    tagComparisons?: outputs.ManagementZoneRuleConditionTagComparison[];
    tags?: outputs.ManagementZoneRuleConditionTag[];
    teches?: outputs.ManagementZoneRuleConditionTech[];
    unknowns?: string;
}

export interface ManagementZoneRuleConditionApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionAzureComputeMode {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionAzureComputeModeComparison {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionAzureSkuComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionAzureSkus {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionBaseComparisonBasic {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionBaseConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionBitness {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionBitnessComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionCloudType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionCloudTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionComparison {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionCustomApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionCustomApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionCustomHostMetadata {
    attribute: string;
    dynamicKey: outputs.ManagementZoneRuleConditionCustomHostMetadataDynamicKey;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionCustomHostMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.ManagementZoneRuleConditionCustomHostMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionCustomHostMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionCustomHostMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionCustomProcessMetadata {
    attribute: string;
    dynamicKey: outputs.ManagementZoneRuleConditionCustomProcessMetadataDynamicKey;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionCustomProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.ManagementZoneRuleConditionCustomProcessMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionCustomProcessMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionCustomProcessMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionDatabaseTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionDatabaseTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionDcrumDecoder {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionDcrumDecoderComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionEntity {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionEntityIdComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionHostTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ManagementZoneRuleConditionHostTechValue;
}

export interface ManagementZoneRuleConditionHostTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ManagementZoneRuleConditionHypervisor {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionHypervisorTypeComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionIndexedName {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionIndexedNameComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionIndexedString {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionIndexedStringComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionIndexedTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ManagementZoneRuleConditionIndexedTagValue;
}

export interface ManagementZoneRuleConditionIndexedTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ManagementZoneRuleConditionIndexedTagComparisonValue;
}

export interface ManagementZoneRuleConditionIndexedTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionIndexedTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionInteger {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: number;
}

export interface ManagementZoneRuleConditionIntegerComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: number;
}

export interface ManagementZoneRuleConditionIpaddress {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionIpaddressComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionMobilePlatform {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionMobilePlatformComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionOsArch {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionOsType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionOsarchitectureComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionOstypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionPaasType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionPaasTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionProcessMetadata {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionServiceTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionServiceTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionServiceType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionServiceTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionSimpleHostTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ManagementZoneRuleConditionSimpleHostTechComparisonValue;
}

export interface ManagementZoneRuleConditionSimpleHostTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ManagementZoneRuleConditionSimpleTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ManagementZoneRuleConditionSimpleTechComparisonValue;
}

export interface ManagementZoneRuleConditionSimpleTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ManagementZoneRuleConditionString {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionStringComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionStringConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionStringKey {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface ManagementZoneRuleConditionSyntheticEngine {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionSyntheticEngineTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ManagementZoneRuleConditionTagValue;
}

export interface ManagementZoneRuleConditionTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ManagementZoneRuleConditionTagComparisonValue;
}

export interface ManagementZoneRuleConditionTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ManagementZoneRuleConditionTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ManagementZoneRuleConditionTechValue;
}

export interface ManagementZoneRuleConditionTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface MobileApplicationApdex {
    /**
     * Apdex **frustrated** threshold, in milliseconds: a duration greater than or equal to this value is considered frustrated
     */
    frustrated: number;
    /**
     * Apdex error condition: if `true` the user session is considered frustrated when an error is reported
     */
    frustratedOnError?: boolean;
    /**
     * Apdex **tolerable** threshold, in milliseconds: a duration greater than or equal to this value is considered tolerable
     */
    tolerable: number;
}

export interface MobileApplicationProperties {
    /**
     * A User Action / Session Property based on a value reported by the API
     */
    apiValues?: outputs.MobileApplicationPropertiesApiValue[];
    /**
     * A User Action / Session Property based on a Server Side Request Attribute
     */
    requestAttributes?: outputs.MobileApplicationPropertiesRequestAttribute[];
}

export interface MobileApplicationPropertiesApiValue {
    aggregation?: string;
    cleanupRule?: string;
    displayName?: string;
    key: string;
    /**
     * The name of the application
     */
    name?: string;
    storeAsSessionProperty?: boolean;
    storeAsUserActionProperty?: boolean;
    type: string;
}

export interface MobileApplicationPropertiesRequestAttribute {
    aggregation?: string;
    cleanupRule?: string;
    displayName?: string;
    id: string;
    key: string;
    storeAsSessionProperty?: boolean;
    storeAsUserActionProperty?: boolean;
    type: string;
}

export interface NotificationAnsibleTower {
    /**
     * Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
     */
    acceptAnyCertificate: boolean;
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The custom message of the notification.   This message will be displayed in the extra variables **Message** field of your job template.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
     */
    customMessage: string;
    /**
     * The ID of the target Ansible Tower job template
     */
    jobTemplateId: number;
    /**
     * The URL of the target Ansible Tower job template
     */
    jobTemplateUrl: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * The password for the Ansible Tower account
     */
    password?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * The username of the Ansible Tower account
     */
    username: string;
}

export interface NotificationConfig {
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * Defines the actual set of fields depending on the value. See one of the following objects:  * `EMAIL` > EmailNotificationConfig  * `PAGER_DUTY` > PagerDutyNotificationConfig  * `WEBHOOK` > WebHookNotificationConfig  * `SLACK` > SlackNotificationConfig  * `HIPCHAT` > HipChatNotificationConfig  * `VICTOROPS` > VictorOpsNotificationConfig  * `SERVICE_NOW` > ServiceNowNotificationConfig  * `XMATTERS` > XMattersNotificationConfig  * `ANSIBLETOWER` > AnsibleTowerNotificationConfig  * `OPS_GENIE` > OpsGenieNotificationConfig  * `JIRA` > JiraNotificationConfig  * `TRELLO` > TrelloNotificationConfig
     */
    type: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface NotificationEmail {
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The list of the email BCC-recipients
     */
    bccReceivers?: string[];
    /**
     * The template of the email notification.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
     */
    body: string;
    /**
     * The list of the email CC-recipients
     */
    ccReceivers?: string[];
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * The list of the email recipients
     */
    receivers?: string[];
    /**
     * The subject of the email notifications
     */
    subject: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface NotificationHipchat {
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
     */
    message: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * The URL of the HipChat WebHook.  This is confidential information, therefore GET requests return this field with the `null` value, and it is optional for PUT requests
     */
    url?: string;
}

export interface NotificationJira {
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The description of the Jira issue to be created by this notification.   You can use same placeholders as in issue summary
     */
    description: string;
    /**
     * The type of the Jira issue to be created by this notification
     */
    issueType: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * The password for the Jira profile
     */
    password?: string;
    /**
     * The project key of the Jira issue to be created by this notification
     */
    projectKey: string;
    /**
     * The summary of the Jira issue to be created by this notification.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
     */
    summary: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * The URL of the Jira API endpoint
     */
    url: string;
    /**
     * The username of the Jira profile
     */
    username: string;
}

export interface NotificationOpsGenie {
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The API key to access OpsGenie
     */
    apiKey?: string;
    /**
     * The region domain of the OpsGenie
     */
    domain: string;
    /**
     * The content of the message.  You can use the following placeholders:  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem
     */
    message: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface NotificationPagerDuty {
    /**
     * The name of the PagerDuty account
     */
    account: string;
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * The API key to access PagerDuty
     */
    serviceApiKey?: string;
    /**
     * The name of the service
     */
    serviceName: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface NotificationServiceNow {
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The ServiceNow instance identifier. It refers to the first part of your own ServiceNow URL.   This field is mutually exclusive with the **url** field. You can only use one of them
     */
    instanceName?: string;
    /**
     * The content of the ServiceNow description.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
     */
    message: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * The username to the ServiceNow account
     */
    password?: string;
    /**
     * Send events into ServiceNow ITOM (`true`)
     */
    sendEvents: boolean;
    /**
     * Send incidents into ServiceNow ITSM (`true`)
     */
    sendIncidents: boolean;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * The URL of the on-premise ServiceNow installation.   This field is mutually exclusive with the **instanceName** field. You can only use one of them
     */
    url?: string;
    /**
     * The username of the ServiceNow account.   Make sure that your user account has the `restService`, `webRequestAdmin`, and `x_dynat_ruxit.Integration` roles
     */
    username: string;
}

export interface NotificationSlack {
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The channel (for example, `#general`) or the user (for example, `@john.smith`) to send the message to
     */
    channel: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * The content of the message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
     */
    title: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * The URL of the Slack WebHook.  This is confidential information, therefore GET requests return this field with the `null` value, and it is optional for PUT requests
     */
    url?: string;
}

export interface NotificationTrello {
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The application key for the Trello account
     */
    applicationKey: string;
    /**
     * The application token for the Trello account
     */
    authorizationToken?: string;
    /**
     * The Trello board to which the card should be assigned
     */
    boardId: string;
    /**
     * The description of the Trello card.   You can use same placeholders as in card text
     */
    description: string;
    /**
     * The Trello list to which the card should be assigned
     */
    listId: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * The Trello list to which the card of the resolved problem should be assigned
     */
    resolvedListId: string;
    /**
     * The text of the generated Trello card.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
     */
    text: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface NotificationVictorOps {
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * The API key for the target VictorOps account
     */
    apiKey?: string;
    /**
     * The content of the message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`
     */
    message: string;
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * The routing key, defining the group to be notified
     */
    routingKey: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface NotificationWebHook {
    /**
     * Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
     */
    acceptAnyCertificate: boolean;
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * A list of the additional HTTP headers
     */
    headers?: outputs.NotificationWebHookHeader[];
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * Call webhook if new events merge into existing problems
     */
    notifyEventMerges?: boolean;
    /**
     * The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
     */
    payload: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * The URL of the WebHook endpoint
     */
    url: string;
}

export interface NotificationWebHookHeader {
    name: string;
    value?: string;
}

export interface NotificationXmatters {
    /**
     * Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
     */
    acceptAnyCertificate: boolean;
    /**
     * The configuration is enabled (`true`) or disabled (`false`)
     */
    active: boolean;
    /**
     * The ID of the associated alerting profile
     */
    alertingProfile: string;
    /**
     * A list of the additional HTTP headers
     */
    headers?: outputs.NotificationXmattersHeader[];
    /**
     * The name of the notification configuration
     */
    name: string;
    /**
     * The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
     */
    payload: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    /**
     * The URL of the xMatters WebHook
     */
    url: string;
}

export interface NotificationXmattersHeader {
    name: string;
    value?: string;
}

export interface ProcessgroupNamingCondition {
    conditions?: outputs.ProcessgroupNamingConditionCondition[];
}

export interface ProcessgroupNamingConditionCondition {
    /**
     * @deprecated You should use 'application_type' instead of 'application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    applicationTypeComparisons?: outputs.ProcessgroupNamingConditionConditionApplicationTypeComparison[];
    applicationTypes?: outputs.ProcessgroupNamingConditionConditionApplicationType[];
    azureComputeModeComparisons?: outputs.ProcessgroupNamingConditionConditionAzureComputeModeComparison[];
    /**
     * @deprecated You should use 'azure_compute_mode' instead of 'azure_compute_mode_comparison'. This attribute still exists for backwards compatibility.
     */
    azureComputeModes?: outputs.ProcessgroupNamingConditionConditionAzureComputeMode[];
    /**
     * @deprecated You should use 'azure_sku' instead of 'azure_sku_comparision'. This attribute still exists for backwards compatibility.
     */
    azureSkuComparisions?: outputs.ProcessgroupNamingConditionConditionAzureSkuComparision[];
    azureSkus?: outputs.ProcessgroupNamingConditionConditionAzureSkus[];
    /**
     * @deprecated You should use 'comparison' instead of 'base_comparison_basic'. This attribute still exists for backwards compatibility.
     */
    baseComparisonBasics?: outputs.ProcessgroupNamingConditionConditionBaseComparisonBasic[];
    /**
     * @deprecated 'base_condition_key' is deprecated. You should use 'key'
     */
    baseConditionKeys?: outputs.ProcessgroupNamingConditionConditionBaseConditionKey[];
    /**
     * @deprecated You should use 'bitness' instead of 'bitness_comparision'. This attribute still exists for backwards compatibility.
     */
    bitnessComparisions?: outputs.ProcessgroupNamingConditionConditionBitnessComparision[];
    bitnesses?: outputs.ProcessgroupNamingConditionConditionBitness[];
    /**
     * @deprecated You should use 'cloud_type' instead of 'cloud_type_comparison'. This attribute still exists for backwards compatibility.
     */
    cloudTypeComparisons?: outputs.ProcessgroupNamingConditionConditionCloudTypeComparison[];
    cloudTypes?: outputs.ProcessgroupNamingConditionConditionCloudType[];
    comparisons?: outputs.ProcessgroupNamingConditionConditionComparison[];
    /**
     * @deprecated You should use 'custom_application_type' instead of 'custom_application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    customApplicationTypeComparisons?: outputs.ProcessgroupNamingConditionConditionCustomApplicationTypeComparison[];
    customApplicationTypes?: outputs.ProcessgroupNamingConditionConditionCustomApplicationType[];
    /**
     * @deprecated 'custom_host_metadata_condition_key' is deprecated. You should use 'custom_host_metadata'
     */
    customHostMetadataConditionKeys?: outputs.ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey[];
    customHostMetadatas?: outputs.ProcessgroupNamingConditionConditionCustomHostMetadata[];
    /**
     * @deprecated 'custom_process_metadata_condition_key' is deprecated. You should use 'custom_process_metadata'
     */
    customProcessMetadataConditionKeys?: outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey[];
    customProcessMetadatas?: outputs.ProcessgroupNamingConditionConditionCustomProcessMetadata[];
    databaseTopologies?: outputs.ProcessgroupNamingConditionConditionDatabaseTopology[];
    /**
     * @deprecated You should use 'database_topology' instead of 'database_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    databaseTopologyComparisons?: outputs.ProcessgroupNamingConditionConditionDatabaseTopologyComparison[];
    /**
     * @deprecated You should use 'dcrum_decoder' instead of 'dcrum_decoder_comparison'. This attribute still exists for backwards compatibility.
     */
    dcrumDecoderComparisons?: outputs.ProcessgroupNamingConditionConditionDcrumDecoderComparison[];
    dcrumDecoders?: outputs.ProcessgroupNamingConditionConditionDcrumDecoder[];
    entities?: outputs.ProcessgroupNamingConditionConditionEntity[];
    /**
     * @deprecated You should use 'entity' instead of 'entity_id_comparison'. This attribute still exists for backwards compatibility.
     */
    entityIdComparisons?: outputs.ProcessgroupNamingConditionConditionEntityIdComparison[];
    hostTeches?: outputs.ProcessgroupNamingConditionConditionHostTech[];
    /**
     * @deprecated `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
     */
    hypervisorTypeComparisions?: outputs.ProcessgroupNamingConditionConditionHypervisorTypeComparision[];
    hypervisors?: outputs.ProcessgroupNamingConditionConditionHypervisor[];
    /**
     * @deprecated You should use 'indexed_name' instead of 'indexed_name_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedNameComparisons?: outputs.ProcessgroupNamingConditionConditionIndexedNameComparison[];
    indexedNames?: outputs.ProcessgroupNamingConditionConditionIndexedName[];
    /**
     * @deprecated You should use 'indexed_string' instead of 'indexed_string_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedStringComparisons?: outputs.ProcessgroupNamingConditionConditionIndexedStringComparison[];
    indexedStrings?: outputs.ProcessgroupNamingConditionConditionIndexedString[];
    /**
     * @deprecated You should use 'indexed_tag' instead of 'indexed_tag_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedTagComparisons?: outputs.ProcessgroupNamingConditionConditionIndexedTagComparison[];
    indexedTags?: outputs.ProcessgroupNamingConditionConditionIndexedTag[];
    /**
     * @deprecated You should use 'integer' instead of 'integer_comparison'. This attribute still exists for backwards compatibility.
     */
    integerComparisons?: outputs.ProcessgroupNamingConditionConditionIntegerComparison[];
    integers?: outputs.ProcessgroupNamingConditionConditionInteger[];
    /**
     * @deprecated You should use 'ipaddress' instead of 'ipaddress_comparison'. This attribute still exists for backwards compatibility.
     */
    ipaddressComparisons?: outputs.ProcessgroupNamingConditionConditionIpaddressComparison[];
    ipaddresses?: outputs.ProcessgroupNamingConditionConditionIpaddress[];
    keys?: outputs.ProcessgroupNamingConditionConditionKey[];
    /**
     * @deprecated You should use 'mobile_platform' instead of 'mobile_platform_comparison'. This attribute still exists for backwards compatibility.
     */
    mobilePlatformComparisons?: outputs.ProcessgroupNamingConditionConditionMobilePlatformComparison[];
    mobilePlatforms?: outputs.ProcessgroupNamingConditionConditionMobilePlatform[];
    osArches?: outputs.ProcessgroupNamingConditionConditionOsArch[];
    osTypes?: outputs.ProcessgroupNamingConditionConditionOsType[];
    /**
     * @deprecated You should use 'os_arch' instead of 'osarchitecture_comparison'. This attribute still exists for backwards compatibility.
     */
    osarchitectureComparisons?: outputs.ProcessgroupNamingConditionConditionOsarchitectureComparison[];
    /**
     * @deprecated You should use 'os_type' instead of 'ostype_comparison'. This attribute still exists for backwards compatibility.
     */
    ostypeComparisons?: outputs.ProcessgroupNamingConditionConditionOstypeComparison[];
    /**
     * @deprecated You should use 'paas_type' instead of 'paas_type_comparison'. This attribute still exists for backwards compatibility.
     */
    paasTypeComparisons?: outputs.ProcessgroupNamingConditionConditionPaasTypeComparison[];
    paasTypes?: outputs.ProcessgroupNamingConditionConditionPaasType[];
    /**
     * @deprecated 'process_metadata_condition_key' is deprecated. You should use 'process_metadata'
     */
    processMetadataConditionKeys?: outputs.ProcessgroupNamingConditionConditionProcessMetadataConditionKey[];
    processMetadatas?: outputs.ProcessgroupNamingConditionConditionProcessMetadata[];
    serviceTopologies?: outputs.ProcessgroupNamingConditionConditionServiceTopology[];
    /**
     * @deprecated You should use 'service_topology' instead of 'service_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTopologyComparisons?: outputs.ProcessgroupNamingConditionConditionServiceTopologyComparison[];
    /**
     * @deprecated You should use 'service_type' instead of 'service_type_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTypeComparisons?: outputs.ProcessgroupNamingConditionConditionServiceTypeComparison[];
    serviceTypes?: outputs.ProcessgroupNamingConditionConditionServiceType[];
    /**
     * @deprecated You should use 'host_tech' instead of 'simple_host_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleHostTechComparisons?: outputs.ProcessgroupNamingConditionConditionSimpleHostTechComparison[];
    /**
     * @deprecated You should use 'tech' instead of 'simple_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleTechComparisons?: outputs.ProcessgroupNamingConditionConditionSimpleTechComparison[];
    /**
     * @deprecated You should use 'string' instead of 'string_comparison'. This attribute still exists for backwards compatibility.
     */
    stringComparisons?: outputs.ProcessgroupNamingConditionConditionStringComparison[];
    /**
     * @deprecated 'string_condition_key' is deprecated. You should use 'string_key'
     */
    stringConditionKeys?: outputs.ProcessgroupNamingConditionConditionStringConditionKey[];
    stringKeys?: outputs.ProcessgroupNamingConditionConditionStringKey[];
    strings?: outputs.ProcessgroupNamingConditionConditionString[];
    /**
     * @deprecated You should use 'synthetic_engine' instead of 'synthetic_engine_type_comparison'. This attribute still exists for backwards compatibility.
     */
    syntheticEngineTypeComparisons?: outputs.ProcessgroupNamingConditionConditionSyntheticEngineTypeComparison[];
    syntheticEngines?: outputs.ProcessgroupNamingConditionConditionSyntheticEngine[];
    /**
     * @deprecated You should use 'tag' instead of 'tag_comparison'. This attribute still exists for backwards compatibility.
     */
    tagComparisons?: outputs.ProcessgroupNamingConditionConditionTagComparison[];
    tags?: outputs.ProcessgroupNamingConditionConditionTag[];
    teches?: outputs.ProcessgroupNamingConditionConditionTech[];
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionAzureComputeMode {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionAzureComputeModeComparison {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionAzureSkuComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionAzureSkus {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionBaseComparisonBasic {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionBaseConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionBitness {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionBitnessComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionCloudType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionCloudTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionComparison {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionCustomApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionCustomApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionCustomHostMetadata {
    attribute: string;
    dynamicKey: outputs.ProcessgroupNamingConditionConditionCustomHostMetadataDynamicKey;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.ProcessgroupNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionCustomHostMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionCustomProcessMetadata {
    attribute: string;
    dynamicKey: outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataDynamicKey;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionCustomProcessMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionDatabaseTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionDatabaseTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionDcrumDecoder {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionDcrumDecoderComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionEntity {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionEntityIdComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionHostTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ProcessgroupNamingConditionConditionHostTechValue;
}

export interface ProcessgroupNamingConditionConditionHostTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ProcessgroupNamingConditionConditionHypervisor {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionHypervisorTypeComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionIndexedName {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionIndexedNameComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionIndexedString {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionIndexedStringComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionIndexedTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ProcessgroupNamingConditionConditionIndexedTagValue;
}

export interface ProcessgroupNamingConditionConditionIndexedTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ProcessgroupNamingConditionConditionIndexedTagComparisonValue;
}

export interface ProcessgroupNamingConditionConditionIndexedTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionIndexedTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionInteger {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: number;
}

export interface ProcessgroupNamingConditionConditionIntegerComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: number;
}

export interface ProcessgroupNamingConditionConditionIpaddress {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionIpaddressComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionMobilePlatform {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionMobilePlatformComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionOsArch {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionOsType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionOsarchitectureComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionOstypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionPaasType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionPaasTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionProcessMetadata {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionServiceTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionServiceTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionServiceType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionServiceTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionSimpleHostTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue;
}

export interface ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ProcessgroupNamingConditionConditionSimpleTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ProcessgroupNamingConditionConditionSimpleTechComparisonValue;
}

export interface ProcessgroupNamingConditionConditionSimpleTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ProcessgroupNamingConditionConditionString {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionStringComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionStringConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionStringKey {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface ProcessgroupNamingConditionConditionSyntheticEngine {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionSyntheticEngineTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ProcessgroupNamingConditionConditionTagValue;
}

export interface ProcessgroupNamingConditionConditionTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ProcessgroupNamingConditionConditionTagComparisonValue;
}

export interface ProcessgroupNamingConditionConditionTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ProcessgroupNamingConditionConditionTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ProcessgroupNamingConditionConditionTechValue;
}

export interface ProcessgroupNamingConditionConditionTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface QueueManagerAliasQueue {
    /**
     * Alias queue definitions for queue manager
     */
    aliasQueues?: outputs.QueueManagerAliasQueueAliasQueue[];
}

export interface QueueManagerAliasQueueAliasQueue {
    aliasQueueName: string;
    baseQueueName: string;
    clusterVisibilities?: string[];
}

export interface QueueManagerClusterQueue {
    /**
     * Cluster queue definitions for queue manager
     */
    clusterQueues?: outputs.QueueManagerClusterQueueClusterQueue[];
}

export interface QueueManagerClusterQueueClusterQueue {
    clusterVisibilities?: string[];
    localQueueName: string;
}

export interface QueueManagerRemoteQueue {
    /**
     * Remote queue definitions for queue manager
     */
    remoteQueues?: outputs.QueueManagerRemoteQueueRemoteQueue[];
}

export interface QueueManagerRemoteQueueRemoteQueue {
    clusterVisibilities?: string[];
    localQueueName: string;
    remoteQueueManager: string;
    remoteQueueName: string;
}

export interface RequestAttributeDataSource {
    /**
     * Specifies the location where the values are captured and stored.  Required if the **source** is one of the following: `GET_PARAMETER`, `URI`, `REQUEST_HEADER`, `RESPONSE_HEADER`.   Not applicable in other cases.   If the **source** value is `REQUEST_HEADER` or `RESPONSE_HEADER`, the `CAPTURE_AND_STORE_ON_BOTH` location is not allowed
     */
    capturingAndStorageLocation?: string;
    /**
     * IBM integration bus label node name condition for which the value is captured
     */
    cicsSdkMethodNodeCondition?: outputs.RequestAttributeDataSourceCicsSdkMethodNodeCondition;
    /**
     * The data source is enabled (`true`) or disabled (`false`)
     */
    enabled: boolean;
    /**
     * IBM integration bus label node name condition for which the value is captured
     */
    iibLabelMethodNodeCondition?: outputs.RequestAttributeDataSourceIibLabelMethodNodeCondition;
    /**
     * IBM integration bus label node name condition for which the value is captured
     */
    iibMethodNodeCondition?: outputs.RequestAttributeDataSourceIibMethodNodeCondition;
    /**
     * The IBM integration bus node type for which the value is captured.  This or `iibMethodNodeCondition` is required if the **source** is: `IIB_NODE`.  Not applicable in other cases
     */
    iibNodeType?: string;
    /**
     * The method specification if the **source** value is `METHOD_PARAM`.   Not applicable in other cases
     */
    methods?: outputs.RequestAttributeDataSourceMethod[];
    /**
     * The name of the web request parameter to capture.  Required if the **source** is one of the following: `POST_PARAMETER`, `GET_PARAMETER`, `REQUEST_HEADER`, `RESPONSE_HEADER`, `CUSTOM_ATTRIBUTE`.  Not applicable in other cases
     */
    parameterName?: string;
    /**
     * Conditions for data capturing
     */
    scope?: outputs.RequestAttributeDataSourceScope;
    /**
     * The technology of the session attribute to capture if the **source** value is `SESSION_ATTRIBUTE`.
     */
    sessionAttributeTechnology?: string;
    /**
     * The source of the attribute to capture. Works in conjunction with **parameterName** or **methods** and **technology**
     */
    source: string;
    technology?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    valueProcessing?: outputs.RequestAttributeDataSourceValueProcessing;
}

export interface RequestAttributeDataSourceCicsSdkMethodNodeCondition {
    negate?: boolean;
    operator: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    value: string;
}

export interface RequestAttributeDataSourceIibLabelMethodNodeCondition {
    negate?: boolean;
    operator: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    value: string;
}

export interface RequestAttributeDataSourceIibMethodNodeCondition {
    negate?: boolean;
    operator: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    value: string;
}

export interface RequestAttributeDataSourceMethod {
    argumentIndex?: number;
    capture: string;
    deepObjectAccess?: string;
    method?: outputs.RequestAttributeDataSourceMethodMethod;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface RequestAttributeDataSourceMethodMethod {
    argumentTypes?: string[];
    className?: string;
    fileName?: string;
    fileNameMatcher?: string;
    methodName: string;
    modifiers?: string[];
    returnType: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    visibility: string;
}

export interface RequestAttributeDataSourceScope {
    hostGroup?: string;
    processGroup?: string;
    serviceTechnology?: string;
    tagOfProcessGroup?: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface RequestAttributeDataSourceValueProcessing {
    extractSubstring?: outputs.RequestAttributeDataSourceValueProcessingExtractSubstring;
    splitAt?: string;
    trim?: boolean;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    valueCondition?: outputs.RequestAttributeDataSourceValueProcessingValueCondition;
    valueExtractorRegex?: string;
}

export interface RequestAttributeDataSourceValueProcessingExtractSubstring {
    delimiter: string;
    endDelimiter?: string;
    position: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
}

export interface RequestAttributeDataSourceValueProcessingValueCondition {
    negate?: boolean;
    operator: string;
    /**
     * allows for configuring properties that are not explicitly supported by the current version of this provider
     */
    unknowns?: string;
    value: string;
}

export interface RequestNamingConditions {
    conditions?: outputs.RequestNamingConditionsCondition[];
}

export interface RequestNamingConditionsCondition {
    attribute: string;
    comparison: outputs.RequestNamingConditionsConditionComparison;
}

export interface RequestNamingConditionsConditionComparison {
    boolean?: outputs.RequestNamingConditionsConditionComparisonBoolean;
    esbInputNodeType?: outputs.RequestNamingConditionsConditionComparisonEsbInputNodeType;
    failedState?: outputs.RequestNamingConditionsConditionComparisonFailedState;
    failureReason?: outputs.RequestNamingConditionsConditionComparisonFailureReason;
    fastString?: outputs.RequestNamingConditionsConditionComparisonFastString;
    flawState?: outputs.RequestNamingConditionsConditionComparisonFlawState;
    generic?: outputs.RequestNamingConditionsConditionComparisonGeneric;
    httpMethod?: outputs.RequestNamingConditionsConditionComparisonHttpMethod;
    httpStatusClass?: outputs.RequestNamingConditionsConditionComparisonHttpStatusClass;
    iibInputNodeType?: outputs.RequestNamingConditionsConditionComparisonIibInputNodeType;
    negate?: boolean;
    number?: outputs.RequestNamingConditionsConditionComparisonNumber;
    numberRequestAttribute?: outputs.RequestNamingConditionsConditionComparisonNumberRequestAttribute;
    serviceType?: outputs.RequestNamingConditionsConditionComparisonServiceType;
    string?: outputs.RequestNamingConditionsConditionComparisonString;
    stringRequestAttribute?: outputs.RequestNamingConditionsConditionComparisonStringRequestAttribute;
    tag?: outputs.RequestNamingConditionsConditionComparisonTag;
    zosCallType?: outputs.RequestNamingConditionsConditionComparisonZosCallType;
}

export interface RequestNamingConditionsConditionComparisonBoolean {
    operator?: string;
    unknowns?: string;
    value?: boolean;
    values?: boolean[];
}

export interface RequestNamingConditionsConditionComparisonEsbInputNodeType {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonFailedState {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonFailureReason {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonFastString {
    caseSensitive?: boolean;
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonFlawState {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonGeneric {
    type: string;
    unknowns?: string;
}

export interface RequestNamingConditionsConditionComparisonHttpMethod {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonHttpStatusClass {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonIibInputNodeType {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonNumber {
    operator?: string;
    unknowns?: string;
    value?: number;
    values?: number[];
}

export interface RequestNamingConditionsConditionComparisonNumberRequestAttribute {
    matchOnChildCalls?: boolean;
    operator?: string;
    requestAttribute: string;
    source?: outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSource;
    unknowns?: string;
    value?: number;
    values?: number[];
}

export interface RequestNamingConditionsConditionComparisonNumberRequestAttributeSource {
    managementZone?: string;
    serviceTag?: outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag;
    unknowns?: string;
}

export interface RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag {
    context?: string;
    key: string;
    tagKey?: outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey;
    value?: string;
}

export interface RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey {
    context?: string;
    key?: string;
}

export interface RequestNamingConditionsConditionComparisonServiceType {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonString {
    caseSensitive?: boolean;
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonStringRequestAttribute {
    caseSensitive?: boolean;
    matchOnChildCalls?: boolean;
    operator?: string;
    requestAttribute: string;
    source?: outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSource;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingConditionsConditionComparisonStringRequestAttributeSource {
    managementZone?: string;
    serviceTag?: outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag;
    unknowns?: string;
}

export interface RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag {
    context?: string;
    key: string;
    tagKey?: outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey;
    value?: string;
}

export interface RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey {
    context?: string;
    key?: string;
}

export interface RequestNamingConditionsConditionComparisonTag {
    operator?: string;
    unknowns?: string;
    value?: outputs.RequestNamingConditionsConditionComparisonTagValue;
    values?: outputs.RequestNamingConditionsConditionComparisonTagValues;
}

export interface RequestNamingConditionsConditionComparisonTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface RequestNamingConditionsConditionComparisonTagValues {
    values?: outputs.RequestNamingConditionsConditionComparisonTagValuesValue[];
}

export interface RequestNamingConditionsConditionComparisonTagValuesValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface RequestNamingConditionsConditionComparisonZosCallType {
    operator?: string;
    unknowns?: string;
    value?: string;
    values?: string[];
}

export interface RequestNamingPlaceholders {
    placeholders?: outputs.RequestNamingPlaceholdersPlaceholder[];
}

export interface RequestNamingPlaceholdersPlaceholder {
    aggregation?: string;
    attribute: string;
    delimiterOrRegex?: string;
    endDelimiter?: string;
    kind: string;
    name: string;
    normalization?: string;
    requestAttribute?: string;
    source?: outputs.RequestNamingPlaceholdersPlaceholderSource;
    unknowns?: string;
    useFromChildCalls?: boolean;
}

export interface RequestNamingPlaceholdersPlaceholderSource {
    managementZone?: string;
    serviceTag?: outputs.RequestNamingPlaceholdersPlaceholderSourceServiceTag;
    unknowns?: string;
}

export interface RequestNamingPlaceholdersPlaceholderSourceServiceTag {
    context?: string;
    key: string;
    tagKey?: outputs.RequestNamingPlaceholdersPlaceholderSourceServiceTagTagKey;
    value?: string;
}

export interface RequestNamingPlaceholdersPlaceholderSourceServiceTagTagKey {
    context?: string;
    key?: string;
}

export interface ServiceAnomaliesFailureRates {
    /**
     * Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
     */
    auto?: outputs.ServiceAnomaliesFailureRatesAuto;
    /**
     * Fixed thresholds for failure rate increase detection
     */
    thresholds?: outputs.ServiceAnomaliesFailureRatesThresholds;
}

export interface ServiceAnomaliesFailureRatesAuto {
    absolute: number;
    relative: number;
    unknowns?: string;
}

export interface ServiceAnomaliesFailureRatesThresholds {
    sensitivity: string;
    threshold: number;
    unknowns?: string;
}

export interface ServiceAnomaliesLoad {
    /**
     * The configuration of traffic drops detection
     */
    drops?: outputs.ServiceAnomaliesLoadDrops;
    /**
     * The configuration of traffic spikes detection
     */
    spikes?: outputs.ServiceAnomaliesLoadSpikes;
}

export interface ServiceAnomaliesLoadDrops {
    /**
     * Alert if the service stays in abnormal state for at least *X* minutes
     */
    minutes?: number;
    /**
     * Alert if the observed load is more than *X* % of the expected value
     */
    percent?: number;
}

export interface ServiceAnomaliesLoadSpikes {
    minutes?: number;
    percent?: number;
    unknowns?: string;
}

export interface ServiceAnomaliesResponseTimes {
    /**
     * Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
     */
    auto?: outputs.ServiceAnomaliesResponseTimesAuto;
    /**
     * Fixed thresholds for response time degradation detection
     */
    thresholds?: outputs.ServiceAnomaliesResponseTimesThresholds;
}

export interface ServiceAnomaliesResponseTimesAuto {
    /**
     * The configuration of load spikes detection. Detecting load spikes will be disabled if this block is omitted.
     */
    load: string;
    milliseconds: number;
    percent: number;
    slowestMilliseconds: number;
    slowestPercent: number;
    unknowns?: string;
}

export interface ServiceAnomaliesResponseTimesThresholds {
    /**
     * The configuration of load spikes detection. Detecting load spikes will be disabled if this block is omitted.
     */
    load: string;
    milliseconds: number;
    sensitivity: string;
    slowestMilliseconds: number;
    unknowns?: string;
}

export interface ServiceNamingCondition {
    conditions?: outputs.ServiceNamingConditionCondition[];
}

export interface ServiceNamingConditionCondition {
    /**
     * @deprecated You should use 'application_type' instead of 'application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    applicationTypeComparisons?: outputs.ServiceNamingConditionConditionApplicationTypeComparison[];
    applicationTypes?: outputs.ServiceNamingConditionConditionApplicationType[];
    azureComputeModeComparisons?: outputs.ServiceNamingConditionConditionAzureComputeModeComparison[];
    /**
     * @deprecated You should use 'azure_compute_mode' instead of 'azure_compute_mode_comparison'. This attribute still exists for backwards compatibility.
     */
    azureComputeModes?: outputs.ServiceNamingConditionConditionAzureComputeMode[];
    /**
     * @deprecated You should use 'azure_sku' instead of 'azure_sku_comparision'. This attribute still exists for backwards compatibility.
     */
    azureSkuComparisions?: outputs.ServiceNamingConditionConditionAzureSkuComparision[];
    azureSkus?: outputs.ServiceNamingConditionConditionAzureSkus[];
    /**
     * @deprecated You should use 'comparison' instead of 'base_comparison_basic'. This attribute still exists for backwards compatibility.
     */
    baseComparisonBasics?: outputs.ServiceNamingConditionConditionBaseComparisonBasic[];
    /**
     * @deprecated 'base_condition_key' is deprecated. You should use 'key'
     */
    baseConditionKeys?: outputs.ServiceNamingConditionConditionBaseConditionKey[];
    /**
     * @deprecated You should use 'bitness' instead of 'bitness_comparision'. This attribute still exists for backwards compatibility.
     */
    bitnessComparisions?: outputs.ServiceNamingConditionConditionBitnessComparision[];
    bitnesses?: outputs.ServiceNamingConditionConditionBitness[];
    /**
     * @deprecated You should use 'cloud_type' instead of 'cloud_type_comparison'. This attribute still exists for backwards compatibility.
     */
    cloudTypeComparisons?: outputs.ServiceNamingConditionConditionCloudTypeComparison[];
    cloudTypes?: outputs.ServiceNamingConditionConditionCloudType[];
    comparisons?: outputs.ServiceNamingConditionConditionComparison[];
    /**
     * @deprecated You should use 'custom_application_type' instead of 'custom_application_type_comparison'. This attribute still exists for backwards compatibility.
     */
    customApplicationTypeComparisons?: outputs.ServiceNamingConditionConditionCustomApplicationTypeComparison[];
    customApplicationTypes?: outputs.ServiceNamingConditionConditionCustomApplicationType[];
    /**
     * @deprecated 'custom_host_metadata_condition_key' is deprecated. You should use 'custom_host_metadata'
     */
    customHostMetadataConditionKeys?: outputs.ServiceNamingConditionConditionCustomHostMetadataConditionKey[];
    customHostMetadatas?: outputs.ServiceNamingConditionConditionCustomHostMetadata[];
    /**
     * @deprecated 'custom_process_metadata_condition_key' is deprecated. You should use 'custom_process_metadata'
     */
    customProcessMetadataConditionKeys?: outputs.ServiceNamingConditionConditionCustomProcessMetadataConditionKey[];
    customProcessMetadatas?: outputs.ServiceNamingConditionConditionCustomProcessMetadata[];
    databaseTopologies?: outputs.ServiceNamingConditionConditionDatabaseTopology[];
    /**
     * @deprecated You should use 'database_topology' instead of 'database_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    databaseTopologyComparisons?: outputs.ServiceNamingConditionConditionDatabaseTopologyComparison[];
    /**
     * @deprecated You should use 'dcrum_decoder' instead of 'dcrum_decoder_comparison'. This attribute still exists for backwards compatibility.
     */
    dcrumDecoderComparisons?: outputs.ServiceNamingConditionConditionDcrumDecoderComparison[];
    dcrumDecoders?: outputs.ServiceNamingConditionConditionDcrumDecoder[];
    entities?: outputs.ServiceNamingConditionConditionEntity[];
    /**
     * @deprecated You should use 'entity' instead of 'entity_id_comparison'. This attribute still exists for backwards compatibility.
     */
    entityIdComparisons?: outputs.ServiceNamingConditionConditionEntityIdComparison[];
    hostTeches?: outputs.ServiceNamingConditionConditionHostTech[];
    /**
     * @deprecated `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
     */
    hypervisorTypeComparisions?: outputs.ServiceNamingConditionConditionHypervisorTypeComparision[];
    hypervisors?: outputs.ServiceNamingConditionConditionHypervisor[];
    /**
     * @deprecated You should use 'indexed_name' instead of 'indexed_name_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedNameComparisons?: outputs.ServiceNamingConditionConditionIndexedNameComparison[];
    indexedNames?: outputs.ServiceNamingConditionConditionIndexedName[];
    /**
     * @deprecated You should use 'indexed_string' instead of 'indexed_string_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedStringComparisons?: outputs.ServiceNamingConditionConditionIndexedStringComparison[];
    indexedStrings?: outputs.ServiceNamingConditionConditionIndexedString[];
    /**
     * @deprecated You should use 'indexed_tag' instead of 'indexed_tag_comparison'. This attribute still exists for backwards compatibility.
     */
    indexedTagComparisons?: outputs.ServiceNamingConditionConditionIndexedTagComparison[];
    indexedTags?: outputs.ServiceNamingConditionConditionIndexedTag[];
    /**
     * @deprecated You should use 'integer' instead of 'integer_comparison'. This attribute still exists for backwards compatibility.
     */
    integerComparisons?: outputs.ServiceNamingConditionConditionIntegerComparison[];
    integers?: outputs.ServiceNamingConditionConditionInteger[];
    /**
     * @deprecated You should use 'ipaddress' instead of 'ipaddress_comparison'. This attribute still exists for backwards compatibility.
     */
    ipaddressComparisons?: outputs.ServiceNamingConditionConditionIpaddressComparison[];
    ipaddresses?: outputs.ServiceNamingConditionConditionIpaddress[];
    keys?: outputs.ServiceNamingConditionConditionKey[];
    /**
     * @deprecated You should use 'mobile_platform' instead of 'mobile_platform_comparison'. This attribute still exists for backwards compatibility.
     */
    mobilePlatformComparisons?: outputs.ServiceNamingConditionConditionMobilePlatformComparison[];
    mobilePlatforms?: outputs.ServiceNamingConditionConditionMobilePlatform[];
    osArches?: outputs.ServiceNamingConditionConditionOsArch[];
    osTypes?: outputs.ServiceNamingConditionConditionOsType[];
    /**
     * @deprecated You should use 'os_arch' instead of 'osarchitecture_comparison'. This attribute still exists for backwards compatibility.
     */
    osarchitectureComparisons?: outputs.ServiceNamingConditionConditionOsarchitectureComparison[];
    /**
     * @deprecated You should use 'os_type' instead of 'ostype_comparison'. This attribute still exists for backwards compatibility.
     */
    ostypeComparisons?: outputs.ServiceNamingConditionConditionOstypeComparison[];
    /**
     * @deprecated You should use 'paas_type' instead of 'paas_type_comparison'. This attribute still exists for backwards compatibility.
     */
    paasTypeComparisons?: outputs.ServiceNamingConditionConditionPaasTypeComparison[];
    paasTypes?: outputs.ServiceNamingConditionConditionPaasType[];
    /**
     * @deprecated 'process_metadata_condition_key' is deprecated. You should use 'process_metadata'
     */
    processMetadataConditionKeys?: outputs.ServiceNamingConditionConditionProcessMetadataConditionKey[];
    processMetadatas?: outputs.ServiceNamingConditionConditionProcessMetadata[];
    serviceTopologies?: outputs.ServiceNamingConditionConditionServiceTopology[];
    /**
     * @deprecated You should use 'service_topology' instead of 'service_topology_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTopologyComparisons?: outputs.ServiceNamingConditionConditionServiceTopologyComparison[];
    /**
     * @deprecated You should use 'service_type' instead of 'service_type_comparison'. This attribute still exists for backwards compatibility.
     */
    serviceTypeComparisons?: outputs.ServiceNamingConditionConditionServiceTypeComparison[];
    serviceTypes?: outputs.ServiceNamingConditionConditionServiceType[];
    /**
     * @deprecated You should use 'host_tech' instead of 'simple_host_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleHostTechComparisons?: outputs.ServiceNamingConditionConditionSimpleHostTechComparison[];
    /**
     * @deprecated You should use 'tech' instead of 'simple_tech_comparison'. This attribute still exists for backwards compatibility.
     */
    simpleTechComparisons?: outputs.ServiceNamingConditionConditionSimpleTechComparison[];
    /**
     * @deprecated You should use 'string' instead of 'string_comparison'. This attribute still exists for backwards compatibility.
     */
    stringComparisons?: outputs.ServiceNamingConditionConditionStringComparison[];
    /**
     * @deprecated 'string_condition_key' is deprecated. You should use 'string_key'
     */
    stringConditionKeys?: outputs.ServiceNamingConditionConditionStringConditionKey[];
    stringKeys?: outputs.ServiceNamingConditionConditionStringKey[];
    strings?: outputs.ServiceNamingConditionConditionString[];
    /**
     * @deprecated You should use 'synthetic_engine' instead of 'synthetic_engine_type_comparison'. This attribute still exists for backwards compatibility.
     */
    syntheticEngineTypeComparisons?: outputs.ServiceNamingConditionConditionSyntheticEngineTypeComparison[];
    syntheticEngines?: outputs.ServiceNamingConditionConditionSyntheticEngine[];
    /**
     * @deprecated You should use 'tag' instead of 'tag_comparison'. This attribute still exists for backwards compatibility.
     */
    tagComparisons?: outputs.ServiceNamingConditionConditionTagComparison[];
    tags?: outputs.ServiceNamingConditionConditionTag[];
    teches?: outputs.ServiceNamingConditionConditionTech[];
    unknowns?: string;
}

export interface ServiceNamingConditionConditionApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionAzureComputeMode {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionAzureComputeModeComparison {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionAzureSkuComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionAzureSkus {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionBaseComparisonBasic {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionBaseConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionBitness {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionBitnessComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionCloudType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionCloudTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionComparison {
    negate?: boolean;
    type: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionCustomApplicationType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionCustomApplicationTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionCustomHostMetadata {
    attribute: string;
    dynamicKey: outputs.ServiceNamingConditionConditionCustomHostMetadataDynamicKey;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionCustomHostMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.ServiceNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionCustomHostMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionCustomProcessMetadata {
    attribute: string;
    dynamicKey: outputs.ServiceNamingConditionConditionCustomProcessMetadataDynamicKey;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionCustomProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: outputs.ServiceNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionCustomProcessMetadataDynamicKey {
    key: string;
    source: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionDatabaseTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionDatabaseTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionDcrumDecoder {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionDcrumDecoderComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionEntity {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionEntityIdComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionHostTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ServiceNamingConditionConditionHostTechValue;
}

export interface ServiceNamingConditionConditionHostTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ServiceNamingConditionConditionHypervisor {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionHypervisorTypeComparision {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionIndexedName {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionIndexedNameComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionIndexedString {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionIndexedStringComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionIndexedTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ServiceNamingConditionConditionIndexedTagValue;
}

export interface ServiceNamingConditionConditionIndexedTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ServiceNamingConditionConditionIndexedTagComparisonValue;
}

export interface ServiceNamingConditionConditionIndexedTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionIndexedTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionInteger {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: number;
}

export interface ServiceNamingConditionConditionIntegerComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: number;
}

export interface ServiceNamingConditionConditionIpaddress {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionIpaddressComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionKey {
    attribute: string;
    type?: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionMobilePlatform {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionMobilePlatformComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionOsArch {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionOsType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionOsarchitectureComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionOstypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionPaasType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionPaasTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionProcessMetadata {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionProcessMetadataConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionServiceTopology {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionServiceTopologyComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionServiceType {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionServiceTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionSimpleHostTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ServiceNamingConditionConditionSimpleHostTechComparisonValue;
}

export interface ServiceNamingConditionConditionSimpleHostTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ServiceNamingConditionConditionSimpleTechComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ServiceNamingConditionConditionSimpleTechComparisonValue;
}

export interface ServiceNamingConditionConditionSimpleTechComparisonValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface ServiceNamingConditionConditionString {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionStringComparison {
    caseSensitive?: boolean;
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionStringConditionKey {
    attribute: string;
    dynamicKey: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionStringKey {
    attribute: string;
    dynamicKey: string;
    unknowns?: string;
}

export interface ServiceNamingConditionConditionSyntheticEngine {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionSyntheticEngineTypeComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionTag {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ServiceNamingConditionConditionTagValue;
}

export interface ServiceNamingConditionConditionTagComparison {
    negate?: boolean;
    operator: string;
    /**
     * @deprecated The value of the attribute type is implicit, therefore shouldn't get specified
     */
    type?: string;
    unknowns?: string;
    value?: outputs.ServiceNamingConditionConditionTagComparisonValue;
}

export interface ServiceNamingConditionConditionTagComparisonValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionTagValue {
    context: string;
    key: string;
    unknowns?: string;
    value?: string;
}

export interface ServiceNamingConditionConditionTech {
    negate?: boolean;
    operator: string;
    unknowns?: string;
    value?: outputs.ServiceNamingConditionConditionTechValue;
}

export interface ServiceNamingConditionConditionTechValue {
    type?: string;
    unknowns?: string;
    verbatimType?: string;
}

export interface SpanCaptureRuleMatches {
    /**
     * Matching strategies for the Span
     */
    matches: outputs.SpanCaptureRuleMatchesMatch[];
}

export interface SpanCaptureRuleMatchesMatch {
    caseSensitive?: boolean;
    comparison: string;
    key?: string;
    source: string;
    value?: string;
}

export interface SpanContextPropagationMatches {
    /**
     * Matching strategies for the Span
     */
    matches: outputs.SpanContextPropagationMatchesMatch[];
}

export interface SpanContextPropagationMatchesMatch {
    caseSensitive?: boolean;
    comparison: string;
    key?: string;
    source: string;
    value?: string;
}

export interface SpanEntryPointMatches {
    /**
     * Matching strategies for the Span
     */
    matches: outputs.SpanEntryPointMatchesMatch[];
}

export interface SpanEntryPointMatchesMatch {
    caseSensitive?: boolean;
    comparison: string;
    key?: string;
    source: string;
    value?: string;
}

export interface UserGroupPermissions {
    /**
     * A permission granted to one or multiple environments
     */
    grants: outputs.UserGroupPermissionsGrant[];
}

export interface UserGroupPermissionsGrant {
    environments?: string[];
    permission: string;
}

export interface WebApplicationConversionGoals {
    /**
     * A conversion goal of the application
     */
    goals: outputs.WebApplicationConversionGoalsGoal[];
}

export interface WebApplicationConversionGoalsGoal {
    destination?: outputs.WebApplicationConversionGoalsGoalDestination;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of the web application, displayed in the UI
     */
    name: string;
    /**
     * The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
     */
    type?: string;
    userAction?: outputs.WebApplicationConversionGoalsGoalUserAction;
    visitDuration?: outputs.WebApplicationConversionGoalsGoalVisitDuration;
    visitNumAction?: outputs.WebApplicationConversionGoalsGoalVisitNumAction;
}

export interface WebApplicationConversionGoalsGoalDestination {
    caseSensitive?: boolean;
    matchType?: string;
    urlOrPath: string;
}

export interface WebApplicationConversionGoalsGoalUserAction {
    actionType?: string;
    caseSensitive?: boolean;
    matchEntity?: string;
    matchType?: string;
    value?: string;
}

export interface WebApplicationConversionGoalsGoalVisitDuration {
    duration: number;
}

export interface WebApplicationConversionGoalsGoalVisitNumAction {
    numUserActions?: number;
}

export interface WebApplicationCustomActionApdexSettings {
    /**
     * Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
     */
    frustratingFallbackThreshold?: number;
    /**
     * Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
     */
    frustratingThreshold?: number;
    /**
     * no documentation available
     */
    threshold?: number;
    /**
     * Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
     */
    toleratedFallbackThreshold?: number;
    /**
     * Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
     */
    toleratedThreshold?: number;
}

export interface WebApplicationKeyUserAction {
    /**
     * Configuration of the key user action
     */
    actions: outputs.WebApplicationKeyUserActionAction[];
}

export interface WebApplicationKeyUserActionAction {
    domain?: string;
    /**
     * The name of the web application, displayed in the UI
     */
    name: string;
    /**
     * The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
     */
    type: string;
}

export interface WebApplicationLoadActionApdexSettings {
    /**
     * Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
     */
    frustratingFallbackThreshold?: number;
    /**
     * Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
     */
    frustratingThreshold?: number;
    /**
     * no documentation available
     */
    threshold?: number;
    /**
     * Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
     */
    toleratedFallbackThreshold?: number;
    /**
     * Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
     */
    toleratedThreshold?: number;
}

export interface WebApplicationMetaDataCaptureSettings {
    /**
     * Java script agent meta data capture settings
     */
    captures?: outputs.WebApplicationMetaDataCaptureSettingsCapture[];
}

export interface WebApplicationMetaDataCaptureSettingsCapture {
    capturingName: string;
    /**
     * The name of the web application, displayed in the UI
     */
    name: string;
    publicMetadata?: boolean;
    /**
     * The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
     */
    type: string;
    uniqueId?: number;
    useLastValue?: boolean;
}

export interface WebApplicationMonitoringSettings {
    /**
     * Add the cross origin = anonymous attribute to capture JavaScript error messages and W3C resource timings
     */
    addCrossOriginAnonymousAttribute?: boolean;
    /**
     * Advanced JavaScript tag settings
     */
    advancedJavascriptTagSettings?: outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings;
    /**
     * The name of the angular package
     */
    angularPackageName?: string;
    /**
     * Settings for restricting certain browser type, version, platform and, comparator. It also restricts the mode
     */
    browserRestrictionSettings?: outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettings;
    /**
     * Optimize the value of cache control headers for use with Dynatrace real user monitoring enabled/disabled
     */
    cacheControlHeaderOptimizations?: boolean;
    /**
     * Settings for content capture
     */
    contentCapture: outputs.WebApplicationMonitoringSettingsContentCapture;
    /**
     * Domain for cookie placement. Maximum 150 characters.
     */
    cookiePlacementDomain?: string;
    /**
     * To enable RUM for XHR calls to AWS Lambda, define a regular expression matching these calls, Dynatrace can then automatically add a custom header (`x-dtc`) to each such request to the respective endpoints in AWS.
     */
    correlationHeaderInclusionRegex?: string;
    customConfigurationProperties?: string;
    excludeXhrRegex?: string;
    fetchRequests?: boolean;
    /**
     * Possible valures are `CODE_SNIPPET`, `CODE_SNIPPET_ASYNC`, `INLINE_CODE` and `JAVASCRIPT_TAG`.
     */
    injectionMode: string;
    ipAddressRestrictionSettings?: outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettings;
    javascriptFrameworkSupport?: outputs.WebApplicationMonitoringSettingsJavascriptFrameworkSupport;
    javascriptInjectionRules?: outputs.WebApplicationMonitoringSettingsJavascriptInjectionRules;
    libraryFileLocation?: string;
    monitoringDataPath?: string;
    scriptTagCacheDurationInHours?: number;
    secureCookieAttribute?: boolean;
    serverRequestPathId?: string;
    xmlHttpRequest?: boolean;
}

export interface WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings {
    additionalEventHandlers?: outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers;
    eventWrapperSettings?: outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings;
    globalEventCaptureSettings?: outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings;
    instrumentUnsupportedAjaxFrameworks?: boolean;
    maxActionNameLength: number;
    maxErrorsToCapture: number;
    specialCharactersToEscape?: string;
    syncBeaconFirefox?: boolean;
    syncBeaconInternetExplorer?: boolean;
}

export interface WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers {
    blur?: boolean;
    change?: boolean;
    click?: boolean;
    maxDomNodes: number;
    mouseup?: boolean;
    toStringMethod?: boolean;
    useMouseUpEventForClicks?: boolean;
}

export interface WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings {
    blur?: boolean;
    change?: boolean;
    click?: boolean;
    mouseup?: boolean;
    touchEnd?: boolean;
    touchStart?: boolean;
}

export interface WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings {
    additionalEventCapturedAsUserInput?: string;
    click?: boolean;
    doubleclick?: boolean;
    keydown?: boolean;
    keyup?: boolean;
    mousedown?: boolean;
    mouseup?: boolean;
    scroll?: boolean;
}

export interface WebApplicationMonitoringSettingsBrowserRestrictionSettings {
    mode: string;
    restrictions?: outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictions;
}

export interface WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictions {
    restrictions: outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction[];
}

export interface WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction {
    browserType: string;
    browserVersion?: string;
    comparator?: string;
    platform?: string;
}

export interface WebApplicationMonitoringSettingsContentCapture {
    javascriptErrors?: boolean;
    resourceTimingSettings?: outputs.WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings;
    timeoutSettings?: outputs.WebApplicationMonitoringSettingsContentCaptureTimeoutSettings;
    visuallyCompleteAndSpeedIndex?: boolean;
    visuallyCompleteSettings?: outputs.WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings;
}

export interface WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings {
    instrumentationDelay: number;
    nonW3cResourceTimings?: boolean;
    resourceTimingCaptureType?: string;
    resourceTimingsDomainLimit?: number;
    w3cResourceTimings?: boolean;
}

export interface WebApplicationMonitoringSettingsContentCaptureTimeoutSettings {
    temporaryActionLimit: number;
    temporaryActionTotalTimeout: number;
    timedActionSupport?: boolean;
}

export interface WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings {
    excludeUrlRegex?: string;
    ignoredMutationsList?: string;
    inactivityTimeout?: number;
    mutationTimeout?: number;
    threshold?: number;
}

export interface WebApplicationMonitoringSettingsIpAddressRestrictionSettings {
    mode: string;
    restrictions?: outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictions;
}

export interface WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictions {
    ranges: outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange[];
}

export interface WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange {
    address: string;
    addressTo?: string;
    subnetMask?: number;
}

export interface WebApplicationMonitoringSettingsJavascriptFrameworkSupport {
    activeXObject?: boolean;
    angular?: boolean;
    dojo?: boolean;
    extjs?: boolean;
    icefaces?: boolean;
    jquery?: boolean;
    mooTools?: boolean;
    prototype?: boolean;
}

export interface WebApplicationMonitoringSettingsJavascriptInjectionRules {
    rules: outputs.WebApplicationMonitoringSettingsJavascriptInjectionRulesRule[];
}

export interface WebApplicationMonitoringSettingsJavascriptInjectionRulesRule {
    enabled?: boolean;
    htmlPattern?: string;
    rule: string;
    target?: string;
    urlOperator: string;
    urlPattern?: string;
}

export interface WebApplicationSessionReplayConfig {
    /**
     * Session replay sampling rating in percent
     */
    costControlPercentage: number;
    /**
     * A list of URLs to be excluded from CSS resource capturing
     */
    cssResourceCapturingExclusionRules?: string[];
    /**
     * Capture (`true`) or don't capture (`false`) CSS resources from the session
     */
    enableCssResourceCapturing?: boolean;
    /**
     * SessionReplay Enabled/Disabled
     */
    enabled?: boolean;
}

export interface WebApplicationUserActionAndSessionProperties {
    /**
     * User action and session properties settings
     */
    properties?: outputs.WebApplicationUserActionAndSessionPropertiesProperty[];
}

export interface WebApplicationUserActionAndSessionPropertiesProperty {
    aggregation?: string;
    cleanupRule?: string;
    displayName?: string;
    /**
     * The ID of this resource.
     */
    id: number;
    ignoreCase?: boolean;
    key: string;
    longStringLength?: number;
    metadataId?: number;
    origin: string;
    serverSideRequestAttribute?: string;
    storeAsSessionProperty?: boolean;
    storeAsUserActionProperty?: boolean;
    /**
     * The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
     */
    type: string;
}

export interface WebApplicationUserActionNamingSettings {
    /**
     * User action naming rules for custom actions
     */
    customActionNamingRules?: outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRules;
    /**
     * Case insensitive naming
     */
    ignoreCase?: boolean;
    /**
     * User action naming rules for loading actions
     */
    loadActionNamingRules?: outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRules;
    /**
     * User action placeholders
     */
    placeholders?: outputs.WebApplicationUserActionNamingSettingsPlaceholders;
    /**
     * User action naming rules for custom actions
     */
    queryParameterCleanups?: string[];
    /**
     * Deactivate this setting if different domains should not result in separate user actions
     */
    splitUserActionsByDomain?: boolean;
    /**
     * First load action found under an XHR action should be used when true. Else the deepest one under the xhr action is used
     */
    useFirstDetectedLoadAction?: boolean;
    /**
     * User action naming rules for XHR actions
     */
    xhrActionNamingRules?: outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRules;
}

export interface WebApplicationUserActionNamingSettingsCustomActionNamingRules {
    rules: outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule[];
}

export interface WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule {
    conditions?: outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditions;
    template: string;
    useOrConditions?: boolean;
}

export interface WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditions {
    conditions: outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCondition[];
}

export interface WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCondition {
    operand1: string;
    operand2?: string;
    operator: string;
}

export interface WebApplicationUserActionNamingSettingsLoadActionNamingRules {
    rules: outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule[];
}

export interface WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule {
    conditions?: outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditions;
    template: string;
    useOrConditions?: boolean;
}

export interface WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditions {
    conditions: outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCondition[];
}

export interface WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCondition {
    operand1: string;
    operand2?: string;
    operator: string;
}

export interface WebApplicationUserActionNamingSettingsPlaceholders {
    placeholders: outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder[];
}

export interface WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder {
    input: string;
    metadataId?: number;
    /**
     * The name of the web application, displayed in the UI
     */
    name: string;
    processingPart: string;
    processingSteps?: outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps;
    useGuessedElementIdentifier?: boolean;
}

export interface WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps {
    steps: outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep[];
}

export interface WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep {
    fallbackToInput?: boolean;
    patternAfter?: string;
    patternAfterSearchType?: string;
    patternBefore?: string;
    patternBeforeSearchType?: string;
    patternToReplace?: string;
    regularExpression?: string;
    replacement?: string;
    /**
     * The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
     */
    type: string;
}

export interface WebApplicationUserActionNamingSettingsXhrActionNamingRules {
    rules: outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule[];
}

export interface WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule {
    conditions?: outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditions;
    template: string;
    useOrConditions?: boolean;
}

export interface WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditions {
    conditions: outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCondition[];
}

export interface WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCondition {
    operand1: string;
    operand2?: string;
    operator: string;
}

export interface WebApplicationUserTags {
    /**
     * User tag settings
     */
    tags: outputs.WebApplicationUserTagsTag[];
}

export interface WebApplicationUserTagsTag {
    cleanupRule?: string;
    /**
     * The ID of this resource.
     */
    id: number;
    ignoreCase?: boolean;
    metadataId?: number;
    serverSideRequestAttribute?: string;
}

export interface WebApplicationWaterfallSettings {
    /**
     * Warn about resources with a lower browser cache rate above *X*%. Values between 1 and 100 are allowed.
     */
    resourceBrowserCachingThreshold: number;
    /**
     * Warn about resources larger than *X* bytes. Values between 0 and 99999000 are allowed.
     */
    resourcesThreshold: number;
    /**
     * Warn about slow CDN resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
     */
    slowCndResourcesThreshold: number;
    /**
     * Warn about slow 1st party resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
     */
    slowFirstPartyResourcesThreshold: number;
    /**
     * Warn about slow 3rd party resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
     */
    slowThirdPartyResourcesThreshold: number;
    /**
     * Warn if Speed index exceeds *X* % of Visually complete. Values between 1 and 99 are allowed.
     */
    speedIndexVisuallyCompleteRatioThreshold: number;
    /**
     * Warn about uncompressed resources larger than *X* bytes. Values between 0 and 99999 are allowed.
     */
    uncompressedResourcesThreshold: number;
}

export interface WebApplicationXhrActionApdexSettings {
    /**
     * Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
     */
    frustratingFallbackThreshold?: number;
    /**
     * Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
     */
    frustratingThreshold?: number;
    /**
     * no documentation available
     */
    threshold?: number;
    /**
     * Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
     */
    toleratedFallbackThreshold?: number;
    /**
     * Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
     */
    toleratedThreshold?: number;
}

export interface WebhookNotificationHeaders {
    /**
     * An additional HTTP Header to include when sending requests
     */
    headers: outputs.WebhookNotificationHeadersHeader[];
}

export interface WebhookNotificationHeadersHeader {
    /**
     * The name of the notification configuration
     */
    name: string;
    secretValue?: string;
    value?: string;
}

export interface XmattersNotificationHeaders {
    /**
     * An additional HTTP Header to include when sending requests
     */
    headers: outputs.XmattersNotificationHeadersHeader[];
}

export interface XmattersNotificationHeadersHeader {
    /**
     * The name of the notification configuration
     */
    name: string;
    secretValue?: string;
    value?: string;
}

