// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * > **Dynatrace SaaS only**
 *
 * > To utilize this resource with access to all segments, please define the environment variables `DT_CLIENT_ID`, `DT_CLIENT_SECRET`, `DT_ACCOUNT_ID` with an OAuth client including the following permissions: **View Filter-Segments** (`storage:filter-segments:read`), **Create and Update Filter-Segments** (`storage:filter-segments:write`), **Share Filter-Segments** (`storage:filter-segments:share`), **Delete Filter-Segments** (`storage:filter-segments:delete`) and **Maintain all Filter-Segments on the environment** (`storage:filter-segments:admin`).
 *
 * > This resource is excluded by default in the export utility, please explicitly specify the resource to retrieve existing configuration.
 *
 * > The `includes.items[X].filter` attribute, which is a JSON string, is unfriendly for configuration as code. The structure of that attribute is not publicly documented and therefore subject to change without warning. The resource schema has been created to match our REST API, but we will be reaching out to product management on further enhancement of this endpoint. In the meantime, please use the export utility to create configurations more efficiently.
 *
 * ## Dynatrace Documentation
 *
 * - Segments - https://docs.dynatrace.com/docs/manage/segments
 *
 * - Grail Storage Filter-Segments (API) - https://########.apps.dynatrace.com/platform/swagger-ui/index.html?urls.primaryName=Grail+-+Filter+Segments
 *
 * ## Resource Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as dynatrace from "@pulumiverse/dynatrace";
 *
 * // ID GQ7NqJGPV1N
 * const _name_ = new dynatrace.Segment("#name#", {
 *     description: "Example description",
 *     isPublic: true,
 *     includes: {
 *         items: [
 *             {
 *                 dataObject: "_all_data_object",
 *                 filter: JSON.stringify({
 *                     children: [{
 *                         key: {
 *                             range: {
 *                                 from: 0,
 *                                 to: 16,
 *                             },
 *                             textValue: "k8s.cluster.name",
 *                             type: "Key",
 *                             value: "k8s.cluster.name",
 *                         },
 *                         operator: {
 *                             range: {
 *                                 from: 17,
 *                                 to: 18,
 *                             },
 *                             textValue: "=",
 *                             type: "ComparisonOperator",
 *                             value: "=",
 *                         },
 *                         range: {
 *                             from: 0,
 *                             to: 27,
 *                         },
 *                         type: "Statement",
 *                         value: {
 *                             range: {
 *                                 from: 19,
 *                                 to: 27,
 *                             },
 *                             textValue: "$cluster",
 *                             type: "String",
 *                             value: "$cluster",
 *                         },
 *                     }],
 *                     explicit: false,
 *                     logicalOperator: "AND",
 *                     range: {
 *                         from: 0,
 *                         to: 27,
 *                     },
 *                     type: "Group",
 *                 }),
 *             },
 *             {
 *                 dataObject: "dt.entity.cloud_application",
 *                 filter: "",
 *                 relationship: {
 *                     name: "clustered_by",
 *                     target: "dt.entity.kubernetes_cluster",
 *                 },
 *             },
 *             {
 *                 dataObject: "dt.entity.cloud_application_instance",
 *                 filter: "",
 *                 relationship: {
 *                     name: "clustered_by",
 *                     target: "dt.entity.kubernetes_cluster",
 *                 },
 *             },
 *             {
 *                 dataObject: "dt.entity.cloud_application_namespace",
 *                 filter: "",
 *                 relationship: {
 *                     name: "clustered_by",
 *                     target: "dt.entity.kubernetes_cluster",
 *                 },
 *             },
 *             {
 *                 dataObject: "dt.entity.container_group_instance",
 *                 filter: "",
 *                 relationship: {
 *                     name: "belongs_to",
 *                     target: "dt.entity.kubernetes_cluster",
 *                 },
 *             },
 *             {
 *                 dataObject: "dt.entity.host",
 *                 filter: "",
 *                 relationship: {
 *                     name: "clustered_by",
 *                     target: "dt.entity.kubernetes_cluster",
 *                 },
 *             },
 *             {
 *                 dataObject: "dt.entity.kubernetes_cluster",
 *                 filter: JSON.stringify({
 *                     children: [{
 *                         key: {
 *                             range: {
 *                                 from: 0,
 *                                 to: 11,
 *                             },
 *                             textValue: "entity.name",
 *                             type: "Key",
 *                             value: "entity.name",
 *                         },
 *                         operator: {
 *                             range: {
 *                                 from: 12,
 *                                 to: 13,
 *                             },
 *                             textValue: "=",
 *                             type: "ComparisonOperator",
 *                             value: "=",
 *                         },
 *                         range: {
 *                             from: 0,
 *                             to: 22,
 *                         },
 *                         type: "Statement",
 *                         value: {
 *                             range: {
 *                                 from: 14,
 *                                 to: 22,
 *                             },
 *                             textValue: "$cluster",
 *                             type: "String",
 *                             value: "$cluster",
 *                         },
 *                     }],
 *                     explicit: false,
 *                     logicalOperator: "AND",
 *                     range: {
 *                         from: 0,
 *                         to: 22,
 *                     },
 *                     type: "Group",
 *                 }),
 *             },
 *             {
 *                 dataObject: "dt.entity.kubernetes_node",
 *                 filter: "",
 *                 relationship: {
 *                     name: "clustered_by",
 *                     target: "dt.entity.kubernetes_cluster",
 *                 },
 *             },
 *             {
 *                 dataObject: "dt.entity.kubernetes_service",
 *                 filter: "",
 *                 relationship: {
 *                     name: "clustered_by",
 *                     target: "dt.entity.kubernetes_cluster",
 *                 },
 *             },
 *             {
 *                 dataObject: "dt.entity.service",
 *                 filter: "",
 *                 relationship: {
 *                     name: "clustered_by",
 *                     target: "dt.entity.kubernetes_cluster",
 *                 },
 *             },
 *         ],
 *     },
 *     variables: {
 *         type: "query",
 *         value: `fetch dt.entity.kubernetes_cluster
 * | fields cluster = entity.name
 * | sort cluster
 * `,
 *     },
 * });
 * ```
 */
export class Segment extends pulumi.CustomResource {
    /**
     * Get an existing Segment resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: SegmentState, opts?: pulumi.CustomResourceOptions): Segment {
        return new Segment(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'dynatrace:index/segment:Segment';

    /**
     * Returns true if the given object is an instance of Segment.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Segment {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Segment.__pulumiType;
    }

    /**
     * Description of the filter-segment
     */
    public readonly description!: pulumi.Output<string | undefined>;
    /**
     * List of includes of the filter-segment
     */
    public readonly includes!: pulumi.Output<outputs.SegmentIncludes | undefined>;
    /**
     * Indicates if the filter-segment is publicly accessible within the tenant
     */
    public readonly isPublic!: pulumi.Output<boolean>;
    /**
     * Name of the filter-segment
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * Variables of the filter-segment
     */
    public readonly variables!: pulumi.Output<outputs.SegmentVariables | undefined>;

    /**
     * Create a Segment resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: SegmentArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: SegmentArgs | SegmentState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as SegmentState | undefined;
            resourceInputs["description"] = state ? state.description : undefined;
            resourceInputs["includes"] = state ? state.includes : undefined;
            resourceInputs["isPublic"] = state ? state.isPublic : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["variables"] = state ? state.variables : undefined;
        } else {
            const args = argsOrState as SegmentArgs | undefined;
            if ((!args || args.isPublic === undefined) && !opts.urn) {
                throw new Error("Missing required property 'isPublic'");
            }
            resourceInputs["description"] = args ? args.description : undefined;
            resourceInputs["includes"] = args ? args.includes : undefined;
            resourceInputs["isPublic"] = args ? args.isPublic : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["variables"] = args ? args.variables : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Segment.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Segment resources.
 */
export interface SegmentState {
    /**
     * Description of the filter-segment
     */
    description?: pulumi.Input<string>;
    /**
     * List of includes of the filter-segment
     */
    includes?: pulumi.Input<inputs.SegmentIncludes>;
    /**
     * Indicates if the filter-segment is publicly accessible within the tenant
     */
    isPublic?: pulumi.Input<boolean>;
    /**
     * Name of the filter-segment
     */
    name?: pulumi.Input<string>;
    /**
     * Variables of the filter-segment
     */
    variables?: pulumi.Input<inputs.SegmentVariables>;
}

/**
 * The set of arguments for constructing a Segment resource.
 */
export interface SegmentArgs {
    /**
     * Description of the filter-segment
     */
    description?: pulumi.Input<string>;
    /**
     * List of includes of the filter-segment
     */
    includes?: pulumi.Input<inputs.SegmentIncludes>;
    /**
     * Indicates if the filter-segment is publicly accessible within the tenant
     */
    isPublic: pulumi.Input<boolean>;
    /**
     * Name of the filter-segment
     */
    name?: pulumi.Input<string>;
    /**
     * Variables of the filter-segment
     */
    variables?: pulumi.Input<inputs.SegmentVariables>;
}
